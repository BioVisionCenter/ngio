{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"NGIO: Streamlined OME-Zarr Image Analysis","text":"<p>ngio is a Python library designed to simplify bioimage analysis workflows, offering an intuitive interface for working with OME-Zarr files.</p>"},{"location":"#what-is-ngio","title":"What is Ngio?","text":"<p>Ngio is built for the OME-Zarr file format, a modern, cloud-optimized format for biological imaging data. OME-Zarr stores large, multi-dimensional microscopy images and metadata in an efficient and scalable way.</p> <p>Ngio's mission is to streamline working with OME-Zarr files by providing a simple, object-based API for opening, exploring, and manipulating OME-Zarr images and high-content screening (HCS) plates. It also offers comprehensive support for labels, tables and regions of interest (ROIs), making it easy to extract and analyze specific regions in your data.</p>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#simple-object-based-api","title":"\ud83d\udd0d Simple Object-Based API","text":"<ul> <li>Easily open, explore, and manipulate OME-Zarr images and HCS plates</li> <li>Create and derive new images and labels with minimal boilerplate code</li> </ul>"},{"location":"#rich-tables-and-regions-of-interest-roi-support","title":"\ud83d\udcca Rich Tables and Regions of Interest (ROI) Support","text":"<ul> <li>Tight integration with tabular data</li> <li>Extract and analyze specific regions of interest</li> <li>Store measurements and other metadata in the OME-Zarr container</li> <li>Extensible &amp; modular allowing users to define custom table schemas and on disk serialization</li> </ul>"},{"location":"#scalable-data-processing","title":"\ud83d\udd04 Scalable Data Processing","text":"<ul> <li>Powerful iterators for building scalable and generalizable image processing pipelines</li> <li>Extensible mapping mechanism for custom parallelization strategies</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Refer to the Getting Started guide to integrate ngio into your workflows. We also provide a collection of Tutorials to help you get up and running quickly. For more advanced usage and API documentation, see our API Reference.</p>"},{"location":"#supported-ome-zarr-versions","title":"Supported OME-Zarr versions","text":"<p>Ngio supports OME-Zarr v0.4 and v0.5, with Zarr v2 and v3 storage formats.</p>"},{"location":"#development-status","title":"Development Status","text":"<p>Warning</p> <p>Ngio is under active development and is not yet stable. The API is subject to change, and bugs and breaking changes are expected. We follow Semantic Versioning. Which means for 0.x releases potentially breaking changes can be introduced in minor releases.</p>"},{"location":"#available-features","title":"Available Features","text":"<ul> <li>\u2705 OME-Zarr metadata handling and validation</li> <li>\u2705 Image and label access across pyramid levels</li> <li>\u2705 ROI and table support</li> <li>\u2705 Image processing iterators</li> <li>\u2705 Streaming from remote sources</li> <li>\u2705 Documentation and examples</li> </ul>"},{"location":"#upcoming-features","title":"Upcoming Features","text":"<ul> <li>Enhanced performance optimizations (parallel iterators, optimized io strategies)</li> </ul>"},{"location":"#contributors","title":"Contributors","text":"<p>Ngio is developed at the BioVisionCenter, University of Zurich, by @lorenzocerrone and @jluethi.</p>"},{"location":"#license","title":"License","text":"<p>Ngio is released under the BSD-3-Clause License. See LICENSE for details.</p>"},{"location":"#repository","title":"Repository","text":"<p>Visit our GitHub repository for the latest code, issues, and contributions.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#052","title":"[0.5.2]","text":""},{"location":"changelog/#fix","title":"Fix","text":"<ul> <li>Fix critical bug in masking roi image handling causing incorrect results when image and mask have different pixel sizes.</li> <li>Fix bug in loading masking roi images when paths other than default are used.</li> </ul>"},{"location":"changelog/#051","title":"[0.5.1]","text":""},{"location":"changelog/#fix_1","title":"Fix","text":"<ul> <li>Fix bug causing incorrect channel metadata when creating an image.</li> <li>Fix correctly setting the space and time units when creating an image.</li> <li>Fix minor bug in <code>set_channel_windows_with_percentiles</code> method.</li> </ul>"},{"location":"changelog/#chores","title":"Chores","text":"<ul> <li>Improve logging consistency across the codebase.</li> </ul>"},{"location":"changelog/#v050","title":"[v0.5.0]","text":""},{"location":"changelog/#features","title":"Features","text":"<ul> <li>Add support for OME-NGFF v0.5</li> <li>Move to zarr-python v3</li> <li>API to delete labels and tables from OME-Zarr containers and HCS plates.</li> <li>Allow to explicitly set axes order when building masking roi tables.</li> <li>New metadata modification APIs for <code>Image</code>, <code>Label</code>, and <code>OmeZarrContainer</code>:</li> <li><code>set_channel_labels</code> - Update channel labels</li> <li><code>set_channel_colors</code> - Update channel colors</li> <li><code>set_channel_windows</code> - Update channel display windows (start/end values)</li> <li><code>set_channel_windows_with_percentiles</code> - Update display windows based on data percentiles</li> <li><code>set_axes_names</code> - Rename axes in the metadata</li> <li><code>set_axes_unit</code> - Set space and time units for axes</li> <li><code>set_name</code> - Set the image/label name in metadata</li> <li>Add translation support in all image/label creation and derivation APIs.</li> </ul>"},{"location":"changelog/#api-breaking-changes","title":"API Breaking Changes","text":"<ul> <li>New <code>Roi</code> models, now supporting arbitrary axes.</li> <li>The <code>compressor</code> argument has been renamed to <code>compressors</code> in all relevant functions and methods to reflect the support for multiple compressors in zarr v3.</li> <li>The <code>version</code> argument has been renamed to <code>ngff_version</code> in all relevant functions and methods to specify the OME-NGFF version.</li> <li>Remove the <code>parallel_safe</code> argument from all zarr related functions and methods. The locking mechanism is now handled internally and only depends on the <code>cache</code>.</li> <li>Remove the unused <code>parent</code> argument from <code>ZarrGroupHandler</code>.</li> <li>Internal changes to <code>ZarrGroupHandler</code> to support cleanup unused apis.</li> <li>Remove <code>ngio_logger</code> in favor of standard warnings module.</li> </ul>"},{"location":"changelog/#migration-guide-v04-v05","title":"Migration Guide (v0.4 \u2192 v0.5)","text":""},{"location":"changelog/#roi-api-changes","title":"Roi API Changes","text":"<p>The <code>Roi</code> class now uses a flexible slice-based model supporting arbitrary axes:</p> <pre><code># Old (v0.4)\nroi = Roi(x=34.1, y=10, x_length=321.6, y_length=330)\n\n# New (v0.5)\nroi = Roi.from_values(slices={\"x\": (34.1, 321.6), \"y\": (10, 330)}, name=None)\n\n# Accessing coordinates\n# Old: roi.x, roi.y, roi.x_length, roi.y_length\n# New: roi.get(\"x\").start, roi.get(\"y\").start, roi.get(\"x\").length, roi.get(\"y\").length\n</code></pre>"},{"location":"changelog/#argument-renames","title":"Argument Renames","text":"<pre><code># compressor \u2192 compressors\n# Old (v0.4)\ncreate_empty_ome_zarr(..., compressor=Blosc())\n\n# New (v0.5)\ncreate_empty_ome_zarr(..., compressors=Blosc())\n\n# version \u2192 ngff_version\n# Old (v0.4)\ncreate_empty_ome_zarr(..., version=\"0.4\")\n\n# New (v0.5)\ncreate_empty_ome_zarr(..., ngff_version=\"0.4\")\n</code></pre>"},{"location":"changelog/#removed-arguments","title":"Removed Arguments","text":"<ul> <li><code>parallel_safe</code>: No longer needed, locking is handled internally</li> <li><code>ngio_logger</code>: Use Python's standard <code>warnings</code> module instead</li> </ul>"},{"location":"changelog/#deprecations","title":"Deprecations","text":"<ul> <li>Standardized all deprecation warnings to indicate removal in <code>ngio=0.6</code>.</li> <li>Deprecated <code>set_channel_percentiles</code> method, use <code>set_channel_windows_with_percentiles</code> instead.</li> </ul>"},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Fix bug in <code>consolidate</code> function when using coarsening mode with non power-of-two shapes.</li> <li>Fix HCS plate column name formatting to use standardized zero-padding (e.g., column <code>3</code> is now stored as <code>\"03\"</code>).</li> <li>Fix <code>_stringify_column</code> not passing <code>num_digits</code> parameter to <code>_format_int_column</code>.</li> </ul>"},{"location":"changelog/#documentation","title":"Documentation","text":"<ul> <li>Fix incorrect and incomplete docstrings across the codebase:</li> <li><code>compute_masking_roi</code>: Added Args/Returns, fixed description (supports 2D, 3D, 4D).</li> <li><code>lazy_compute_slices</code>: Added Args/Returns sections.</li> <li><code>LabelsContainer.list</code>: Fixed description (was \"Create the /labels group\").</li> <li><code>build_masking_roi_table</code>: Added Args/Returns sections.</li> <li><code>TablesContainer</code>: Fixed class and method descriptions (were referencing labels instead of tables).</li> <li><code>NgioPlateMeta.add_well</code>: Fixed description (was \"Add an image to the well\").</li> <li><code>NgioPlateMeta.derive</code>: Fixed type annotation in docstring (<code>NgffVersion</code> \u2192 <code>NgffVersions</code>).</li> <li>Added missing docstrings to several HCS helper functions.</li> </ul>"},{"location":"changelog/#v047","title":"[v0.4.7]","text":""},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>Fix bug adding time axis to masking roi tables.</li> </ul>"},{"location":"changelog/#bug-fixes_2","title":"Bug Fixes","text":"<ul> <li>Fix channel selection from <code>wavelength_id</code></li> <li>Fix table opening mode to stop wrtiting groups when opening in append mode.</li> </ul>"},{"location":"changelog/#v045","title":"[v0.4.5]","text":""},{"location":"changelog/#bug-fixes_3","title":"Bug Fixes","text":"<ul> <li>Pin Dask to version &lt;2025.11 to avoid errors when writing zarr pyramids with dask (see https://github.com/dask/dask/issues/12159#issuecomment-3548421833)</li> </ul>"},{"location":"changelog/#v044","title":"[v0.4.4]","text":""},{"location":"changelog/#bug-fixes_4","title":"Bug Fixes","text":"<ul> <li>Fix bug in channel visualization when using hex colors with leading '#'.</li> <li>Remove strict range check in channel window.</li> </ul>"},{"location":"changelog/#v043","title":"[v0.4.3]","text":""},{"location":"changelog/#bug-fixes_5","title":"Bug Fixes","text":"<ul> <li>Fix bug in deriving labels and image from OME-Zarr with non standard path names.</li> <li>Add missing pillow dependency.</li> <li>Update pixi workspace config.</li> </ul>"},{"location":"changelog/#v042","title":"[v0.4.2]","text":""},{"location":"changelog/#api-changes","title":"API Changes","text":"<ul> <li>Make roi.to_slicing_dict(pixel_size) always require pixel_size argument for consistency with other roi methods.</li> <li>Make PixelSize object a Pydantic model to allow for serialization.</li> </ul>"},{"location":"changelog/#bug-fixes_6","title":"Bug Fixes","text":"<ul> <li>Improve robustness when rounding Rois to pixel coordinates. </li> </ul>"},{"location":"changelog/#v041","title":"[v0.4.1]","text":""},{"location":"changelog/#bug-fixes_7","title":"Bug Fixes","text":"<ul> <li>Fix bug in zoom transform when input axes contain unknown axes (e.g. virtual axes). Now unknown axes are treated as virtual axes and set to 1 in the target shape.</li> </ul>"},{"location":"changelog/#v040","title":"[v0.4.0]","text":""},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>Add Iterators for image processing pipelines</li> <li>Add support for time in rois and roi-tables</li> <li>Building masking roi tables expanded to time series data</li> <li>Add zoom transformation</li> <li>Add support for rescaling on-the-fly masks for masked images</li> <li>Big refactor of the io pipeline to support iterators and lazy loading</li> <li>Add support for customize dimension separators and compression codecs</li> <li>Simplify AxesHandler and Dataset Classes</li> </ul>"},{"location":"changelog/#api-changes_1","title":"API Changes","text":"<ul> <li>The image-like <code>get_*</code> api have been slightly changed. Now if a single int is passed as slice_kwargs, it is interpreted as a single index. So the dimension is automatically squeezed.</li> <li>Remove the <code>get_*_delayed</code> methods, now data cam only be loaded as numpy or dask array.Use the <code>get_as_dask</code> method instead, which returns a dask array that can be used with dask delayed.</li> <li>A new model for channel selection is available. Now channels can be selected by name, index or with <code>ChannelSelectionModel</code> object.</li> <li>Change <code>table_name</code> keyword argument to <code>name</code> for consistency in all table concatenation functions, e.g. <code>concatenate_image_tables</code>,  <code>concatenate_image_tables_as</code>, etc.</li> <li>Change to <code>Dimension</code> class. <code>get_shape</code> and <code>get_canonical_shape</code> have been removed, <code>get</code> uses new keyword arguments <code>default</code> instead of <code>strict</code>.</li> <li>Image like objects now have a more clean API to load data. Instead of <code>get_array</code> and <code>set_array</code>, they now use <code>get_as_numpy</code>, and <code>get_as_dask</code> for delayed arrays.</li> <li>Also for <code>get_roi</code> now specific methods are available. For ROI objects, the <code>get_roi_as_numpy</code>, and <code>get_roi_as_dask</code> methods.</li> <li>Table ops moved to <code>ngio.images</code></li> <li>int <code>label</code> as an explicit attribute in <code>Roi</code> objects (previously only in stored in name and relying on convention)</li> <li>Slight changes to <code>Image</code> and <code>Label</code> objects. Some minor attributes have been renamed for consistency.</li> </ul>"},{"location":"changelog/#table-specs","title":"Table specs","text":"<ul> <li>Add <code>t_second</code> and <code>len_t_second</code> to ROI tables and masking ROI tables</li> </ul>"},{"location":"changelog/#v035","title":"[v0.3.5]","text":"<ul> <li>Remove path normalization for images in wells. While the spec requires paths to be alphanumeric, this patch removes the normalization to allow for arbitrary image paths.</li> </ul>"},{"location":"changelog/#v034","title":"[v0.3.4]","text":"<ul> <li>allow to write as <code>anndata_v1</code> for backward compatibility with older ngio versions.</li> </ul>"},{"location":"changelog/#v033","title":"[v0.3.3]","text":""},{"location":"changelog/#chores_1","title":"Chores","text":"<ul> <li>improve dataset download process and streamline the CI workflows</li> </ul>"},{"location":"changelog/#v032","title":"[v0.3.2]","text":""},{"location":"changelog/#api-changes_2","title":"API Changes","text":"<ul> <li>change table backend default to <code>anndata_v1</code> for backward compatibility. This will be chaanged again when ngio <code>v0.2.x</code> is no longer supported.</li> </ul>"},{"location":"changelog/#bug-fixes_8","title":"Bug Fixes","text":"<ul> <li>fix #13 (converters tools)</li> <li>fix #88</li> </ul>"},{"location":"code_of_conduct/","title":"Code of Conduct","text":"<p>Warning</p> <p>The library is still in the early stages of development, the code of conduct is not yet established.</p>"},{"location":"contributing/","title":"Contributing Guide","text":"<p>Warning</p> <p>The library is still in the early stages of development, no contribution guidelines are established yet. But contributions are welcome! Please open an issue or a pull request to discuss your ideas. We are looking for contributors to help us improve the library and documentation.</p>"},{"location":"api/hcs/","title":"HCS API Documentation","text":""},{"location":"api/hcs/#open-a-plate","title":"Open a Plate","text":""},{"location":"api/hcs/#ngio.open_ome_zarr_plate","title":"ngio.open_ome_zarr_plate","text":"<pre><code>open_ome_zarr_plate(\n    store: StoreOrGroup,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n) -&gt; OmeZarrPlate\n</code></pre> <p>Open an OME-Zarr plate.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group that stores the plate.</p> </li> <li> <code>cache</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use a cache for the zarr group metadata.</p> </li> <li> <code>mode</code>               (<code>AccessModeLiteral</code>, default:                   <code>'r+'</code> )           \u2013            <p>The access mode for the image. Defaults to \"r+\".</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def open_ome_zarr_plate(\n    store: StoreOrGroup,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n) -&gt; OmeZarrPlate:\n    \"\"\"Open an OME-Zarr plate.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group that stores the plate.\n        cache (bool): Whether to use a cache for the zarr group metadata.\n        mode (AccessModeLiteral): The\n            access mode for the image. Defaults to \"r+\".\n    \"\"\"\n    group_handler = ZarrGroupHandler(store=store, cache=cache, mode=mode)\n    return OmeZarrPlate(group_handler)\n</code></pre>"},{"location":"api/hcs/#ngioomezarrplate-class-reference","title":"ngio.OmeZarrPlate Class Reference","text":""},{"location":"api/hcs/#ngio.OmeZarrPlate","title":"ngio.OmeZarrPlate","text":"<pre><code>OmeZarrPlate(\n    group_handler: ZarrGroupHandler,\n    table_container: TablesContainer | None = None,\n)\n</code></pre> <p>A class to handle the Plate Sequence in an OME-Zarr file.</p> <p>Initialize the LabelGroupHandler.</p> <p>Parameters:</p> <ul> <li> <code>group_handler</code>               (<code>ZarrGroupHandler</code>)           \u2013            <p>The Zarr group handler that contains the Plate.</p> </li> <li> <code>table_container</code>               (<code>TablesContainer | None</code>, default:                   <code>None</code> )           \u2013            <p>The tables container that contains plate level tables.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def __init__(\n    self,\n    group_handler: ZarrGroupHandler,\n    table_container: TablesContainer | None = None,\n) -&gt; None:\n    \"\"\"Initialize the LabelGroupHandler.\n\n    Args:\n        group_handler: The Zarr group handler that contains the Plate.\n        table_container: The tables container that contains plate level tables.\n    \"\"\"\n    self._group_handler = group_handler\n    self._meta_handler = PlateMetaHandler(group_handler)\n    self._tables_container = table_container\n    self._wells_cache: NgioCache[OmeZarrWell] = NgioCache(\n        use_cache=self._group_handler.use_cache\n    )\n    self._images_cache: NgioCache[OmeZarrContainer] = NgioCache(\n        use_cache=self._group_handler.use_cache\n    )\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.meta_handler","title":"meta_handler  <code>property</code>","text":"<pre><code>meta_handler\n</code></pre> <p>Return the metadata handler.</p>"},{"location":"api/hcs/#ngio.OmeZarrPlate.meta","title":"meta  <code>property</code>","text":"<pre><code>meta\n</code></pre> <p>Return the metadata.</p>"},{"location":"api/hcs/#ngio.OmeZarrPlate.columns","title":"columns  <code>property</code>","text":"<pre><code>columns: list[str]\n</code></pre> <p>Return the number of columns in the plate.</p>"},{"location":"api/hcs/#ngio.OmeZarrPlate.rows","title":"rows  <code>property</code>","text":"<pre><code>rows: list[str]\n</code></pre> <p>Return the number of rows in the plate.</p>"},{"location":"api/hcs/#ngio.OmeZarrPlate.acquisitions_names","title":"acquisitions_names  <code>property</code>","text":"<pre><code>acquisitions_names: list[str | None]\n</code></pre> <p>Return the acquisitions in the plate.</p>"},{"location":"api/hcs/#ngio.OmeZarrPlate.acquisition_ids","title":"acquisition_ids  <code>property</code>","text":"<pre><code>acquisition_ids: list[int]\n</code></pre> <p>Return the acquisitions ids in the plate.</p>"},{"location":"api/hcs/#ngio.OmeZarrPlate.tables_container","title":"tables_container  <code>property</code>","text":"<pre><code>tables_container: TablesContainer\n</code></pre> <p>Return the tables container.</p>"},{"location":"api/hcs/#ngio.OmeZarrPlate.wells_paths","title":"wells_paths","text":"<pre><code>wells_paths() -&gt; list[str]\n</code></pre> <p>Return the wells paths in the plate.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def wells_paths(self) -&gt; list[str]:\n    \"\"\"Return the wells paths in the plate.\"\"\"\n    return self.meta.wells_paths\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.images_paths_async","title":"images_paths_async  <code>async</code>","text":"<pre><code>images_paths_async(\n    acquisition: int | None = None,\n) -&gt; list[str]\n</code></pre> <p>Return the images paths in the plate asynchronously.</p> <p>If acquisition is None, return all images paths in the plate. Else, return the images paths in the plate for the given acquisition.</p> <p>Parameters:</p> <ul> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>async def images_paths_async(self, acquisition: int | None = None) -&gt; list[str]:\n    \"\"\"Return the images paths in the plate asynchronously.\n\n    If acquisition is None, return all images paths in the plate.\n    Else, return the images paths in the plate for the given acquisition.\n\n    Args:\n        acquisition (int | None): The acquisition id to filter the images.\n    \"\"\"\n    wells = await self.get_wells_async()\n    paths = []\n    for well_path, well in wells.items():\n        for img_path in well.paths(acquisition):\n            paths.append(f\"{well_path}/{img_path}\")\n    return paths\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.images_paths","title":"images_paths","text":"<pre><code>images_paths(acquisition: int | None = None) -&gt; list[str]\n</code></pre> <p>Return the images paths in the plate.</p> <p>If acquisition is None, return all images paths in the plate. Else, return the images paths in the plate for the given acquisition.</p> <p>Parameters:</p> <ul> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def images_paths(self, acquisition: int | None = None) -&gt; list[str]:\n    \"\"\"Return the images paths in the plate.\n\n    If acquisition is None, return all images paths in the plate.\n    Else, return the images paths in the plate for the given acquisition.\n\n    Args:\n        acquisition (int | None): The acquisition id to filter the images.\n    \"\"\"\n    wells = self.get_wells()\n    images = []\n    for well_path, well in wells.items():\n        for img_path in well.paths(acquisition):\n            images.append(f\"{well_path}/{img_path}\")\n    return images\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.well_images_paths","title":"well_images_paths","text":"<pre><code>well_images_paths(\n    row: str,\n    column: int | str,\n    acquisition: int | None = None,\n) -&gt; list[str]\n</code></pre> <p>Return the images paths in a well.</p> <p>If acquisition is None, return all images paths in the well. Else, return the images paths in the well for the given acquisition.</p> <p>Parameters:</p> <ul> <li> <code>row</code>               (<code>str</code>)           \u2013            <p>The row of the well.</p> </li> <li> <code>column</code>               (<code>int | str</code>)           \u2013            <p>The column of the well.</p> </li> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def well_images_paths(\n    self, row: str, column: int | str, acquisition: int | None = None\n) -&gt; list[str]:\n    \"\"\"Return the images paths in a well.\n\n    If acquisition is None, return all images paths in the well.\n    Else, return the images paths in the well for the given acquisition.\n\n    Args:\n        row (str): The row of the well.\n        column (int | str): The column of the well.\n        acquisition (int | None): The acquisition id to filter the images.\n    \"\"\"\n    images = []\n    well = self.get_well(row=row, column=column)\n    for path in well.paths(acquisition):\n        images.append(self._image_path(row=row, column=column, path=path))\n    return images\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.get_image_acquisition_id","title":"get_image_acquisition_id","text":"<pre><code>get_image_acquisition_id(\n    row: str, column: int | str, image_path: str\n) -&gt; int | None\n</code></pre> <p>Get the acquisition id of an image in a well.</p> <p>Parameters:</p> <ul> <li> <code>row</code>               (<code>str</code>)           \u2013            <p>The row of the well.</p> </li> <li> <code>column</code>               (<code>int | str</code>)           \u2013            <p>The column of the well.</p> </li> <li> <code>image_path</code>               (<code>str</code>)           \u2013            <p>The path of the image.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int | None</code>           \u2013            <p>int | None: The acquisition id of the image.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_image_acquisition_id(\n    self, row: str, column: int | str, image_path: str\n) -&gt; int | None:\n    \"\"\"Get the acquisition id of an image in a well.\n\n    Args:\n        row (str): The row of the well.\n        column (int | str): The column of the well.\n        image_path (str): The path of the image.\n\n    Returns:\n        int | None: The acquisition id of the image.\n    \"\"\"\n    well = self.get_well(row=row, column=column)\n    return well.get_image_acquisition_id(image_path=image_path)\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.get_well","title":"get_well","text":"<pre><code>get_well(row: str, column: int | str) -&gt; OmeZarrWell\n</code></pre> <p>Get a well from the plate.</p> <p>Parameters:</p> <ul> <li> <code>row</code>               (<code>str</code>)           \u2013            <p>The row of the well.</p> </li> <li> <code>column</code>               (<code>int | str</code>)           \u2013            <p>The column of the well.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OmeZarrWell</code> (              <code>OmeZarrWell</code> )          \u2013            <p>The well.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_well(self, row: str, column: int | str) -&gt; OmeZarrWell:\n    \"\"\"Get a well from the plate.\n\n    Args:\n        row (str): The row of the well.\n        column (int | str): The column of the well.\n\n    Returns:\n        OmeZarrWell: The well.\n    \"\"\"\n    well_path = self._well_path(row=row, column=column)\n    return self._get_well(well_path=well_path)\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.get_wells_async","title":"get_wells_async  <code>async</code>","text":"<pre><code>get_wells_async() -&gt; dict[str, OmeZarrWell]\n</code></pre> <p>Get all wells in the plate asynchronously.</p> <p>This method processes wells in parallel for improved performance when working with a large number of wells.</p> <p>Returns:</p> <ul> <li> <code>dict[str, OmeZarrWell]</code>           \u2013            <p>dict[str, OmeZarrWell]: A dictionary of wells, where the key is the well path and the value is the well object.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>async def get_wells_async(self) -&gt; dict[str, OmeZarrWell]:\n    \"\"\"Get all wells in the plate asynchronously.\n\n    This method processes wells in parallel for improved performance\n    when working with a large number of wells.\n\n    Returns:\n        dict[str, OmeZarrWell]: A dictionary of wells, where the key is the well\n            path and the value is the well object.\n    \"\"\"\n    wells, tasks = {}, []\n    for well_path in self.wells_paths():\n        task = asyncio.to_thread(\n            lambda well_path: (well_path, self._get_well(well_path)), well_path\n        )\n        tasks.append(task)\n\n    results = await asyncio.gather(*tasks)\n    for well_path, well in results:\n        wells[well_path] = well\n\n    return wells\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.get_wells","title":"get_wells","text":"<pre><code>get_wells() -&gt; dict[str, OmeZarrWell]\n</code></pre> <p>Get all wells in the plate.</p> <p>Returns:</p> <ul> <li> <code>dict[str, OmeZarrWell]</code>           \u2013            <p>dict[str, OmeZarrWell]: A dictionary of wells, where the key is the well path and the value is the well object.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_wells(self) -&gt; dict[str, OmeZarrWell]:\n    \"\"\"Get all wells in the plate.\n\n    Returns:\n        dict[str, OmeZarrWell]: A dictionary of wells, where the key is the well\n            path and the value is the well object.\n    \"\"\"\n    wells = {}\n    for well_path in self.wells_paths():\n        wells[well_path] = self._get_well(well_path)\n    return wells\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.get_images_async","title":"get_images_async  <code>async</code>","text":"<pre><code>get_images_async(\n    acquisition: int | None = None,\n) -&gt; dict[str, OmeZarrContainer]\n</code></pre> <p>Get all images in the plate asynchronously.</p> <p>This method processes images in parallel for improved performance when working with a large number of images.</p> <p>Parameters:</p> <ul> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, OmeZarrContainer]</code>           \u2013            <p>dict[str, OmeZarrContainer]: A dictionary of images, where the key is the image path and the value is the image object.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>async def get_images_async(\n    self, acquisition: int | None = None\n) -&gt; dict[str, OmeZarrContainer]:\n    \"\"\"Get all images in the plate asynchronously.\n\n    This method processes images in parallel for improved performance\n    when working with a large number of images.\n\n    Args:\n        acquisition: The acquisition id to filter the images.\n\n    Returns:\n        dict[str, OmeZarrContainer]: A dictionary of images, where the key is the\n            image path and the value is the image object.\n    \"\"\"\n    paths = await self.images_paths_async(acquisition=acquisition)\n\n    images, tasks = {}, []\n    for image_path in paths:\n        task = asyncio.to_thread(\n            lambda image_path: (image_path, self._get_image(image_path)), image_path\n        )\n        tasks.append(task)\n\n    results = await asyncio.gather(*tasks)\n\n    for image_path, image in results:\n        images[image_path] = image\n    return images\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.get_images","title":"get_images","text":"<pre><code>get_images(\n    acquisition: int | None = None,\n) -&gt; dict[str, OmeZarrContainer]\n</code></pre> <p>Get all images in the plate.</p> <p>Parameters:</p> <ul> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_images(self, acquisition: int | None = None) -&gt; dict[str, OmeZarrContainer]:\n    \"\"\"Get all images in the plate.\n\n    Args:\n        acquisition: The acquisition id to filter the images.\n    \"\"\"\n    paths = self.images_paths(acquisition=acquisition)\n    images = {}\n    for image_path in paths:\n        images[image_path] = self._get_image(image_path)\n\n    return images\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.get_image","title":"get_image","text":"<pre><code>get_image(\n    row: str, column: int | str, image_path: str\n) -&gt; OmeZarrContainer\n</code></pre> <p>Get an image from the plate.</p> <p>Parameters:</p> <ul> <li> <code>row</code>               (<code>str</code>)           \u2013            <p>The row of the well.</p> </li> <li> <code>column</code>               (<code>int | str</code>)           \u2013            <p>The column of the well.</p> </li> <li> <code>image_path</code>               (<code>str</code>)           \u2013            <p>The path of the image.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OmeZarrContainer</code> (              <code>OmeZarrContainer</code> )          \u2013            <p>The image.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_image(\n    self, row: str, column: int | str, image_path: str\n) -&gt; OmeZarrContainer:\n    \"\"\"Get an image from the plate.\n\n    Args:\n        row (str): The row of the well.\n        column (int | str): The column of the well.\n        image_path (str): The path of the image.\n\n    Returns:\n        OmeZarrContainer: The image.\n    \"\"\"\n    image_path = self._image_path(row=row, column=column, path=image_path)\n    return self._get_image(image_path)\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.get_image_store","title":"get_image_store","text":"<pre><code>get_image_store(\n    row: str, column: int | str, image_path: str\n) -&gt; StoreOrGroup\n</code></pre> <p>Get the image store from the plate.</p> <p>Parameters:</p> <ul> <li> <code>row</code>               (<code>str</code>)           \u2013            <p>The row of the well.</p> </li> <li> <code>column</code>               (<code>int | str</code>)           \u2013            <p>The column of the well.</p> </li> <li> <code>image_path</code>               (<code>str</code>)           \u2013            <p>The path of the image.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_image_store(\n    self, row: str, column: int | str, image_path: str\n) -&gt; StoreOrGroup:\n    \"\"\"Get the image store from the plate.\n\n    Args:\n        row (str): The row of the well.\n        column (int | str): The column of the well.\n        image_path (str): The path of the image.\n    \"\"\"\n    well = self.get_well(row=row, column=column)\n    return well.get_image_store(image_path=image_path)\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.get_well_images","title":"get_well_images","text":"<pre><code>get_well_images(\n    row: str,\n    column: str | int,\n    acquisition: int | None = None,\n) -&gt; dict[str, OmeZarrContainer]\n</code></pre> <p>Get all images in a well.</p> <p>Parameters:</p> <ul> <li> <code>row</code>               (<code>str</code>)           \u2013            <p>The row of the well.</p> </li> <li> <code>column</code>               (<code>str | int</code>)           \u2013            <p>The column of the well.</p> </li> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_well_images(\n    self, row: str, column: str | int, acquisition: int | None = None\n) -&gt; dict[str, OmeZarrContainer]:\n    \"\"\"Get all images in a well.\n\n    Args:\n        row: The row of the well.\n        column: The column of the well.\n        acquisition: The acquisition id to filter the images.\n    \"\"\"\n    images = {}\n    for image_paths in self.well_images_paths(\n        row=row, column=column, acquisition=acquisition\n    ):\n        group_handler = self._group_handler.get_handler(image_paths)\n        images[image_paths] = OmeZarrContainer(group_handler)\n    return images\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.atomic_add_image","title":"atomic_add_image","text":"<pre><code>atomic_add_image(\n    row: str,\n    column: int | str,\n    image_path: str,\n    acquisition_id: int | None = None,\n    acquisition_name: str | None = None,\n) -&gt; str\n</code></pre> <p>Parallel safe version of add_image.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def atomic_add_image(\n    self,\n    row: str,\n    column: int | str,\n    image_path: str,\n    acquisition_id: int | None = None,\n    acquisition_name: str | None = None,\n) -&gt; str:\n    \"\"\"Parallel safe version of add_image.\"\"\"\n    if image_path is None:\n        raise ValueError(\n            \"Image path cannot be None for atomic add_image. \"\n            \"If your intent is to add a well, use add_well instead.\"\n        )\n    path = self._add_image(\n        row=row,\n        column=column,\n        image_path=image_path,\n        acquisition_id=acquisition_id,\n        acquisition_name=acquisition_name,\n        atomic=True,\n    )\n    return path\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.add_image","title":"add_image","text":"<pre><code>add_image(\n    row: str,\n    column: int | str,\n    image_path: str,\n    acquisition_id: int | None = None,\n    acquisition_name: str | None = None,\n) -&gt; str\n</code></pre> <p>Add an image to an ome-zarr plate.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def add_image(\n    self,\n    row: str,\n    column: int | str,\n    image_path: str,\n    acquisition_id: int | None = None,\n    acquisition_name: str | None = None,\n) -&gt; str:\n    \"\"\"Add an image to an ome-zarr plate.\"\"\"\n    if image_path is None:\n        raise ValueError(\n            \"Image path cannot be None for atomic add_image. \"\n            \"If your intent is to add a well, use add_well instead.\"\n        )\n    path = self._add_image(\n        row=row,\n        column=column,\n        image_path=image_path,\n        acquisition_id=acquisition_id,\n        acquisition_name=acquisition_name,\n        atomic=False,\n    )\n    return path\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.add_well","title":"add_well","text":"<pre><code>add_well(row: str, column: int | str) -&gt; OmeZarrWell\n</code></pre> <p>Add a well to an ome-zarr plate.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def add_well(\n    self,\n    row: str,\n    column: int | str,\n) -&gt; OmeZarrWell:\n    \"\"\"Add a well to an ome-zarr plate.\"\"\"\n    _ = self._add_image(\n        row=row,\n        column=column,\n        image_path=None,\n        acquisition_id=None,\n        acquisition_name=None,\n        atomic=False,\n    )\n    return self.get_well(row=row, column=column)\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.add_column","title":"add_column","text":"<pre><code>add_column(column: int | str) -&gt; OmeZarrPlate\n</code></pre> <p>Add a column to an ome-zarr plate.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def add_column(\n    self,\n    column: int | str,\n) -&gt; \"OmeZarrPlate\":\n    \"\"\"Add a column to an ome-zarr plate.\"\"\"\n    meta, _ = self.meta.add_column(column)\n    self.meta_handler.update_meta(meta)\n    self.meta_handler._group_handler.clean_cache()\n    return self\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.add_row","title":"add_row","text":"<pre><code>add_row(row: str) -&gt; OmeZarrPlate\n</code></pre> <p>Add a row to an ome-zarr plate.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def add_row(\n    self,\n    row: str,\n) -&gt; \"OmeZarrPlate\":\n    \"\"\"Add a row to an ome-zarr plate.\"\"\"\n    meta, _ = self.meta.add_row(row)\n    self.meta_handler.update_meta(meta)\n    self.meta_handler._group_handler.clean_cache()\n    return self\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.add_acquisition","title":"add_acquisition","text":"<pre><code>add_acquisition(\n    acquisition_id: int, acquisition_name: str\n) -&gt; OmeZarrPlate\n</code></pre> <p>Add an acquisition to an ome-zarr plate.</p> <p>Be aware that this is not a parallel safe operation.</p> <p>Parameters:</p> <ul> <li> <code>acquisition_id</code>               (<code>int</code>)           \u2013            <p>The acquisition id.</p> </li> <li> <code>acquisition_name</code>               (<code>str</code>)           \u2013            <p>The acquisition name.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def add_acquisition(\n    self,\n    acquisition_id: int,\n    acquisition_name: str,\n) -&gt; \"OmeZarrPlate\":\n    \"\"\"Add an acquisition to an ome-zarr plate.\n\n    Be aware that this is not a parallel safe operation.\n\n    Args:\n        acquisition_id (int): The acquisition id.\n        acquisition_name (str): The acquisition name.\n    \"\"\"\n    meta = self.meta.add_acquisition(\n        acquisition_id=acquisition_id, acquisition_name=acquisition_name\n    )\n    self.meta_handler.update_meta(meta)\n    self.meta_handler._group_handler.clean_cache()\n    return self\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.atomic_remove_image","title":"atomic_remove_image","text":"<pre><code>atomic_remove_image(\n    row: str, column: int | str, image_path: str\n)\n</code></pre> <p>Parallel safe version of remove_image.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def atomic_remove_image(\n    self,\n    row: str,\n    column: int | str,\n    image_path: str,\n):\n    \"\"\"Parallel safe version of remove_image.\"\"\"\n    return self._remove_image(\n        row=row,\n        column=column,\n        image_path=image_path,\n        atomic=True,\n    )\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.remove_image","title":"remove_image","text":"<pre><code>remove_image(row: str, column: int | str, image_path: str)\n</code></pre> <p>Remove an image from an ome-zarr plate.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def remove_image(\n    self,\n    row: str,\n    column: int | str,\n    image_path: str,\n):\n    \"\"\"Remove an image from an ome-zarr plate.\"\"\"\n    return self._remove_image(\n        row=row,\n        column=column,\n        image_path=image_path,\n        atomic=False,\n    )\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.derive_plate","title":"derive_plate","text":"<pre><code>derive_plate(\n    store: StoreOrGroup,\n    plate_name: str | None = None,\n    version: NgffVersions | None = None,\n    ngff_version: NgffVersions = DefaultNgffVersion,\n    keep_acquisitions: bool = False,\n    cache: bool = False,\n    overwrite: bool = False,\n) -&gt; OmeZarrPlate\n</code></pre> <p>Derive a new OME-Zarr plate from an existing one.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group that stores the plate.</p> </li> <li> <code>plate_name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the new plate.</p> </li> <li> <code>version</code>               (<code>NgffVersion | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Please use 'ngff_version' instead.</p> </li> <li> <code>ngff_version</code>               (<code>NgffVersion</code>, default:                   <code>DefaultNgffVersion</code> )           \u2013            <p>The NGFF version to use for the new plate.</p> </li> <li> <code>keep_acquisitions</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to keep the acquisitions in the new plate.</p> </li> <li> <code>cache</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use a cache for the zarr group metadata.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to overwrite the existing plate.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def derive_plate(\n    self,\n    store: StoreOrGroup,\n    plate_name: str | None = None,\n    version: NgffVersions | None = None,\n    ngff_version: NgffVersions = DefaultNgffVersion,\n    keep_acquisitions: bool = False,\n    cache: bool = False,\n    overwrite: bool = False,\n) -&gt; \"OmeZarrPlate\":\n    \"\"\"Derive a new OME-Zarr plate from an existing one.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group that stores the plate.\n        plate_name (str | None): The name of the new plate.\n        version (NgffVersion | None): Deprecated. Please use 'ngff_version' instead.\n        ngff_version (NgffVersion): The NGFF version to use for the new plate.\n        keep_acquisitions (bool): Whether to keep the acquisitions in the new plate.\n        cache (bool): Whether to use a cache for the zarr group metadata.\n        overwrite (bool): Whether to overwrite the existing plate.\n    \"\"\"\n    return derive_ome_zarr_plate(\n        ome_zarr_plate=self,\n        store=store,\n        plate_name=plate_name,\n        ngff_version=ngff_version,\n        version=version,\n        keep_acquisitions=keep_acquisitions,\n        cache=cache,\n        overwrite=overwrite,\n    )\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.list_tables","title":"list_tables","text":"<pre><code>list_tables(\n    filter_types: TypedTable | str | None = None,\n) -&gt; list[str]\n</code></pre> <p>List all tables in the image.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def list_tables(self, filter_types: TypedTable | str | None = None) -&gt; list[str]:\n    \"\"\"List all tables in the image.\"\"\"\n    _tables_container = self._get_tables_container(create_mode=False)\n    if _tables_container is None:\n        return []\n    return self.tables_container.list(filter_types=filter_types)\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.list_roi_tables","title":"list_roi_tables","text":"<pre><code>list_roi_tables() -&gt; list[str]\n</code></pre> <p>List all ROI tables in the image.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def list_roi_tables(self) -&gt; list[str]:\n    \"\"\"List all ROI tables in the image.\"\"\"\n    roi = self.tables_container.list(\n        filter_types=\"roi_table\",\n    )\n    masking_roi = self.tables_container.list(\n        filter_types=\"masking_roi_table\",\n    )\n    return roi + masking_roi\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.get_roi_table","title":"get_roi_table","text":"<pre><code>get_roi_table(name: str) -&gt; RoiTable\n</code></pre> <p>Get a ROI table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_roi_table(self, name: str) -&gt; RoiTable:\n    \"\"\"Get a ROI table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, RoiTable):\n        raise NgioValueError(f\"Table {name} is not a ROI table. Got {type(table)}\")\n    return table\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.get_masking_roi_table","title":"get_masking_roi_table","text":"<pre><code>get_masking_roi_table(name: str) -&gt; MaskingRoiTable\n</code></pre> <p>Get a masking ROI table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_masking_roi_table(self, name: str) -&gt; MaskingRoiTable:\n    \"\"\"Get a masking ROI table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, MaskingRoiTable):\n        raise NgioValueError(\n            f\"Table {name} is not a masking ROI table. Got {type(table)}\"\n        )\n    return table\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.get_feature_table","title":"get_feature_table","text":"<pre><code>get_feature_table(name: str) -&gt; FeatureTable\n</code></pre> <p>Get a feature table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_feature_table(self, name: str) -&gt; FeatureTable:\n    \"\"\"Get a feature table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, FeatureTable):\n        raise NgioValueError(\n            f\"Table {name} is not a feature table. Got {type(table)}\"\n        )\n    return table\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.get_generic_roi_table","title":"get_generic_roi_table","text":"<pre><code>get_generic_roi_table(name: str) -&gt; GenericRoiTable\n</code></pre> <p>Get a generic ROI table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_generic_roi_table(self, name: str) -&gt; GenericRoiTable:\n    \"\"\"Get a generic ROI table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, GenericRoiTable):\n        raise NgioValueError(\n            f\"Table {name} is not a generic ROI table. Got {type(table)}\"\n        )\n    return table\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.get_condition_table","title":"get_condition_table","text":"<pre><code>get_condition_table(name: str) -&gt; ConditionTable\n</code></pre> <p>Get a condition table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_condition_table(self, name: str) -&gt; ConditionTable:\n    \"\"\"Get a condition table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, ConditionTable):\n        raise NgioValueError(\n            f\"Table {name} is not a condition table. Got {type(table)}\"\n        )\n    return table\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.get_table","title":"get_table","text":"<pre><code>get_table(\n    name: str, check_type: TypedTable | None = None\n) -&gt; Table\n</code></pre> <p>Get a table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> <li> <code>check_type</code>               (<code>TypedTable | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Please use 'get_table_as' instead, or one of the type specific get_*table() methods.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_table(self, name: str, check_type: TypedTable | None = None) -&gt; Table:\n    \"\"\"Get a table from the image.\n\n    Args:\n        name (str): The name of the table.\n        check_type (TypedTable | None): Deprecated. Please use\n            'get_table_as' instead, or one of the type specific\n            get_*table() methods.\n\n    \"\"\"\n    if check_type is not None:\n        logger.warning(\n            \"The 'check_type' argument is deprecated and will be removed in \"\n            \"ngio=0.6. Please use 'get_table_as' instead or one of the \"\n            \"type specific get_*table() methods.\"\n        )\n    return self.tables_container.get(name=name, strict=False)\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.get_table_as","title":"get_table_as","text":"<pre><code>get_table_as(\n    name: str,\n    table_cls: type[TableType],\n    backend: TableBackend | None = None,\n) -&gt; TableType\n</code></pre> <p>Get a table from the image as a specific type.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> <li> <code>table_cls</code>               (<code>type[TableType]</code>)           \u2013            <p>The type of the table.</p> </li> <li> <code>backend</code>               (<code>TableBackend | None</code>, default:                   <code>None</code> )           \u2013            <p>The backend to use. If None, the default backend is used.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_table_as(\n    self,\n    name: str,\n    table_cls: type[TableType],\n    backend: TableBackend | None = None,\n) -&gt; TableType:\n    \"\"\"Get a table from the image as a specific type.\n\n    Args:\n        name (str): The name of the table.\n        table_cls (type[TableType]): The type of the table.\n        backend (TableBackend | None): The backend to use. If None,\n            the default backend is used.\n    \"\"\"\n    return self.tables_container.get_as(\n        name=name,\n        table_cls=table_cls,\n        backend=backend,\n    )\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.add_table","title":"add_table","text":"<pre><code>add_table(\n    name: str,\n    table: Table,\n    backend: TableBackend = DefaultTableBackend,\n    overwrite: bool = False,\n) -&gt; None\n</code></pre> <p>Add a table to the image.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def add_table(\n    self,\n    name: str,\n    table: Table,\n    backend: TableBackend = DefaultTableBackend,\n    overwrite: bool = False,\n) -&gt; None:\n    \"\"\"Add a table to the image.\"\"\"\n    self.tables_container.add(\n        name=name, table=table, backend=backend, overwrite=overwrite\n    )\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.delete_table","title":"delete_table","text":"<pre><code>delete_table(name: str, missing_ok: bool = False) -&gt; None\n</code></pre> <p>Delete a table from the group.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table to delete.</p> </li> <li> <code>missing_ok</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, do not raise an error if the table does not exist.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def delete_table(self, name: str, missing_ok: bool = False) -&gt; None:\n    \"\"\"Delete a table from the group.\n\n    Args:\n        name (str): The name of the table to delete.\n        missing_ok (bool): If True, do not raise an error if the table does not\n            exist.\n\n    \"\"\"\n    table_container = self._get_tables_container(create_mode=False)\n    if table_container is None and missing_ok:\n        return\n    if table_container is None:\n        raise NgioValueError(\n            f\"No tables found in the image, cannot delete {name}. \"\n            \"Set missing_ok=True to ignore this error.\"\n        )\n    table_container.delete(name=name, missing_ok=missing_ok)\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.list_image_tables","title":"list_image_tables","text":"<pre><code>list_image_tables(\n    acquisition: int | None = None,\n    filter_types: str | None = None,\n    mode: Literal[\"common\", \"all\"] = \"common\",\n) -&gt; list[str]\n</code></pre> <p>List all image tables in the image.</p> <p>Parameters:</p> <ul> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> <li> <code>filter_types</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The type of tables to filter. If None, return all tables. Defaults to None.</p> </li> <li> <code>mode</code>               (<code>Literal['common', 'all']</code>, default:                   <code>'common'</code> )           \u2013            <p>The mode to use for listing the tables. If 'common', return only common tables between all images. If 'all', return all tables. Defaults to 'common'.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def list_image_tables(\n    self,\n    acquisition: int | None = None,\n    filter_types: str | None = None,\n    mode: Literal[\"common\", \"all\"] = \"common\",\n) -&gt; list[str]:\n    \"\"\"List all image tables in the image.\n\n    Args:\n        acquisition (int | None): The acquisition id to filter the images.\n        filter_types (str | None): The type of tables to filter. If None,\n            return all tables. Defaults to None.\n        mode (Literal[\"common\", \"all\"]): The mode to use for listing the tables.\n            If 'common', return only common tables between all images.\n            If 'all', return all tables. Defaults to 'common'.\n    \"\"\"\n    images = tuple(self.get_images(acquisition=acquisition).values())\n    return list_image_tables(\n        images=images,\n        filter_types=filter_types,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.list_image_tables_async","title":"list_image_tables_async  <code>async</code>","text":"<pre><code>list_image_tables_async(\n    acquisition: int | None = None,\n    filter_types: str | None = None,\n    mode: Literal[\"common\", \"all\"] = \"common\",\n) -&gt; list[str]\n</code></pre> <p>List all image tables in the image asynchronously.</p> <p>Parameters:</p> <ul> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> <li> <code>filter_types</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The type of tables to filter. If None, return all tables. Defaults to None.</p> </li> <li> <code>mode</code>               (<code>Literal['common', 'all']</code>, default:                   <code>'common'</code> )           \u2013            <p>The mode to use for listing the tables. If 'common', return only common tables between all images. If 'all', return all tables. Defaults to 'common'.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>async def list_image_tables_async(\n    self,\n    acquisition: int | None = None,\n    filter_types: str | None = None,\n    mode: Literal[\"common\", \"all\"] = \"common\",\n) -&gt; list[str]:\n    \"\"\"List all image tables in the image asynchronously.\n\n    Args:\n        acquisition (int | None): The acquisition id to filter the images.\n        filter_types (str | None): The type of tables to filter. If None,\n            return all tables. Defaults to None.\n        mode (Literal[\"common\", \"all\"]): The mode to use for listing the tables.\n            If 'common', return only common tables between all images.\n            If 'all', return all tables. Defaults to 'common'.\n    \"\"\"\n    images = await self.get_images_async(acquisition=acquisition)\n    images = tuple(images.values())\n    return await list_image_tables_async(\n        images=images,\n        filter_types=filter_types,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.concatenate_image_tables","title":"concatenate_image_tables","text":"<pre><code>concatenate_image_tables(\n    name: str,\n    acquisition: int | None = None,\n    strict: bool = True,\n    index_key: str | None = None,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; Table\n</code></pre> <p>Concatenate tables from all images in the plate.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table to concatenate.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The key to use for the index of the concatenated table.</p> </li> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, raise an error if the table is not found in the image.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>If a string is provided, a new index column will be created new_index_pattern = {row}{column}{path_in_well}_{label}</p> </li> <li> <code>mode</code>               (<code>Literal['eager', 'lazy']</code>, default:                   <code>'eager'</code> )           \u2013            <p>The mode to use for concatenation. Can be 'eager' or 'lazy'. if 'eager', the table will be loaded into memory. if 'lazy', the table will be loaded as a lazy frame.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def concatenate_image_tables(\n    self,\n    name: str,\n    acquisition: int | None = None,\n    strict: bool = True,\n    index_key: str | None = None,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; Table:\n    \"\"\"Concatenate tables from all images in the plate.\n\n    Args:\n        name: The name of the table to concatenate.\n        index_key: The key to use for the index of the concatenated table.\n        acquisition: The acquisition id to filter the images.\n        strict: If True, raise an error if the table is not found in the image.\n        index_key: If a string is provided, a new index column will be created\n            new_index_pattern = {row}_{column}_{path_in_well}_{label}\n        mode: The mode to use for concatenation. Can be 'eager' or 'lazy'.\n            if 'eager', the table will be loaded into memory.\n            if 'lazy', the table will be loaded as a lazy frame.\n    \"\"\"\n    images = self.get_images(acquisition=acquisition)\n    extras = _build_extras(tuple(images.keys()))\n    return concatenate_image_tables(\n        images=tuple(images.values()),\n        extras=extras,\n        name=name,\n        index_key=index_key,\n        strict=strict,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.concatenate_image_tables_as","title":"concatenate_image_tables_as","text":"<pre><code>concatenate_image_tables_as(\n    name: str,\n    table_cls: type[TableType],\n    acquisition: int | None = None,\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; TableType\n</code></pre> <p>Concatenate tables from all images in the plate as a specific type.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table to concatenate.</p> </li> <li> <code>table_cls</code>               (<code>type[TableType]</code>)           \u2013            <p>The type of the table to concatenate.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The key to use for the index of the concatenated table.</p> </li> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>If a string is provided, a new index column will be created new_index_pattern = {row}{column}{path_in_well}_{label}</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, raise an error if the table is not found in the image.</p> </li> <li> <code>mode</code>               (<code>Literal['eager', 'lazy']</code>, default:                   <code>'eager'</code> )           \u2013            <p>The mode to use for concatenation. Can be 'eager' or 'lazy'. if 'eager', the table will be loaded into memory. if 'lazy', the table will be loaded as a lazy frame.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def concatenate_image_tables_as(\n    self,\n    name: str,\n    table_cls: type[TableType],\n    acquisition: int | None = None,\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; TableType:\n    \"\"\"Concatenate tables from all images in the plate as a specific type.\n\n    Args:\n        name: The name of the table to concatenate.\n        table_cls: The type of the table to concatenate.\n        index_key: The key to use for the index of the concatenated table.\n        acquisition: The acquisition id to filter the images.\n        index_key: If a string is provided, a new index column will be created\n            new_index_pattern = {row}_{column}_{path_in_well}_{label}\n        strict: If True, raise an error if the table is not found in the image.\n        mode: The mode to use for concatenation. Can be 'eager' or 'lazy'.\n            if 'eager', the table will be loaded into memory.\n            if 'lazy', the table will be loaded as a lazy frame.\n    \"\"\"\n    images = self.get_images(acquisition=acquisition)\n    extras = _build_extras(tuple(images.keys()))\n    return concatenate_image_tables_as(\n        images=tuple(images.values()),\n        extras=extras,\n        name=name,\n        table_cls=table_cls,\n        index_key=index_key,\n        strict=strict,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.concatenate_image_tables_async","title":"concatenate_image_tables_async  <code>async</code>","text":"<pre><code>concatenate_image_tables_async(\n    name: str,\n    acquisition: int | None = None,\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; Table\n</code></pre> <p>Concatenate tables from all images in the plate asynchronously.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table to concatenate.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The key to use for the index of the concatenated table.</p> </li> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>If a string is provided, a new index column will be created new_index_pattern = {row}{column}{path_in_well}_{label}</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, raise an error if the table is not found in the image.</p> </li> <li> <code>mode</code>               (<code>Literal['eager', 'lazy']</code>, default:                   <code>'eager'</code> )           \u2013            <p>The mode to use for concatenation. Can be 'eager' or 'lazy'. if 'eager', the table will be loaded into memory. if 'lazy', the table will be loaded as a lazy frame.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>async def concatenate_image_tables_async(\n    self,\n    name: str,\n    acquisition: int | None = None,\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; Table:\n    \"\"\"Concatenate tables from all images in the plate asynchronously.\n\n    Args:\n        name: The name of the table to concatenate.\n        index_key: The key to use for the index of the concatenated table.\n        acquisition: The acquisition id to filter the images.\n        index_key: If a string is provided, a new index column will be created\n            new_index_pattern = {row}_{column}_{path_in_well}_{label}\n        strict: If True, raise an error if the table is not found in the image.\n        mode: The mode to use for concatenation. Can be 'eager' or 'lazy'.\n            if 'eager', the table will be loaded into memory.\n            if 'lazy', the table will be loaded as a lazy frame.\n    \"\"\"\n    images = await self.get_images_async(acquisition=acquisition)\n    extras = _build_extras(tuple(images.keys()))\n    return await concatenate_image_tables_async(\n        images=tuple(images.values()),\n        extras=extras,\n        name=name,\n        index_key=index_key,\n        strict=strict,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.concatenate_image_tables_as_async","title":"concatenate_image_tables_as_async  <code>async</code>","text":"<pre><code>concatenate_image_tables_as_async(\n    name: str,\n    table_cls: type[TableType],\n    acquisition: int | None = None,\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; TableType\n</code></pre> <p>Concatenate tables from all images in the plate as a specific type.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table to concatenate.</p> </li> <li> <code>table_cls</code>               (<code>type[TableType]</code>)           \u2013            <p>The type of the table to concatenate.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The key to use for the index of the concatenated table.</p> </li> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>If a string is provided, a new index column will be created new_index_pattern = {row}{column}{path_in_well}_{label}</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, raise an error if the table is not found in the image.</p> </li> <li> <code>mode</code>               (<code>Literal['eager', 'lazy']</code>, default:                   <code>'eager'</code> )           \u2013            <p>The mode to use for concatenation. Can be 'eager' or 'lazy'. if 'eager', the table will be loaded into memory. if 'lazy', the table will be loaded as a lazy frame.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>async def concatenate_image_tables_as_async(\n    self,\n    name: str,\n    table_cls: type[TableType],\n    acquisition: int | None = None,\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; TableType:\n    \"\"\"Concatenate tables from all images in the plate as a specific type.\n\n    Args:\n        name: The name of the table to concatenate.\n        table_cls: The type of the table to concatenate.\n        index_key: The key to use for the index of the concatenated table.\n        acquisition: The acquisition id to filter the images.\n        index_key: If a string is provided, a new index column will be created\n            new_index_pattern = {row}_{column}_{path_in_well}_{label}\n        strict: If True, raise an error if the table is not found in the image.\n        mode: The mode to use for concatenation. Can be 'eager' or 'lazy'.\n            if 'eager', the table will be loaded into memory.\n            if 'lazy', the table will be loaded as a lazy frame.\n    \"\"\"\n    images = await self.get_images_async(acquisition=acquisition)\n    extras = _build_extras(tuple(images.keys()))\n    return await concatenate_image_tables_as_async(\n        images=tuple(images.values()),\n        extras=extras,\n        name=name,\n        table_cls=table_cls,\n        index_key=index_key,\n        strict=strict,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/hcs/#open-a-well","title":"Open a Well","text":""},{"location":"api/hcs/#ngio.open_ome_zarr_well","title":"ngio.open_ome_zarr_well","text":"<pre><code>open_ome_zarr_well(\n    store: StoreOrGroup,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n) -&gt; OmeZarrWell\n</code></pre> <p>Open an OME-Zarr well.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group that stores the plate.</p> </li> <li> <code>cache</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use a cache for the zarr group metadata.</p> </li> <li> <code>mode</code>               (<code>AccessModeLiteral</code>, default:                   <code>'r+'</code> )           \u2013            <p>The access mode for the image. Defaults to \"r+\".</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def open_ome_zarr_well(\n    store: StoreOrGroup,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n) -&gt; OmeZarrWell:\n    \"\"\"Open an OME-Zarr well.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group that stores the plate.\n        cache (bool): Whether to use a cache for the zarr group metadata.\n        mode (AccessModeLiteral): The access mode for the image. Defaults to \"r+\".\n    \"\"\"\n    group_handler = ZarrGroupHandler(\n        store=store,\n        cache=cache,\n        mode=mode,\n    )\n    return OmeZarrWell(group_handler)\n</code></pre>"},{"location":"api/hcs/#ngioomezarrwell-class-reference","title":"ngio.OmeZarrWell Class Reference","text":""},{"location":"api/hcs/#ngio.OmeZarrWell","title":"ngio.OmeZarrWell","text":"<pre><code>OmeZarrWell(group_handler: ZarrGroupHandler)\n</code></pre> <p>A class to handle the Well Sequence in an OME-Zarr file.</p> <p>Initialize the LabelGroupHandler.</p> <p>Parameters:</p> <ul> <li> <code>group_handler</code>               (<code>ZarrGroupHandler</code>)           \u2013            <p>The Zarr group handler that contains the Well.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def __init__(self, group_handler: ZarrGroupHandler) -&gt; None:\n    \"\"\"Initialize the LabelGroupHandler.\n\n    Args:\n        group_handler: The Zarr group handler that contains the Well.\n    \"\"\"\n    self._group_handler = group_handler\n    self._meta_handler = WellMetaHandler(group_handler)\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrWell.meta_handler","title":"meta_handler  <code>property</code>","text":"<pre><code>meta_handler\n</code></pre> <p>Return the metadata handler.</p>"},{"location":"api/hcs/#ngio.OmeZarrWell.meta","title":"meta  <code>property</code>","text":"<pre><code>meta\n</code></pre> <p>Return the metadata.</p>"},{"location":"api/hcs/#ngio.OmeZarrWell.acquisition_ids","title":"acquisition_ids  <code>property</code>","text":"<pre><code>acquisition_ids: list[int]\n</code></pre> <p>Return the acquisitions ids in the well.</p>"},{"location":"api/hcs/#ngio.OmeZarrWell.paths","title":"paths","text":"<pre><code>paths(acquisition: int | None = None) -&gt; list[str]\n</code></pre> <p>Return the images paths in the well.</p> <p>If acquisition is None, return all images paths in the well. Else, return the images paths in the well for the given acquisition.</p> <p>Parameters:</p> <ul> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def paths(self, acquisition: int | None = None) -&gt; list[str]:\n    \"\"\"Return the images paths in the well.\n\n    If acquisition is None, return all images paths in the well.\n    Else, return the images paths in the well for the given acquisition.\n\n    Args:\n        acquisition (int | None): The acquisition id to filter the images.\n    \"\"\"\n    return self.meta.paths(acquisition)\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrWell.get_image_store","title":"get_image_store","text":"<pre><code>get_image_store(image_path: str) -&gt; StoreOrGroup\n</code></pre> <p>Get the image store from the well.</p> <p>Parameters:</p> <ul> <li> <code>image_path</code>               (<code>str</code>)           \u2013            <p>The path of the image.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_image_store(self, image_path: str) -&gt; StoreOrGroup:\n    \"\"\"Get the image store from the well.\n\n    Args:\n        image_path (str): The path of the image.\n    \"\"\"\n    return self._group_handler.get_group(image_path, create_mode=True)\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrWell.get_image_acquisition_id","title":"get_image_acquisition_id","text":"<pre><code>get_image_acquisition_id(image_path: str) -&gt; int | None\n</code></pre> <p>Get the acquisition id of an image in the well.</p> <p>Parameters:</p> <ul> <li> <code>image_path</code>               (<code>str</code>)           \u2013            <p>The path of the image.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int | None</code>           \u2013            <p>int | None: The acquisition id of the image.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_image_acquisition_id(self, image_path: str) -&gt; int | None:\n    \"\"\"Get the acquisition id of an image in the well.\n\n    Args:\n        image_path (str): The path of the image.\n\n    Returns:\n        int | None: The acquisition id of the image.\n    \"\"\"\n    return self.meta.get_image_acquisition_id(image_path=image_path)\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrWell.get_image","title":"get_image","text":"<pre><code>get_image(image_path: str) -&gt; OmeZarrContainer\n</code></pre> <p>Get an image from the well.</p> <p>Parameters:</p> <ul> <li> <code>image_path</code>               (<code>str</code>)           \u2013            <p>The path of the image.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OmeZarrContainer</code> (              <code>OmeZarrContainer</code> )          \u2013            <p>The image.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_image(self, image_path: str) -&gt; OmeZarrContainer:\n    \"\"\"Get an image from the well.\n\n    Args:\n        image_path (str): The path of the image.\n\n    Returns:\n        OmeZarrContainer: The image.\n    \"\"\"\n    handler = self._group_handler.get_handler(image_path)\n    return OmeZarrContainer(handler)\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrWell.atomic_add_image","title":"atomic_add_image","text":"<pre><code>atomic_add_image(\n    image_path: str,\n    acquisition_id: int | None = None,\n    strict: bool = True,\n) -&gt; StoreOrGroup\n</code></pre> <p>Parallel safe version of add_image.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def atomic_add_image(\n    self,\n    image_path: str,\n    acquisition_id: int | None = None,\n    strict: bool = True,\n) -&gt; StoreOrGroup:\n    \"\"\"Parallel safe version of add_image.\"\"\"\n    return self._add_image(\n        image_path=image_path,\n        acquisition_id=acquisition_id,\n        atomic=True,\n        strict=strict,\n    )\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrWell.add_image","title":"add_image","text":"<pre><code>add_image(\n    image_path: str,\n    acquisition_id: int | None = None,\n    strict: bool = True,\n) -&gt; StoreOrGroup\n</code></pre> <p>Add an image to an ome-zarr well.</p> <p>Parameters:</p> <ul> <li> <code>image_path</code>               (<code>str</code>)           \u2013            <p>The path of the image.</p> </li> <li> <code>acquisition_id</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to check if the acquisition id is already exists in the well. Defaults to True. If False this might lead to acquisition in a well that does not exist at the plate level.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def add_image(\n    self,\n    image_path: str,\n    acquisition_id: int | None = None,\n    strict: bool = True,\n) -&gt; StoreOrGroup:\n    \"\"\"Add an image to an ome-zarr well.\n\n    Args:\n        image_path (str): The path of the image.\n        acquisition_id (int | None): The acquisition id to filter the images.\n        strict (bool): Whether to check if the acquisition id is already exists\n            in the well. Defaults to True. If False this might lead to\n            acquisition in a well that does not exist at the plate level.\n    \"\"\"\n    return self._add_image(\n        image_path=image_path,\n        acquisition_id=acquisition_id,\n        atomic=False,\n        strict=strict,\n    )\n</code></pre>"},{"location":"api/images/","title":"Images Like: API Documentation","text":""},{"location":"api/images/#open-an-image","title":"Open an Image","text":""},{"location":"api/images/#ngio.open_image","title":"ngio.open_image","text":"<pre><code>open_image(\n    store: StoreOrGroup,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = True,\n    axes_setup: AxesSetup | None = None,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n) -&gt; Image\n</code></pre> <p>Open a single level image from an OME-Zarr image.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group to create the image in.</p> </li> <li> <code>path</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the image in the ome_zarr file.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the image.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Only used if the pixel size is provided. If True, the     pixel size must match the image pixel size exactly. If False, the     closest pixel size level will be returned.</p> </li> <li> <code>axes_setup</code>               (<code>AxesSetup | None</code>, default:                   <code>None</code> )           \u2013            <p>Axes setup to load ome-zarr with non-standard axes configurations.</p> </li> <li> <code>cache</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use a cache for the zarr group metadata.</p> </li> <li> <code>mode</code>               (<code>AccessModeLiteral</code>, default:                   <code>'r+'</code> )           \u2013            <p>The access mode for the image. Defaults to \"r+\".</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def open_image(\n    store: StoreOrGroup,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = True,\n    axes_setup: AxesSetup | None = None,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n) -&gt; Image:\n    \"\"\"Open a single level image from an OME-Zarr image.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group to create the image in.\n        path (str | None): The path to the image in the ome_zarr file.\n        pixel_size (PixelSize | None): The pixel size of the image.\n        strict (bool): Only used if the pixel size is provided. If True, the\n                pixel size must match the image pixel size exactly. If False, the\n                closest pixel size level will be returned.\n        axes_setup (AxesSetup | None): Axes setup to load ome-zarr with\n            non-standard axes configurations.\n        cache (bool): Whether to use a cache for the zarr group metadata.\n        mode (AccessModeLiteral): The\n            access mode for the image. Defaults to \"r+\".\n    \"\"\"\n    group_handler = ZarrGroupHandler(store=store, cache=cache, mode=mode)\n    images_container = ImagesContainer(group_handler, axes_setup=axes_setup)\n    return images_container.get(\n        path=path,\n        pixel_size=pixel_size,\n        strict=strict,\n    )\n</code></pre>"},{"location":"api/images/#ngioimage-class-reference","title":"ngio.Image Class Reference","text":""},{"location":"api/images/#ngio.Image","title":"ngio.Image","text":"<pre><code>Image(\n    group_handler: ZarrGroupHandler,\n    path: str,\n    meta_handler: ImageMetaHandler,\n)\n</code></pre> <p>               Bases: <code>AbstractImage</code></p> <p>A class to handle a single image (or level) in an OME-Zarr image.</p> <p>This class is meant to be subclassed by specific image types.</p> <p>Initialize the Image at a single level.</p> <p>Parameters:</p> <ul> <li> <code>group_handler</code>               (<code>ZarrGroupHandler</code>)           \u2013            <p>The Zarr group handler.</p> </li> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path to the image in the ome_zarr file.</p> </li> <li> <code>meta_handler</code>               (<code>ImageMetaHandler</code>)           \u2013            <p>The image metadata handler.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def __init__(\n    self,\n    group_handler: ZarrGroupHandler,\n    path: str,\n    meta_handler: ImageMetaHandler,\n) -&gt; None:\n    \"\"\"Initialize the Image at a single level.\n\n    Args:\n        group_handler: The Zarr group handler.\n        path: The path to the image in the ome_zarr file.\n        meta_handler: The image metadata handler.\n\n    \"\"\"\n    super().__init__(\n        group_handler=group_handler, path=path, meta_handler=meta_handler\n    )\n</code></pre>"},{"location":"api/images/#ngio.Image.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Return the path of the image.</p>"},{"location":"api/images/#ngio.Image.dataset","title":"dataset  <code>property</code>","text":"<pre><code>dataset: Dataset\n</code></pre> <p>Return the dataset of the image.</p>"},{"location":"api/images/#ngio.Image.dimensions","title":"dimensions  <code>property</code>","text":"<pre><code>dimensions: Dimensions\n</code></pre> <p>Return the dimensions of the image.</p>"},{"location":"api/images/#ngio.Image.pixel_size","title":"pixel_size  <code>property</code>","text":"<pre><code>pixel_size: PixelSize\n</code></pre> <p>Return the pixel size of the image.</p>"},{"location":"api/images/#ngio.Image.axes_handler","title":"axes_handler  <code>property</code>","text":"<pre><code>axes_handler: AxesHandler\n</code></pre> <p>Return the axes handler of the image.</p>"},{"location":"api/images/#ngio.Image.axes_setup","title":"axes_setup  <code>property</code>","text":"<pre><code>axes_setup: AxesSetup\n</code></pre> <p>Return the axes setup of the image.</p>"},{"location":"api/images/#ngio.Image.axes","title":"axes  <code>property</code>","text":"<pre><code>axes: tuple[str, ...]\n</code></pre> <p>Return the axes of the image.</p>"},{"location":"api/images/#ngio.Image.zarr_array","title":"zarr_array  <code>property</code>","text":"<pre><code>zarr_array: Array\n</code></pre> <p>Return the Zarr array.</p>"},{"location":"api/images/#ngio.Image.shape","title":"shape  <code>property</code>","text":"<pre><code>shape: tuple[int, ...]\n</code></pre> <p>Return the shape of the image.</p>"},{"location":"api/images/#ngio.Image.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype: str\n</code></pre> <p>Return the dtype of the image.</p>"},{"location":"api/images/#ngio.Image.chunks","title":"chunks  <code>property</code>","text":"<pre><code>chunks: tuple[int, ...]\n</code></pre> <p>Return the chunks of the image.</p>"},{"location":"api/images/#ngio.Image.is_3d","title":"is_3d  <code>property</code>","text":"<pre><code>is_3d: bool\n</code></pre> <p>Return True if the image is 3D.</p>"},{"location":"api/images/#ngio.Image.is_2d","title":"is_2d  <code>property</code>","text":"<pre><code>is_2d: bool\n</code></pre> <p>Return True if the image is 2D.</p>"},{"location":"api/images/#ngio.Image.is_time_series","title":"is_time_series  <code>property</code>","text":"<pre><code>is_time_series: bool\n</code></pre> <p>Return True if the image is a time series.</p>"},{"location":"api/images/#ngio.Image.is_2d_time_series","title":"is_2d_time_series  <code>property</code>","text":"<pre><code>is_2d_time_series: bool\n</code></pre> <p>Return True if the image is a 2D time series.</p>"},{"location":"api/images/#ngio.Image.is_3d_time_series","title":"is_3d_time_series  <code>property</code>","text":"<pre><code>is_3d_time_series: bool\n</code></pre> <p>Return True if the image is a 3D time series.</p>"},{"location":"api/images/#ngio.Image.is_multi_channels","title":"is_multi_channels  <code>property</code>","text":"<pre><code>is_multi_channels: bool\n</code></pre> <p>Return True if the image is multichannel.</p>"},{"location":"api/images/#ngio.Image.space_unit","title":"space_unit  <code>property</code>","text":"<pre><code>space_unit: str | None\n</code></pre> <p>Return the space unit of the image.</p>"},{"location":"api/images/#ngio.Image.time_unit","title":"time_unit  <code>property</code>","text":"<pre><code>time_unit: str | None\n</code></pre> <p>Return the time unit of the image.</p>"},{"location":"api/images/#ngio.Image.meta_handler","title":"meta_handler  <code>property</code>","text":"<pre><code>meta_handler: ImageMetaHandler\n</code></pre> <p>Return the metadata handler.</p>"},{"location":"api/images/#ngio.Image.meta","title":"meta  <code>property</code>","text":"<pre><code>meta: NgioImageMeta\n</code></pre> <p>Return the metadata.</p>"},{"location":"api/images/#ngio.Image.channels_meta","title":"channels_meta  <code>property</code>","text":"<pre><code>channels_meta: ChannelsMeta\n</code></pre> <p>Return the channels metadata.</p>"},{"location":"api/images/#ngio.Image.channel_labels","title":"channel_labels  <code>property</code>","text":"<pre><code>channel_labels: list[str]\n</code></pre> <p>Return the channels of the image.</p>"},{"location":"api/images/#ngio.Image.wavelength_ids","title":"wavelength_ids  <code>property</code>","text":"<pre><code>wavelength_ids: list[str | None]\n</code></pre> <p>Return the list of wavelength of the image.</p>"},{"location":"api/images/#ngio.Image.num_channels","title":"num_channels  <code>property</code>","text":"<pre><code>num_channels: int\n</code></pre> <p>Return the number of channels.</p>"},{"location":"api/images/#ngio.Image.has_axis","title":"has_axis","text":"<pre><code>has_axis(axis: str) -&gt; bool\n</code></pre> <p>Return True if the image has the given axis.</p> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def has_axis(self, axis: str) -&gt; bool:\n    \"\"\"Return True if the image has the given axis.\"\"\"\n    return self.axes_handler.has_axis(axis)\n</code></pre>"},{"location":"api/images/#ngio.Image.set_axes_unit","title":"set_axes_unit","text":"<pre><code>set_axes_unit(\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n) -&gt; None\n</code></pre> <p>Set the axes unit of the image.</p> <p>Parameters:</p> <ul> <li> <code>space_unit</code>               (<code>SpaceUnits</code>, default:                   <code>DefaultSpaceUnit</code> )           \u2013            <p>The space unit of the image.</p> </li> <li> <code>time_unit</code>               (<code>TimeUnits</code>, default:                   <code>DefaultTimeUnit</code> )           \u2013            <p>The time unit of the image.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def set_axes_unit(\n    self,\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n) -&gt; None:\n    \"\"\"Set the axes unit of the image.\n\n    Args:\n        space_unit (SpaceUnits): The space unit of the image.\n        time_unit (TimeUnits): The time unit of the image.\n    \"\"\"\n    meta = self._meta_handler.get_meta()\n    meta = meta.to_units(space_unit=space_unit, time_unit=time_unit)\n    self._meta_handler.update_meta(meta)  # type: ignore\n</code></pre>"},{"location":"api/images/#ngio.Image.set_axes_names","title":"set_axes_names","text":"<pre><code>set_axes_names(axes_names: Sequence[str]) -&gt; None\n</code></pre> <p>Set the axes names of the label.</p> <p>Parameters:</p> <ul> <li> <code>axes_names</code>               (<code>Sequence[str]</code>)           \u2013            <p>The axes names to set.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def set_axes_names(self, axes_names: Sequence[str]) -&gt; None:\n    \"\"\"Set the axes names of the label.\n\n    Args:\n        axes_names (Sequence[str]): The axes names to set.\n    \"\"\"\n    meta = self._meta_handler.get_meta()\n    meta = meta.rename_axes(axes_names=axes_names)\n    self._meta_handler._axes_setup = meta.axes_handler.axes_setup\n    self._meta_handler.update_meta(meta)  # type: ignore\n</code></pre>"},{"location":"api/images/#ngio.Image.set_name","title":"set_name","text":"<pre><code>set_name(name: str) -&gt; None\n</code></pre> <p>Set the name of the image in the metadata.</p> <p>This does not change the group name or any paths.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the image.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def set_name(\n    self,\n    name: str,\n) -&gt; None:\n    \"\"\"Set the name of the image in the metadata.\n\n    This does not change the group name or any paths.\n\n    Args:\n        name (str): The name of the image.\n    \"\"\"\n    meta = self._meta_handler.get_meta()\n    meta = meta.rename_image(name=name)\n    self._meta_handler.update_meta(meta)  # type: ignore\n</code></pre>"},{"location":"api/images/#ngio.Image.roi","title":"roi","text":"<pre><code>roi(name: str | None = 'image') -&gt; Roi\n</code></pre> <p>Return the ROI covering the entire image.</p> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def roi(self, name: str | None = \"image\") -&gt; Roi:\n    \"\"\"Return the ROI covering the entire image.\"\"\"\n    slices = {}\n    for ax_name in [\"t\", \"z\", \"y\", \"x\"]:\n        axis_size = self.dimensions.get(ax_name, default=None)\n        if axis_size is None:\n            continue\n        slices[ax_name] = slice(0, axis_size)\n    roi_px = Roi.from_values(name=name, slices=slices, space=\"pixel\")\n    return roi_px.to_world(pixel_size=self.pixel_size)\n</code></pre>"},{"location":"api/images/#ngio.Image.build_image_roi_table","title":"build_image_roi_table","text":"<pre><code>build_image_roi_table(\n    name: str | None = \"image\",\n) -&gt; RoiTable\n</code></pre> <p>Build the ROI table containing the ROI covering the entire image.</p> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def build_image_roi_table(self, name: str | None = \"image\") -&gt; RoiTable:\n    \"\"\"Build the ROI table containing the ROI covering the entire image.\"\"\"\n    return RoiTable(rois=[self.roi(name=name)])\n</code></pre>"},{"location":"api/images/#ngio.Image.require_dimensions_match","title":"require_dimensions_match","text":"<pre><code>require_dimensions_match(\n    other: AbstractImage, allow_singleton: bool = False\n) -&gt; None\n</code></pre> <p>Assert that two images have matching spatial dimensions.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>AbstractImage</code>)           \u2013            <p>The other image to compare to.</p> </li> <li> <code>allow_singleton</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, allow singleton dimensions to be compatible with non-singleton dimensions.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NgioValueError</code>             \u2013            <p>If the images do not have compatible dimensions.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def require_dimensions_match(\n    self,\n    other: \"AbstractImage\",\n    allow_singleton: bool = False,\n) -&gt; None:\n    \"\"\"Assert that two images have matching spatial dimensions.\n\n    Args:\n        other: The other image to compare to.\n        allow_singleton: If True, allow singleton dimensions to be\n            compatible with non-singleton dimensions.\n\n    Raises:\n        NgioValueError: If the images do not have compatible dimensions.\n    \"\"\"\n    self.dimensions.require_dimensions_match(\n        other.dimensions, allow_singleton=allow_singleton\n    )\n</code></pre>"},{"location":"api/images/#ngio.Image.check_if_dimensions_match","title":"check_if_dimensions_match","text":"<pre><code>check_if_dimensions_match(\n    other: AbstractImage, allow_singleton: bool = False\n) -&gt; bool\n</code></pre> <p>Check if two images have matching spatial dimensions.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>AbstractImage</code>)           \u2013            <p>The other image to compare to.</p> </li> <li> <code>allow_singleton</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, allow singleton dimensions to be compatible with non-singleton dimensions.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the images have matching dimensions, False otherwise.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def check_if_dimensions_match(\n    self,\n    other: \"AbstractImage\",\n    allow_singleton: bool = False,\n) -&gt; bool:\n    \"\"\"Check if two images have matching spatial dimensions.\n\n    Args:\n        other: The other image to compare to.\n        allow_singleton: If True, allow singleton dimensions to be\n            compatible with non-singleton dimensions.\n\n    Returns:\n        bool: True if the images have matching dimensions, False otherwise.\n    \"\"\"\n    return self.dimensions.check_if_dimensions_match(\n        other.dimensions, allow_singleton=allow_singleton\n    )\n</code></pre>"},{"location":"api/images/#ngio.Image.require_axes_match","title":"require_axes_match","text":"<pre><code>require_axes_match(other: AbstractImage) -&gt; None\n</code></pre> <p>Assert that two images have compatible axes.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>AbstractImage</code>)           \u2013            <p>The other image to compare to.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NgioValueError</code>             \u2013            <p>If the images do not have compatible axes.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def require_axes_match(\n    self,\n    other: \"AbstractImage\",\n) -&gt; None:\n    \"\"\"Assert that two images have compatible axes.\n\n    Args:\n        other: The other image to compare to.\n\n    Raises:\n        NgioValueError: If the images do not have compatible axes.\n    \"\"\"\n    self.dimensions.require_axes_match(other.dimensions)\n</code></pre>"},{"location":"api/images/#ngio.Image.check_if_axes_match","title":"check_if_axes_match","text":"<pre><code>check_if_axes_match(other: AbstractImage) -&gt; bool\n</code></pre> <p>Check if two images have compatible axes.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>AbstractImage</code>)           \u2013            <p>The other image to compare to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the images have compatible axes, False otherwise.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def check_if_axes_match(\n    self,\n    other: \"AbstractImage\",\n) -&gt; bool:\n    \"\"\"Check if two images have compatible axes.\n\n    Args:\n        other: The other image to compare to.\n\n    Returns:\n        bool: True if the images have compatible axes, False otherwise.\n\n    \"\"\"\n    return self.dimensions.check_if_axes_match(other.dimensions)\n</code></pre>"},{"location":"api/images/#ngio.Image.require_rescalable","title":"require_rescalable","text":"<pre><code>require_rescalable(other: AbstractImage) -&gt; None\n</code></pre> <p>Assert that two images can be rescaled to each other.</p> <p>For this to be true, the images must have the same axes, and the pixel sizes must be compatible (i.e. one can be scaled to the other).</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>AbstractImage</code>)           \u2013            <p>The other image to compare to.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NgioValueError</code>             \u2013            <p>If the images cannot be scaled to each other.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def require_rescalable(\n    self,\n    other: \"AbstractImage\",\n) -&gt; None:\n    \"\"\"Assert that two images can be rescaled to each other.\n\n    For this to be true, the images must have the same axes, and\n    the pixel sizes must be compatible (i.e. one can be scaled to the other).\n\n    Args:\n        other: The other image to compare to.\n\n    Raises:\n        NgioValueError: If the images cannot be scaled to each other.\n    \"\"\"\n    self.dimensions.require_rescalable(other.dimensions)\n</code></pre>"},{"location":"api/images/#ngio.Image.check_if_rescalable","title":"check_if_rescalable","text":"<pre><code>check_if_rescalable(other: AbstractImage) -&gt; bool\n</code></pre> <p>Check if two images can be rescaled to each other.</p> <p>For this to be true, the images must have the same axes, and the pixel sizes must be compatible (i.e. one can be scaled to the other).</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>AbstractImage</code>)           \u2013            <p>The other image to compare to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the images can be rescaled to each other, False otherwise.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def check_if_rescalable(\n    self,\n    other: \"AbstractImage\",\n) -&gt; bool:\n    \"\"\"Check if two images can be rescaled to each other.\n\n    For this to be true, the images must have the same axes, and\n    the pixel sizes must be compatible (i.e. one can be scaled to the other).\n\n    Args:\n        other: The other image to compare to.\n\n    Returns:\n        bool: True if the images can be rescaled to each other, False otherwise.\n    \"\"\"\n    return self.dimensions.check_if_rescalable(other.dimensions)\n</code></pre>"},{"location":"api/images/#ngio.Image.get_channel_idx","title":"get_channel_idx","text":"<pre><code>get_channel_idx(\n    channel_label: str | None = None,\n    wavelength_id: str | None = None,\n) -&gt; int\n</code></pre> <p>Get the index of a channel by its label or wavelength ID.</p> Source code in <code>ngio/images/_image.py</code> <pre><code>def get_channel_idx(\n    self, channel_label: str | None = None, wavelength_id: str | None = None\n) -&gt; int:\n    \"\"\"Get the index of a channel by its label or wavelength ID.\"\"\"\n    return self.channels_meta.get_channel_idx(\n        channel_label=channel_label, wavelength_id=wavelength_id\n    )\n</code></pre>"},{"location":"api/images/#ngio.Image.get_as_numpy","title":"get_as_numpy","text":"<pre><code>get_as_numpy(\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: slice | int | Sequence[int] | None,\n) -&gt; ndarray\n</code></pre> <p>Get the image as a numpy array.</p> <p>Parameters:</p> <ul> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Select a specific channel by label. If None, all channels are returned. Alternatively, you can slice arbitrary channels using the slice_kwargs (c=[0, 2]).</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The order of the axes to return the array.</p> </li> <li> <code>transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>The transforms to apply to the array.</p> </li> <li> <code>**slicing_kwargs</code>               (<code>slice | int | Sequence[int] | None</code>, default:                   <code>{}</code> )           \u2013            <p>The slices to get the array.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The array of the region of interest.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def get_as_numpy(\n    self,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: slice | int | Sequence[int] | None,\n) -&gt; np.ndarray:\n    \"\"\"Get the image as a numpy array.\n\n    Args:\n        channel_selection: Select a specific channel by label.\n            If None, all channels are returned.\n            Alternatively, you can slice arbitrary channels\n            using the slice_kwargs (c=[0, 2]).\n        axes_order: The order of the axes to return the array.\n        transforms: The transforms to apply to the array.\n        **slicing_kwargs: The slices to get the array.\n\n    Returns:\n        The array of the region of interest.\n    \"\"\"\n    _slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self, channel_selection=channel_selection, slicing_dict=slicing_kwargs\n    )\n    return self._get_as_numpy(\n        axes_order=axes_order, transforms=transforms, **_slicing_kwargs\n    )\n</code></pre>"},{"location":"api/images/#ngio.Image.get_roi_as_numpy","title":"get_roi_as_numpy","text":"<pre><code>get_roi_as_numpy(\n    roi: Roi,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; ndarray\n</code></pre> <p>Get the image as a numpy array for a region of interest.</p> <p>Parameters:</p> <ul> <li> <code>roi</code>               (<code>Roi</code>)           \u2013            <p>The region of interest to get the array.</p> </li> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Select a what subset of channels to return. If None, all channels are returned.</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The order of the axes to return the array.</p> </li> <li> <code>transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>The transforms to apply to the array.</p> </li> <li> <code>**slicing_kwargs</code>               (<code>SlicingInputType</code>, default:                   <code>{}</code> )           \u2013            <p>The slices to get the array.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The array of the region of interest.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def get_roi_as_numpy(\n    self,\n    roi: Roi,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; np.ndarray:\n    \"\"\"Get the image as a numpy array for a region of interest.\n\n    Args:\n        roi: The region of interest to get the array.\n        channel_selection: Select a what subset of channels to return.\n            If None, all channels are returned.\n        axes_order: The order of the axes to return the array.\n        transforms: The transforms to apply to the array.\n        **slicing_kwargs: The slices to get the array.\n\n    Returns:\n        The array of the region of interest.\n    \"\"\"\n    _slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self, channel_selection=channel_selection, slicing_dict=slicing_kwargs\n    )\n    return self._get_roi_as_numpy(\n        roi=roi, axes_order=axes_order, transforms=transforms, **_slicing_kwargs\n    )\n</code></pre>"},{"location":"api/images/#ngio.Image.get_as_dask","title":"get_as_dask","text":"<pre><code>get_as_dask(\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; Array\n</code></pre> <p>Get the image as a dask array.</p> <p>Parameters:</p> <ul> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Select a what subset of channels to return. If None, all channels are returned.</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The order of the axes to return the array.</p> </li> <li> <code>transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>The transforms to apply to the array.</p> </li> <li> <code>**slicing_kwargs</code>               (<code>SlicingInputType</code>, default:                   <code>{}</code> )           \u2013            <p>The slices to get the array.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array</code>           \u2013            <p>The dask array of the region of interest.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def get_as_dask(\n    self,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; da.Array:\n    \"\"\"Get the image as a dask array.\n\n    Args:\n        channel_selection: Select a what subset of channels to return.\n            If None, all channels are returned.\n        axes_order: The order of the axes to return the array.\n        transforms: The transforms to apply to the array.\n        **slicing_kwargs: The slices to get the array.\n\n    Returns:\n        The dask array of the region of interest.\n    \"\"\"\n    _slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self, channel_selection=channel_selection, slicing_dict=slicing_kwargs\n    )\n    return self._get_as_dask(\n        axes_order=axes_order, transforms=transforms, **_slicing_kwargs\n    )\n</code></pre>"},{"location":"api/images/#ngio.Image.get_roi_as_dask","title":"get_roi_as_dask","text":"<pre><code>get_roi_as_dask(\n    roi: Roi,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; Array\n</code></pre> <p>Get the image as a dask array for a region of interest.</p> <p>Parameters:</p> <ul> <li> <code>roi</code>               (<code>Roi</code>)           \u2013            <p>The region of interest to get the array.</p> </li> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Select a what subset of channels to return. If None, all channels are returned.</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The order of the axes to return the array.</p> </li> <li> <code>transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>The transforms to apply to the array.</p> </li> <li> <code>**slicing_kwargs</code>               (<code>SlicingInputType</code>, default:                   <code>{}</code> )           \u2013            <p>The slices to get the array.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array</code>           \u2013            <p>The dask array of the region of interest.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def get_roi_as_dask(\n    self,\n    roi: Roi,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; da.Array:\n    \"\"\"Get the image as a dask array for a region of interest.\n\n    Args:\n        roi: The region of interest to get the array.\n        channel_selection: Select a what subset of channels to return.\n            If None, all channels are returned.\n        axes_order: The order of the axes to return the array.\n        transforms: The transforms to apply to the array.\n        **slicing_kwargs: The slices to get the array.\n\n    Returns:\n        The dask array of the region of interest.\n    \"\"\"\n    _slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self, channel_selection=channel_selection, slicing_dict=slicing_kwargs\n    )\n    return self._get_roi_as_dask(\n        roi=roi, axes_order=axes_order, transforms=transforms, **_slicing_kwargs\n    )\n</code></pre>"},{"location":"api/images/#ngio.Image.get_array","title":"get_array","text":"<pre><code>get_array(\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    mode: Literal[\"numpy\", \"dask\"] = \"numpy\",\n    **slicing_kwargs: SlicingInputType,\n) -&gt; ndarray | Array\n</code></pre> <p>Get the image as a zarr array.</p> <p>Parameters:</p> <ul> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Select a what subset of channels to return. If None, all channels are returned.</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The order of the axes to return the array.</p> </li> <li> <code>transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>The transforms to apply to the array.</p> </li> <li> <code>mode</code>               (<code>Literal['numpy', 'dask']</code>, default:                   <code>'numpy'</code> )           \u2013            <p>The object type to return. Can be \"dask\", \"numpy\".</p> </li> <li> <code>**slicing_kwargs</code>               (<code>SlicingInputType</code>, default:                   <code>{}</code> )           \u2013            <p>The slices to get the array.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray | Array</code>           \u2013            <p>The zarr array of the region of interest.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def get_array(\n    self,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    mode: Literal[\"numpy\", \"dask\"] = \"numpy\",\n    **slicing_kwargs: SlicingInputType,\n) -&gt; np.ndarray | da.Array:\n    \"\"\"Get the image as a zarr array.\n\n    Args:\n        channel_selection: Select a what subset of channels to return.\n            If None, all channels are returned.\n        axes_order: The order of the axes to return the array.\n        transforms: The transforms to apply to the array.\n        mode: The object type to return.\n            Can be \"dask\", \"numpy\".\n        **slicing_kwargs: The slices to get the array.\n\n    Returns:\n        The zarr array of the region of interest.\n    \"\"\"\n    _slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self, channel_selection=channel_selection, slicing_dict=slicing_kwargs\n    )\n    return self._get_array(\n        axes_order=axes_order, mode=mode, transforms=transforms, **_slicing_kwargs\n    )\n</code></pre>"},{"location":"api/images/#ngio.Image.get_roi","title":"get_roi","text":"<pre><code>get_roi(\n    roi: Roi,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    mode: Literal[\"numpy\", \"dask\"] = \"numpy\",\n    **slicing_kwargs: SlicingInputType,\n) -&gt; ndarray | Array\n</code></pre> <p>Get the image as a zarr array for a region of interest.</p> <p>Parameters:</p> <ul> <li> <code>roi</code>               (<code>Roi</code>)           \u2013            <p>The region of interest to get the array.</p> </li> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Select a what subset of channels to return. If None, all channels are returned.</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The order of the axes to return the array.</p> </li> <li> <code>transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>The transforms to apply to the array.</p> </li> <li> <code>mode</code>               (<code>Literal['numpy', 'dask']</code>, default:                   <code>'numpy'</code> )           \u2013            <p>The object type to return. Can be \"dask\", \"numpy\".</p> </li> <li> <code>**slicing_kwargs</code>               (<code>SlicingInputType</code>, default:                   <code>{}</code> )           \u2013            <p>The slices to get the array.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray | Array</code>           \u2013            <p>The zarr array of the region of interest.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def get_roi(\n    self,\n    roi: Roi,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    mode: Literal[\"numpy\", \"dask\"] = \"numpy\",\n    **slicing_kwargs: SlicingInputType,\n) -&gt; np.ndarray | da.Array:\n    \"\"\"Get the image as a zarr array for a region of interest.\n\n    Args:\n        roi: The region of interest to get the array.\n        channel_selection: Select a what subset of channels to return.\n            If None, all channels are returned.\n        axes_order: The order of the axes to return the array.\n        transforms: The transforms to apply to the array.\n        mode: The object type to return.\n            Can be \"dask\", \"numpy\".\n        **slicing_kwargs: The slices to get the array.\n\n    Returns:\n        The zarr array of the region of interest.\n    \"\"\"\n    _slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self, channel_selection=channel_selection, slicing_dict=slicing_kwargs\n    )\n    return self._get_roi(\n        roi=roi,\n        axes_order=axes_order,\n        mode=mode,\n        transforms=transforms,\n        **_slicing_kwargs,\n    )\n</code></pre>"},{"location":"api/images/#ngio.Image.set_array","title":"set_array","text":"<pre><code>set_array(\n    patch: ndarray | Array,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; None\n</code></pre> <p>Set the image array.</p> <p>Parameters:</p> <ul> <li> <code>patch</code>               (<code>ndarray | Array</code>)           \u2013            <p>The array to set.</p> </li> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Select a what subset of channels to return. If None, all channels are set.</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The order of the axes to set the array.</p> </li> <li> <code>transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>The transforms to apply to the array.</p> </li> <li> <code>**slicing_kwargs</code>               (<code>SlicingInputType</code>, default:                   <code>{}</code> )           \u2013            <p>The slices to set the array.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def set_array(\n    self,\n    patch: np.ndarray | da.Array,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; None:\n    \"\"\"Set the image array.\n\n    Args:\n        patch: The array to set.\n        channel_selection: Select a what subset of channels to return.\n            If None, all channels are set.\n        axes_order: The order of the axes to set the array.\n        transforms: The transforms to apply to the array.\n        **slicing_kwargs: The slices to set the array.\n    \"\"\"\n    _slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self, channel_selection=channel_selection, slicing_dict=slicing_kwargs\n    )\n    self._set_array(\n        patch=patch, axes_order=axes_order, transforms=transforms, **_slicing_kwargs\n    )\n</code></pre>"},{"location":"api/images/#ngio.Image.set_roi","title":"set_roi","text":"<pre><code>set_roi(\n    roi: Roi,\n    patch: ndarray | Array,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; None\n</code></pre> <p>Set the image array for a region of interest.</p> <p>Parameters:</p> <ul> <li> <code>roi</code>               (<code>Roi</code>)           \u2013            <p>The region of interest to set the array.</p> </li> <li> <code>patch</code>               (<code>ndarray | Array</code>)           \u2013            <p>The array to set.</p> </li> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Select a what subset of channels to return.</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The order of the axes to set the array.</p> </li> <li> <code>transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>The transforms to apply to the array.</p> </li> <li> <code>**slicing_kwargs</code>               (<code>SlicingInputType</code>, default:                   <code>{}</code> )           \u2013            <p>The slices to set the array.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def set_roi(\n    self,\n    roi: Roi,\n    patch: np.ndarray | da.Array,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; None:\n    \"\"\"Set the image array for a region of interest.\n\n    Args:\n        roi: The region of interest to set the array.\n        patch: The array to set.\n        channel_selection: Select a what subset of channels to return.\n        axes_order: The order of the axes to set the array.\n        transforms: The transforms to apply to the array.\n        **slicing_kwargs: The slices to set the array.\n    \"\"\"\n    _slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self, channel_selection=channel_selection, slicing_dict=slicing_kwargs\n    )\n    self._set_roi(\n        roi=roi,\n        patch=patch,\n        axes_order=axes_order,\n        transforms=transforms,\n        **_slicing_kwargs,\n    )\n</code></pre>"},{"location":"api/images/#ngio.Image.consolidate","title":"consolidate","text":"<pre><code>consolidate(\n    order: InterpolationOrder = \"linear\",\n    mode: Literal[\"dask\", \"numpy\", \"coarsen\"] = \"dask\",\n) -&gt; None\n</code></pre> <p>Consolidate the label on disk.</p> Source code in <code>ngio/images/_image.py</code> <pre><code>def consolidate(\n    self,\n    order: InterpolationOrder = \"linear\",\n    mode: Literal[\"dask\", \"numpy\", \"coarsen\"] = \"dask\",\n) -&gt; None:\n    \"\"\"Consolidate the label on disk.\"\"\"\n    self._consolidate(order=order, mode=mode)\n</code></pre>"},{"location":"api/images/#open-a-label","title":"Open a Label","text":""},{"location":"api/images/#ngio.open_label","title":"ngio.open_label","text":"<pre><code>open_label(\n    store: StoreOrGroup,\n    name: str | None = None,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = True,\n    axes_setup: AxesSetup | None = None,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n) -&gt; Label\n</code></pre> <p>Open a single level label from an OME-Zarr Label group.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group to create the image in.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the label. If None, we will try to open the store as a multiscale label.</p> </li> <li> <code>path</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the image in the ome_zarr file.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the image.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Only used if the pixel size is provided. If True, the pixel size must match the image pixel size exactly. If False, the closest pixel size level will be returned.</p> </li> <li> <code>axes_setup</code>               (<code>AxesSetup | None</code>, default:                   <code>None</code> )           \u2013            <p>Axes setup to load ome-zarr with non-standard axes configurations.</p> </li> <li> <code>cache</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use a cache for the zarr group metadata.</p> </li> <li> <code>mode</code>               (<code>AccessModeLiteral</code>, default:                   <code>'r+'</code> )           \u2013            <p>The access mode for the image. Defaults to \"r+\".</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def open_label(\n    store: StoreOrGroup,\n    name: str | None = None,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = True,\n    axes_setup: AxesSetup | None = None,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n) -&gt; Label:\n    \"\"\"Open a single level label from an OME-Zarr Label group.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group to create the image in.\n        name (str | None): The name of the label. If None,\n            we will try to open the store as a multiscale label.\n        path (str | None): The path to the image in the ome_zarr file.\n        pixel_size (PixelSize | None): The pixel size of the image.\n        strict (bool): Only used if the pixel size is provided. If True, the\n            pixel size must match the image pixel size exactly. If False, the\n            closest pixel size level will be returned.\n        axes_setup (AxesSetup | None): Axes setup to load ome-zarr with\n            non-standard axes configurations.\n        cache (bool): Whether to use a cache for the zarr group metadata.\n        mode (AccessModeLiteral): The access mode for the image. Defaults to \"r+\".\n\n    \"\"\"\n    group_handler = ZarrGroupHandler(store=store, cache=cache, mode=mode)\n    if name is None:\n        label_meta_handler = LabelMetaHandler(group_handler, axes_setup=axes_setup)\n        path = (\n            label_meta_handler.get_meta()\n            .get_dataset(path=path, pixel_size=pixel_size, strict=strict)\n            .path\n        )\n        return Label(group_handler, path, label_meta_handler)\n\n    labels_container = LabelsContainer(group_handler, axes_setup=axes_setup)\n    return labels_container.get(\n        name=name,\n        path=path,\n        pixel_size=pixel_size,\n        strict=strict,\n    )\n</code></pre>"},{"location":"api/images/#ngiolabel-class-reference","title":"ngio.Label Class Reference","text":""},{"location":"api/images/#ngio.Label","title":"ngio.Label","text":"<pre><code>Label(\n    group_handler: ZarrGroupHandler,\n    path: str,\n    meta_handler: LabelMetaHandler,\n)\n</code></pre> <p>               Bases: <code>AbstractImage</code></p> <p>Placeholder class for a label.</p> <p>Initialize the Image at a single level.</p> <p>Parameters:</p> <ul> <li> <code>group_handler</code>               (<code>ZarrGroupHandler</code>)           \u2013            <p>The Zarr group handler.</p> </li> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path to the image in the ome_zarr file.</p> </li> <li> <code>meta_handler</code>               (<code>LabelMetaHandler</code>)           \u2013            <p>The image metadata handler.</p> </li> </ul> Source code in <code>ngio/images/_label.py</code> <pre><code>def __init__(\n    self,\n    group_handler: ZarrGroupHandler,\n    path: str,\n    meta_handler: LabelMetaHandler,\n) -&gt; None:\n    \"\"\"Initialize the Image at a single level.\n\n    Args:\n        group_handler: The Zarr group handler.\n        path: The path to the image in the ome_zarr file.\n        meta_handler: The image metadata handler.\n\n    \"\"\"\n    super().__init__(\n        group_handler=group_handler, path=path, meta_handler=meta_handler\n    )\n</code></pre>"},{"location":"api/images/#ngio.Label.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Return the path of the image.</p>"},{"location":"api/images/#ngio.Label.dataset","title":"dataset  <code>property</code>","text":"<pre><code>dataset: Dataset\n</code></pre> <p>Return the dataset of the image.</p>"},{"location":"api/images/#ngio.Label.dimensions","title":"dimensions  <code>property</code>","text":"<pre><code>dimensions: Dimensions\n</code></pre> <p>Return the dimensions of the image.</p>"},{"location":"api/images/#ngio.Label.pixel_size","title":"pixel_size  <code>property</code>","text":"<pre><code>pixel_size: PixelSize\n</code></pre> <p>Return the pixel size of the image.</p>"},{"location":"api/images/#ngio.Label.axes_handler","title":"axes_handler  <code>property</code>","text":"<pre><code>axes_handler: AxesHandler\n</code></pre> <p>Return the axes handler of the image.</p>"},{"location":"api/images/#ngio.Label.axes_setup","title":"axes_setup  <code>property</code>","text":"<pre><code>axes_setup: AxesSetup\n</code></pre> <p>Return the axes setup of the image.</p>"},{"location":"api/images/#ngio.Label.axes","title":"axes  <code>property</code>","text":"<pre><code>axes: tuple[str, ...]\n</code></pre> <p>Return the axes of the image.</p>"},{"location":"api/images/#ngio.Label.zarr_array","title":"zarr_array  <code>property</code>","text":"<pre><code>zarr_array: Array\n</code></pre> <p>Return the Zarr array.</p>"},{"location":"api/images/#ngio.Label.shape","title":"shape  <code>property</code>","text":"<pre><code>shape: tuple[int, ...]\n</code></pre> <p>Return the shape of the image.</p>"},{"location":"api/images/#ngio.Label.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype: str\n</code></pre> <p>Return the dtype of the image.</p>"},{"location":"api/images/#ngio.Label.chunks","title":"chunks  <code>property</code>","text":"<pre><code>chunks: tuple[int, ...]\n</code></pre> <p>Return the chunks of the image.</p>"},{"location":"api/images/#ngio.Label.is_3d","title":"is_3d  <code>property</code>","text":"<pre><code>is_3d: bool\n</code></pre> <p>Return True if the image is 3D.</p>"},{"location":"api/images/#ngio.Label.is_2d","title":"is_2d  <code>property</code>","text":"<pre><code>is_2d: bool\n</code></pre> <p>Return True if the image is 2D.</p>"},{"location":"api/images/#ngio.Label.is_time_series","title":"is_time_series  <code>property</code>","text":"<pre><code>is_time_series: bool\n</code></pre> <p>Return True if the image is a time series.</p>"},{"location":"api/images/#ngio.Label.is_2d_time_series","title":"is_2d_time_series  <code>property</code>","text":"<pre><code>is_2d_time_series: bool\n</code></pre> <p>Return True if the image is a 2D time series.</p>"},{"location":"api/images/#ngio.Label.is_3d_time_series","title":"is_3d_time_series  <code>property</code>","text":"<pre><code>is_3d_time_series: bool\n</code></pre> <p>Return True if the image is a 3D time series.</p>"},{"location":"api/images/#ngio.Label.is_multi_channels","title":"is_multi_channels  <code>property</code>","text":"<pre><code>is_multi_channels: bool\n</code></pre> <p>Return True if the image is multichannel.</p>"},{"location":"api/images/#ngio.Label.space_unit","title":"space_unit  <code>property</code>","text":"<pre><code>space_unit: str | None\n</code></pre> <p>Return the space unit of the image.</p>"},{"location":"api/images/#ngio.Label.time_unit","title":"time_unit  <code>property</code>","text":"<pre><code>time_unit: str | None\n</code></pre> <p>Return the time unit of the image.</p>"},{"location":"api/images/#ngio.Label.get_as_numpy","title":"get_as_numpy  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_as_numpy = _get_as_numpy\n</code></pre>"},{"location":"api/images/#ngio.Label.get_as_dask","title":"get_as_dask  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_as_dask = _get_as_dask\n</code></pre>"},{"location":"api/images/#ngio.Label.get_array","title":"get_array  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_array = _get_array\n</code></pre>"},{"location":"api/images/#ngio.Label.get_roi_as_numpy","title":"get_roi_as_numpy  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_roi_as_numpy = _get_roi_as_numpy\n</code></pre>"},{"location":"api/images/#ngio.Label.get_roi_as_dask","title":"get_roi_as_dask  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_roi_as_dask = _get_roi_as_dask\n</code></pre>"},{"location":"api/images/#ngio.Label.get_roi","title":"get_roi  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_roi = _get_roi\n</code></pre>"},{"location":"api/images/#ngio.Label.set_array","title":"set_array  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>set_array = _set_array\n</code></pre>"},{"location":"api/images/#ngio.Label.set_roi","title":"set_roi  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>set_roi = _set_roi\n</code></pre>"},{"location":"api/images/#ngio.Label.meta_handler","title":"meta_handler  <code>property</code>","text":"<pre><code>meta_handler: LabelMetaHandler\n</code></pre> <p>Return the metadata handler.</p>"},{"location":"api/images/#ngio.Label.meta","title":"meta  <code>property</code>","text":"<pre><code>meta: NgioLabelMeta\n</code></pre> <p>Return the metadata.</p>"},{"location":"api/images/#ngio.Label.has_axis","title":"has_axis","text":"<pre><code>has_axis(axis: str) -&gt; bool\n</code></pre> <p>Return True if the image has the given axis.</p> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def has_axis(self, axis: str) -&gt; bool:\n    \"\"\"Return True if the image has the given axis.\"\"\"\n    return self.axes_handler.has_axis(axis)\n</code></pre>"},{"location":"api/images/#ngio.Label.set_axes_unit","title":"set_axes_unit","text":"<pre><code>set_axes_unit(\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n) -&gt; None\n</code></pre> <p>Set the axes unit of the image.</p> <p>Parameters:</p> <ul> <li> <code>space_unit</code>               (<code>SpaceUnits</code>, default:                   <code>DefaultSpaceUnit</code> )           \u2013            <p>The space unit of the image.</p> </li> <li> <code>time_unit</code>               (<code>TimeUnits</code>, default:                   <code>DefaultTimeUnit</code> )           \u2013            <p>The time unit of the image.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def set_axes_unit(\n    self,\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n) -&gt; None:\n    \"\"\"Set the axes unit of the image.\n\n    Args:\n        space_unit (SpaceUnits): The space unit of the image.\n        time_unit (TimeUnits): The time unit of the image.\n    \"\"\"\n    meta = self._meta_handler.get_meta()\n    meta = meta.to_units(space_unit=space_unit, time_unit=time_unit)\n    self._meta_handler.update_meta(meta)  # type: ignore\n</code></pre>"},{"location":"api/images/#ngio.Label.set_axes_names","title":"set_axes_names","text":"<pre><code>set_axes_names(axes_names: Sequence[str]) -&gt; None\n</code></pre> <p>Set the axes names of the label.</p> <p>Parameters:</p> <ul> <li> <code>axes_names</code>               (<code>Sequence[str]</code>)           \u2013            <p>The axes names to set.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def set_axes_names(self, axes_names: Sequence[str]) -&gt; None:\n    \"\"\"Set the axes names of the label.\n\n    Args:\n        axes_names (Sequence[str]): The axes names to set.\n    \"\"\"\n    meta = self._meta_handler.get_meta()\n    meta = meta.rename_axes(axes_names=axes_names)\n    self._meta_handler._axes_setup = meta.axes_handler.axes_setup\n    self._meta_handler.update_meta(meta)  # type: ignore\n</code></pre>"},{"location":"api/images/#ngio.Label.set_name","title":"set_name","text":"<pre><code>set_name(name: str) -&gt; None\n</code></pre> <p>Set the name of the image in the metadata.</p> <p>This does not change the group name or any paths.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the image.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def set_name(\n    self,\n    name: str,\n) -&gt; None:\n    \"\"\"Set the name of the image in the metadata.\n\n    This does not change the group name or any paths.\n\n    Args:\n        name (str): The name of the image.\n    \"\"\"\n    meta = self._meta_handler.get_meta()\n    meta = meta.rename_image(name=name)\n    self._meta_handler.update_meta(meta)  # type: ignore\n</code></pre>"},{"location":"api/images/#ngio.Label.roi","title":"roi","text":"<pre><code>roi(name: str | None = 'image') -&gt; Roi\n</code></pre> <p>Return the ROI covering the entire image.</p> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def roi(self, name: str | None = \"image\") -&gt; Roi:\n    \"\"\"Return the ROI covering the entire image.\"\"\"\n    slices = {}\n    for ax_name in [\"t\", \"z\", \"y\", \"x\"]:\n        axis_size = self.dimensions.get(ax_name, default=None)\n        if axis_size is None:\n            continue\n        slices[ax_name] = slice(0, axis_size)\n    roi_px = Roi.from_values(name=name, slices=slices, space=\"pixel\")\n    return roi_px.to_world(pixel_size=self.pixel_size)\n</code></pre>"},{"location":"api/images/#ngio.Label.build_image_roi_table","title":"build_image_roi_table","text":"<pre><code>build_image_roi_table(\n    name: str | None = \"image\",\n) -&gt; RoiTable\n</code></pre> <p>Build the ROI table containing the ROI covering the entire image.</p> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def build_image_roi_table(self, name: str | None = \"image\") -&gt; RoiTable:\n    \"\"\"Build the ROI table containing the ROI covering the entire image.\"\"\"\n    return RoiTable(rois=[self.roi(name=name)])\n</code></pre>"},{"location":"api/images/#ngio.Label.require_dimensions_match","title":"require_dimensions_match","text":"<pre><code>require_dimensions_match(\n    other: AbstractImage, allow_singleton: bool = False\n) -&gt; None\n</code></pre> <p>Assert that two images have matching spatial dimensions.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>AbstractImage</code>)           \u2013            <p>The other image to compare to.</p> </li> <li> <code>allow_singleton</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, allow singleton dimensions to be compatible with non-singleton dimensions.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NgioValueError</code>             \u2013            <p>If the images do not have compatible dimensions.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def require_dimensions_match(\n    self,\n    other: \"AbstractImage\",\n    allow_singleton: bool = False,\n) -&gt; None:\n    \"\"\"Assert that two images have matching spatial dimensions.\n\n    Args:\n        other: The other image to compare to.\n        allow_singleton: If True, allow singleton dimensions to be\n            compatible with non-singleton dimensions.\n\n    Raises:\n        NgioValueError: If the images do not have compatible dimensions.\n    \"\"\"\n    self.dimensions.require_dimensions_match(\n        other.dimensions, allow_singleton=allow_singleton\n    )\n</code></pre>"},{"location":"api/images/#ngio.Label.check_if_dimensions_match","title":"check_if_dimensions_match","text":"<pre><code>check_if_dimensions_match(\n    other: AbstractImage, allow_singleton: bool = False\n) -&gt; bool\n</code></pre> <p>Check if two images have matching spatial dimensions.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>AbstractImage</code>)           \u2013            <p>The other image to compare to.</p> </li> <li> <code>allow_singleton</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, allow singleton dimensions to be compatible with non-singleton dimensions.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the images have matching dimensions, False otherwise.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def check_if_dimensions_match(\n    self,\n    other: \"AbstractImage\",\n    allow_singleton: bool = False,\n) -&gt; bool:\n    \"\"\"Check if two images have matching spatial dimensions.\n\n    Args:\n        other: The other image to compare to.\n        allow_singleton: If True, allow singleton dimensions to be\n            compatible with non-singleton dimensions.\n\n    Returns:\n        bool: True if the images have matching dimensions, False otherwise.\n    \"\"\"\n    return self.dimensions.check_if_dimensions_match(\n        other.dimensions, allow_singleton=allow_singleton\n    )\n</code></pre>"},{"location":"api/images/#ngio.Label.require_axes_match","title":"require_axes_match","text":"<pre><code>require_axes_match(other: AbstractImage) -&gt; None\n</code></pre> <p>Assert that two images have compatible axes.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>AbstractImage</code>)           \u2013            <p>The other image to compare to.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NgioValueError</code>             \u2013            <p>If the images do not have compatible axes.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def require_axes_match(\n    self,\n    other: \"AbstractImage\",\n) -&gt; None:\n    \"\"\"Assert that two images have compatible axes.\n\n    Args:\n        other: The other image to compare to.\n\n    Raises:\n        NgioValueError: If the images do not have compatible axes.\n    \"\"\"\n    self.dimensions.require_axes_match(other.dimensions)\n</code></pre>"},{"location":"api/images/#ngio.Label.check_if_axes_match","title":"check_if_axes_match","text":"<pre><code>check_if_axes_match(other: AbstractImage) -&gt; bool\n</code></pre> <p>Check if two images have compatible axes.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>AbstractImage</code>)           \u2013            <p>The other image to compare to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the images have compatible axes, False otherwise.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def check_if_axes_match(\n    self,\n    other: \"AbstractImage\",\n) -&gt; bool:\n    \"\"\"Check if two images have compatible axes.\n\n    Args:\n        other: The other image to compare to.\n\n    Returns:\n        bool: True if the images have compatible axes, False otherwise.\n\n    \"\"\"\n    return self.dimensions.check_if_axes_match(other.dimensions)\n</code></pre>"},{"location":"api/images/#ngio.Label.require_rescalable","title":"require_rescalable","text":"<pre><code>require_rescalable(other: AbstractImage) -&gt; None\n</code></pre> <p>Assert that two images can be rescaled to each other.</p> <p>For this to be true, the images must have the same axes, and the pixel sizes must be compatible (i.e. one can be scaled to the other).</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>AbstractImage</code>)           \u2013            <p>The other image to compare to.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NgioValueError</code>             \u2013            <p>If the images cannot be scaled to each other.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def require_rescalable(\n    self,\n    other: \"AbstractImage\",\n) -&gt; None:\n    \"\"\"Assert that two images can be rescaled to each other.\n\n    For this to be true, the images must have the same axes, and\n    the pixel sizes must be compatible (i.e. one can be scaled to the other).\n\n    Args:\n        other: The other image to compare to.\n\n    Raises:\n        NgioValueError: If the images cannot be scaled to each other.\n    \"\"\"\n    self.dimensions.require_rescalable(other.dimensions)\n</code></pre>"},{"location":"api/images/#ngio.Label.check_if_rescalable","title":"check_if_rescalable","text":"<pre><code>check_if_rescalable(other: AbstractImage) -&gt; bool\n</code></pre> <p>Check if two images can be rescaled to each other.</p> <p>For this to be true, the images must have the same axes, and the pixel sizes must be compatible (i.e. one can be scaled to the other).</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>AbstractImage</code>)           \u2013            <p>The other image to compare to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the images can be rescaled to each other, False otherwise.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def check_if_rescalable(\n    self,\n    other: \"AbstractImage\",\n) -&gt; bool:\n    \"\"\"Check if two images can be rescaled to each other.\n\n    For this to be true, the images must have the same axes, and\n    the pixel sizes must be compatible (i.e. one can be scaled to the other).\n\n    Args:\n        other: The other image to compare to.\n\n    Returns:\n        bool: True if the images can be rescaled to each other, False otherwise.\n    \"\"\"\n    return self.dimensions.check_if_rescalable(other.dimensions)\n</code></pre>"},{"location":"api/images/#ngio.Label.build_masking_roi_table","title":"build_masking_roi_table","text":"<pre><code>build_masking_roi_table(\n    axes_order: Sequence[str] | None = None,\n) -&gt; MaskingRoiTable\n</code></pre> <p>Compute the masking ROI table.</p> Source code in <code>ngio/images/_label.py</code> <pre><code>def build_masking_roi_table(\n    self, axes_order: Sequence[str] | None = None\n) -&gt; MaskingRoiTable:\n    \"\"\"Compute the masking ROI table.\"\"\"\n    return build_masking_roi_table(self, axes_order=axes_order)\n</code></pre>"},{"location":"api/images/#ngio.Label.consolidate","title":"consolidate","text":"<pre><code>consolidate(\n    mode: Literal[\"dask\", \"numpy\", \"coarsen\"] = \"dask\",\n) -&gt; None\n</code></pre> <p>Consolidate the label on disk.</p> Source code in <code>ngio/images/_label.py</code> <pre><code>def consolidate(\n    self,\n    mode: Literal[\"dask\", \"numpy\", \"coarsen\"] = \"dask\",\n) -&gt; None:\n    \"\"\"Consolidate the label on disk.\"\"\"\n    self._consolidate(\n        order=\"nearest\",\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/iterators/","title":"Iterators API Reference","text":""},{"location":"api/iterators/#imageprocessingiterator","title":"ImageProcessingIterator","text":""},{"location":"api/iterators/#ngio.experimental.iterators.ImageProcessingIterator","title":"ngio.experimental.iterators.ImageProcessingIterator","text":"<pre><code>ImageProcessingIterator(\n    input_image: Image,\n    output_image: Image,\n    input_channel_selection: ChannelSlicingInputType = None,\n    output_channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    input_transforms: Sequence[TransformProtocol]\n    | None = None,\n    output_transforms: Sequence[TransformProtocol]\n    | None = None,\n)\n</code></pre> <p>               Bases: <code>AbstractIteratorBuilder[ndarray, Array]</code></p> <p>Base class for iterators over ROIs.</p> <p>Initialize the iterator with a ROI table and input/output images.</p> <p>Parameters:</p> <ul> <li> <code>input_image</code>               (<code>Image</code>)           \u2013            <p>The input image to be used as input for the segmentation.</p> </li> <li> <code>output_image</code>               (<code>Image</code>)           \u2013            <p>The image where the ROIs will be written.</p> </li> <li> <code>input_channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Optional selection of channels to use for the input image.</p> </li> <li> <code>output_channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Optional selection of channels to use for the output image.</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional axes order for the segmentation.</p> </li> <li> <code>input_transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional transforms to apply to the input image.</p> </li> <li> <code>output_transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional transforms to apply to the output label.</p> </li> </ul> Source code in <code>ngio/experimental/iterators/_image_processing.py</code> <pre><code>def __init__(\n    self,\n    input_image: Image,\n    output_image: Image,\n    input_channel_selection: ChannelSlicingInputType = None,\n    output_channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    input_transforms: Sequence[TransformProtocol] | None = None,\n    output_transforms: Sequence[TransformProtocol] | None = None,\n) -&gt; None:\n    \"\"\"Initialize the iterator with a ROI table and input/output images.\n\n    Args:\n        input_image (Image): The input image to be used as input for the\n            segmentation.\n        output_image (Image): The image where the ROIs will be written.\n        input_channel_selection (ChannelSlicingInputType): Optional\n            selection of channels to use for the input image.\n        output_channel_selection (ChannelSlicingInputType): Optional\n            selection of channels to use for the output image.\n        axes_order (Sequence[str] | None): Optional axes order for the\n            segmentation.\n        input_transforms (Sequence[TransformProtocol] | None): Optional\n            transforms to apply to the input image.\n        output_transforms (Sequence[TransformProtocol] | None): Optional\n            transforms to apply to the output label.\n    \"\"\"\n    self._input = input_image\n    self._output = output_image\n    self._ref_image = input_image\n    self._rois = input_image.build_image_roi_table(name=None).rois()\n\n    # Set iteration parameters\n    self._input_slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self._input,\n        channel_selection=input_channel_selection,\n        slicing_dict={},\n    )\n    self._output_slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self._output,\n        channel_selection=output_channel_selection,\n        slicing_dict={},\n    )\n    self._input_channel_selection = input_channel_selection\n    self._output_channel_selection = output_channel_selection\n    self._axes_order = axes_order\n    self._input_transforms = input_transforms\n    self._output_transforms = output_transforms\n\n    self._input.require_dimensions_match(self._output, allow_singleton=True)\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.ImageProcessingIterator.rois","title":"rois  <code>property</code>","text":"<pre><code>rois: list[Roi]\n</code></pre> <p>Get the list of ROIs for the iterator.</p>"},{"location":"api/iterators/#ngio.experimental.iterators.ImageProcessingIterator.ref_image","title":"ref_image  <code>property</code>","text":"<pre><code>ref_image: AbstractImage\n</code></pre> <p>Get the reference image for the iterator.</p>"},{"location":"api/iterators/#ngio.experimental.iterators.ImageProcessingIterator.grid","title":"grid","text":"<pre><code>grid(\n    size_x: int | None = None,\n    size_y: int | None = None,\n    size_z: int | None = None,\n    size_t: int | None = None,\n    stride_x: int | None = None,\n    stride_y: int | None = None,\n    stride_z: int | None = None,\n    stride_t: int | None = None,\n    base_name: str = \"\",\n) -&gt; Self\n</code></pre> <p>Create a grid of ROIs based on the input image dimensions.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def grid(\n    self,\n    size_x: int | None = None,\n    size_y: int | None = None,\n    size_z: int | None = None,\n    size_t: int | None = None,\n    stride_x: int | None = None,\n    stride_y: int | None = None,\n    stride_z: int | None = None,\n    stride_t: int | None = None,\n    base_name: str = \"\",\n) -&gt; Self:\n    \"\"\"Create a grid of ROIs based on the input image dimensions.\"\"\"\n    rois = grid(\n        rois=self.rois,\n        ref_image=self.ref_image,\n        size_x=size_x,\n        size_y=size_y,\n        size_z=size_z,\n        size_t=size_t,\n        stride_x=stride_x,\n        stride_y=stride_y,\n        stride_z=stride_z,\n        stride_t=stride_t,\n        base_name=base_name,\n    )\n    return self._new_from_rois(rois)\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.ImageProcessingIterator.by_yx","title":"by_yx","text":"<pre><code>by_yx() -&gt; Self\n</code></pre> <p>Return a new iterator that iterates over ROIs by YX coordinates.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def by_yx(self) -&gt; Self:\n    \"\"\"Return a new iterator that iterates over ROIs by YX coordinates.\"\"\"\n    rois = by_yx(self.rois, self.ref_image)\n    return self._new_from_rois(rois)\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.ImageProcessingIterator.by_zyx","title":"by_zyx","text":"<pre><code>by_zyx(strict: bool = True) -&gt; Self\n</code></pre> <p>Return a new iterator that iterates over ROIs by ZYX coordinates.</p> <p>Parameters:</p> <ul> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, only iterate over ZYX if a Z axis is present and not of size 1.</p> </li> </ul> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def by_zyx(self, strict: bool = True) -&gt; Self:\n    \"\"\"Return a new iterator that iterates over ROIs by ZYX coordinates.\n\n    Args:\n        strict (bool): If True, only iterate over ZYX if a Z axis\n            is present and not of size 1.\n\n    \"\"\"\n    rois = by_zyx(self.rois, self.ref_image, strict=strict)\n    return self._new_from_rois(rois)\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.ImageProcessingIterator.by_chunks","title":"by_chunks","text":"<pre><code>by_chunks(overlap_xy: int = 0, overlap_z: int = 0) -&gt; Self\n</code></pre> <p>Return a new iterator that iterates over ROIs by chunks.</p> <p>Parameters:</p> <ul> <li> <code>overlap_xy</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Overlap in XY dimensions.</p> </li> <li> <code>overlap_z</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Overlap in Z dimension.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SegmentationIterator</code> (              <code>Self</code> )          \u2013            <p>A new iterator with chunked ROIs.</p> </li> </ul> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def by_chunks(self, overlap_xy: int = 0, overlap_z: int = 0) -&gt; Self:\n    \"\"\"Return a new iterator that iterates over ROIs by chunks.\n\n    Args:\n        overlap_xy (int): Overlap in XY dimensions.\n        overlap_z (int): Overlap in Z dimension.\n\n    Returns:\n        SegmentationIterator: A new iterator with chunked ROIs.\n    \"\"\"\n    rois = by_chunks(\n        self.rois, self.ref_image, overlap_xy=overlap_xy, overlap_z=overlap_z\n    )\n    return self._new_from_rois(rois)\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.ImageProcessingIterator.product","title":"product","text":"<pre><code>product(other: list[Roi] | GenericRoiTable) -&gt; Self\n</code></pre> <p>Cartesian product of the current ROIs with an arbitrary list of ROIs.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def product(self, other: list[Roi] | GenericRoiTable) -&gt; Self:\n    \"\"\"Cartesian product of the current ROIs with an arbitrary list of ROIs.\"\"\"\n    if isinstance(other, GenericRoiTable):\n        other = other.rois()\n    rois = rois_product(self.rois, other)\n    return self._new_from_rois(rois)\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.ImageProcessingIterator.iter","title":"iter","text":"<pre><code>iter(\n    lazy: Literal[True],\n    data_mode: Literal[\"numpy\"],\n    iterator_mode: Literal[\"readwrite\"],\n) -&gt; Generator[\n    tuple[\n        DataGetterProtocol[NumpyPipeType],\n        DataSetterProtocol[NumpyPipeType],\n    ]\n]\n</code></pre><pre><code>iter(\n    lazy: Literal[True],\n    data_mode: Literal[\"numpy\"],\n    iterator_mode: Literal[\"readonly\"] = ...,\n) -&gt; Generator[DataGetterProtocol[NumpyPipeType]]\n</code></pre><pre><code>iter(\n    lazy: Literal[True],\n    data_mode: Literal[\"dask\"],\n    iterator_mode: Literal[\"readwrite\"],\n) -&gt; Generator[\n    tuple[\n        DataGetterProtocol[DaskPipeType],\n        DataSetterProtocol[DaskPipeType],\n    ]\n]\n</code></pre><pre><code>iter(\n    lazy: Literal[True],\n    data_mode: Literal[\"dask\"],\n    iterator_mode: Literal[\"readonly\"] = ...,\n) -&gt; Generator[DataGetterProtocol[DaskPipeType]]\n</code></pre><pre><code>iter(\n    lazy: Literal[False],\n    data_mode: Literal[\"numpy\"],\n    iterator_mode: Literal[\"readwrite\"],\n) -&gt; Generator[\n    tuple[NumpyPipeType, DataSetterProtocol[NumpyPipeType]]\n]\n</code></pre><pre><code>iter(\n    lazy: Literal[False],\n    data_mode: Literal[\"numpy\"],\n    iterator_mode: Literal[\"readonly\"] = ...,\n) -&gt; Generator[NumpyPipeType]\n</code></pre><pre><code>iter(\n    lazy: Literal[False],\n    data_mode: Literal[\"dask\"],\n    iterator_mode: Literal[\"readwrite\"],\n) -&gt; Generator[\n    tuple[DaskPipeType, DataSetterProtocol[DaskPipeType]]\n]\n</code></pre><pre><code>iter(\n    lazy: Literal[False],\n    data_mode: Literal[\"dask\"],\n    iterator_mode: Literal[\"readonly\"] = ...,\n) -&gt; Generator[DaskPipeType]\n</code></pre> <pre><code>iter(\n    lazy: bool = False,\n    data_mode: Literal[\"numpy\", \"dask\"] = \"dask\",\n    iterator_mode: Literal[\n        \"readwrite\", \"readonly\"\n    ] = \"readwrite\",\n) -&gt; Generator\n</code></pre> <p>Create an iterator over the pixels of the ROIs.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def iter(\n    self,\n    lazy: bool = False,\n    data_mode: Literal[\"numpy\", \"dask\"] = \"dask\",\n    iterator_mode: Literal[\"readwrite\", \"readonly\"] = \"readwrite\",\n) -&gt; Generator:\n    \"\"\"Create an iterator over the pixels of the ROIs.\"\"\"\n    if data_mode == \"numpy\":\n        getters = self._numpy_getters_generator()\n        setters = self._numpy_setters_generator()\n    elif data_mode == \"dask\":\n        getters = self._dask_getters_generator()\n        setters = self._dask_setters_generator()\n    else:\n        raise NgioValueError(f\"Invalid mode: {data_mode}\")\n\n    if iterator_mode == \"readonly\":\n        if lazy:\n            return getters\n        else:\n            return (getter() for getter in getters)\n    if lazy:\n        return self._read_and_write_generator(getters, setters)\n    else:\n        gen = self._read_and_write_generator(getters, setters)\n        return ((getter(), setter) for getter, setter in gen)\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.ImageProcessingIterator.iter_as_numpy","title":"iter_as_numpy","text":"<pre><code>iter_as_numpy()\n</code></pre> <p>Create an iterator over the pixels of the ROIs.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def iter_as_numpy(\n    self,\n):\n    \"\"\"Create an iterator over the pixels of the ROIs.\"\"\"\n    return self.iter(lazy=False, data_mode=\"numpy\", iterator_mode=\"readwrite\")\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.ImageProcessingIterator.iter_as_dask","title":"iter_as_dask","text":"<pre><code>iter_as_dask()\n</code></pre> <p>Create an iterator over the pixels of the ROIs.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def iter_as_dask(\n    self,\n):\n    \"\"\"Create an iterator over the pixels of the ROIs.\"\"\"\n    return self.iter(lazy=False, data_mode=\"dask\", iterator_mode=\"readwrite\")\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.ImageProcessingIterator.map_as_numpy","title":"map_as_numpy","text":"<pre><code>map_as_numpy(\n    func: Callable[[NumpyPipeType], NumpyPipeType],\n    mapper: MapperProtocol[NumpyPipeType] | None = None,\n) -&gt; None\n</code></pre> <p>Apply a transformation function to the ROI pixels.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def map_as_numpy(\n    self,\n    func: Callable[[NumpyPipeType], NumpyPipeType],\n    mapper: MapperProtocol[NumpyPipeType] | None = None,\n) -&gt; None:\n    \"\"\"Apply a transformation function to the ROI pixels.\"\"\"\n    if mapper is None:\n        _mapper = BasicMapper[NumpyPipeType]()\n    else:\n        _mapper = mapper\n\n    _mapper(\n        func=func,\n        getters=self._numpy_getters_generator(),\n        setters=self._numpy_setters_generator(),\n    )\n    self.post_consolidate()\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.ImageProcessingIterator.map_as_dask","title":"map_as_dask","text":"<pre><code>map_as_dask(\n    func: Callable[[DaskPipeType], DaskPipeType],\n    mapper: MapperProtocol[DaskPipeType] | None = None,\n) -&gt; None\n</code></pre> <p>Apply a transformation function to the ROI pixels.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def map_as_dask(\n    self,\n    func: Callable[[DaskPipeType], DaskPipeType],\n    mapper: MapperProtocol[DaskPipeType] | None = None,\n) -&gt; None:\n    \"\"\"Apply a transformation function to the ROI pixels.\"\"\"\n    if mapper is None:\n        _mapper = BasicMapper[DaskPipeType]()\n    else:\n        _mapper = mapper\n\n    _mapper(\n        func=func,\n        getters=self._dask_getters_generator(),\n        setters=self._dask_setters_generator(),\n    )\n    self.post_consolidate()\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.ImageProcessingIterator.check_if_regions_overlap","title":"check_if_regions_overlap","text":"<pre><code>check_if_regions_overlap() -&gt; bool\n</code></pre> <p>Check if any of the ROIs overlap logically.</p> <p>If two ROIs cover the same pixel, they are considered to overlap. This does not consider chunking or other storage details.</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if any ROIs overlap. False otherwise.</p> </li> </ul> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def check_if_regions_overlap(self) -&gt; bool:\n    \"\"\"Check if any of the ROIs overlap logically.\n\n    If two ROIs cover the same pixel, they are considered to overlap.\n    This does not consider chunking or other storage details.\n\n    Returns:\n        bool: True if any ROIs overlap. False otherwise.\n    \"\"\"\n    if len(self.rois) &lt; 2:\n        # Less than 2 ROIs cannot overlap\n        return False\n\n    slicing_tuples = (\n        g.slicing_ops.normalized_slicing_tuple\n        for g in self._numpy_getters_generator()\n    )\n    x = check_if_regions_overlap(slicing_tuples)\n    return x\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.ImageProcessingIterator.require_no_regions_overlap","title":"require_no_regions_overlap","text":"<pre><code>require_no_regions_overlap() -&gt; None\n</code></pre> <p>Ensure that the Iterator's ROIs do not overlap.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def require_no_regions_overlap(self) -&gt; None:\n    \"\"\"Ensure that the Iterator's ROIs do not overlap.\"\"\"\n    if self.check_if_regions_overlap():\n        raise NgioValueError(\"Some rois overlap.\")\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.ImageProcessingIterator.check_if_chunks_overlap","title":"check_if_chunks_overlap","text":"<pre><code>check_if_chunks_overlap() -&gt; bool\n</code></pre> <p>Check if any of the ROIs overlap in terms of chunks.</p> <p>If two ROIs cover the same chunk, they are considered to overlap in chunks. This does not consider pixel-level overlaps.</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if any ROIs overlap in chunks, False otherwise.</p> </li> </ul> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def check_if_chunks_overlap(self) -&gt; bool:\n    \"\"\"Check if any of the ROIs overlap in terms of chunks.\n\n    If two ROIs cover the same chunk, they are considered to overlap in chunks.\n    This does not consider pixel-level overlaps.\n\n    Returns:\n        bool: True if any ROIs overlap in chunks, False otherwise.\n    \"\"\"\n    from ngio.io_pipes._ops_slices_utils import check_if_chunks_overlap\n\n    if len(self.rois) &lt; 2:\n        # Less than 2 ROIs cannot overlap\n        return False\n\n    slicing_tuples = (\n        g.slicing_ops.normalized_slicing_tuple\n        for g in self._numpy_getters_generator()\n    )\n    shape = self.ref_image.shape\n    chunks = self.ref_image.chunks\n    return check_if_chunks_overlap(slicing_tuples, shape, chunks)\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.ImageProcessingIterator.require_no_chunks_overlap","title":"require_no_chunks_overlap","text":"<pre><code>require_no_chunks_overlap() -&gt; None\n</code></pre> <p>Ensure that the ROIs do not overlap in terms of chunks.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def require_no_chunks_overlap(self) -&gt; None:\n    \"\"\"Ensure that the ROIs do not overlap in terms of chunks.\"\"\"\n    if self.check_if_chunks_overlap():\n        raise NgioValueError(\"Some rois overlap in chunks.\")\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.ImageProcessingIterator.get_init_kwargs","title":"get_init_kwargs","text":"<pre><code>get_init_kwargs() -&gt; dict\n</code></pre> <p>Return the initialization arguments for the iterator.</p> Source code in <code>ngio/experimental/iterators/_image_processing.py</code> <pre><code>def get_init_kwargs(self) -&gt; dict:\n    \"\"\"Return the initialization arguments for the iterator.\"\"\"\n    return {\n        \"input_image\": self._input,\n        \"output_image\": self._output,\n        \"input_channel_selection\": self._input_channel_selection,\n        \"output_channel_selection\": self._output_channel_selection,\n        \"axes_order\": self._axes_order,\n        \"input_transforms\": self._input_transforms,\n        \"output_transforms\": self._output_transforms,\n    }\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.ImageProcessingIterator.build_numpy_getter","title":"build_numpy_getter","text":"<pre><code>build_numpy_getter(roi: Roi) -&gt; DataGetterProtocol[ndarray]\n</code></pre> Source code in <code>ngio/experimental/iterators/_image_processing.py</code> <pre><code>def build_numpy_getter(self, roi: Roi) -&gt; DataGetterProtocol[np.ndarray]:\n    return NumpyRoiGetter(\n        zarr_array=self._input.zarr_array,\n        dimensions=self._input.dimensions,\n        roi=roi,\n        axes_order=self._axes_order,\n        transforms=self._input_transforms,\n        slicing_dict=self._input_slicing_kwargs,\n    )\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.ImageProcessingIterator.build_numpy_setter","title":"build_numpy_setter","text":"<pre><code>build_numpy_setter(roi: Roi) -&gt; DataSetterProtocol[ndarray]\n</code></pre> Source code in <code>ngio/experimental/iterators/_image_processing.py</code> <pre><code>def build_numpy_setter(self, roi: Roi) -&gt; DataSetterProtocol[np.ndarray]:\n    return NumpyRoiSetter(\n        zarr_array=self._output.zarr_array,\n        dimensions=self._output.dimensions,\n        roi=roi,\n        axes_order=self._axes_order,\n        transforms=self._output_transforms,\n        slicing_dict=self._output_slicing_kwargs,\n    )\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.ImageProcessingIterator.build_dask_getter","title":"build_dask_getter","text":"<pre><code>build_dask_getter(roi: Roi) -&gt; DataGetterProtocol[Array]\n</code></pre> Source code in <code>ngio/experimental/iterators/_image_processing.py</code> <pre><code>def build_dask_getter(self, roi: Roi) -&gt; DataGetterProtocol[da.Array]:\n    return DaskRoiGetter(\n        zarr_array=self._input.zarr_array,\n        dimensions=self._input.dimensions,\n        roi=roi,\n        axes_order=self._axes_order,\n        transforms=self._input_transforms,\n        slicing_dict=self._input_slicing_kwargs,\n    )\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.ImageProcessingIterator.build_dask_setter","title":"build_dask_setter","text":"<pre><code>build_dask_setter(roi: Roi) -&gt; DataSetterProtocol[Array]\n</code></pre> Source code in <code>ngio/experimental/iterators/_image_processing.py</code> <pre><code>def build_dask_setter(self, roi: Roi) -&gt; DataSetterProtocol[da.Array]:\n    return DaskRoiSetter(\n        zarr_array=self._output.zarr_array,\n        dimensions=self._output.dimensions,\n        roi=roi,\n        axes_order=self._axes_order,\n        transforms=self._output_transforms,\n        slicing_dict=self._output_slicing_kwargs,\n    )\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.ImageProcessingIterator.post_consolidate","title":"post_consolidate","text":"<pre><code>post_consolidate()\n</code></pre> Source code in <code>ngio/experimental/iterators/_image_processing.py</code> <pre><code>def post_consolidate(self):\n    self._output.consolidate()\n</code></pre>"},{"location":"api/iterators/#segmentationiterator","title":"SegmentationIterator","text":""},{"location":"api/iterators/#ngio.experimental.iterators.SegmentationIterator","title":"ngio.experimental.iterators.SegmentationIterator","text":"<pre><code>SegmentationIterator(\n    input_image: Image,\n    output_label: Label,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    input_transforms: Sequence[TransformProtocol]\n    | None = None,\n    output_transforms: Sequence[TransformProtocol]\n    | None = None,\n)\n</code></pre> <p>               Bases: <code>AbstractIteratorBuilder[ndarray, Array]</code></p> <p>Base class for iterators over ROIs.</p> <p>Initialize the iterator with a ROI table and input/output images.</p> <p>Parameters:</p> <ul> <li> <code>input_image</code>               (<code>Image</code>)           \u2013            <p>The input image to be used as input for the segmentation.</p> </li> <li> <code>output_label</code>               (<code>Label</code>)           \u2013            <p>The label image where the ROIs will be written.</p> </li> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Optional selection of channels to use for the segmentation.</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional axes order for the segmentation.</p> </li> <li> <code>input_transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional transforms to apply to the input image.</p> </li> <li> <code>output_transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional transforms to apply to the output label.</p> </li> </ul> Source code in <code>ngio/experimental/iterators/_segmentation.py</code> <pre><code>def __init__(\n    self,\n    input_image: Image,\n    output_label: Label,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    input_transforms: Sequence[TransformProtocol] | None = None,\n    output_transforms: Sequence[TransformProtocol] | None = None,\n) -&gt; None:\n    \"\"\"Initialize the iterator with a ROI table and input/output images.\n\n    Args:\n        input_image (Image): The input image to be used as input for the\n            segmentation.\n        output_label (Label): The label image where the ROIs will be written.\n        channel_selection (ChannelSlicingInputType): Optional\n            selection of channels to use for the segmentation.\n        axes_order (Sequence[str] | None): Optional axes order for the\n            segmentation.\n        input_transforms (Sequence[TransformProtocol] | None): Optional\n            transforms to apply to the input image.\n        output_transforms (Sequence[TransformProtocol] | None): Optional\n            transforms to apply to the output label.\n    \"\"\"\n    self._input = input_image\n    self._output = output_label\n    self._ref_image = input_image\n    self._rois = input_image.build_image_roi_table(name=None).rois()\n\n    # Set iteration parameters\n    self._input_slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self._input, channel_selection=channel_selection, slicing_dict={}\n    )\n    self._channel_selection = channel_selection\n    self._axes_order = axes_order\n    self._input_transforms = input_transforms\n    self._output_transforms = output_transforms\n\n    self._input.require_dimensions_match(self._output, allow_singleton=False)\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.SegmentationIterator.rois","title":"rois  <code>property</code>","text":"<pre><code>rois: list[Roi]\n</code></pre> <p>Get the list of ROIs for the iterator.</p>"},{"location":"api/iterators/#ngio.experimental.iterators.SegmentationIterator.ref_image","title":"ref_image  <code>property</code>","text":"<pre><code>ref_image: AbstractImage\n</code></pre> <p>Get the reference image for the iterator.</p>"},{"location":"api/iterators/#ngio.experimental.iterators.SegmentationIterator.grid","title":"grid","text":"<pre><code>grid(\n    size_x: int | None = None,\n    size_y: int | None = None,\n    size_z: int | None = None,\n    size_t: int | None = None,\n    stride_x: int | None = None,\n    stride_y: int | None = None,\n    stride_z: int | None = None,\n    stride_t: int | None = None,\n    base_name: str = \"\",\n) -&gt; Self\n</code></pre> <p>Create a grid of ROIs based on the input image dimensions.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def grid(\n    self,\n    size_x: int | None = None,\n    size_y: int | None = None,\n    size_z: int | None = None,\n    size_t: int | None = None,\n    stride_x: int | None = None,\n    stride_y: int | None = None,\n    stride_z: int | None = None,\n    stride_t: int | None = None,\n    base_name: str = \"\",\n) -&gt; Self:\n    \"\"\"Create a grid of ROIs based on the input image dimensions.\"\"\"\n    rois = grid(\n        rois=self.rois,\n        ref_image=self.ref_image,\n        size_x=size_x,\n        size_y=size_y,\n        size_z=size_z,\n        size_t=size_t,\n        stride_x=stride_x,\n        stride_y=stride_y,\n        stride_z=stride_z,\n        stride_t=stride_t,\n        base_name=base_name,\n    )\n    return self._new_from_rois(rois)\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.SegmentationIterator.by_yx","title":"by_yx","text":"<pre><code>by_yx() -&gt; Self\n</code></pre> <p>Return a new iterator that iterates over ROIs by YX coordinates.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def by_yx(self) -&gt; Self:\n    \"\"\"Return a new iterator that iterates over ROIs by YX coordinates.\"\"\"\n    rois = by_yx(self.rois, self.ref_image)\n    return self._new_from_rois(rois)\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.SegmentationIterator.by_zyx","title":"by_zyx","text":"<pre><code>by_zyx(strict: bool = True) -&gt; Self\n</code></pre> <p>Return a new iterator that iterates over ROIs by ZYX coordinates.</p> <p>Parameters:</p> <ul> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, only iterate over ZYX if a Z axis is present and not of size 1.</p> </li> </ul> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def by_zyx(self, strict: bool = True) -&gt; Self:\n    \"\"\"Return a new iterator that iterates over ROIs by ZYX coordinates.\n\n    Args:\n        strict (bool): If True, only iterate over ZYX if a Z axis\n            is present and not of size 1.\n\n    \"\"\"\n    rois = by_zyx(self.rois, self.ref_image, strict=strict)\n    return self._new_from_rois(rois)\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.SegmentationIterator.by_chunks","title":"by_chunks","text":"<pre><code>by_chunks(overlap_xy: int = 0, overlap_z: int = 0) -&gt; Self\n</code></pre> <p>Return a new iterator that iterates over ROIs by chunks.</p> <p>Parameters:</p> <ul> <li> <code>overlap_xy</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Overlap in XY dimensions.</p> </li> <li> <code>overlap_z</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Overlap in Z dimension.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SegmentationIterator</code> (              <code>Self</code> )          \u2013            <p>A new iterator with chunked ROIs.</p> </li> </ul> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def by_chunks(self, overlap_xy: int = 0, overlap_z: int = 0) -&gt; Self:\n    \"\"\"Return a new iterator that iterates over ROIs by chunks.\n\n    Args:\n        overlap_xy (int): Overlap in XY dimensions.\n        overlap_z (int): Overlap in Z dimension.\n\n    Returns:\n        SegmentationIterator: A new iterator with chunked ROIs.\n    \"\"\"\n    rois = by_chunks(\n        self.rois, self.ref_image, overlap_xy=overlap_xy, overlap_z=overlap_z\n    )\n    return self._new_from_rois(rois)\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.SegmentationIterator.product","title":"product","text":"<pre><code>product(other: list[Roi] | GenericRoiTable) -&gt; Self\n</code></pre> <p>Cartesian product of the current ROIs with an arbitrary list of ROIs.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def product(self, other: list[Roi] | GenericRoiTable) -&gt; Self:\n    \"\"\"Cartesian product of the current ROIs with an arbitrary list of ROIs.\"\"\"\n    if isinstance(other, GenericRoiTable):\n        other = other.rois()\n    rois = rois_product(self.rois, other)\n    return self._new_from_rois(rois)\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.SegmentationIterator.iter","title":"iter","text":"<pre><code>iter(\n    lazy: Literal[True],\n    data_mode: Literal[\"numpy\"],\n    iterator_mode: Literal[\"readwrite\"],\n) -&gt; Generator[\n    tuple[\n        DataGetterProtocol[NumpyPipeType],\n        DataSetterProtocol[NumpyPipeType],\n    ]\n]\n</code></pre><pre><code>iter(\n    lazy: Literal[True],\n    data_mode: Literal[\"numpy\"],\n    iterator_mode: Literal[\"readonly\"] = ...,\n) -&gt; Generator[DataGetterProtocol[NumpyPipeType]]\n</code></pre><pre><code>iter(\n    lazy: Literal[True],\n    data_mode: Literal[\"dask\"],\n    iterator_mode: Literal[\"readwrite\"],\n) -&gt; Generator[\n    tuple[\n        DataGetterProtocol[DaskPipeType],\n        DataSetterProtocol[DaskPipeType],\n    ]\n]\n</code></pre><pre><code>iter(\n    lazy: Literal[True],\n    data_mode: Literal[\"dask\"],\n    iterator_mode: Literal[\"readonly\"] = ...,\n) -&gt; Generator[DataGetterProtocol[DaskPipeType]]\n</code></pre><pre><code>iter(\n    lazy: Literal[False],\n    data_mode: Literal[\"numpy\"],\n    iterator_mode: Literal[\"readwrite\"],\n) -&gt; Generator[\n    tuple[NumpyPipeType, DataSetterProtocol[NumpyPipeType]]\n]\n</code></pre><pre><code>iter(\n    lazy: Literal[False],\n    data_mode: Literal[\"numpy\"],\n    iterator_mode: Literal[\"readonly\"] = ...,\n) -&gt; Generator[NumpyPipeType]\n</code></pre><pre><code>iter(\n    lazy: Literal[False],\n    data_mode: Literal[\"dask\"],\n    iterator_mode: Literal[\"readwrite\"],\n) -&gt; Generator[\n    tuple[DaskPipeType, DataSetterProtocol[DaskPipeType]]\n]\n</code></pre><pre><code>iter(\n    lazy: Literal[False],\n    data_mode: Literal[\"dask\"],\n    iterator_mode: Literal[\"readonly\"] = ...,\n) -&gt; Generator[DaskPipeType]\n</code></pre> <pre><code>iter(\n    lazy: bool = False,\n    data_mode: Literal[\"numpy\", \"dask\"] = \"dask\",\n    iterator_mode: Literal[\n        \"readwrite\", \"readonly\"\n    ] = \"readwrite\",\n) -&gt; Generator\n</code></pre> <p>Create an iterator over the pixels of the ROIs.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def iter(\n    self,\n    lazy: bool = False,\n    data_mode: Literal[\"numpy\", \"dask\"] = \"dask\",\n    iterator_mode: Literal[\"readwrite\", \"readonly\"] = \"readwrite\",\n) -&gt; Generator:\n    \"\"\"Create an iterator over the pixels of the ROIs.\"\"\"\n    if data_mode == \"numpy\":\n        getters = self._numpy_getters_generator()\n        setters = self._numpy_setters_generator()\n    elif data_mode == \"dask\":\n        getters = self._dask_getters_generator()\n        setters = self._dask_setters_generator()\n    else:\n        raise NgioValueError(f\"Invalid mode: {data_mode}\")\n\n    if iterator_mode == \"readonly\":\n        if lazy:\n            return getters\n        else:\n            return (getter() for getter in getters)\n    if lazy:\n        return self._read_and_write_generator(getters, setters)\n    else:\n        gen = self._read_and_write_generator(getters, setters)\n        return ((getter(), setter) for getter, setter in gen)\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.SegmentationIterator.iter_as_numpy","title":"iter_as_numpy","text":"<pre><code>iter_as_numpy()\n</code></pre> <p>Create an iterator over the pixels of the ROIs.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def iter_as_numpy(\n    self,\n):\n    \"\"\"Create an iterator over the pixels of the ROIs.\"\"\"\n    return self.iter(lazy=False, data_mode=\"numpy\", iterator_mode=\"readwrite\")\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.SegmentationIterator.iter_as_dask","title":"iter_as_dask","text":"<pre><code>iter_as_dask()\n</code></pre> <p>Create an iterator over the pixels of the ROIs.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def iter_as_dask(\n    self,\n):\n    \"\"\"Create an iterator over the pixels of the ROIs.\"\"\"\n    return self.iter(lazy=False, data_mode=\"dask\", iterator_mode=\"readwrite\")\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.SegmentationIterator.map_as_numpy","title":"map_as_numpy","text":"<pre><code>map_as_numpy(\n    func: Callable[[NumpyPipeType], NumpyPipeType],\n    mapper: MapperProtocol[NumpyPipeType] | None = None,\n) -&gt; None\n</code></pre> <p>Apply a transformation function to the ROI pixels.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def map_as_numpy(\n    self,\n    func: Callable[[NumpyPipeType], NumpyPipeType],\n    mapper: MapperProtocol[NumpyPipeType] | None = None,\n) -&gt; None:\n    \"\"\"Apply a transformation function to the ROI pixels.\"\"\"\n    if mapper is None:\n        _mapper = BasicMapper[NumpyPipeType]()\n    else:\n        _mapper = mapper\n\n    _mapper(\n        func=func,\n        getters=self._numpy_getters_generator(),\n        setters=self._numpy_setters_generator(),\n    )\n    self.post_consolidate()\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.SegmentationIterator.map_as_dask","title":"map_as_dask","text":"<pre><code>map_as_dask(\n    func: Callable[[DaskPipeType], DaskPipeType],\n    mapper: MapperProtocol[DaskPipeType] | None = None,\n) -&gt; None\n</code></pre> <p>Apply a transformation function to the ROI pixels.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def map_as_dask(\n    self,\n    func: Callable[[DaskPipeType], DaskPipeType],\n    mapper: MapperProtocol[DaskPipeType] | None = None,\n) -&gt; None:\n    \"\"\"Apply a transformation function to the ROI pixels.\"\"\"\n    if mapper is None:\n        _mapper = BasicMapper[DaskPipeType]()\n    else:\n        _mapper = mapper\n\n    _mapper(\n        func=func,\n        getters=self._dask_getters_generator(),\n        setters=self._dask_setters_generator(),\n    )\n    self.post_consolidate()\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.SegmentationIterator.check_if_regions_overlap","title":"check_if_regions_overlap","text":"<pre><code>check_if_regions_overlap() -&gt; bool\n</code></pre> <p>Check if any of the ROIs overlap logically.</p> <p>If two ROIs cover the same pixel, they are considered to overlap. This does not consider chunking or other storage details.</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if any ROIs overlap. False otherwise.</p> </li> </ul> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def check_if_regions_overlap(self) -&gt; bool:\n    \"\"\"Check if any of the ROIs overlap logically.\n\n    If two ROIs cover the same pixel, they are considered to overlap.\n    This does not consider chunking or other storage details.\n\n    Returns:\n        bool: True if any ROIs overlap. False otherwise.\n    \"\"\"\n    if len(self.rois) &lt; 2:\n        # Less than 2 ROIs cannot overlap\n        return False\n\n    slicing_tuples = (\n        g.slicing_ops.normalized_slicing_tuple\n        for g in self._numpy_getters_generator()\n    )\n    x = check_if_regions_overlap(slicing_tuples)\n    return x\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.SegmentationIterator.require_no_regions_overlap","title":"require_no_regions_overlap","text":"<pre><code>require_no_regions_overlap() -&gt; None\n</code></pre> <p>Ensure that the Iterator's ROIs do not overlap.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def require_no_regions_overlap(self) -&gt; None:\n    \"\"\"Ensure that the Iterator's ROIs do not overlap.\"\"\"\n    if self.check_if_regions_overlap():\n        raise NgioValueError(\"Some rois overlap.\")\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.SegmentationIterator.check_if_chunks_overlap","title":"check_if_chunks_overlap","text":"<pre><code>check_if_chunks_overlap() -&gt; bool\n</code></pre> <p>Check if any of the ROIs overlap in terms of chunks.</p> <p>If two ROIs cover the same chunk, they are considered to overlap in chunks. This does not consider pixel-level overlaps.</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if any ROIs overlap in chunks, False otherwise.</p> </li> </ul> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def check_if_chunks_overlap(self) -&gt; bool:\n    \"\"\"Check if any of the ROIs overlap in terms of chunks.\n\n    If two ROIs cover the same chunk, they are considered to overlap in chunks.\n    This does not consider pixel-level overlaps.\n\n    Returns:\n        bool: True if any ROIs overlap in chunks, False otherwise.\n    \"\"\"\n    from ngio.io_pipes._ops_slices_utils import check_if_chunks_overlap\n\n    if len(self.rois) &lt; 2:\n        # Less than 2 ROIs cannot overlap\n        return False\n\n    slicing_tuples = (\n        g.slicing_ops.normalized_slicing_tuple\n        for g in self._numpy_getters_generator()\n    )\n    shape = self.ref_image.shape\n    chunks = self.ref_image.chunks\n    return check_if_chunks_overlap(slicing_tuples, shape, chunks)\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.SegmentationIterator.require_no_chunks_overlap","title":"require_no_chunks_overlap","text":"<pre><code>require_no_chunks_overlap() -&gt; None\n</code></pre> <p>Ensure that the ROIs do not overlap in terms of chunks.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def require_no_chunks_overlap(self) -&gt; None:\n    \"\"\"Ensure that the ROIs do not overlap in terms of chunks.\"\"\"\n    if self.check_if_chunks_overlap():\n        raise NgioValueError(\"Some rois overlap in chunks.\")\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.SegmentationIterator.get_init_kwargs","title":"get_init_kwargs","text":"<pre><code>get_init_kwargs() -&gt; dict\n</code></pre> <p>Return the initialization arguments for the iterator.</p> Source code in <code>ngio/experimental/iterators/_segmentation.py</code> <pre><code>def get_init_kwargs(self) -&gt; dict:\n    \"\"\"Return the initialization arguments for the iterator.\"\"\"\n    return {\n        \"input_image\": self._input,\n        \"output_label\": self._output,\n        \"channel_selection\": self._channel_selection,\n        \"axes_order\": self._axes_order,\n        \"input_transforms\": self._input_transforms,\n        \"output_transforms\": self._output_transforms,\n    }\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.SegmentationIterator.build_numpy_getter","title":"build_numpy_getter","text":"<pre><code>build_numpy_getter(roi: Roi) -&gt; DataGetterProtocol[ndarray]\n</code></pre> Source code in <code>ngio/experimental/iterators/_segmentation.py</code> <pre><code>def build_numpy_getter(self, roi: Roi) -&gt; DataGetterProtocol[np.ndarray]:\n    return NumpyRoiGetter(\n        zarr_array=self._input.zarr_array,\n        dimensions=self._input.dimensions,\n        roi=roi,\n        axes_order=self._axes_order,\n        transforms=self._input_transforms,\n        slicing_dict=self._input_slicing_kwargs,\n    )\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.SegmentationIterator.build_numpy_setter","title":"build_numpy_setter","text":"<pre><code>build_numpy_setter(roi: Roi) -&gt; DataSetterProtocol[ndarray]\n</code></pre> Source code in <code>ngio/experimental/iterators/_segmentation.py</code> <pre><code>def build_numpy_setter(self, roi: Roi) -&gt; DataSetterProtocol[np.ndarray]:\n    return NumpyRoiSetter(\n        zarr_array=self._output.zarr_array,\n        dimensions=self._output.dimensions,\n        roi=roi,\n        axes_order=self._axes_order,\n        transforms=self._output_transforms,\n        remove_channel_selection=True,\n    )\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.SegmentationIterator.build_dask_getter","title":"build_dask_getter","text":"<pre><code>build_dask_getter(roi: Roi) -&gt; DataGetterProtocol[Array]\n</code></pre> Source code in <code>ngio/experimental/iterators/_segmentation.py</code> <pre><code>def build_dask_getter(self, roi: Roi) -&gt; DataGetterProtocol[da.Array]:\n    return DaskRoiGetter(\n        zarr_array=self._input.zarr_array,\n        dimensions=self._input.dimensions,\n        roi=roi,\n        axes_order=self._axes_order,\n        transforms=self._input_transforms,\n        slicing_dict=self._input_slicing_kwargs,\n    )\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.SegmentationIterator.build_dask_setter","title":"build_dask_setter","text":"<pre><code>build_dask_setter(roi: Roi) -&gt; DataSetterProtocol[Array]\n</code></pre> Source code in <code>ngio/experimental/iterators/_segmentation.py</code> <pre><code>def build_dask_setter(self, roi: Roi) -&gt; DataSetterProtocol[da.Array]:\n    return DaskRoiSetter(\n        zarr_array=self._output.zarr_array,\n        dimensions=self._output.dimensions,\n        roi=roi,\n        axes_order=self._axes_order,\n        transforms=self._output_transforms,\n        remove_channel_selection=True,\n    )\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.SegmentationIterator.post_consolidate","title":"post_consolidate","text":"<pre><code>post_consolidate()\n</code></pre> Source code in <code>ngio/experimental/iterators/_segmentation.py</code> <pre><code>def post_consolidate(self):\n    self._output.consolidate()\n</code></pre>"},{"location":"api/iterators/#maskedsegmentationiterator","title":"MaskedSegmentationIterator","text":""},{"location":"api/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator","title":"ngio.experimental.iterators.MaskedSegmentationIterator","text":"<pre><code>MaskedSegmentationIterator(\n    input_image: MaskedImage,\n    output_label: Label,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    input_transforms: Sequence[TransformProtocol]\n    | None = None,\n    output_transforms: Sequence[TransformProtocol]\n    | None = None,\n)\n</code></pre> <p>               Bases: <code>SegmentationIterator</code></p> <p>Base class for iterators over ROIs.</p> <p>Initialize the iterator with a ROI table and input/output images.</p> <p>Parameters:</p> <ul> <li> <code>input_image</code>               (<code>MaskedImage</code>)           \u2013            <p>The input image to be used as input for the segmentation.</p> </li> <li> <code>output_label</code>               (<code>Label</code>)           \u2013            <p>The label image where the ROIs will be written.</p> </li> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Optional selection of channels to use for the segmentation.</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional axes order for the segmentation.</p> </li> <li> <code>input_transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional transforms to apply to the input image.</p> </li> <li> <code>output_transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional transforms to apply to the output label.</p> </li> </ul> Source code in <code>ngio/experimental/iterators/_segmentation.py</code> <pre><code>def __init__(\n    self,\n    input_image: MaskedImage,\n    output_label: Label,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    input_transforms: Sequence[TransformProtocol] | None = None,\n    output_transforms: Sequence[TransformProtocol] | None = None,\n) -&gt; None:\n    \"\"\"Initialize the iterator with a ROI table and input/output images.\n\n    Args:\n        input_image (MaskedImage): The input image to be used as input for the\n            segmentation.\n        output_label (Label): The label image where the ROIs will be written.\n        channel_selection (ChannelSlicingInputType): Optional\n            selection of channels to use for the segmentation.\n        axes_order (Sequence[str] | None): Optional axes order for the\n            segmentation.\n        input_transforms (Sequence[TransformProtocol] | None): Optional\n            transforms to apply to the input image.\n        output_transforms (Sequence[TransformProtocol] | None): Optional\n            transforms to apply to the output label.\n    \"\"\"\n    self._input = input_image\n    self._output = output_label\n\n    self._ref_image = input_image\n    self._set_rois(input_image._masking_roi_table.rois())\n\n    # Set iteration parameters\n    self._input_slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self._input, channel_selection=channel_selection, slicing_dict={}\n    )\n    self._channel_selection = channel_selection\n    self._axes_order = axes_order\n    self._input_transforms = input_transforms\n    self._output_transforms = output_transforms\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator.rois","title":"rois  <code>property</code>","text":"<pre><code>rois: list[Roi]\n</code></pre> <p>Get the list of ROIs for the iterator.</p>"},{"location":"api/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator.ref_image","title":"ref_image  <code>property</code>","text":"<pre><code>ref_image: AbstractImage\n</code></pre> <p>Get the reference image for the iterator.</p>"},{"location":"api/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator.grid","title":"grid","text":"<pre><code>grid(\n    size_x: int | None = None,\n    size_y: int | None = None,\n    size_z: int | None = None,\n    size_t: int | None = None,\n    stride_x: int | None = None,\n    stride_y: int | None = None,\n    stride_z: int | None = None,\n    stride_t: int | None = None,\n    base_name: str = \"\",\n) -&gt; Self\n</code></pre> <p>Create a grid of ROIs based on the input image dimensions.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def grid(\n    self,\n    size_x: int | None = None,\n    size_y: int | None = None,\n    size_z: int | None = None,\n    size_t: int | None = None,\n    stride_x: int | None = None,\n    stride_y: int | None = None,\n    stride_z: int | None = None,\n    stride_t: int | None = None,\n    base_name: str = \"\",\n) -&gt; Self:\n    \"\"\"Create a grid of ROIs based on the input image dimensions.\"\"\"\n    rois = grid(\n        rois=self.rois,\n        ref_image=self.ref_image,\n        size_x=size_x,\n        size_y=size_y,\n        size_z=size_z,\n        size_t=size_t,\n        stride_x=stride_x,\n        stride_y=stride_y,\n        stride_z=stride_z,\n        stride_t=stride_t,\n        base_name=base_name,\n    )\n    return self._new_from_rois(rois)\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator.by_yx","title":"by_yx","text":"<pre><code>by_yx() -&gt; Self\n</code></pre> <p>Return a new iterator that iterates over ROIs by YX coordinates.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def by_yx(self) -&gt; Self:\n    \"\"\"Return a new iterator that iterates over ROIs by YX coordinates.\"\"\"\n    rois = by_yx(self.rois, self.ref_image)\n    return self._new_from_rois(rois)\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator.by_zyx","title":"by_zyx","text":"<pre><code>by_zyx(strict: bool = True) -&gt; Self\n</code></pre> <p>Return a new iterator that iterates over ROIs by ZYX coordinates.</p> <p>Parameters:</p> <ul> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, only iterate over ZYX if a Z axis is present and not of size 1.</p> </li> </ul> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def by_zyx(self, strict: bool = True) -&gt; Self:\n    \"\"\"Return a new iterator that iterates over ROIs by ZYX coordinates.\n\n    Args:\n        strict (bool): If True, only iterate over ZYX if a Z axis\n            is present and not of size 1.\n\n    \"\"\"\n    rois = by_zyx(self.rois, self.ref_image, strict=strict)\n    return self._new_from_rois(rois)\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator.by_chunks","title":"by_chunks","text":"<pre><code>by_chunks(overlap_xy: int = 0, overlap_z: int = 0) -&gt; Self\n</code></pre> <p>Return a new iterator that iterates over ROIs by chunks.</p> <p>Parameters:</p> <ul> <li> <code>overlap_xy</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Overlap in XY dimensions.</p> </li> <li> <code>overlap_z</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Overlap in Z dimension.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SegmentationIterator</code> (              <code>Self</code> )          \u2013            <p>A new iterator with chunked ROIs.</p> </li> </ul> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def by_chunks(self, overlap_xy: int = 0, overlap_z: int = 0) -&gt; Self:\n    \"\"\"Return a new iterator that iterates over ROIs by chunks.\n\n    Args:\n        overlap_xy (int): Overlap in XY dimensions.\n        overlap_z (int): Overlap in Z dimension.\n\n    Returns:\n        SegmentationIterator: A new iterator with chunked ROIs.\n    \"\"\"\n    rois = by_chunks(\n        self.rois, self.ref_image, overlap_xy=overlap_xy, overlap_z=overlap_z\n    )\n    return self._new_from_rois(rois)\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator.product","title":"product","text":"<pre><code>product(other: list[Roi] | GenericRoiTable) -&gt; Self\n</code></pre> <p>Cartesian product of the current ROIs with an arbitrary list of ROIs.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def product(self, other: list[Roi] | GenericRoiTable) -&gt; Self:\n    \"\"\"Cartesian product of the current ROIs with an arbitrary list of ROIs.\"\"\"\n    if isinstance(other, GenericRoiTable):\n        other = other.rois()\n    rois = rois_product(self.rois, other)\n    return self._new_from_rois(rois)\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator.iter","title":"iter","text":"<pre><code>iter(\n    lazy: Literal[True],\n    data_mode: Literal[\"numpy\"],\n    iterator_mode: Literal[\"readwrite\"],\n) -&gt; Generator[\n    tuple[\n        DataGetterProtocol[NumpyPipeType],\n        DataSetterProtocol[NumpyPipeType],\n    ]\n]\n</code></pre><pre><code>iter(\n    lazy: Literal[True],\n    data_mode: Literal[\"numpy\"],\n    iterator_mode: Literal[\"readonly\"] = ...,\n) -&gt; Generator[DataGetterProtocol[NumpyPipeType]]\n</code></pre><pre><code>iter(\n    lazy: Literal[True],\n    data_mode: Literal[\"dask\"],\n    iterator_mode: Literal[\"readwrite\"],\n) -&gt; Generator[\n    tuple[\n        DataGetterProtocol[DaskPipeType],\n        DataSetterProtocol[DaskPipeType],\n    ]\n]\n</code></pre><pre><code>iter(\n    lazy: Literal[True],\n    data_mode: Literal[\"dask\"],\n    iterator_mode: Literal[\"readonly\"] = ...,\n) -&gt; Generator[DataGetterProtocol[DaskPipeType]]\n</code></pre><pre><code>iter(\n    lazy: Literal[False],\n    data_mode: Literal[\"numpy\"],\n    iterator_mode: Literal[\"readwrite\"],\n) -&gt; Generator[\n    tuple[NumpyPipeType, DataSetterProtocol[NumpyPipeType]]\n]\n</code></pre><pre><code>iter(\n    lazy: Literal[False],\n    data_mode: Literal[\"numpy\"],\n    iterator_mode: Literal[\"readonly\"] = ...,\n) -&gt; Generator[NumpyPipeType]\n</code></pre><pre><code>iter(\n    lazy: Literal[False],\n    data_mode: Literal[\"dask\"],\n    iterator_mode: Literal[\"readwrite\"],\n) -&gt; Generator[\n    tuple[DaskPipeType, DataSetterProtocol[DaskPipeType]]\n]\n</code></pre><pre><code>iter(\n    lazy: Literal[False],\n    data_mode: Literal[\"dask\"],\n    iterator_mode: Literal[\"readonly\"] = ...,\n) -&gt; Generator[DaskPipeType]\n</code></pre> <pre><code>iter(\n    lazy: bool = False,\n    data_mode: Literal[\"numpy\", \"dask\"] = \"dask\",\n    iterator_mode: Literal[\n        \"readwrite\", \"readonly\"\n    ] = \"readwrite\",\n) -&gt; Generator\n</code></pre> <p>Create an iterator over the pixels of the ROIs.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def iter(\n    self,\n    lazy: bool = False,\n    data_mode: Literal[\"numpy\", \"dask\"] = \"dask\",\n    iterator_mode: Literal[\"readwrite\", \"readonly\"] = \"readwrite\",\n) -&gt; Generator:\n    \"\"\"Create an iterator over the pixels of the ROIs.\"\"\"\n    if data_mode == \"numpy\":\n        getters = self._numpy_getters_generator()\n        setters = self._numpy_setters_generator()\n    elif data_mode == \"dask\":\n        getters = self._dask_getters_generator()\n        setters = self._dask_setters_generator()\n    else:\n        raise NgioValueError(f\"Invalid mode: {data_mode}\")\n\n    if iterator_mode == \"readonly\":\n        if lazy:\n            return getters\n        else:\n            return (getter() for getter in getters)\n    if lazy:\n        return self._read_and_write_generator(getters, setters)\n    else:\n        gen = self._read_and_write_generator(getters, setters)\n        return ((getter(), setter) for getter, setter in gen)\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator.iter_as_numpy","title":"iter_as_numpy","text":"<pre><code>iter_as_numpy()\n</code></pre> <p>Create an iterator over the pixels of the ROIs.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def iter_as_numpy(\n    self,\n):\n    \"\"\"Create an iterator over the pixels of the ROIs.\"\"\"\n    return self.iter(lazy=False, data_mode=\"numpy\", iterator_mode=\"readwrite\")\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator.iter_as_dask","title":"iter_as_dask","text":"<pre><code>iter_as_dask()\n</code></pre> <p>Create an iterator over the pixels of the ROIs.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def iter_as_dask(\n    self,\n):\n    \"\"\"Create an iterator over the pixels of the ROIs.\"\"\"\n    return self.iter(lazy=False, data_mode=\"dask\", iterator_mode=\"readwrite\")\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator.map_as_numpy","title":"map_as_numpy","text":"<pre><code>map_as_numpy(\n    func: Callable[[NumpyPipeType], NumpyPipeType],\n    mapper: MapperProtocol[NumpyPipeType] | None = None,\n) -&gt; None\n</code></pre> <p>Apply a transformation function to the ROI pixels.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def map_as_numpy(\n    self,\n    func: Callable[[NumpyPipeType], NumpyPipeType],\n    mapper: MapperProtocol[NumpyPipeType] | None = None,\n) -&gt; None:\n    \"\"\"Apply a transformation function to the ROI pixels.\"\"\"\n    if mapper is None:\n        _mapper = BasicMapper[NumpyPipeType]()\n    else:\n        _mapper = mapper\n\n    _mapper(\n        func=func,\n        getters=self._numpy_getters_generator(),\n        setters=self._numpy_setters_generator(),\n    )\n    self.post_consolidate()\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator.map_as_dask","title":"map_as_dask","text":"<pre><code>map_as_dask(\n    func: Callable[[DaskPipeType], DaskPipeType],\n    mapper: MapperProtocol[DaskPipeType] | None = None,\n) -&gt; None\n</code></pre> <p>Apply a transformation function to the ROI pixels.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def map_as_dask(\n    self,\n    func: Callable[[DaskPipeType], DaskPipeType],\n    mapper: MapperProtocol[DaskPipeType] | None = None,\n) -&gt; None:\n    \"\"\"Apply a transformation function to the ROI pixels.\"\"\"\n    if mapper is None:\n        _mapper = BasicMapper[DaskPipeType]()\n    else:\n        _mapper = mapper\n\n    _mapper(\n        func=func,\n        getters=self._dask_getters_generator(),\n        setters=self._dask_setters_generator(),\n    )\n    self.post_consolidate()\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator.check_if_regions_overlap","title":"check_if_regions_overlap","text":"<pre><code>check_if_regions_overlap() -&gt; bool\n</code></pre> <p>Check if any of the ROIs overlap logically.</p> <p>If two ROIs cover the same pixel, they are considered to overlap. This does not consider chunking or other storage details.</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if any ROIs overlap. False otherwise.</p> </li> </ul> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def check_if_regions_overlap(self) -&gt; bool:\n    \"\"\"Check if any of the ROIs overlap logically.\n\n    If two ROIs cover the same pixel, they are considered to overlap.\n    This does not consider chunking or other storage details.\n\n    Returns:\n        bool: True if any ROIs overlap. False otherwise.\n    \"\"\"\n    if len(self.rois) &lt; 2:\n        # Less than 2 ROIs cannot overlap\n        return False\n\n    slicing_tuples = (\n        g.slicing_ops.normalized_slicing_tuple\n        for g in self._numpy_getters_generator()\n    )\n    x = check_if_regions_overlap(slicing_tuples)\n    return x\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator.require_no_regions_overlap","title":"require_no_regions_overlap","text":"<pre><code>require_no_regions_overlap() -&gt; None\n</code></pre> <p>Ensure that the Iterator's ROIs do not overlap.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def require_no_regions_overlap(self) -&gt; None:\n    \"\"\"Ensure that the Iterator's ROIs do not overlap.\"\"\"\n    if self.check_if_regions_overlap():\n        raise NgioValueError(\"Some rois overlap.\")\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator.check_if_chunks_overlap","title":"check_if_chunks_overlap","text":"<pre><code>check_if_chunks_overlap() -&gt; bool\n</code></pre> <p>Check if any of the ROIs overlap in terms of chunks.</p> <p>If two ROIs cover the same chunk, they are considered to overlap in chunks. This does not consider pixel-level overlaps.</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if any ROIs overlap in chunks, False otherwise.</p> </li> </ul> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def check_if_chunks_overlap(self) -&gt; bool:\n    \"\"\"Check if any of the ROIs overlap in terms of chunks.\n\n    If two ROIs cover the same chunk, they are considered to overlap in chunks.\n    This does not consider pixel-level overlaps.\n\n    Returns:\n        bool: True if any ROIs overlap in chunks, False otherwise.\n    \"\"\"\n    from ngio.io_pipes._ops_slices_utils import check_if_chunks_overlap\n\n    if len(self.rois) &lt; 2:\n        # Less than 2 ROIs cannot overlap\n        return False\n\n    slicing_tuples = (\n        g.slicing_ops.normalized_slicing_tuple\n        for g in self._numpy_getters_generator()\n    )\n    shape = self.ref_image.shape\n    chunks = self.ref_image.chunks\n    return check_if_chunks_overlap(slicing_tuples, shape, chunks)\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator.require_no_chunks_overlap","title":"require_no_chunks_overlap","text":"<pre><code>require_no_chunks_overlap() -&gt; None\n</code></pre> <p>Ensure that the ROIs do not overlap in terms of chunks.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def require_no_chunks_overlap(self) -&gt; None:\n    \"\"\"Ensure that the ROIs do not overlap in terms of chunks.\"\"\"\n    if self.check_if_chunks_overlap():\n        raise NgioValueError(\"Some rois overlap in chunks.\")\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator.get_init_kwargs","title":"get_init_kwargs","text":"<pre><code>get_init_kwargs() -&gt; dict\n</code></pre> <p>Return the initialization arguments for the iterator.</p> Source code in <code>ngio/experimental/iterators/_segmentation.py</code> <pre><code>def get_init_kwargs(self) -&gt; dict:\n    \"\"\"Return the initialization arguments for the iterator.\"\"\"\n    return {\n        \"input_image\": self._input,\n        \"output_label\": self._output,\n        \"channel_selection\": self._channel_selection,\n        \"axes_order\": self._axes_order,\n        \"input_transforms\": self._input_transforms,\n        \"output_transforms\": self._output_transforms,\n    }\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator.build_numpy_getter","title":"build_numpy_getter","text":"<pre><code>build_numpy_getter(roi: Roi)\n</code></pre> Source code in <code>ngio/experimental/iterators/_segmentation.py</code> <pre><code>def build_numpy_getter(self, roi: Roi):\n    return NumpyGetterMasked(\n        zarr_array=self._input.zarr_array,\n        dimensions=self._input.dimensions,\n        roi=roi,\n        label_zarr_array=self._input._label.zarr_array,\n        label_dimensions=self._input._label.dimensions,\n        axes_order=self._axes_order,\n        transforms=self._input_transforms,\n        slicing_dict=self._input_slicing_kwargs,\n    )\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator.build_numpy_setter","title":"build_numpy_setter","text":"<pre><code>build_numpy_setter(roi: Roi)\n</code></pre> Source code in <code>ngio/experimental/iterators/_segmentation.py</code> <pre><code>def build_numpy_setter(self, roi: Roi):\n    return NumpySetterMasked(\n        roi=roi,\n        zarr_array=self._output.zarr_array,\n        dimensions=self._output.dimensions,\n        label_zarr_array=self._input._label.zarr_array,\n        label_dimensions=self._input._label.dimensions,\n        axes_order=self._axes_order,\n        transforms=self._output_transforms,\n        remove_channel_selection=True,\n    )\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator.build_dask_getter","title":"build_dask_getter","text":"<pre><code>build_dask_getter(roi: Roi)\n</code></pre> Source code in <code>ngio/experimental/iterators/_segmentation.py</code> <pre><code>def build_dask_getter(self, roi: Roi):\n    return DaskGetterMasked(\n        roi=roi,\n        zarr_array=self._input.zarr_array,\n        dimensions=self._input.dimensions,\n        label_zarr_array=self._input._label.zarr_array,\n        label_dimensions=self._input._label.dimensions,\n        axes_order=self._axes_order,\n        transforms=self._input_transforms,\n        slicing_dict=self._input_slicing_kwargs,\n    )\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator.build_dask_setter","title":"build_dask_setter","text":"<pre><code>build_dask_setter(roi: Roi)\n</code></pre> Source code in <code>ngio/experimental/iterators/_segmentation.py</code> <pre><code>def build_dask_setter(self, roi: Roi):\n    return DaskSetterMasked(\n        roi=roi,\n        zarr_array=self._output.zarr_array,\n        dimensions=self._output.dimensions,\n        label_zarr_array=self._input._label.zarr_array,\n        label_dimensions=self._input._label.dimensions,\n        axes_order=self._axes_order,\n        transforms=self._output_transforms,\n        remove_channel_selection=True,\n    )\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator.post_consolidate","title":"post_consolidate","text":"<pre><code>post_consolidate()\n</code></pre> Source code in <code>ngio/experimental/iterators/_segmentation.py</code> <pre><code>def post_consolidate(self):\n    self._output.consolidate()\n</code></pre>"},{"location":"api/iterators/#featureextractoriterator","title":"FeatureExtractorIterator","text":""},{"location":"api/iterators/#ngio.experimental.iterators.FeatureExtractorIterator","title":"ngio.experimental.iterators.FeatureExtractorIterator","text":"<pre><code>FeatureExtractorIterator(\n    input_image: Image,\n    input_label: Label,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    input_transforms: Sequence[TransformProtocol]\n    | None = None,\n    label_transforms: Sequence[TransformProtocol]\n    | None = None,\n)\n</code></pre> <p>               Bases: <code>AbstractIteratorBuilder[NumpyPipeType, DaskPipeType]</code></p> <p>Base class for iterators over ROIs.</p> <p>Initialize the iterator with a ROI table and input/output images.</p> <p>Parameters:</p> <ul> <li> <code>input_image</code>               (<code>Image</code>)           \u2013            <p>The input image to be used as input for the segmentation.</p> </li> <li> <code>input_label</code>               (<code>Label</code>)           \u2013            <p>The input label with the segmentation masks.</p> </li> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Optional selection of channels to use for the segmentation.</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional axes order for the segmentation.</p> </li> <li> <code>input_transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional transforms to apply to the input image.</p> </li> <li> <code>label_transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional transforms to apply to the output label.</p> </li> </ul> Source code in <code>ngio/experimental/iterators/_feature.py</code> <pre><code>def __init__(\n    self,\n    input_image: Image,\n    input_label: Label,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    input_transforms: Sequence[TransformProtocol] | None = None,\n    label_transforms: Sequence[TransformProtocol] | None = None,\n) -&gt; None:\n    \"\"\"Initialize the iterator with a ROI table and input/output images.\n\n    Args:\n        input_image (Image): The input image to be used as input for the\n            segmentation.\n        input_label (Label): The input label with the segmentation masks.\n        channel_selection (ChannelSlicingInputType): Optional\n            selection of channels to use for the segmentation.\n        axes_order (Sequence[str] | None): Optional axes order for the\n            segmentation.\n        input_transforms (Sequence[TransformProtocol] | None): Optional\n            transforms to apply to the input image.\n        label_transforms (Sequence[TransformProtocol] | None): Optional\n            transforms to apply to the output label.\n    \"\"\"\n    self._input = input_image\n    self._input_label = input_label\n    self._ref_image = input_image\n    self._rois = input_image.build_image_roi_table(name=None).rois()\n\n    # Set iteration parameters\n    self._input_slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self._input, channel_selection=channel_selection, slicing_dict={}\n    )\n    self._channel_selection = channel_selection\n    self._axes_order = axes_order\n    self._input_transforms = input_transforms\n    self._label_transforms = label_transforms\n\n    self._input.require_axes_match(self._input_label)\n    self._input.require_rescalable(self._input_label)\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.FeatureExtractorIterator.rois","title":"rois  <code>property</code>","text":"<pre><code>rois: list[Roi]\n</code></pre> <p>Get the list of ROIs for the iterator.</p>"},{"location":"api/iterators/#ngio.experimental.iterators.FeatureExtractorIterator.ref_image","title":"ref_image  <code>property</code>","text":"<pre><code>ref_image: AbstractImage\n</code></pre> <p>Get the reference image for the iterator.</p>"},{"location":"api/iterators/#ngio.experimental.iterators.FeatureExtractorIterator.grid","title":"grid","text":"<pre><code>grid(\n    size_x: int | None = None,\n    size_y: int | None = None,\n    size_z: int | None = None,\n    size_t: int | None = None,\n    stride_x: int | None = None,\n    stride_y: int | None = None,\n    stride_z: int | None = None,\n    stride_t: int | None = None,\n    base_name: str = \"\",\n) -&gt; Self\n</code></pre> <p>Create a grid of ROIs based on the input image dimensions.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def grid(\n    self,\n    size_x: int | None = None,\n    size_y: int | None = None,\n    size_z: int | None = None,\n    size_t: int | None = None,\n    stride_x: int | None = None,\n    stride_y: int | None = None,\n    stride_z: int | None = None,\n    stride_t: int | None = None,\n    base_name: str = \"\",\n) -&gt; Self:\n    \"\"\"Create a grid of ROIs based on the input image dimensions.\"\"\"\n    rois = grid(\n        rois=self.rois,\n        ref_image=self.ref_image,\n        size_x=size_x,\n        size_y=size_y,\n        size_z=size_z,\n        size_t=size_t,\n        stride_x=stride_x,\n        stride_y=stride_y,\n        stride_z=stride_z,\n        stride_t=stride_t,\n        base_name=base_name,\n    )\n    return self._new_from_rois(rois)\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.FeatureExtractorIterator.by_yx","title":"by_yx","text":"<pre><code>by_yx() -&gt; Self\n</code></pre> <p>Return a new iterator that iterates over ROIs by YX coordinates.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def by_yx(self) -&gt; Self:\n    \"\"\"Return a new iterator that iterates over ROIs by YX coordinates.\"\"\"\n    rois = by_yx(self.rois, self.ref_image)\n    return self._new_from_rois(rois)\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.FeatureExtractorIterator.by_zyx","title":"by_zyx","text":"<pre><code>by_zyx(strict: bool = True) -&gt; Self\n</code></pre> <p>Return a new iterator that iterates over ROIs by ZYX coordinates.</p> <p>Parameters:</p> <ul> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, only iterate over ZYX if a Z axis is present and not of size 1.</p> </li> </ul> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def by_zyx(self, strict: bool = True) -&gt; Self:\n    \"\"\"Return a new iterator that iterates over ROIs by ZYX coordinates.\n\n    Args:\n        strict (bool): If True, only iterate over ZYX if a Z axis\n            is present and not of size 1.\n\n    \"\"\"\n    rois = by_zyx(self.rois, self.ref_image, strict=strict)\n    return self._new_from_rois(rois)\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.FeatureExtractorIterator.by_chunks","title":"by_chunks","text":"<pre><code>by_chunks(overlap_xy: int = 0, overlap_z: int = 0) -&gt; Self\n</code></pre> <p>Return a new iterator that iterates over ROIs by chunks.</p> <p>Parameters:</p> <ul> <li> <code>overlap_xy</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Overlap in XY dimensions.</p> </li> <li> <code>overlap_z</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Overlap in Z dimension.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SegmentationIterator</code> (              <code>Self</code> )          \u2013            <p>A new iterator with chunked ROIs.</p> </li> </ul> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def by_chunks(self, overlap_xy: int = 0, overlap_z: int = 0) -&gt; Self:\n    \"\"\"Return a new iterator that iterates over ROIs by chunks.\n\n    Args:\n        overlap_xy (int): Overlap in XY dimensions.\n        overlap_z (int): Overlap in Z dimension.\n\n    Returns:\n        SegmentationIterator: A new iterator with chunked ROIs.\n    \"\"\"\n    rois = by_chunks(\n        self.rois, self.ref_image, overlap_xy=overlap_xy, overlap_z=overlap_z\n    )\n    return self._new_from_rois(rois)\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.FeatureExtractorIterator.product","title":"product","text":"<pre><code>product(other: list[Roi] | GenericRoiTable) -&gt; Self\n</code></pre> <p>Cartesian product of the current ROIs with an arbitrary list of ROIs.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def product(self, other: list[Roi] | GenericRoiTable) -&gt; Self:\n    \"\"\"Cartesian product of the current ROIs with an arbitrary list of ROIs.\"\"\"\n    if isinstance(other, GenericRoiTable):\n        other = other.rois()\n    rois = rois_product(self.rois, other)\n    return self._new_from_rois(rois)\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.FeatureExtractorIterator.iter","title":"iter","text":"<pre><code>iter(\n    lazy: Literal[True],\n    data_mode: Literal[\"numpy\"],\n    iterator_mode: Literal[\"readwrite\"],\n) -&gt; Generator[\n    tuple[\n        DataGetterProtocol[NumpyPipeType],\n        DataSetterProtocol[NumpyPipeType],\n    ]\n]\n</code></pre><pre><code>iter(\n    lazy: Literal[True],\n    data_mode: Literal[\"numpy\"],\n    iterator_mode: Literal[\"readonly\"] = ...,\n) -&gt; Generator[DataGetterProtocol[NumpyPipeType]]\n</code></pre><pre><code>iter(\n    lazy: Literal[True],\n    data_mode: Literal[\"dask\"],\n    iterator_mode: Literal[\"readwrite\"],\n) -&gt; Generator[\n    tuple[\n        DataGetterProtocol[DaskPipeType],\n        DataSetterProtocol[DaskPipeType],\n    ]\n]\n</code></pre><pre><code>iter(\n    lazy: Literal[True],\n    data_mode: Literal[\"dask\"],\n    iterator_mode: Literal[\"readonly\"] = ...,\n) -&gt; Generator[DataGetterProtocol[DaskPipeType]]\n</code></pre><pre><code>iter(\n    lazy: Literal[False],\n    data_mode: Literal[\"numpy\"],\n    iterator_mode: Literal[\"readwrite\"],\n) -&gt; Generator[\n    tuple[NumpyPipeType, DataSetterProtocol[NumpyPipeType]]\n]\n</code></pre><pre><code>iter(\n    lazy: Literal[False],\n    data_mode: Literal[\"numpy\"],\n    iterator_mode: Literal[\"readonly\"] = ...,\n) -&gt; Generator[NumpyPipeType]\n</code></pre><pre><code>iter(\n    lazy: Literal[False],\n    data_mode: Literal[\"dask\"],\n    iterator_mode: Literal[\"readwrite\"],\n) -&gt; Generator[\n    tuple[DaskPipeType, DataSetterProtocol[DaskPipeType]]\n]\n</code></pre><pre><code>iter(\n    lazy: Literal[False],\n    data_mode: Literal[\"dask\"],\n    iterator_mode: Literal[\"readonly\"] = ...,\n) -&gt; Generator[DaskPipeType]\n</code></pre> <pre><code>iter(\n    lazy: bool = False,\n    data_mode: Literal[\"numpy\", \"dask\"] = \"dask\",\n    iterator_mode: Literal[\n        \"readwrite\", \"readonly\"\n    ] = \"readwrite\",\n) -&gt; Generator\n</code></pre> <p>Create an iterator over the pixels of the ROIs.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def iter(\n    self,\n    lazy: bool = False,\n    data_mode: Literal[\"numpy\", \"dask\"] = \"dask\",\n    iterator_mode: Literal[\"readwrite\", \"readonly\"] = \"readwrite\",\n) -&gt; Generator:\n    \"\"\"Create an iterator over the pixels of the ROIs.\"\"\"\n    if data_mode == \"numpy\":\n        getters = self._numpy_getters_generator()\n        setters = self._numpy_setters_generator()\n    elif data_mode == \"dask\":\n        getters = self._dask_getters_generator()\n        setters = self._dask_setters_generator()\n    else:\n        raise NgioValueError(f\"Invalid mode: {data_mode}\")\n\n    if iterator_mode == \"readonly\":\n        if lazy:\n            return getters\n        else:\n            return (getter() for getter in getters)\n    if lazy:\n        return self._read_and_write_generator(getters, setters)\n    else:\n        gen = self._read_and_write_generator(getters, setters)\n        return ((getter(), setter) for getter, setter in gen)\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.FeatureExtractorIterator.map_as_numpy","title":"map_as_numpy","text":"<pre><code>map_as_numpy(\n    func: Callable[[NumpyPipeType], NumpyPipeType],\n    mapper: MapperProtocol[NumpyPipeType] | None = None,\n) -&gt; None\n</code></pre> <p>Apply a transformation function to the ROI pixels.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def map_as_numpy(\n    self,\n    func: Callable[[NumpyPipeType], NumpyPipeType],\n    mapper: MapperProtocol[NumpyPipeType] | None = None,\n) -&gt; None:\n    \"\"\"Apply a transformation function to the ROI pixels.\"\"\"\n    if mapper is None:\n        _mapper = BasicMapper[NumpyPipeType]()\n    else:\n        _mapper = mapper\n\n    _mapper(\n        func=func,\n        getters=self._numpy_getters_generator(),\n        setters=self._numpy_setters_generator(),\n    )\n    self.post_consolidate()\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.FeatureExtractorIterator.map_as_dask","title":"map_as_dask","text":"<pre><code>map_as_dask(\n    func: Callable[[DaskPipeType], DaskPipeType],\n    mapper: MapperProtocol[DaskPipeType] | None = None,\n) -&gt; None\n</code></pre> <p>Apply a transformation function to the ROI pixels.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def map_as_dask(\n    self,\n    func: Callable[[DaskPipeType], DaskPipeType],\n    mapper: MapperProtocol[DaskPipeType] | None = None,\n) -&gt; None:\n    \"\"\"Apply a transformation function to the ROI pixels.\"\"\"\n    if mapper is None:\n        _mapper = BasicMapper[DaskPipeType]()\n    else:\n        _mapper = mapper\n\n    _mapper(\n        func=func,\n        getters=self._dask_getters_generator(),\n        setters=self._dask_setters_generator(),\n    )\n    self.post_consolidate()\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.FeatureExtractorIterator.check_if_regions_overlap","title":"check_if_regions_overlap","text":"<pre><code>check_if_regions_overlap() -&gt; bool\n</code></pre> <p>Check if any of the ROIs overlap logically.</p> <p>If two ROIs cover the same pixel, they are considered to overlap. This does not consider chunking or other storage details.</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if any ROIs overlap. False otherwise.</p> </li> </ul> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def check_if_regions_overlap(self) -&gt; bool:\n    \"\"\"Check if any of the ROIs overlap logically.\n\n    If two ROIs cover the same pixel, they are considered to overlap.\n    This does not consider chunking or other storage details.\n\n    Returns:\n        bool: True if any ROIs overlap. False otherwise.\n    \"\"\"\n    if len(self.rois) &lt; 2:\n        # Less than 2 ROIs cannot overlap\n        return False\n\n    slicing_tuples = (\n        g.slicing_ops.normalized_slicing_tuple\n        for g in self._numpy_getters_generator()\n    )\n    x = check_if_regions_overlap(slicing_tuples)\n    return x\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.FeatureExtractorIterator.require_no_regions_overlap","title":"require_no_regions_overlap","text":"<pre><code>require_no_regions_overlap() -&gt; None\n</code></pre> <p>Ensure that the Iterator's ROIs do not overlap.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def require_no_regions_overlap(self) -&gt; None:\n    \"\"\"Ensure that the Iterator's ROIs do not overlap.\"\"\"\n    if self.check_if_regions_overlap():\n        raise NgioValueError(\"Some rois overlap.\")\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.FeatureExtractorIterator.check_if_chunks_overlap","title":"check_if_chunks_overlap","text":"<pre><code>check_if_chunks_overlap() -&gt; bool\n</code></pre> <p>Check if any of the ROIs overlap in terms of chunks.</p> <p>If two ROIs cover the same chunk, they are considered to overlap in chunks. This does not consider pixel-level overlaps.</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if any ROIs overlap in chunks, False otherwise.</p> </li> </ul> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def check_if_chunks_overlap(self) -&gt; bool:\n    \"\"\"Check if any of the ROIs overlap in terms of chunks.\n\n    If two ROIs cover the same chunk, they are considered to overlap in chunks.\n    This does not consider pixel-level overlaps.\n\n    Returns:\n        bool: True if any ROIs overlap in chunks, False otherwise.\n    \"\"\"\n    from ngio.io_pipes._ops_slices_utils import check_if_chunks_overlap\n\n    if len(self.rois) &lt; 2:\n        # Less than 2 ROIs cannot overlap\n        return False\n\n    slicing_tuples = (\n        g.slicing_ops.normalized_slicing_tuple\n        for g in self._numpy_getters_generator()\n    )\n    shape = self.ref_image.shape\n    chunks = self.ref_image.chunks\n    return check_if_chunks_overlap(slicing_tuples, shape, chunks)\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.FeatureExtractorIterator.require_no_chunks_overlap","title":"require_no_chunks_overlap","text":"<pre><code>require_no_chunks_overlap() -&gt; None\n</code></pre> <p>Ensure that the ROIs do not overlap in terms of chunks.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def require_no_chunks_overlap(self) -&gt; None:\n    \"\"\"Ensure that the ROIs do not overlap in terms of chunks.\"\"\"\n    if self.check_if_chunks_overlap():\n        raise NgioValueError(\"Some rois overlap in chunks.\")\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.FeatureExtractorIterator.get_init_kwargs","title":"get_init_kwargs","text":"<pre><code>get_init_kwargs() -&gt; dict\n</code></pre> <p>Return the initialization arguments for the iterator.</p> Source code in <code>ngio/experimental/iterators/_feature.py</code> <pre><code>def get_init_kwargs(self) -&gt; dict:\n    \"\"\"Return the initialization arguments for the iterator.\"\"\"\n    return {\n        \"input_image\": self._input,\n        \"input_label\": self._input_label,\n        \"channel_selection\": self._channel_selection,\n        \"axes_order\": self._axes_order,\n        \"input_transforms\": self._input_transforms,\n        \"label_transforms\": self._label_transforms,\n    }\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.FeatureExtractorIterator.build_numpy_getter","title":"build_numpy_getter","text":"<pre><code>build_numpy_getter(roi: Roi) -&gt; NumpyFeatureGetter\n</code></pre> Source code in <code>ngio/experimental/iterators/_feature.py</code> <pre><code>def build_numpy_getter(self, roi: Roi) -&gt; NumpyFeatureGetter:\n    data_getter = NumpyRoiGetter(\n        zarr_array=self._input.zarr_array,\n        dimensions=self._input.dimensions,\n        axes_order=self._axes_order,\n        transforms=self._input_transforms,\n        roi=roi,\n        slicing_dict=self._input_slicing_kwargs,\n    )\n    label_getter = NumpyRoiGetter(\n        zarr_array=self._input_label.zarr_array,\n        dimensions=self._input_label.dimensions,\n        axes_order=self._axes_order,\n        transforms=self._label_transforms,\n        roi=roi,\n        remove_channel_selection=True,\n    )\n    return NumpyFeatureGetter(data_getter, label_getter)\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.FeatureExtractorIterator.build_dask_getter","title":"build_dask_getter","text":"<pre><code>build_dask_getter(roi: Roi) -&gt; DaskFeatureGetter\n</code></pre> Source code in <code>ngio/experimental/iterators/_feature.py</code> <pre><code>def build_dask_getter(self, roi: Roi) -&gt; DaskFeatureGetter:\n    data_getter = DaskRoiGetter(\n        zarr_array=self._input.zarr_array,\n        dimensions=self._input.dimensions,\n        axes_order=self._axes_order,\n        transforms=self._input_transforms,\n        roi=roi,\n        slicing_dict=self._input_slicing_kwargs,\n    )\n    label_getter = DaskRoiGetter(\n        zarr_array=self._input_label.zarr_array,\n        dimensions=self._input_label.dimensions,\n        axes_order=self._axes_order,\n        transforms=self._label_transforms,\n        roi=roi,\n        remove_channel_selection=True,\n    )\n    return DaskFeatureGetter(data_getter, label_getter)\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.FeatureExtractorIterator.build_numpy_setter","title":"build_numpy_setter","text":"<pre><code>build_numpy_setter(roi: Roi) -&gt; None\n</code></pre> Source code in <code>ngio/experimental/iterators/_feature.py</code> <pre><code>def build_numpy_setter(self, roi: Roi) -&gt; None:\n    return None\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.FeatureExtractorIterator.build_dask_setter","title":"build_dask_setter","text":"<pre><code>build_dask_setter(roi: Roi) -&gt; None\n</code></pre> Source code in <code>ngio/experimental/iterators/_feature.py</code> <pre><code>def build_dask_setter(self, roi: Roi) -&gt; None:\n    return None\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.FeatureExtractorIterator.post_consolidate","title":"post_consolidate","text":"<pre><code>post_consolidate()\n</code></pre> Source code in <code>ngio/experimental/iterators/_feature.py</code> <pre><code>def post_consolidate(self):\n    pass\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.FeatureExtractorIterator.iter_as_numpy","title":"iter_as_numpy","text":"<pre><code>iter_as_numpy()\n</code></pre> <p>Create an iterator over the pixels of the ROIs.</p> Source code in <code>ngio/experimental/iterators/_feature.py</code> <pre><code>def iter_as_numpy(self):  # type: ignore[override]\n    \"\"\"Create an iterator over the pixels of the ROIs.\"\"\"\n    return self.iter(lazy=False, data_mode=\"numpy\", iterator_mode=\"readonly\")\n</code></pre>"},{"location":"api/iterators/#ngio.experimental.iterators.FeatureExtractorIterator.iter_as_dask","title":"iter_as_dask","text":"<pre><code>iter_as_dask()\n</code></pre> <p>Create an iterator over the pixels of the ROIs.</p> Source code in <code>ngio/experimental/iterators/_feature.py</code> <pre><code>def iter_as_dask(self):  # type: ignore[override]\n    \"\"\"Create an iterator over the pixels of the ROIs.\"\"\"\n    return self.iter(lazy=False, data_mode=\"dask\", iterator_mode=\"readonly\")\n</code></pre>"},{"location":"api/ome_zarr_container/","title":"OmeZarrContainer: API Documentation","text":""},{"location":"api/ome_zarr_container/#open-an-ome-zarr-container","title":"Open an OME-Zarr Container","text":""},{"location":"api/ome_zarr_container/#ngio.open_ome_zarr_container","title":"ngio.open_ome_zarr_container","text":"<pre><code>open_ome_zarr_container(\n    store: StoreOrGroup,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n    axes_setup: AxesSetup | None = None,\n    validate_arrays: bool = True,\n) -&gt; OmeZarrContainer\n</code></pre> <p>Open an OME-Zarr image.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def open_ome_zarr_container(\n    store: StoreOrGroup,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n    axes_setup: AxesSetup | None = None,\n    validate_arrays: bool = True,\n) -&gt; OmeZarrContainer:\n    \"\"\"Open an OME-Zarr image.\"\"\"\n    handler = ZarrGroupHandler(store=store, cache=cache, mode=mode)\n    return OmeZarrContainer(\n        group_handler=handler,\n        validate_paths=validate_arrays,\n        axes_setup=axes_setup,\n    )\n</code></pre>"},{"location":"api/ome_zarr_container/#create-an-ome-zarr-container","title":"Create an OME-Zarr Container","text":""},{"location":"api/ome_zarr_container/#ngio.create_empty_ome_zarr","title":"ngio.create_empty_ome_zarr","text":"<pre><code>create_empty_ome_zarr(\n    store: StoreOrGroup,\n    shape: Sequence[int],\n    pixelsize: float | tuple[float, float] | None = None,\n    z_spacing: float = 1.0,\n    time_spacing: float = 1.0,\n    scaling_factors: Sequence[float]\n    | Literal[\"auto\"] = \"auto\",\n    levels: int | list[str] = 5,\n    translation: Sequence[float] | None = None,\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n    axes_names: Sequence[str] | None = None,\n    channels_meta: Sequence[str | Channel] | None = None,\n    name: str | None = None,\n    axes_setup: AxesSetup | None = None,\n    ngff_version: NgffVersions = DefaultNgffVersion,\n    chunks: ChunksLike = \"auto\",\n    shards: ShardsLike | None = None,\n    dtype: str = \"uint16\",\n    dimension_separator: Literal[\".\", \"/\"] = \"/\",\n    compressors: CompressorLike = \"auto\",\n    extra_array_kwargs: Mapping[str, Any] | None = None,\n    overwrite: bool = False,\n    xy_pixelsize: float | None = None,\n    xy_scaling_factor: float | None = None,\n    z_scaling_factor: float | None = None,\n    channel_labels: list[str] | None = None,\n    channel_wavelengths: list[str] | None = None,\n    channel_colors: Sequence[str] | None = None,\n    channel_active: Sequence[bool] | None = None,\n) -&gt; OmeZarrContainer\n</code></pre> <p>Create an empty OME-Zarr image with the given shape and metadata.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group to create the image in.</p> </li> <li> <code>shape</code>               (<code>Sequence[int]</code>)           \u2013            <p>The shape of the image.</p> </li> <li> <code>pixelsize</code>               (<code>float | tuple[float, float] | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size in x and y dimensions.</p> </li> <li> <code>z_spacing</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The spacing between z slices. Defaults to 1.0.</p> </li> <li> <code>time_spacing</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The spacing between time points. Defaults to 1.0.</p> </li> <li> <code>scaling_factors</code>               (<code>Sequence[float] | Literal['auto']</code>, default:                   <code>'auto'</code> )           \u2013            <p>The down-scaling factors for the pyramid levels. Defaults to \"auto\".</p> </li> <li> <code>levels</code>               (<code>int | list[str]</code>, default:                   <code>5</code> )           \u2013            <p>The number of levels in the pyramid or a list of level names. Defaults to 5.</p> </li> <li> <code>translation</code>               (<code>Sequence[float] | None</code>, default:                   <code>None</code> )           \u2013            <p>The translation for each axis. at the highest resolution level. Defaults to None.</p> </li> <li> <code>space_unit</code>               (<code>SpaceUnits</code>, default:                   <code>DefaultSpaceUnit</code> )           \u2013            <p>The unit of space. Defaults to DefaultSpaceUnit.</p> </li> <li> <code>time_unit</code>               (<code>TimeUnits</code>, default:                   <code>DefaultTimeUnit</code> )           \u2013            <p>The unit of time. Defaults to DefaultTimeUnit.</p> </li> <li> <code>axes_names</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The names of the axes. If None the canonical names are used. Defaults to None.</p> </li> <li> <code>channels_meta</code>               (<code>Sequence[str | Channel] | None</code>, default:                   <code>None</code> )           \u2013            <p>The channels metadata. Defaults to None.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the image. Defaults to None.</p> </li> <li> <code>axes_setup</code>               (<code>AxesSetup | None</code>, default:                   <code>None</code> )           \u2013            <p>Axes setup to create ome-zarr with non-standard axes configurations. Defaults to None.</p> </li> <li> <code>ngff_version</code>               (<code>NgffVersions</code>, default:                   <code>DefaultNgffVersion</code> )           \u2013            <p>The version of the OME-Zarr specification. Defaults to DefaultNgffVersion.</p> </li> <li> <code>chunks</code>               (<code>ChunksLike</code>, default:                   <code>'auto'</code> )           \u2013            <p>The chunk shape. Defaults to \"auto\".</p> </li> <li> <code>shards</code>               (<code>ShardsLike | None</code>, default:                   <code>None</code> )           \u2013            <p>The shard shape. Defaults to None.</p> </li> <li> <code>dtype</code>               (<code>str</code>, default:                   <code>'uint16'</code> )           \u2013            <p>The data type of the image. Defaults to \"uint16\".</p> </li> <li> <code>dimension_separator</code>               (<code>Literal['.', '/']</code>, default:                   <code>'/'</code> )           \u2013            <p>The dimension separator to use. Defaults to \"/\".</p> </li> <li> <code>compressors</code>               (<code>CompressorLike</code>, default:                   <code>'auto'</code> )           \u2013            <p>The compressor to use. Defaults to \"auto\".</p> </li> <li> <code>extra_array_kwargs</code>               (<code>Mapping[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Extra arguments to pass to the zarr array creation. Defaults to None.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to overwrite an existing image. Defaults to False.</p> </li> <li> <code>xy_pixelsize</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Use pixelsize instead.</p> </li> <li> <code>xy_scaling_factor</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Use scaling_factors instead.</p> </li> <li> <code>z_scaling_factor</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Use scaling_factors instead.</p> </li> <li> <code>channel_labels</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Use channels_meta instead.</p> </li> <li> <code>channel_wavelengths</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Use channels_meta instead.</p> </li> <li> <code>channel_colors</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Use channels_meta instead.</p> </li> <li> <code>channel_active</code>               (<code>Sequence[bool] | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Use channels_meta instead.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def create_empty_ome_zarr(\n    store: StoreOrGroup,\n    shape: Sequence[int],\n    pixelsize: float | tuple[float, float] | None = None,\n    z_spacing: float = 1.0,\n    time_spacing: float = 1.0,\n    scaling_factors: Sequence[float] | Literal[\"auto\"] = \"auto\",\n    levels: int | list[str] = 5,\n    translation: Sequence[float] | None = None,\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n    axes_names: Sequence[str] | None = None,\n    channels_meta: Sequence[str | Channel] | None = None,\n    name: str | None = None,\n    axes_setup: AxesSetup | None = None,\n    ngff_version: NgffVersions = DefaultNgffVersion,\n    chunks: ChunksLike = \"auto\",\n    shards: ShardsLike | None = None,\n    dtype: str = \"uint16\",\n    dimension_separator: Literal[\".\", \"/\"] = \"/\",\n    compressors: CompressorLike = \"auto\",\n    extra_array_kwargs: Mapping[str, Any] | None = None,\n    overwrite: bool = False,\n    # Deprecated arguments\n    xy_pixelsize: float | None = None,\n    xy_scaling_factor: float | None = None,\n    z_scaling_factor: float | None = None,\n    channel_labels: list[str] | None = None,\n    channel_wavelengths: list[str] | None = None,\n    channel_colors: Sequence[str] | None = None,\n    channel_active: Sequence[bool] | None = None,\n) -&gt; OmeZarrContainer:\n    \"\"\"Create an empty OME-Zarr image with the given shape and metadata.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group to create the image in.\n        shape (Sequence[int]): The shape of the image.\n        pixelsize (float | tuple[float, float] | None): The pixel size in x and y\n            dimensions.\n        z_spacing (float): The spacing between z slices. Defaults to 1.0.\n        time_spacing (float): The spacing between time points. Defaults to 1.0.\n        scaling_factors (Sequence[float] | Literal[\"auto\"]): The down-scaling factors\n            for the pyramid levels. Defaults to \"auto\".\n        levels (int | list[str]): The number of levels in the pyramid or a list of\n            level names. Defaults to 5.\n        translation (Sequence[float] | None): The translation for each axis.\n            at the highest resolution level. Defaults to None.\n        space_unit (SpaceUnits): The unit of space. Defaults to DefaultSpaceUnit.\n        time_unit (TimeUnits): The unit of time. Defaults to DefaultTimeUnit.\n        axes_names (Sequence[str] | None): The names of the axes. If None the\n            canonical names are used. Defaults to None.\n        channels_meta (Sequence[str | Channel] | None): The channels metadata.\n            Defaults to None.\n        name (str | None): The name of the image. Defaults to None.\n        axes_setup (AxesSetup | None): Axes setup to create ome-zarr with\n            non-standard axes configurations. Defaults to None.\n        ngff_version (NgffVersions): The version of the OME-Zarr specification.\n            Defaults to DefaultNgffVersion.\n        chunks (ChunksLike): The chunk shape. Defaults to \"auto\".\n        shards (ShardsLike | None): The shard shape. Defaults to None.\n        dtype (str): The data type of the image. Defaults to \"uint16\".\n        dimension_separator (Literal[\".\", \"/\"]): The dimension separator to use.\n            Defaults to \"/\".\n        compressors (CompressorLike): The compressor to use. Defaults to \"auto\".\n        extra_array_kwargs (Mapping[str, Any] | None): Extra arguments to pass to\n            the zarr array creation. Defaults to None.\n        overwrite (bool): Whether to overwrite an existing image. Defaults to False.\n        xy_pixelsize (float | None): Deprecated. Use pixelsize instead.\n        xy_scaling_factor (float | None): Deprecated. Use scaling_factors instead.\n        z_scaling_factor (float | None): Deprecated. Use scaling_factors instead.\n        channel_labels (list[str] | None): Deprecated. Use channels_meta instead.\n        channel_wavelengths (list[str] | None): Deprecated. Use channels_meta instead.\n        channel_colors (Sequence[str] | None): Deprecated. Use channels_meta instead.\n        channel_active (Sequence[bool] | None): Deprecated. Use channels_meta instead.\n    \"\"\"\n    if xy_pixelsize is not None:\n        logger.warning(\n            \"'xy_pixelsize' is deprecated and will be removed in ngio=0.6. \"\n            \"Please use 'pixelsize' instead.\"\n        )\n        pixelsize = xy_pixelsize\n    if xy_scaling_factor is not None or z_scaling_factor is not None:\n        logger.warning(\n            \"'xy_scaling_factor' and 'z_scaling_factor' are deprecated and will be \"\n            \"removed in ngio=0.6. Please use 'scaling_factors' instead.\"\n        )\n        xy_scaling_factor_ = xy_scaling_factor or 2.0\n        z_scaling_factor_ = z_scaling_factor or 1.0\n        if len(shape) == 2:\n            scaling_factors = (xy_scaling_factor_, xy_scaling_factor_)\n        else:\n            zyx_factors = (z_scaling_factor_, xy_scaling_factor_, xy_scaling_factor_)\n            scaling_factors = (1.0,) * (len(shape) - 3) + zyx_factors\n\n    if channel_labels is not None:\n        logger.warning(\n            \"'channel_labels' is deprecated and will be removed in ngio=0.6. \"\n            \"Please use 'channels_meta' instead.\"\n        )\n        channels_meta = channel_labels\n\n    if channel_wavelengths is not None:\n        logger.warning(\n            \"'channel_wavelengths' is deprecated and will be removed in ngio=0.6. \"\n            \"Please use 'channels_meta' instead.\"\n        )\n    if channel_colors is not None:\n        logger.warning(\n            \"'channel_colors' is deprecated and will be removed in ngio=0.6. \"\n            \"Please use 'channels_meta' instead.\"\n        )\n    if channel_active is not None:\n        logger.warning(\n            \"'channel_active' is deprecated and will be removed in ngio=0.6. \"\n            \"Please use 'channels_meta' instead.\"\n        )\n\n    if pixelsize is None:\n        raise NgioValueError(\"pixelsize must be provided.\")\n\n    handler, axes_setup = init_image_like(\n        store=store,\n        meta_type=NgioImageMeta,\n        shape=shape,\n        pixelsize=pixelsize,\n        z_spacing=z_spacing,\n        time_spacing=time_spacing,\n        scaling_factors=scaling_factors,\n        levels=levels,\n        translation=translation,\n        space_unit=space_unit,\n        time_unit=time_unit,\n        axes_names=axes_names,\n        channels_meta=channels_meta,\n        name=name,\n        axes_setup=axes_setup,\n        ngff_version=ngff_version,\n        chunks=chunks,\n        shards=shards,\n        dtype=dtype,\n        dimension_separator=dimension_separator,\n        compressors=compressors,\n        extra_array_kwargs=extra_array_kwargs,\n        overwrite=overwrite,\n    )\n\n    ome_zarr = OmeZarrContainer(group_handler=handler, axes_setup=axes_setup)\n    if (\n        channel_labels is not None\n        or channel_wavelengths is not None\n        or channel_colors is not None\n        or channel_active is not None\n    ):\n        # Deprecated way of setting channel metadata\n        # we set it here for backward compatibility\n        ome_zarr.set_channel_meta(\n            labels=channel_labels,\n            wavelength_id=channel_wavelengths,\n            percentiles=None,\n            colors=channel_colors,\n            active=channel_active,\n        )\n    return ome_zarr\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.create_ome_zarr_from_array","title":"ngio.create_ome_zarr_from_array","text":"<pre><code>create_ome_zarr_from_array(\n    store: StoreOrGroup,\n    array: ndarray,\n    pixelsize: float | tuple[float, float] | None = None,\n    z_spacing: float = 1.0,\n    time_spacing: float = 1.0,\n    scaling_factors: Sequence[float]\n    | Literal[\"auto\"] = \"auto\",\n    levels: int | list[str] = 5,\n    translation: Sequence[float] | None = None,\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n    axes_names: Sequence[str] | None = None,\n    channels_meta: Sequence[str | Channel] | None = None,\n    percentiles: tuple[float, float] = (0.1, 99.9),\n    name: str | None = None,\n    axes_setup: AxesSetup | None = None,\n    ngff_version: NgffVersions = DefaultNgffVersion,\n    chunks: ChunksLike = \"auto\",\n    shards: ShardsLike | None = None,\n    dimension_separator: Literal[\".\", \"/\"] = \"/\",\n    compressors: CompressorLike = \"auto\",\n    extra_array_kwargs: Mapping[str, Any] | None = None,\n    overwrite: bool = False,\n    xy_pixelsize: float | None = None,\n    xy_scaling_factor: float | None = None,\n    z_scaling_factor: float | None = None,\n    channel_labels: list[str] | None = None,\n    channel_wavelengths: list[str] | None = None,\n    channel_colors: Sequence[str] | None = None,\n    channel_active: Sequence[bool] | None = None,\n) -&gt; OmeZarrContainer\n</code></pre> <p>Create an OME-Zarr image from a numpy array.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group to create the image in.</p> </li> <li> <code>array</code>               (<code>ndarray</code>)           \u2013            <p>The image data.</p> </li> <li> <code>pixelsize</code>               (<code>float | tuple[float, float] | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size in x and y dimensions.</p> </li> <li> <code>z_spacing</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The spacing between z slices. Defaults to 1.0.</p> </li> <li> <code>time_spacing</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The spacing between time points. Defaults to 1.0.</p> </li> <li> <code>scaling_factors</code>               (<code>Sequence[float] | Literal['auto']</code>, default:                   <code>'auto'</code> )           \u2013            <p>The down-scaling factors for the pyramid levels. Defaults to \"auto\".</p> </li> <li> <code>levels</code>               (<code>int | list[str]</code>, default:                   <code>5</code> )           \u2013            <p>The number of levels in the pyramid or a list of level names. Defaults to 5.</p> </li> <li> <code>translation</code>               (<code>Sequence[float] | None</code>, default:                   <code>None</code> )           \u2013            <p>The translation for each axis. at the highest resolution level. Defaults to None.</p> </li> <li> <code>space_unit</code>               (<code>SpaceUnits</code>, default:                   <code>DefaultSpaceUnit</code> )           \u2013            <p>The unit of space. Defaults to DefaultSpaceUnit.</p> </li> <li> <code>time_unit</code>               (<code>TimeUnits</code>, default:                   <code>DefaultTimeUnit</code> )           \u2013            <p>The unit of time. Defaults to DefaultTimeUnit.</p> </li> <li> <code>axes_names</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The names of the axes. If None the canonical names are used. Defaults to None.</p> </li> <li> <code>channels_meta</code>               (<code>Sequence[str | Channel] | None</code>, default:                   <code>None</code> )           \u2013            <p>The channels metadata. Defaults to None.</p> </li> <li> <code>percentiles</code>               (<code>tuple[float, float]</code>, default:                   <code>(0.1, 99.9)</code> )           \u2013            <p>The percentiles of the channels for computing display ranges. Defaults to (0.1, 99.9).</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the image. Defaults to None.</p> </li> <li> <code>axes_setup</code>               (<code>AxesSetup | None</code>, default:                   <code>None</code> )           \u2013            <p>Axes setup to create ome-zarr with non-standard axes configurations. Defaults to None.</p> </li> <li> <code>ngff_version</code>               (<code>NgffVersions</code>, default:                   <code>DefaultNgffVersion</code> )           \u2013            <p>The version of the OME-Zarr specification. Defaults to DefaultNgffVersion.</p> </li> <li> <code>chunks</code>               (<code>ChunksLike</code>, default:                   <code>'auto'</code> )           \u2013            <p>The chunk shape. Defaults to \"auto\".</p> </li> <li> <code>shards</code>               (<code>ShardsLike | None</code>, default:                   <code>None</code> )           \u2013            <p>The shard shape. Defaults to None.</p> </li> <li> <code>dimension_separator</code>               (<code>Literal['.', '/']</code>, default:                   <code>'/'</code> )           \u2013            <p>The separator to use for dimensions. Defaults to \"/\".</p> </li> <li> <code>compressors</code>               (<code>CompressorLike</code>, default:                   <code>'auto'</code> )           \u2013            <p>The compressors to use. Defaults to \"auto\".</p> </li> <li> <code>extra_array_kwargs</code>               (<code>Mapping[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Extra arguments to pass to the zarr array creation. Defaults to None.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to overwrite an existing image. Defaults to False.</p> </li> <li> <code>xy_pixelsize</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Use pixelsize instead.</p> </li> <li> <code>xy_scaling_factor</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Use scaling_factors instead.</p> </li> <li> <code>z_scaling_factor</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Use scaling_factors instead.</p> </li> <li> <code>channel_labels</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Use channels_meta instead.</p> </li> <li> <code>channel_wavelengths</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Use channels_meta instead.</p> </li> <li> <code>channel_colors</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Use channels_meta instead.</p> </li> <li> <code>channel_active</code>               (<code>Sequence[bool] | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Use channels_meta instead.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def create_ome_zarr_from_array(\n    store: StoreOrGroup,\n    array: np.ndarray,\n    pixelsize: float | tuple[float, float] | None = None,\n    z_spacing: float = 1.0,\n    time_spacing: float = 1.0,\n    scaling_factors: Sequence[float] | Literal[\"auto\"] = \"auto\",\n    levels: int | list[str] = 5,\n    translation: Sequence[float] | None = None,\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n    axes_names: Sequence[str] | None = None,\n    channels_meta: Sequence[str | Channel] | None = None,\n    percentiles: tuple[float, float] = (0.1, 99.9),\n    name: str | None = None,\n    axes_setup: AxesSetup | None = None,\n    ngff_version: NgffVersions = DefaultNgffVersion,\n    chunks: ChunksLike = \"auto\",\n    shards: ShardsLike | None = None,\n    dimension_separator: Literal[\".\", \"/\"] = \"/\",\n    compressors: CompressorLike = \"auto\",\n    extra_array_kwargs: Mapping[str, Any] | None = None,\n    overwrite: bool = False,\n    # Deprecated arguments\n    xy_pixelsize: float | None = None,\n    xy_scaling_factor: float | None = None,\n    z_scaling_factor: float | None = None,\n    channel_labels: list[str] | None = None,\n    channel_wavelengths: list[str] | None = None,\n    channel_colors: Sequence[str] | None = None,\n    channel_active: Sequence[bool] | None = None,\n) -&gt; OmeZarrContainer:\n    \"\"\"Create an OME-Zarr image from a numpy array.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group to create the image in.\n        array (np.ndarray): The image data.\n        pixelsize (float | tuple[float, float] | None): The pixel size in x and y\n            dimensions.\n        z_spacing (float): The spacing between z slices. Defaults to 1.0.\n        time_spacing (float): The spacing between time points. Defaults to 1.0.\n        scaling_factors (Sequence[float] | Literal[\"auto\"]): The down-scaling factors\n            for the pyramid levels. Defaults to \"auto\".\n        levels (int | list[str]): The number of levels in the pyramid or a list of\n            level names. Defaults to 5.\n        translation (Sequence[float] | None): The translation for each axis.\n            at the highest resolution level. Defaults to None.\n        space_unit (SpaceUnits): The unit of space. Defaults to DefaultSpaceUnit.\n        time_unit (TimeUnits): The unit of time. Defaults to DefaultTimeUnit.\n        axes_names (Sequence[str] | None): The names of the axes. If None the\n            canonical names are used. Defaults to None.\n        channels_meta (Sequence[str | Channel] | None): The channels metadata.\n            Defaults to None.\n        percentiles (tuple[float, float]): The percentiles of the channels for\n            computing display ranges. Defaults to (0.1, 99.9).\n        name (str | None): The name of the image. Defaults to None.\n        axes_setup (AxesSetup | None): Axes setup to create ome-zarr with\n            non-standard axes configurations. Defaults to None.\n        ngff_version (NgffVersions): The version of the OME-Zarr specification.\n            Defaults to DefaultNgffVersion.\n        chunks (ChunksLike): The chunk shape. Defaults to \"auto\".\n        shards (ShardsLike | None): The shard shape. Defaults to None.\n        dimension_separator (Literal[\".\", \"/\"]): The separator to use for\n            dimensions. Defaults to \"/\".\n        compressors (CompressorLike): The compressors to use. Defaults to \"auto\".\n        extra_array_kwargs (Mapping[str, Any] | None): Extra arguments to pass to\n            the zarr array creation. Defaults to None.\n        overwrite (bool): Whether to overwrite an existing image. Defaults to False.\n        xy_pixelsize (float | None): Deprecated. Use pixelsize instead.\n        xy_scaling_factor (float | None): Deprecated. Use scaling_factors instead.\n        z_scaling_factor (float | None): Deprecated. Use scaling_factors instead.\n        channel_labels (list[str] | None): Deprecated. Use channels_meta instead.\n        channel_wavelengths (list[str] | None): Deprecated. Use channels_meta instead.\n        channel_colors (Sequence[str] | None): Deprecated. Use channels_meta instead.\n        channel_active (Sequence[bool] | None): Deprecated. Use channels_meta instead.\n    \"\"\"\n    if len(percentiles) != 2:\n        raise NgioValueError(\n            f\"'percentiles' must be a tuple of two values. Got {percentiles}\"\n        )\n    ome_zarr = create_empty_ome_zarr(\n        store=store,\n        shape=array.shape,\n        pixelsize=pixelsize,\n        z_spacing=z_spacing,\n        time_spacing=time_spacing,\n        scaling_factors=scaling_factors,\n        levels=levels,\n        translation=translation,\n        space_unit=space_unit,\n        time_unit=time_unit,\n        axes_names=axes_names,\n        channels_meta=channels_meta,\n        name=name,\n        axes_setup=axes_setup,\n        ngff_version=ngff_version,\n        chunks=chunks,\n        shards=shards,\n        dimension_separator=dimension_separator,\n        compressors=compressors,\n        extra_array_kwargs=extra_array_kwargs,\n        overwrite=overwrite,\n        xy_pixelsize=xy_pixelsize,\n        xy_scaling_factor=xy_scaling_factor,\n        z_scaling_factor=z_scaling_factor,\n        channel_labels=channel_labels,\n        channel_wavelengths=channel_wavelengths,\n        channel_colors=channel_colors,\n        channel_active=channel_active,\n    )\n    image = ome_zarr.get_image()\n    image.set_array(array)\n    image.consolidate()\n    ome_zarr.set_channel_windows_with_percentiles(percentiles=percentiles)\n    return ome_zarr\n</code></pre>"},{"location":"api/ome_zarr_container/#omezarrcontainer-class","title":"OmeZarrContainer Class","text":""},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer","title":"ngio.OmeZarrContainer","text":"<pre><code>OmeZarrContainer(\n    group_handler: ZarrGroupHandler,\n    table_container: TablesContainer | None = None,\n    label_container: LabelsContainer | None = None,\n    axes_setup: AxesSetup | None = None,\n    validate_paths: bool = False,\n)\n</code></pre> <p>This class is an object representation of an OME-Zarr image.</p> It provides methods to access <ul> <li>The multiscale image metadata</li> <li>To open images at different levels of resolution</li> <li>To access labels and tables associated with the image.</li> <li>To derive new images, labels, and add tables to the image.</li> <li>To modify the image metadata, such as axes units and channel metadata.</li> </ul> <p>Attributes:</p> <ul> <li> <code>images_container</code>               (<code>ImagesContainer</code>)           \u2013            <p>The container for the images.</p> </li> <li> <code>labels_container</code>               (<code>LabelsContainer</code>)           \u2013            <p>The container for the labels.</p> </li> <li> <code>tables_container</code>               (<code>TablesContainer</code>)           \u2013            <p>The container for the tables.</p> </li> </ul> <p>Initialize the OmeZarrContainer.</p> <p>Parameters:</p> <ul> <li> <code>group_handler</code>               (<code>ZarrGroupHandler</code>)           \u2013            <p>The Zarr group handler.</p> </li> <li> <code>table_container</code>               (<code>TablesContainer | None</code>, default:                   <code>None</code> )           \u2013            <p>The tables container.</p> </li> <li> <code>label_container</code>               (<code>LabelsContainer | None</code>, default:                   <code>None</code> )           \u2013            <p>The labels container.</p> </li> <li> <code>axes_setup</code>               (<code>AxesSetup | None</code>, default:                   <code>None</code> )           \u2013            <p>Axes setup to load ome-zarr with non-standard axes configurations.</p> </li> <li> <code>validate_paths</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to validate the paths of the image multiscale</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def __init__(\n    self,\n    group_handler: ZarrGroupHandler,\n    table_container: TablesContainer | None = None,\n    label_container: LabelsContainer | None = None,\n    axes_setup: AxesSetup | None = None,\n    validate_paths: bool = False,\n) -&gt; None:\n    \"\"\"Initialize the OmeZarrContainer.\n\n    Args:\n        group_handler (ZarrGroupHandler): The Zarr group handler.\n        table_container (TablesContainer | None): The tables container.\n        label_container (LabelsContainer | None): The labels container.\n        axes_setup (AxesSetup | None): Axes setup to load ome-zarr with\n            non-standard axes configurations.\n        validate_paths (bool): Whether to validate the paths of the image multiscale\n    \"\"\"\n    self._group_handler = group_handler\n    self._images_container = ImagesContainer(\n        self._group_handler, axes_setup=axes_setup\n    )\n    self._labels_container = label_container\n    self._tables_container = table_container\n\n    if validate_paths:\n        for level_path in self._images_container.level_paths:\n            self.get_image(path=level_path)\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.images_container","title":"images_container  <code>property</code>","text":"<pre><code>images_container: ImagesContainer\n</code></pre> <p>Return the images container.</p> <p>Returns:</p> <ul> <li> <code>ImagesContainer</code> (              <code>ImagesContainer</code> )          \u2013            <p>The images container.</p> </li> </ul>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.labels_container","title":"labels_container  <code>property</code>","text":"<pre><code>labels_container: LabelsContainer\n</code></pre> <p>Return the labels container.</p>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.tables_container","title":"tables_container  <code>property</code>","text":"<pre><code>tables_container: TablesContainer\n</code></pre> <p>Return the tables container.</p>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.meta","title":"meta  <code>property</code>","text":"<pre><code>meta: NgioImageMeta\n</code></pre> <p>Return the image metadata.</p>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.image_meta","title":"image_meta  <code>property</code>","text":"<pre><code>image_meta: NgioImageMeta\n</code></pre> <p>Return the image metadata.</p>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.axes_setup","title":"axes_setup  <code>property</code>","text":"<pre><code>axes_setup: AxesSetup\n</code></pre> <p>Return the axes setup.</p>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.levels","title":"levels  <code>property</code>","text":"<pre><code>levels: int\n</code></pre> <p>Return the number of levels in the image.</p>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.level_paths","title":"level_paths  <code>property</code>","text":"<pre><code>level_paths: list[str]\n</code></pre> <p>Return the paths of the levels in the image.</p>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.levels_paths","title":"levels_paths  <code>property</code>","text":"<pre><code>levels_paths: list[str]\n</code></pre> <p>Deprecated: use 'level_paths' instead.</p>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.is_3d","title":"is_3d  <code>property</code>","text":"<pre><code>is_3d: bool\n</code></pre> <p>Return True if the image is 3D.</p>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.is_2d","title":"is_2d  <code>property</code>","text":"<pre><code>is_2d: bool\n</code></pre> <p>Return True if the image is 2D.</p>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.is_time_series","title":"is_time_series  <code>property</code>","text":"<pre><code>is_time_series: bool\n</code></pre> <p>Return True if the image is a time series.</p>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.is_2d_time_series","title":"is_2d_time_series  <code>property</code>","text":"<pre><code>is_2d_time_series: bool\n</code></pre> <p>Return True if the image is a 2D time series.</p>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.is_3d_time_series","title":"is_3d_time_series  <code>property</code>","text":"<pre><code>is_3d_time_series: bool\n</code></pre> <p>Return True if the image is a 3D time series.</p>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.is_multi_channels","title":"is_multi_channels  <code>property</code>","text":"<pre><code>is_multi_channels: bool\n</code></pre> <p>Return True if the image is multichannel.</p>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.space_unit","title":"space_unit  <code>property</code>","text":"<pre><code>space_unit: str | None\n</code></pre> <p>Return the space unit of the image.</p>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.time_unit","title":"time_unit  <code>property</code>","text":"<pre><code>time_unit: str | None\n</code></pre> <p>Return the time unit of the image.</p>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.channel_labels","title":"channel_labels  <code>property</code>","text":"<pre><code>channel_labels: list[str]\n</code></pre> <p>Return the channels of the image.</p>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.wavelength_ids","title":"wavelength_ids  <code>property</code>","text":"<pre><code>wavelength_ids: list[str | None]\n</code></pre> <p>Return the list of wavelength of the image.</p>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.num_channels","title":"num_channels  <code>property</code>","text":"<pre><code>num_channels: int\n</code></pre> <p>Return the number of channels.</p>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.get_channel_idx","title":"get_channel_idx","text":"<pre><code>get_channel_idx(\n    channel_label: str | None = None,\n    wavelength_id: str | None = None,\n) -&gt; int\n</code></pre> <p>Get the index of a channel by its label or wavelength ID.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_channel_idx(\n    self, channel_label: str | None = None, wavelength_id: str | None = None\n) -&gt; int:\n    \"\"\"Get the index of a channel by its label or wavelength ID.\"\"\"\n    return self.images_container.get_channel_idx(\n        channel_label=channel_label, wavelength_id=wavelength_id\n    )\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.set_channel_meta","title":"set_channel_meta","text":"<pre><code>set_channel_meta(\n    channel_meta: ChannelsMeta | None = None,\n    labels: Sequence[str | None] | int | None = None,\n    wavelength_id: Sequence[str | None] | None = None,\n    start: Sequence[float | None] | None = None,\n    end: Sequence[float | None] | None = None,\n    percentiles: tuple[float, float] | None = None,\n    colors: Sequence[str | None] | None = None,\n    active: Sequence[bool | None] | None = None,\n    **omero_kwargs: dict,\n) -&gt; None\n</code></pre> <p>Create a ChannelsMeta object with the default unit.</p> <p>Parameters:</p> <ul> <li> <code>channel_meta</code>               (<code>ChannelsMeta | None</code>, default:                   <code>None</code> )           \u2013            <p>The channels metadata to set. If none, it will fall back to the deprecated parameters.</p> </li> <li> <code>labels</code>               (<code>Sequence[str | None] | int</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. The list of channels names in the image. If an integer is provided, the channels will be named \"channel_i\".</p> </li> <li> <code>wavelength_id</code>               (<code>Sequence[str | None]</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. The wavelength ID of the channel. If None, the wavelength ID will be the same as the channel name.</p> </li> <li> <code>start</code>               (<code>Sequence[float | None]</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. The start value for each channel. If None, the start value will be computed from the image.</p> </li> <li> <code>end</code>               (<code>Sequence[float | None]</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. The end value for each channel. If None, the end value will be computed from the image.</p> </li> <li> <code>percentiles</code>               (<code>tuple[float, float] | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. The start and end percentiles for each channel. If None, the percentiles will not be computed.</p> </li> <li> <code>colors</code>               (<code>Sequence[str | None]</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. The list of colors for the channels. If None, the colors will be random.</p> </li> <li> <code>active</code>               (<code>Sequence[bool | None]</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Whether the channel should be shown by default.</p> </li> <li> <code>omero_kwargs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Deprecated. Extra fields to store in the omero attributes.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def set_channel_meta(\n    self,\n    channel_meta: ChannelsMeta | None = None,\n    labels: Sequence[str | None] | int | None = None,\n    wavelength_id: Sequence[str | None] | None = None,\n    start: Sequence[float | None] | None = None,\n    end: Sequence[float | None] | None = None,\n    percentiles: tuple[float, float] | None = None,\n    colors: Sequence[str | None] | None = None,\n    active: Sequence[bool | None] | None = None,\n    **omero_kwargs: dict,\n) -&gt; None:\n    \"\"\"Create a ChannelsMeta object with the default unit.\n\n    Args:\n        channel_meta (ChannelsMeta | None): The channels metadata to set.\n            If none, it will fall back to the deprecated parameters.\n        labels(Sequence[str | None] | int): Deprecated. The list of channels names\n            in the image. If an integer is provided, the channels will\n            be named \"channel_i\".\n        wavelength_id(Sequence[str | None]): Deprecated. The wavelength ID of the\n            channel. If None, the wavelength ID will be the same as\n            the channel name.\n        start(Sequence[float | None]): Deprecated. The start value for each channel.\n            If None, the start value will be computed from the image.\n        end(Sequence[float | None]): Deprecated. The end value for each channel.\n            If None, the end value will be computed from the image.\n        percentiles(tuple[float, float] | None): Deprecated. The start and end\n            percentiles for each channel. If None, the percentiles will\n            not be computed.\n        colors(Sequence[str | None]): Deprecated. The list of colors for the\n            channels. If None, the colors will be random.\n        active (Sequence[bool | None]): Deprecated. Whether the channel should\n            be shown by default.\n        omero_kwargs(dict): Deprecated. Extra fields to store in the omero\n            attributes.\n    \"\"\"\n    self._images_container.set_channel_meta(\n        channel_meta=channel_meta,\n        labels=labels,\n        wavelength_id=wavelength_id,\n        start=start,\n        end=end,\n        percentiles=percentiles,\n        colors=colors,\n        active=active,\n        **omero_kwargs,\n    )\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.set_channel_labels","title":"set_channel_labels","text":"<pre><code>set_channel_labels(labels: Sequence[str]) -&gt; None\n</code></pre> <p>Update the labels of the channels.</p> <p>Parameters:</p> <ul> <li> <code>labels</code>               (<code>Sequence[str]</code>)           \u2013            <p>The new labels for the channels.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def set_channel_labels(\n    self,\n    labels: Sequence[str],\n) -&gt; None:\n    \"\"\"Update the labels of the channels.\n\n    Args:\n        labels (Sequence[str]): The new labels for the channels.\n    \"\"\"\n    self._images_container.set_channel_labels(labels=labels)\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.set_channel_colors","title":"set_channel_colors","text":"<pre><code>set_channel_colors(colors: Sequence[str]) -&gt; None\n</code></pre> <p>Update the colors of the channels.</p> <p>Parameters:</p> <ul> <li> <code>colors</code>               (<code>Sequence[str]</code>)           \u2013            <p>The new colors for the channels.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def set_channel_colors(\n    self,\n    colors: Sequence[str],\n) -&gt; None:\n    \"\"\"Update the colors of the channels.\n\n    Args:\n        colors (Sequence[str]): The new colors for the channels.\n    \"\"\"\n    self._images_container.set_channel_colors(colors=colors)\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.set_channel_percentiles","title":"set_channel_percentiles","text":"<pre><code>set_channel_percentiles(\n    start_percentile: float = 0.1,\n    end_percentile: float = 99.9,\n) -&gt; None\n</code></pre> <p>Deprecated: Update the channel windows using percentiles.</p> <p>Parameters:</p> <ul> <li> <code>start_percentile</code>               (<code>float</code>, default:                   <code>0.1</code> )           \u2013            <p>The start percentile.</p> </li> <li> <code>end_percentile</code>               (<code>float</code>, default:                   <code>99.9</code> )           \u2013            <p>The end percentile.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def set_channel_percentiles(\n    self,\n    start_percentile: float = 0.1,\n    end_percentile: float = 99.9,\n) -&gt; None:\n    \"\"\"Deprecated: Update the channel windows using percentiles.\n\n    Args:\n        start_percentile (float): The start percentile.\n        end_percentile (float): The end percentile.\n    \"\"\"\n    logger.warning(\n        \"The 'set_channel_percentiles' method is deprecated and will be removed in \"\n        \"ngio=0.6. Please use 'set_channel_windows_with_percentiles' instead.\"\n    )\n    self._images_container.set_channel_windows_with_percentiles(\n        percentiles=(start_percentile, end_percentile)\n    )\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.set_channel_windows","title":"set_channel_windows","text":"<pre><code>set_channel_windows(\n    starts_ends: Sequence[tuple[float, float]],\n    min_max: Sequence[tuple[float, float]] | None = None,\n) -&gt; None\n</code></pre> <p>Update the channel windows.</p> <p>These values are used by viewers to set the display range of each channel.</p> <p>Parameters:</p> <ul> <li> <code>starts_ends</code>               (<code>Sequence[tuple[float, float]]</code>)           \u2013            <p>The start and end values for each channel.</p> </li> <li> <code>min_max</code>               (<code>Sequence[tuple[float, float]] | None</code>, default:                   <code>None</code> )           \u2013            <p>The min and max values for each channel. If None, the min and max values will not be updated.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def set_channel_windows(\n    self,\n    starts_ends: Sequence[tuple[float, float]],\n    min_max: Sequence[tuple[float, float]] | None = None,\n) -&gt; None:\n    \"\"\"Update the channel windows.\n\n    These values are used by viewers to set the display\n    range of each channel.\n\n    Args:\n        starts_ends (Sequence[tuple[float, float]]): The start and end values\n            for each channel.\n        min_max (Sequence[tuple[float, float]] | None): The min and max values\n            for each channel. If None, the min and max values will not be updated.\n    \"\"\"\n    self._images_container.set_channel_windows(\n        starts_ends=starts_ends,\n        min_max=min_max,\n    )\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.set_channel_windows_with_percentiles","title":"set_channel_windows_with_percentiles","text":"<pre><code>set_channel_windows_with_percentiles(\n    percentiles: tuple[float, float]\n    | list[tuple[float, float]] = (0.1, 99.9),\n) -&gt; None\n</code></pre> <p>Update the channel windows using percentiles.</p> <p>Parameters:</p> <ul> <li> <code>percentiles</code>               (<code>tuple[float, float] | list[tuple[float, float]]</code>, default:                   <code>(0.1, 99.9)</code> )           \u2013            <p>The start and end percentiles for each channel. If a single tuple is provided, the same percentiles will be used for all channels.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def set_channel_windows_with_percentiles(\n    self,\n    percentiles: tuple[float, float] | list[tuple[float, float]] = (0.1, 99.9),\n) -&gt; None:\n    \"\"\"Update the channel windows using percentiles.\n\n    Args:\n        percentiles (tuple[float, float] | list[tuple[float, float]]):\n            The start and end percentiles for each channel.\n            If a single tuple is provided,\n            the same percentiles will be used for all channels.\n    \"\"\"\n    self._images_container.set_channel_windows_with_percentiles(\n        percentiles=percentiles\n    )\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.set_axes_units","title":"set_axes_units","text":"<pre><code>set_axes_units(\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n    set_labels: bool = True,\n) -&gt; None\n</code></pre> <p>Set the units of the image.</p> <p>Parameters:</p> <ul> <li> <code>space_unit</code>               (<code>SpaceUnits</code>, default:                   <code>DefaultSpaceUnit</code> )           \u2013            <p>The unit of space.</p> </li> <li> <code>time_unit</code>               (<code>TimeUnits</code>, default:                   <code>DefaultTimeUnit</code> )           \u2013            <p>The unit of time.</p> </li> <li> <code>set_labels</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to set the units for the labels as well.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def set_axes_units(\n    self,\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n    set_labels: bool = True,\n) -&gt; None:\n    \"\"\"Set the units of the image.\n\n    Args:\n        space_unit (SpaceUnits): The unit of space.\n        time_unit (TimeUnits): The unit of time.\n        set_labels (bool): Whether to set the units for the labels as well.\n    \"\"\"\n    if set_labels:\n        for label_name in self.list_labels():\n            label = self.get_label(label_name)\n            label.set_axes_unit(space_unit=space_unit, time_unit=time_unit)\n    self._images_container.set_axes_unit(space_unit=space_unit, time_unit=time_unit)\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.set_axes_names","title":"set_axes_names","text":"<pre><code>set_axes_names(axes_names: Sequence[str]) -&gt; None\n</code></pre> <p>Set the axes names of the image.</p> <p>Parameters:</p> <ul> <li> <code>axes_names</code>               (<code>Sequence[str]</code>)           \u2013            <p>The axes names of the image.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def set_axes_names(\n    self,\n    axes_names: Sequence[str],\n) -&gt; None:\n    \"\"\"Set the axes names of the image.\n\n    Args:\n        axes_names (Sequence[str]): The axes names of the image.\n    \"\"\"\n    self._images_container.set_axes_names(axes_names=axes_names)\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.set_name","title":"set_name","text":"<pre><code>set_name(name: str) -&gt; None\n</code></pre> <p>Set the name of the image in the metadata.</p> <p>This does not change the group name or any paths.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the image.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def set_name(\n    self,\n    name: str,\n) -&gt; None:\n    \"\"\"Set the name of the image in the metadata.\n\n    This does not change the group name or any paths.\n\n    Args:\n        name (str): The name of the image.\n    \"\"\"\n    self._images_container.set_name(name=name)\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.get_image","title":"get_image","text":"<pre><code>get_image(\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; Image\n</code></pre> <p>Get an image at a specific level.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the image in the ome_zarr file.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the image.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Only used if the pixel size is provided. If True, the pixel size must match the image pixel size exactly. If False, the closest pixel size level will be returned.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_image(\n    self,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; Image:\n    \"\"\"Get an image at a specific level.\n\n    Args:\n        path (str | None): The path to the image in the ome_zarr file.\n        pixel_size (PixelSize | None): The pixel size of the image.\n        strict (bool): Only used if the pixel size is provided. If True, the\n            pixel size must match the image pixel size exactly. If False, the\n            closest pixel size level will be returned.\n\n    \"\"\"\n    return self._images_container.get(\n        path=path, pixel_size=pixel_size, strict=strict\n    )\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.get_masked_image","title":"get_masked_image","text":"<pre><code>get_masked_image(\n    masking_label_name: str | None = None,\n    masking_table_name: str | None = None,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; MaskedImage\n</code></pre> <p>Get a masked image at a specific level.</p> <p>Parameters:</p> <ul> <li> <code>masking_label_name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the masking label to use. If None, the masking table must be provided.</p> </li> <li> <code>masking_table_name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the masking table to use. If None, the masking label must be provided.</p> </li> <li> <code>path</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the image in the ome_zarr file. If None, the first level will be used.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the image. This is only used if path is None.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Only used if the pixel size is provided. If True, the pixel size must match the image pixel size exactly. If False, the closest pixel size level will be returned.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_masked_image(\n    self,\n    masking_label_name: str | None = None,\n    masking_table_name: str | None = None,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; MaskedImage:\n    \"\"\"Get a masked image at a specific level.\n\n    Args:\n        masking_label_name (str | None): The name of the masking label to use.\n            If None, the masking table must be provided.\n        masking_table_name (str | None): The name of the masking table to use.\n            If None, the masking label must be provided.\n        path (str | None): The path to the image in the ome_zarr file.\n            If None, the first level will be used.\n        pixel_size (PixelSize | None): The pixel size of the image.\n            This is only used if path is None.\n        strict (bool): Only used if the pixel size is provided. If True, the\n            pixel size must match the image pixel size exactly. If False, the\n            closest pixel size level will be returned.\n    \"\"\"\n    image = self.get_image(path=path, pixel_size=pixel_size, strict=strict)\n    masking_label, masking_table = self._find_matching_masking_label(\n        masking_label_name=masking_label_name,\n        masking_table_name=masking_table_name,\n        pixel_size=image.pixel_size,\n    )\n    return MaskedImage(\n        group_handler=image._group_handler,\n        path=image.path,\n        meta_handler=image.meta_handler,\n        label=masking_label,\n        masking_roi_table=masking_table,\n    )\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.derive_image","title":"derive_image","text":"<pre><code>derive_image(\n    store: StoreOrGroup,\n    ref_path: str | None = None,\n    shape: Sequence[int] | None = None,\n    pixelsize: float | tuple[float, float] | None = None,\n    z_spacing: float | None = None,\n    time_spacing: float | None = None,\n    name: str | None = None,\n    translation: Sequence[float] | None = None,\n    channels_policy: Literal[\"squeeze\", \"same\", \"singleton\"]\n    | int = \"same\",\n    channels_meta: Sequence[str | Channel] | None = None,\n    ngff_version: NgffVersions | None = None,\n    chunks: ChunksLike | None = None,\n    shards: ShardsLike | None = None,\n    dtype: str = \"uint16\",\n    dimension_separator: Literal[\".\", \"/\"] = \"/\",\n    compressors: CompressorLike = \"auto\",\n    extra_array_kwargs: Mapping[str, Any] | None = None,\n    overwrite: bool = False,\n    copy_labels: bool = False,\n    copy_tables: bool = False,\n    labels: Sequence[str] | None = None,\n    pixel_size: PixelSize | None = None,\n) -&gt; OmeZarrContainer\n</code></pre> <p>Derive a new OME-Zarr container from the current image.</p> <p>If a kwarg is not provided, the value from the reference image will be used.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group to create the image in.</p> </li> <li> <code>ref_path</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the reference image in the image container.</p> </li> <li> <code>shape</code>               (<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The shape of the new image.</p> </li> <li> <code>pixelsize</code>               (<code>float | tuple[float, float] | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the new image.</p> </li> <li> <code>z_spacing</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>The z spacing of the new image.</p> </li> <li> <code>time_spacing</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>The time spacing of the new image.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the new image.</p> </li> <li> <code>translation</code>               (<code>Sequence[float] | None</code>, default:                   <code>None</code> )           \u2013            <p>The translation for each axis at the highest resolution level. Defaults to None.</p> </li> <li> <code>channels_policy</code>               (<code>Literal['squeeze', 'same', 'singleton'] | int</code>, default:                   <code>'same'</code> )           \u2013            <p>Possible policies: - If \"squeeze\", the channels axis will be removed (no matter its size). - If \"same\", the channels axis will be kept as is (if it exists). - If \"singleton\", the channels axis will be set to size 1. - If an integer is provided, the channels axis will be changed to have     that size.</p> </li> <li> <code>channels_meta</code>               (<code>Sequence[str | Channel] | None</code>, default:                   <code>None</code> )           \u2013            <p>The channels metadata of the new image.</p> </li> <li> <code>ngff_version</code>               (<code>NgffVersions | None</code>, default:                   <code>None</code> )           \u2013            <p>The NGFF version to use.</p> </li> <li> <code>chunks</code>               (<code>ChunksLike | None</code>, default:                   <code>None</code> )           \u2013            <p>The chunk shape of the new image.</p> </li> <li> <code>shards</code>               (<code>ShardsLike | None</code>, default:                   <code>None</code> )           \u2013            <p>The shard shape of the new image.</p> </li> <li> <code>dtype</code>               (<code>str</code>, default:                   <code>'uint16'</code> )           \u2013            <p>The data type of the new image. Defaults to \"uint16\".</p> </li> <li> <code>dimension_separator</code>               (<code>Literal['.', '/']</code>, default:                   <code>'/'</code> )           \u2013            <p>The separator to use for dimensions. Defaults to \"/\".</p> </li> <li> <code>compressors</code>               (<code>CompressorLike</code>, default:                   <code>'auto'</code> )           \u2013            <p>The compressors to use. Defaults to \"auto\".</p> </li> <li> <code>extra_array_kwargs</code>               (<code>Mapping[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Extra arguments to pass to the zarr array creation.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to overwrite an existing image. Defaults to False.</p> </li> <li> <code>copy_labels</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to copy the labels from the current image. Defaults to False.</p> </li> <li> <code>copy_tables</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to copy the tables from the current image. Defaults to False.</p> </li> <li> <code>labels</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. This argument is deprecated, please use channels_meta instead.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. The pixel size of the new image. This argument is deprecated, please use pixelsize, z_spacing, and time_spacing instead.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OmeZarrContainer</code> (              <code>OmeZarrContainer</code> )          \u2013            <p>The new derived OME-Zarr container.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def derive_image(\n    self,\n    store: StoreOrGroup,\n    ref_path: str | None = None,\n    # Metadata parameters\n    shape: Sequence[int] | None = None,\n    pixelsize: float | tuple[float, float] | None = None,\n    z_spacing: float | None = None,\n    time_spacing: float | None = None,\n    name: str | None = None,\n    translation: Sequence[float] | None = None,\n    channels_policy: Literal[\"squeeze\", \"same\", \"singleton\"] | int = \"same\",\n    channels_meta: Sequence[str | Channel] | None = None,\n    ngff_version: NgffVersions | None = None,\n    # Zarr Array parameters\n    chunks: ChunksLike | None = None,\n    shards: ShardsLike | None = None,\n    dtype: str = \"uint16\",\n    dimension_separator: Literal[\".\", \"/\"] = \"/\",\n    compressors: CompressorLike = \"auto\",\n    extra_array_kwargs: Mapping[str, Any] | None = None,\n    overwrite: bool = False,\n    # Copy from current image\n    copy_labels: bool = False,\n    copy_tables: bool = False,\n    # Deprecated arguments\n    labels: Sequence[str] | None = None,\n    pixel_size: PixelSize | None = None,\n) -&gt; \"OmeZarrContainer\":\n    \"\"\"Derive a new OME-Zarr container from the current image.\n\n    If a kwarg is not provided, the value from the reference image will be used.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group to create the image in.\n        ref_path (str | None): The path to the reference image in the image\n            container.\n        shape (Sequence[int] | None): The shape of the new image.\n        pixelsize (float | tuple[float, float] | None): The pixel size of the new\n            image.\n        z_spacing (float | None): The z spacing of the new image.\n        time_spacing (float | None): The time spacing of the new image.\n        name (str | None): The name of the new image.\n        translation (Sequence[float] | None): The translation for each axis\n            at the highest resolution level. Defaults to None.\n        channels_policy (Literal[\"squeeze\", \"same\", \"singleton\"] | int): Possible\n            policies:\n            - If \"squeeze\", the channels axis will be removed (no matter its size).\n            - If \"same\", the channels axis will be kept as is (if it exists).\n            - If \"singleton\", the channels axis will be set to size 1.\n            - If an integer is provided, the channels axis will be changed to have\n                that size.\n        channels_meta (Sequence[str | Channel] | None): The channels metadata\n            of the new image.\n        ngff_version (NgffVersions | None): The NGFF version to use.\n        chunks (ChunksLike | None): The chunk shape of the new image.\n        shards (ShardsLike | None): The shard shape of the new image.\n        dtype (str): The data type of the new image. Defaults to \"uint16\".\n        dimension_separator (Literal[\".\", \"/\"]): The separator to use for\n            dimensions. Defaults to \"/\".\n        compressors (CompressorLike): The compressors to use. Defaults to \"auto\".\n        extra_array_kwargs (Mapping[str, Any] | None): Extra arguments to pass to\n            the zarr array creation.\n        overwrite (bool): Whether to overwrite an existing image. Defaults to False.\n        copy_labels (bool): Whether to copy the labels from the current image.\n            Defaults to False.\n        copy_tables (bool): Whether to copy the tables from the current image.\n            Defaults to False.\n        labels (Sequence[str] | None): Deprecated. This argument is deprecated,\n            please use channels_meta instead.\n        pixel_size (PixelSize | None): Deprecated. The pixel size of the new image.\n            This argument is deprecated, please use pixelsize, z_spacing,\n            and time_spacing instead.\n\n    Returns:\n        OmeZarrContainer: The new derived OME-Zarr container.\n\n    \"\"\"\n    new_container = self._images_container.derive(\n        store=store,\n        ref_path=ref_path,\n        shape=shape,\n        pixelsize=pixelsize,\n        z_spacing=z_spacing,\n        time_spacing=time_spacing,\n        name=name,\n        translation=translation,\n        channels_meta=channels_meta,\n        channels_policy=channels_policy,\n        ngff_version=ngff_version,\n        chunks=chunks,\n        shards=shards,\n        dtype=dtype,\n        dimension_separator=dimension_separator,\n        compressors=compressors,\n        extra_array_kwargs=extra_array_kwargs,\n        overwrite=overwrite,\n        labels=labels,\n        pixel_size=pixel_size,\n    )\n    new_ome_zarr = OmeZarrContainer(\n        group_handler=new_container._group_handler,\n        validate_paths=False,\n        axes_setup=new_container.meta.axes_handler.axes_setup,\n    )\n\n    if copy_labels:\n        self.labels_container._group_handler.copy_group(\n            new_ome_zarr.labels_container._group_handler.group\n        )\n\n    if copy_tables:\n        self.tables_container._group_handler.copy_group(\n            new_ome_zarr.tables_container._group_handler.group\n        )\n    return new_ome_zarr\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.list_tables","title":"list_tables","text":"<pre><code>list_tables(\n    filter_types: TypedTable | str | None = None,\n) -&gt; list[str]\n</code></pre> <p>List all tables in the image.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def list_tables(self, filter_types: TypedTable | str | None = None) -&gt; list[str]:\n    \"\"\"List all tables in the image.\"\"\"\n    table_container = self._get_tables_container(create_mode=False)\n    if table_container is None:\n        return []\n\n    return table_container.list(\n        filter_types=filter_types,\n    )\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.list_roi_tables","title":"list_roi_tables","text":"<pre><code>list_roi_tables() -&gt; list[str]\n</code></pre> <p>List all ROI tables in the image.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def list_roi_tables(self) -&gt; list[str]:\n    \"\"\"List all ROI tables in the image.\"\"\"\n    masking_roi = self.tables_container.list(\n        filter_types=\"masking_roi_table\",\n    )\n    roi = self.tables_container.list(\n        filter_types=\"roi_table\",\n    )\n    return masking_roi + roi\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.get_roi_table","title":"get_roi_table","text":"<pre><code>get_roi_table(name: str) -&gt; RoiTable\n</code></pre> <p>Get a ROI table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_roi_table(self, name: str) -&gt; RoiTable:\n    \"\"\"Get a ROI table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, RoiTable):\n        raise NgioValueError(f\"Table {name} is not a ROI table. Got {type(table)}\")\n    return table\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.get_masking_roi_table","title":"get_masking_roi_table","text":"<pre><code>get_masking_roi_table(name: str) -&gt; MaskingRoiTable\n</code></pre> <p>Get a masking ROI table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_masking_roi_table(self, name: str) -&gt; MaskingRoiTable:\n    \"\"\"Get a masking ROI table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, MaskingRoiTable):\n        raise NgioValueError(\n            f\"Table {name} is not a masking ROI table. Got {type(table)}\"\n        )\n    return table\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.get_feature_table","title":"get_feature_table","text":"<pre><code>get_feature_table(name: str) -&gt; FeatureTable\n</code></pre> <p>Get a feature table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_feature_table(self, name: str) -&gt; FeatureTable:\n    \"\"\"Get a feature table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, FeatureTable):\n        raise NgioValueError(\n            f\"Table {name} is not a feature table. Got {type(table)}\"\n        )\n    return table\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.get_generic_roi_table","title":"get_generic_roi_table","text":"<pre><code>get_generic_roi_table(name: str) -&gt; GenericRoiTable\n</code></pre> <p>Get a generic ROI table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_generic_roi_table(self, name: str) -&gt; GenericRoiTable:\n    \"\"\"Get a generic ROI table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, GenericRoiTable):\n        raise NgioValueError(\n            f\"Table {name} is not a generic ROI table. Got {type(table)}\"\n        )\n    return table\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.get_condition_table","title":"get_condition_table","text":"<pre><code>get_condition_table(name: str) -&gt; ConditionTable\n</code></pre> <p>Get a condition table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_condition_table(self, name: str) -&gt; ConditionTable:\n    \"\"\"Get a condition table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, ConditionTable):\n        raise NgioValueError(\n            f\"Table {name} is not a condition table. Got {type(table)}\"\n        )\n    return table\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.get_table","title":"get_table","text":"<pre><code>get_table(\n    name: str, check_type: TypedTable | None = None\n) -&gt; Table\n</code></pre> <p>Get a table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> <li> <code>check_type</code>               (<code>TypedTable | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Please use 'get_table_as' instead, or one of the type specific get_*table() methods.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_table(self, name: str, check_type: TypedTable | None = None) -&gt; Table:\n    \"\"\"Get a table from the image.\n\n    Args:\n        name (str): The name of the table.\n        check_type (TypedTable | None): Deprecated. Please use\n            'get_table_as' instead, or one of the type specific\n            get_*table() methods.\n\n    \"\"\"\n    if check_type is not None:\n        logger.warning(\n            \"The 'check_type' argument is deprecated and will be removed in \"\n            \"ngio=0.6. Please use 'get_table_as' instead or one of the \"\n            \"type specific get_*table() methods.\"\n        )\n    return self.tables_container.get(name=name, strict=False)\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.get_table_as","title":"get_table_as","text":"<pre><code>get_table_as(\n    name: str,\n    table_cls: type[TableType],\n    backend: TableBackend | None = None,\n) -&gt; TableType\n</code></pre> <p>Get a table from the image as a specific type.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> <li> <code>table_cls</code>               (<code>type[TableType]</code>)           \u2013            <p>The type of the table.</p> </li> <li> <code>backend</code>               (<code>TableBackend | None</code>, default:                   <code>None</code> )           \u2013            <p>The backend to use. If None, the default backend is used.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_table_as(\n    self,\n    name: str,\n    table_cls: type[TableType],\n    backend: TableBackend | None = None,\n) -&gt; TableType:\n    \"\"\"Get a table from the image as a specific type.\n\n    Args:\n        name (str): The name of the table.\n        table_cls (type[TableType]): The type of the table.\n        backend (TableBackend | None): The backend to use. If None,\n            the default backend is used.\n    \"\"\"\n    return self.tables_container.get_as(\n        name=name,\n        table_cls=table_cls,\n        backend=backend,\n    )\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.build_image_roi_table","title":"build_image_roi_table","text":"<pre><code>build_image_roi_table(\n    name: str | None = \"image\",\n) -&gt; RoiTable\n</code></pre> <p>Compute the ROI table for an image.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def build_image_roi_table(self, name: str | None = \"image\") -&gt; RoiTable:\n    \"\"\"Compute the ROI table for an image.\"\"\"\n    return self.get_image().build_image_roi_table(name=name)\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.build_masking_roi_table","title":"build_masking_roi_table","text":"<pre><code>build_masking_roi_table(label: str) -&gt; MaskingRoiTable\n</code></pre> <p>Compute the masking ROI table for a label.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def build_masking_roi_table(self, label: str) -&gt; MaskingRoiTable:\n    \"\"\"Compute the masking ROI table for a label.\"\"\"\n    return self.get_label(label).build_masking_roi_table()\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.add_table","title":"add_table","text":"<pre><code>add_table(\n    name: str,\n    table: Table,\n    backend: TableBackend = DefaultTableBackend,\n    overwrite: bool = False,\n) -&gt; None\n</code></pre> <p>Add a table to the image.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def add_table(\n    self,\n    name: str,\n    table: Table,\n    backend: TableBackend = DefaultTableBackend,\n    overwrite: bool = False,\n) -&gt; None:\n    \"\"\"Add a table to the image.\"\"\"\n    self.tables_container.add(\n        name=name, table=table, backend=backend, overwrite=overwrite\n    )\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.delete_table","title":"delete_table","text":"<pre><code>delete_table(name: str, missing_ok: bool = False) -&gt; None\n</code></pre> <p>Delete a table from the group.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table to delete.</p> </li> <li> <code>missing_ok</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, do not raise an error if the table does not exist.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def delete_table(self, name: str, missing_ok: bool = False) -&gt; None:\n    \"\"\"Delete a table from the group.\n\n    Args:\n        name (str): The name of the table to delete.\n        missing_ok (bool): If True, do not raise an error if the table does not\n            exist.\n\n    \"\"\"\n    table_container = self._get_tables_container(create_mode=False)\n    if table_container is None and missing_ok:\n        return\n    if table_container is None:\n        raise NgioValueError(\n            f\"No tables found in the image, cannot delete {name}. \"\n            \"Set missing_ok=True to ignore this error.\"\n        )\n    table_container.delete(name=name, missing_ok=missing_ok)\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.list_labels","title":"list_labels","text":"<pre><code>list_labels() -&gt; list[str]\n</code></pre> <p>List all labels in the image.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def list_labels(self) -&gt; list[str]:\n    \"\"\"List all labels in the image.\"\"\"\n    label_container = self._get_labels_container(create_mode=False)\n    if label_container is None:\n        return []\n    return label_container.list()\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.get_label","title":"get_label","text":"<pre><code>get_label(\n    name: str,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; Label\n</code></pre> <p>Get a label from the group.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the label.</p> </li> <li> <code>path</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the image in the ome_zarr file.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the image.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Only used if the pixel size is provided. If True, the pixel size must match the image pixel size exactly. If False, the closest pixel size level will be returned.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_label(\n    self,\n    name: str,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; Label:\n    \"\"\"Get a label from the group.\n\n    Args:\n        name (str): The name of the label.\n        path (str | None): The path to the image in the ome_zarr file.\n        pixel_size (PixelSize | None): The pixel size of the image.\n        strict (bool): Only used if the pixel size is provided. If True, the\n            pixel size must match the image pixel size exactly. If False, the\n            closest pixel size level will be returned.\n    \"\"\"\n    return self.labels_container.get(\n        name=name, path=path, pixel_size=pixel_size, strict=strict\n    )\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.get_masked_label","title":"get_masked_label","text":"<pre><code>get_masked_label(\n    label_name: str,\n    masking_label_name: str | None = None,\n    masking_table_name: str | None = None,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; MaskedLabel\n</code></pre> <p>Get a masked image at a specific level.</p> <p>Parameters:</p> <ul> <li> <code>label_name</code>               (<code>str</code>)           \u2013            <p>The name of the label.</p> </li> <li> <code>masking_label_name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the masking label.</p> </li> <li> <code>masking_table_name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the masking table.</p> </li> <li> <code>path</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the image in the ome_zarr file.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the image.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Only used if the pixel size is provided. If True, the pixel size must match the image pixel size exactly. If False, the closest pixel size level will be returned.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_masked_label(\n    self,\n    label_name: str,\n    masking_label_name: str | None = None,\n    masking_table_name: str | None = None,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; MaskedLabel:\n    \"\"\"Get a masked image at a specific level.\n\n    Args:\n        label_name (str): The name of the label.\n        masking_label_name (str | None): The name of the masking label.\n        masking_table_name (str | None): The name of the masking table.\n        path (str | None): The path to the image in the ome_zarr file.\n        pixel_size (PixelSize | None): The pixel size of the image.\n        strict (bool): Only used if the pixel size is provided. If True, the\n            pixel size must match the image pixel size exactly. If False, the\n            closest pixel size level will be returned.\n    \"\"\"\n    label = self.get_label(\n        name=label_name, path=path, pixel_size=pixel_size, strict=strict\n    )\n    masking_label, masking_table = self._find_matching_masking_label(\n        masking_label_name=masking_label_name,\n        masking_table_name=masking_table_name,\n        pixel_size=pixel_size,\n    )\n    return MaskedLabel(\n        group_handler=label._group_handler,\n        path=label.path,\n        meta_handler=label.meta_handler,\n        label=masking_label,\n        masking_roi_table=masking_table,\n    )\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.delete_label","title":"delete_label","text":"<pre><code>delete_label(name: str, missing_ok: bool = False) -&gt; None\n</code></pre> <p>Delete a label from the group.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the label to delete.</p> </li> <li> <code>missing_ok</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, do not raise an error if the label does not exist.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def delete_label(self, name: str, missing_ok: bool = False) -&gt; None:\n    \"\"\"Delete a label from the group.\n\n    Args:\n        name (str): The name of the label to delete.\n        missing_ok (bool): If True, do not raise an error if the label does not\n            exist.\n\n    \"\"\"\n    label_container = self._get_labels_container(create_mode=False)\n    if label_container is None and missing_ok:\n        return\n    if label_container is None:\n        raise NgioValueError(\n            f\"No labels found in the image, cannot delete {name}. \"\n            \"Set missing_ok=True to ignore this error.\"\n        )\n    label_container.delete(name=name, missing_ok=missing_ok)\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.derive_label","title":"derive_label","text":"<pre><code>derive_label(\n    name: str,\n    ref_image: Image | Label | None = None,\n    shape: Sequence[int] | None = None,\n    pixelsize: float | tuple[float, float] | None = None,\n    z_spacing: float | None = None,\n    time_spacing: float | None = None,\n    translation: Sequence[float] | None = None,\n    channels_policy: Literal[\"same\", \"squeeze\", \"singleton\"]\n    | int = \"squeeze\",\n    ngff_version: NgffVersions | None = None,\n    chunks: ChunksLike | None = None,\n    shards: ShardsLike | None = None,\n    dtype: str | None = None,\n    dimension_separator: Literal[\".\", \"/\"] | None = None,\n    compressors: CompressorLike | None = None,\n    extra_array_kwargs: Mapping[str, Any] | None = None,\n    overwrite: bool = False,\n    labels: Sequence[str] | None = None,\n    pixel_size: PixelSize | None = None,\n) -&gt; Label\n</code></pre> <p>Derive a new label from an existing image or label.</p> <p>If a kwarg is not provided, the value from the reference image will be used.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the new label.</p> </li> <li> <code>ref_image</code>               (<code>Image | Label | None</code>, default:                   <code>None</code> )           \u2013            <p>The reference image to derive the new label from. If None, the first level image will be used.</p> </li> <li> <code>shape</code>               (<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The shape of the new label.</p> </li> <li> <code>pixelsize</code>               (<code>float | tuple[float, float] | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the new label.</p> </li> <li> <code>z_spacing</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>The z spacing of the new label.</p> </li> <li> <code>time_spacing</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>The time spacing of the new label.</p> </li> <li> <code>translation</code>               (<code>Sequence[float] | None</code>, default:                   <code>None</code> )           \u2013            <p>The translation for each axis at the highest resolution level. Defaults to None.</p> </li> <li> <code>channels_policy</code>               (<code>Literal['same', 'squeeze', 'singleton'] | int</code>, default:                   <code>'squeeze'</code> )           \u2013            <p>Possible policies: - If \"squeeze\", the channels axis will be removed (no matter its size). - If \"same\", the channels axis will be kept as is (if it exists). - If \"singleton\", the channels axis will be set to size 1. - If an integer is provided, the channels axis will be changed to have     that size. Defaults to \"squeeze\".</p> </li> <li> <code>ngff_version</code>               (<code>NgffVersions | None</code>, default:                   <code>None</code> )           \u2013            <p>The NGFF version to use.</p> </li> <li> <code>chunks</code>               (<code>ChunksLike | None</code>, default:                   <code>None</code> )           \u2013            <p>The chunk shape of the new label.</p> </li> <li> <code>shards</code>               (<code>ShardsLike | None</code>, default:                   <code>None</code> )           \u2013            <p>The shard shape of the new label.</p> </li> <li> <code>dtype</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The data type of the new label.</p> </li> <li> <code>dimension_separator</code>               (<code>Literal['.', '/'] | None</code>, default:                   <code>None</code> )           \u2013            <p>The separator to use for dimensions.</p> </li> <li> <code>compressors</code>               (<code>CompressorLike | None</code>, default:                   <code>None</code> )           \u2013            <p>The compressors to use.</p> </li> <li> <code>extra_array_kwargs</code>               (<code>Mapping[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Extra arguments to pass to the zarr array creation.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to overwrite an existing label. Defaults to False.</p> </li> <li> <code>labels</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. This argument is deprecated, please use channels_meta instead.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. The pixel size of the new label. This argument is deprecated, please use pixelsize, z_spacing, and time_spacing instead.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Label</code> (              <code>Label</code> )          \u2013            <p>The new derived label.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def derive_label(\n    self,\n    name: str,\n    ref_image: Image | Label | None = None,\n    # Metadata parameters\n    shape: Sequence[int] | None = None,\n    pixelsize: float | tuple[float, float] | None = None,\n    z_spacing: float | None = None,\n    time_spacing: float | None = None,\n    translation: Sequence[float] | None = None,\n    channels_policy: Literal[\"same\", \"squeeze\", \"singleton\"] | int = \"squeeze\",\n    ngff_version: NgffVersions | None = None,\n    # Zarr Array parameters\n    chunks: ChunksLike | None = None,\n    shards: ShardsLike | None = None,\n    dtype: str | None = None,\n    dimension_separator: Literal[\".\", \"/\"] | None = None,\n    compressors: CompressorLike | None = None,\n    extra_array_kwargs: Mapping[str, Any] | None = None,\n    overwrite: bool = False,\n    # Deprecated arguments\n    labels: Sequence[str] | None = None,\n    pixel_size: PixelSize | None = None,\n) -&gt; \"Label\":\n    \"\"\"Derive a new label from an existing image or label.\n\n    If a kwarg is not provided, the value from the reference image will be used.\n\n    Args:\n        name (str): The name of the new label.\n        ref_image (Image | Label | None): The reference image to derive the new\n            label from. If None, the first level image will be used.\n        shape (Sequence[int] | None): The shape of the new label.\n        pixelsize (float | tuple[float, float] | None): The pixel size of the new\n            label.\n        z_spacing (float | None): The z spacing of the new label.\n        time_spacing (float | None): The time spacing of the new label.\n        translation (Sequence[float] | None): The translation for each axis\n            at the highest resolution level. Defaults to None.\n        channels_policy (Literal[\"same\", \"squeeze\", \"singleton\"] | int): Possible\n            policies:\n            - If \"squeeze\", the channels axis will be removed (no matter its size).\n            - If \"same\", the channels axis will be kept as is (if it exists).\n            - If \"singleton\", the channels axis will be set to size 1.\n            - If an integer is provided, the channels axis will be changed to have\n                that size.\n            Defaults to \"squeeze\".\n        ngff_version (NgffVersions | None): The NGFF version to use.\n        chunks (ChunksLike | None): The chunk shape of the new label.\n        shards (ShardsLike | None): The shard shape of the new label.\n        dtype (str | None): The data type of the new label.\n        dimension_separator (Literal[\".\", \"/\"] | None): The separator to use for\n            dimensions.\n        compressors (CompressorLike | None): The compressors to use.\n        extra_array_kwargs (Mapping[str, Any] | None): Extra arguments to pass to\n            the zarr array creation.\n        overwrite (bool): Whether to overwrite an existing label. Defaults to False.\n        labels (Sequence[str] | None): Deprecated. This argument is deprecated,\n            please use channels_meta instead.\n        pixel_size (PixelSize | None): Deprecated. The pixel size of the new label.\n            This argument is deprecated, please use pixelsize, z_spacing,\n            and time_spacing instead.\n\n    Returns:\n        Label: The new derived label.\n\n    \"\"\"\n    if ref_image is None:\n        ref_image = self.get_image()\n    return self.labels_container.derive(\n        name=name,\n        ref_image=ref_image,\n        shape=shape,\n        pixelsize=pixelsize,\n        z_spacing=z_spacing,\n        time_spacing=time_spacing,\n        translation=translation,\n        channels_policy=channels_policy,\n        ngff_version=ngff_version,\n        chunks=chunks,\n        shards=shards,\n        dtype=dtype,\n        dimension_separator=dimension_separator,\n        compressors=compressors,\n        extra_array_kwargs=extra_array_kwargs,\n        overwrite=overwrite,\n        labels=labels,\n        pixel_size=pixel_size,\n    )\n</code></pre>"},{"location":"api/tables/","title":"Ngio Tables API Documentation","text":""},{"location":"api/ngio/common/","title":"ngio.common API documentation","text":""},{"location":"api/ngio/common/#ngio.common","title":"ngio.common","text":"<p>Common classes and functions that are used across the package.</p>"},{"location":"api/ngio/common/#ngio.common.ChunksLike","title":"ChunksLike  <code>module-attribute</code>","text":"<pre><code>ChunksLike = tuple[int, ...] | Literal['auto']\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.ShardsLike","title":"ShardsLike  <code>module-attribute</code>","text":"<pre><code>ShardsLike = tuple[int, ...] | Literal['auto']\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.InterpolationOrder","title":"InterpolationOrder  <code>module-attribute</code>","text":"<pre><code>InterpolationOrder = Literal['nearest', 'linear', 'cubic']\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Dimensions","title":"Dimensions","text":"<pre><code>Dimensions(\n    shape: tuple[int, ...],\n    chunks: tuple[int, ...],\n    dataset: Dataset,\n)\n</code></pre> <p>Dimension metadata Handling Class.</p> <p>This class is used to handle and manipulate dimension metadata. It provides methods to access and validate dimension information, such as shape, axes, and properties like is_2d, is_3d, is_time_series, etc.</p> <p>Create a Dimension object from a Zarr array.</p> <p>Parameters:</p> <ul> <li> <code>shape</code>               (<code>tuple[int, ...]</code>)           \u2013            <p>The shape of the Zarr array.</p> </li> <li> <code>chunks</code>               (<code>tuple[int, ...]</code>)           \u2013            <p>The chunks of the Zarr array.</p> </li> <li> <code>dataset</code>               (<code>Dataset</code>)           \u2013            <p>The dataset object.</p> </li> </ul> Source code in <code>ngio/common/_dimensions.py</code> <pre><code>def __init__(\n    self,\n    shape: tuple[int, ...],\n    chunks: tuple[int, ...],\n    dataset: Dataset,\n) -&gt; None:\n    \"\"\"Create a Dimension object from a Zarr array.\n\n    Args:\n        shape: The shape of the Zarr array.\n        chunks: The chunks of the Zarr array.\n        dataset: The dataset object.\n    \"\"\"\n    self._shape = shape\n    self._chunks = chunks\n    self._axes_handler = dataset.axes_handler\n    self._pixel_size = dataset.pixel_size\n\n    if len(self._shape) != len(self._axes_handler.axes):\n        raise NgioValueError(\n            \"The number of dimensions must match the number of axes. \"\n            f\"Expected Axis {self._axes_handler.axes_names} but got shape \"\n            f\"{self._shape}.\"\n        )\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Dimensions.require_axes_match","title":"require_axes_match  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>require_axes_match = require_axes_match\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Dimensions.check_if_axes_match","title":"check_if_axes_match  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>check_if_axes_match = check_if_axes_match\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Dimensions.require_dimensions_match","title":"require_dimensions_match  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>require_dimensions_match = require_dimensions_match\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Dimensions.check_if_dimensions_match","title":"check_if_dimensions_match  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>check_if_dimensions_match = check_if_dimensions_match\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Dimensions.require_rescalable","title":"require_rescalable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>require_rescalable = require_rescalable\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Dimensions.check_if_rescalable","title":"check_if_rescalable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>check_if_rescalable = check_if_rescalable\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Dimensions.axes_handler","title":"axes_handler  <code>property</code>","text":"<pre><code>axes_handler: AxesHandler\n</code></pre> <p>Return the axes handler object.</p>"},{"location":"api/ngio/common/#ngio.common.Dimensions.pixel_size","title":"pixel_size  <code>property</code>","text":"<pre><code>pixel_size: PixelSize\n</code></pre> <p>Return the pixel size object.</p>"},{"location":"api/ngio/common/#ngio.common.Dimensions.shape","title":"shape  <code>property</code>","text":"<pre><code>shape: tuple[int, ...]\n</code></pre> <p>Return the shape as a tuple.</p>"},{"location":"api/ngio/common/#ngio.common.Dimensions.chunks","title":"chunks  <code>property</code>","text":"<pre><code>chunks: tuple[int, ...]\n</code></pre> <p>Return the chunks as a tuple.</p>"},{"location":"api/ngio/common/#ngio.common.Dimensions.axes","title":"axes  <code>property</code>","text":"<pre><code>axes: tuple[str, ...]\n</code></pre> <p>Return the axes as a tuple of strings.</p>"},{"location":"api/ngio/common/#ngio.common.Dimensions.is_time_series","title":"is_time_series  <code>property</code>","text":"<pre><code>is_time_series: bool\n</code></pre> <p>Return whether the image is a time series.</p>"},{"location":"api/ngio/common/#ngio.common.Dimensions.is_2d","title":"is_2d  <code>property</code>","text":"<pre><code>is_2d: bool\n</code></pre> <p>Return whether the image is 2D.</p>"},{"location":"api/ngio/common/#ngio.common.Dimensions.is_2d_time_series","title":"is_2d_time_series  <code>property</code>","text":"<pre><code>is_2d_time_series: bool\n</code></pre> <p>Return whether the image is a 2D time series.</p>"},{"location":"api/ngio/common/#ngio.common.Dimensions.is_3d","title":"is_3d  <code>property</code>","text":"<pre><code>is_3d: bool\n</code></pre> <p>Return whether the image is 3D.</p>"},{"location":"api/ngio/common/#ngio.common.Dimensions.is_3d_time_series","title":"is_3d_time_series  <code>property</code>","text":"<pre><code>is_3d_time_series: bool\n</code></pre> <p>Return whether the image is a 3D time series.</p>"},{"location":"api/ngio/common/#ngio.common.Dimensions.is_multi_channels","title":"is_multi_channels  <code>property</code>","text":"<pre><code>is_multi_channels: bool\n</code></pre> <p>Return whether the image has multiple channels.</p>"},{"location":"api/ngio/common/#ngio.common.Dimensions.get","title":"get","text":"<pre><code>get(axis_name: str, default: None = None) -&gt; int | None\n</code></pre><pre><code>get(axis_name: str, default: int) -&gt; int\n</code></pre> <pre><code>get(\n    axis_name: str, default: int | None = None\n) -&gt; int | None\n</code></pre> <p>Return the dimension/shape of the given axis name.</p> <p>Parameters:</p> <ul> <li> <code>axis_name</code>               (<code>str</code>)           \u2013            <p>The name of the axis (either canonical or non-canonical).</p> </li> <li> <code>default</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The default value to return if the axis does not exist.</p> </li> </ul> Source code in <code>ngio/common/_dimensions.py</code> <pre><code>def get(self, axis_name: str, default: int | None = None) -&gt; int | None:\n    \"\"\"Return the dimension/shape of the given axis name.\n\n    Args:\n        axis_name: The name of the axis (either canonical or non-canonical).\n        default: The default value to return if the axis does not exist.\n    \"\"\"\n    index = self.axes_handler.get_index(axis_name)\n    if index is None:\n        return default\n    return self._shape[index]\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.ImagePyramidBuilder","title":"ImagePyramidBuilder","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/ngio/common/#ngio.common.ImagePyramidBuilder.levels","title":"levels  <code>instance-attribute</code>","text":"<pre><code>levels: list[PyramidLevel]\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.ImagePyramidBuilder.axes","title":"axes  <code>instance-attribute</code>","text":"<pre><code>axes: tuple[str, ...]\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.ImagePyramidBuilder.data_type","title":"data_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data_type: str = 'uint16'\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.ImagePyramidBuilder.dimension_separator","title":"dimension_separator  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dimension_separator: Literal['.', '/'] = '/'\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.ImagePyramidBuilder.compressors","title":"compressors  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>compressors: Any = 'auto'\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.ImagePyramidBuilder.zarr_format","title":"zarr_format  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>zarr_format: Literal[2, 3] = 2\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.ImagePyramidBuilder.other_array_kwargs","title":"other_array_kwargs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>other_array_kwargs: Mapping[str, Any] = {}\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.ImagePyramidBuilder.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(arbitrary_types_allowed=True)\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.ImagePyramidBuilder.from_scaling_factors","title":"from_scaling_factors  <code>classmethod</code>","text":"<pre><code>from_scaling_factors(\n    levels_paths: tuple[str, ...],\n    scaling_factors: tuple[float, ...],\n    base_shape: tuple[int, ...],\n    base_scale: tuple[float, ...],\n    axes: tuple[str, ...],\n    base_translation: Sequence[float] | None = None,\n    chunks: ChunksLike = \"auto\",\n    shards: ShardsLike | None = None,\n    data_type: str = \"uint16\",\n    dimension_separator: Literal[\".\", \"/\"] = \"/\",\n    compressors: Any = \"auto\",\n    zarr_format: Literal[2, 3] = 2,\n    other_array_kwargs: Mapping[str, Any] | None = None,\n    precision_scale: bool = True,\n) -&gt; ImagePyramidBuilder\n</code></pre> Source code in <code>ngio/common/_pyramid.py</code> <pre><code>@classmethod\ndef from_scaling_factors(\n    cls,\n    levels_paths: tuple[str, ...],\n    scaling_factors: tuple[float, ...],\n    base_shape: tuple[int, ...],\n    base_scale: tuple[float, ...],\n    axes: tuple[str, ...],\n    base_translation: Sequence[float] | None = None,\n    chunks: ChunksLike = \"auto\",\n    shards: ShardsLike | None = None,\n    data_type: str = \"uint16\",\n    dimension_separator: Literal[\".\", \"/\"] = \"/\",\n    compressors: Any = \"auto\",\n    zarr_format: Literal[2, 3] = 2,\n    other_array_kwargs: Mapping[str, Any] | None = None,\n    precision_scale: bool = True,\n) -&gt; \"ImagePyramidBuilder\":\n    # Since shapes needs to be rounded to integers, we compute them here\n    # and then pass them to from_shapes\n    # This ensures that the shapes and scaling factors are consistent\n    # and avoids accumulation of rounding errors\n    shapes = compute_shapes_from_scaling_factors(\n        base_shape=base_shape,\n        scaling_factors=scaling_factors,\n        num_levels=len(levels_paths),\n    )\n\n    if precision_scale:\n        # Compute precise scales from shapes\n        # Since shapes are rounded to integers, the scaling factors\n        # may not be exactly the same as the input scaling factors\n        # Thus, we compute the scales from the shapes to ensure consistency\n        base_scale_ = compute_scales_from_shapes(\n            shapes=shapes,\n            base_scale=base_scale,\n        )\n    else:\n        base_scale_ = _compute_scales_from_factors(\n            base_scale=base_scale,\n            scaling_factors=scaling_factors,\n            num_levels=len(levels_paths),\n        )\n\n    return cls.from_shapes(\n        shapes=shapes,\n        base_scale=base_scale_,\n        axes=axes,\n        base_translation=base_translation,\n        levels_paths=levels_paths,\n        chunks=chunks,\n        shards=shards,\n        data_type=data_type,\n        dimension_separator=dimension_separator,\n        compressors=compressors,\n        zarr_format=zarr_format,\n        other_array_kwargs=other_array_kwargs,\n    )\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.ImagePyramidBuilder.from_shapes","title":"from_shapes  <code>classmethod</code>","text":"<pre><code>from_shapes(\n    shapes: Sequence[tuple[int, ...]],\n    base_scale: tuple[float, ...] | list[tuple[float, ...]],\n    axes: tuple[str, ...],\n    base_translation: Sequence[float] | None = None,\n    levels_paths: Sequence[str] | None = None,\n    chunks: ChunksLike = \"auto\",\n    shards: ShardsLike | None = None,\n    data_type: str = \"uint16\",\n    dimension_separator: Literal[\".\", \"/\"] = \"/\",\n    compressors: Any = \"auto\",\n    zarr_format: Literal[2, 3] = 2,\n    other_array_kwargs: Mapping[str, Any] | None = None,\n) -&gt; ImagePyramidBuilder\n</code></pre> Source code in <code>ngio/common/_pyramid.py</code> <pre><code>@classmethod\ndef from_shapes(\n    cls,\n    shapes: Sequence[tuple[int, ...]],\n    base_scale: tuple[float, ...] | list[tuple[float, ...]],\n    axes: tuple[str, ...],\n    base_translation: Sequence[float] | None = None,\n    levels_paths: Sequence[str] | None = None,\n    chunks: ChunksLike = \"auto\",\n    shards: ShardsLike | None = None,\n    data_type: str = \"uint16\",\n    dimension_separator: Literal[\".\", \"/\"] = \"/\",\n    compressors: Any = \"auto\",\n    zarr_format: Literal[2, 3] = 2,\n    other_array_kwargs: Mapping[str, Any] | None = None,\n) -&gt; \"ImagePyramidBuilder\":\n    levels = []\n    if levels_paths is None:\n        levels_paths = tuple(str(i) for i in range(len(shapes)))\n\n    _check_order(shapes)\n    if isinstance(base_scale, tuple) and all(\n        isinstance(s, float) for s in base_scale\n    ):\n        scales = compute_scales_from_shapes(shapes, base_scale)\n    elif isinstance(base_scale, list):\n        scales = base_scale\n        if len(scales) != len(shapes):\n            raise NgioValueError(\n                \"Scales must have the same length as shapes \"\n                f\"({len(shapes)}), got {len(scales)}\"\n            )\n    else:\n        raise NgioValueError(\n            \"base_scale must be either a tuple of floats or a list of tuples \"\n            \" of floats.\"\n        )\n\n    translations = _compute_translations_from_shapes(scales, base_translation)\n    for level_path, shape, scale, translation in zip(\n        levels_paths,\n        shapes,\n        scales,\n        translations,\n        strict=True,\n    ):\n        level = PyramidLevel(\n            path=level_path,\n            shape=shape,\n            scale=scale,\n            translation=translation,\n            chunks=chunks,\n            shards=shards,\n        )\n        levels.append(level)\n    other_array_kwargs = other_array_kwargs or {}\n    return cls(\n        levels=levels,\n        axes=axes,\n        data_type=data_type,\n        dimension_separator=dimension_separator,\n        compressors=compressors,\n        zarr_format=zarr_format,\n        other_array_kwargs=other_array_kwargs,\n    )\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.ImagePyramidBuilder.to_zarr","title":"to_zarr","text":"<pre><code>to_zarr(group: Group) -&gt; None\n</code></pre> <p>Save the pyramid specification to a Zarr group.</p> <p>Parameters:</p> <ul> <li> <code>group</code>               (<code>Group</code>)           \u2013            <p>The Zarr group to save the pyramid specification to.</p> </li> </ul> Source code in <code>ngio/common/_pyramid.py</code> <pre><code>def to_zarr(self, group: zarr.Group) -&gt; None:\n    \"\"\"Save the pyramid specification to a Zarr group.\n\n    Args:\n        group (zarr.Group): The Zarr group to save the pyramid specification to.\n    \"\"\"\n    array_static_kwargs = {\n        \"dtype\": self.data_type,\n        \"overwrite\": True,\n        \"compressors\": self.compressors,\n        **self.other_array_kwargs,\n    }\n\n    if self.zarr_format == 2:\n        array_static_kwargs[\"chunk_key_encoding\"] = {\n            \"name\": \"v2\",\n            \"separator\": self.dimension_separator,\n        }\n    else:\n        array_static_kwargs[\"chunk_key_encoding\"] = {\n            \"name\": \"default\",\n            \"separator\": self.dimension_separator,\n        }\n        array_static_kwargs[\"dimension_names\"] = self.axes\n    for p_level in self.levels:\n        group.create_array(\n            name=p_level.path,\n            shape=tuple(p_level.shape),\n            chunks=p_level.chunks,\n            shards=p_level.shards,\n            **array_static_kwargs,\n        )\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Roi","title":"Roi","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/ngio/common/#ngio.common.Roi.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str | None\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Roi.slices","title":"slices  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>slices: list[RoiSlice] = Field(min_length=2)\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Roi.label","title":"label  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>label: int | None = Field(default=None, ge=0)\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Roi.space","title":"space  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>space: Literal['world', 'pixel'] = 'world'\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Roi.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(extra='allow')\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Roi.validate_no_duplicate_axes","title":"validate_no_duplicate_axes  <code>classmethod</code>","text":"<pre><code>validate_no_duplicate_axes(\n    v: list[RoiSlice],\n) -&gt; list[RoiSlice]\n</code></pre> Source code in <code>ngio/common/_roi.py</code> <pre><code>@field_validator(\"slices\")\n@classmethod\ndef validate_no_duplicate_axes(cls, v: list[RoiSlice]) -&gt; list[RoiSlice]:\n    axis_names = [s.axis_name for s in v]\n    if len(axis_names) != len(set(axis_names)):\n        raise NgioValueError(\"Roi slices must have unique axis names\")\n    return v\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Roi.from_values","title":"from_values  <code>classmethod</code>","text":"<pre><code>from_values(\n    slices: Mapping[\n        str,\n        float | tuple[float | None, float | None] | slice,\n    ],\n    name: str | None,\n    label: int | None = None,\n    space: Literal[\"world\", \"pixel\"] = \"world\",\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>ngio/common/_roi.py</code> <pre><code>@classmethod\ndef from_values(\n    cls,\n    slices: Mapping[str, float | tuple[float | None, float | None] | slice],\n    name: str | None,\n    label: int | None = None,\n    space: Literal[\"world\", \"pixel\"] = \"world\",\n    **kwargs,\n) -&gt; Self:\n    _slices = []\n    for axis, _slice in slices.items():\n        _slices.append(RoiSlice.from_value(axis_name=axis, value=_slice))\n    return cls.model_construct(\n        name=name, slices=_slices, label=label, space=space, **kwargs\n    )\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Roi.get","title":"get","text":"<pre><code>get(axis_name: str) -&gt; RoiSlice | None\n</code></pre> Source code in <code>ngio/common/_roi.py</code> <pre><code>def get(self, axis_name: str) -&gt; RoiSlice | None:\n    for roi_slice in self.slices:\n        if roi_slice.axis_name == axis_name:\n            return roi_slice\n    return None\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Roi.get_name","title":"get_name","text":"<pre><code>get_name() -&gt; str\n</code></pre> Source code in <code>ngio/common/_roi.py</code> <pre><code>def get_name(self) -&gt; str:\n    if self.name is not None:\n        return self.name\n    if self.label is not None:\n        return str(self.label)\n    return self._nice_repr__()\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Roi.intersection","title":"intersection","text":"<pre><code>intersection(other: Self) -&gt; Self | None\n</code></pre> Source code in <code>ngio/common/_roi.py</code> <pre><code>def intersection(self, other: Self) -&gt; Self | None:\n    if self.space != other.space:\n        raise NgioValueError(\n            \"Roi intersection failed: One ROI is in pixel space and the \"\n            \"other in world space\"\n        )\n\n    out_slices = self._apply_sym_ops(\n        self.slices, other.slices, op=lambda a, b: a.intersection(b)\n    )\n    if out_slices is None:\n        return None\n\n    name = _join_roi_names(self.name, other.name)\n    label = _join_roi_labels(self.label, other.label)\n    return self.model_copy(\n        update={\"name\": name, \"slices\": out_slices, \"label\": label}\n    )\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Roi.union","title":"union","text":"<pre><code>union(other: Self) -&gt; Self\n</code></pre> Source code in <code>ngio/common/_roi.py</code> <pre><code>def union(self, other: Self) -&gt; Self:\n    if self.space != other.space:\n        raise NgioValueError(\n            \"Roi union failed: One ROI is in pixel space and the \"\n            \"other in world space\"\n        )\n\n    out_slices = self._apply_sym_ops(\n        self.slices, other.slices, op=lambda a, b: a.union(b)\n    )\n    if out_slices is None:\n        raise NgioValueError(\"Roi union failed: could not compute union\")\n\n    name = _join_roi_names(self.name, other.name)\n    label = _join_roi_labels(self.label, other.label)\n    return self.model_copy(\n        update={\"name\": name, \"slices\": out_slices, \"label\": label}\n    )\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Roi.zoom","title":"zoom","text":"<pre><code>zoom(\n    zoom_factor: float = 1.0,\n    axes: tuple[str, ...] = (\"x\", \"y\"),\n) -&gt; Self\n</code></pre> Source code in <code>ngio/common/_roi.py</code> <pre><code>def zoom(\n    self, zoom_factor: float = 1.0, axes: tuple[str, ...] = (\"x\", \"y\")\n) -&gt; Self:\n    new_slices = []\n    for roi_slice in self.slices:\n        if roi_slice.axis_name in axes:\n            new_slices.append(roi_slice.zoom(zoom_factor=zoom_factor))\n        else:\n            new_slices.append(roi_slice)\n    return self.model_copy(update={\"slices\": new_slices})\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Roi.to_world","title":"to_world","text":"<pre><code>to_world(pixel_size: PixelSize | None = None) -&gt; Self\n</code></pre> Source code in <code>ngio/common/_roi.py</code> <pre><code>def to_world(self, pixel_size: PixelSize | None = None) -&gt; Self:\n    if self.space == \"world\":\n        return self.model_copy()\n    if pixel_size is None:\n        raise NgioValueError(\n            \"Pixel sizes must be provided to convert ROI from pixel to world\"\n        )\n    new_slices = []\n    for roi_slice in self.slices:\n        pixel_size_ = pixel_size.get(roi_slice.axis_name, default=1.0)\n        new_slices.append(roi_slice.to_world(pixel_size=pixel_size_))\n    return self.model_copy(update={\"slices\": new_slices, \"space\": \"world\"})\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Roi.to_pixel","title":"to_pixel","text":"<pre><code>to_pixel(pixel_size: PixelSize | None = None) -&gt; Self\n</code></pre> Source code in <code>ngio/common/_roi.py</code> <pre><code>def to_pixel(self, pixel_size: PixelSize | None = None) -&gt; Self:\n    if self.space == \"pixel\":\n        return self.model_copy()\n\n    if pixel_size is None:\n        raise NgioValueError(\n            \"Pixel sizes must be provided to convert ROI from world to pixel\"\n        )\n\n    new_slices = []\n    for roi_slice in self.slices:\n        pixel_size_ = pixel_size.get(roi_slice.axis_name, default=1.0)\n        new_slices.append(roi_slice.to_pixel(pixel_size=pixel_size_))\n    return self.model_copy(update={\"slices\": new_slices, \"space\": \"pixel\"})\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Roi.to_slicing_dict","title":"to_slicing_dict","text":"<pre><code>to_slicing_dict(\n    pixel_size: PixelSize | None = None,\n) -&gt; dict[str, slice]\n</code></pre> Source code in <code>ngio/common/_roi.py</code> <pre><code>def to_slicing_dict(self, pixel_size: PixelSize | None = None) -&gt; dict[str, slice]:\n    roi = self.to_pixel(pixel_size=pixel_size)\n    return {roi_slice.axis_name: roi_slice.to_slice() for roi_slice in roi.slices}\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.RoiSlice","title":"RoiSlice","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/ngio/common/#ngio.common.RoiSlice.axis_name","title":"axis_name  <code>instance-attribute</code>","text":"<pre><code>axis_name: str\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.RoiSlice.start","title":"start  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>start: float | None = Field(default=None)\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.RoiSlice.length","title":"length  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>length: float | None = Field(default=None, ge=0)\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.RoiSlice.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(extra='forbid')\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.RoiSlice.end","title":"end  <code>property</code>","text":"<pre><code>end: float | None\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.RoiSlice.from_value","title":"from_value  <code>classmethod</code>","text":"<pre><code>from_value(\n    axis_name: str,\n    value: float\n    | tuple[float | None, float | None]\n    | slice,\n) -&gt; RoiSlice\n</code></pre> Source code in <code>ngio/common/_roi.py</code> <pre><code>@classmethod\ndef from_value(\n    cls,\n    axis_name: str,\n    value: float | tuple[float | None, float | None] | slice,\n) -&gt; \"RoiSlice\":\n    if isinstance(value, slice):\n        return cls._from_slice(axis_name=axis_name, selection=value)\n    elif isinstance(value, tuple):\n        return cls(axis_name=axis_name, start=value[0], length=value[1])\n    elif isinstance(value, int | float):\n        return cls(axis_name=axis_name, start=value, length=1)\n    else:\n        raise TypeError(f\"Unsupported type for slice value: {type(value)}\")\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.RoiSlice.to_slice","title":"to_slice","text":"<pre><code>to_slice() -&gt; slice\n</code></pre> Source code in <code>ngio/common/_roi.py</code> <pre><code>def to_slice(self) -&gt; slice:\n    return slice(self.start, self.end)\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.RoiSlice.union","title":"union","text":"<pre><code>union(other: RoiSlice) -&gt; RoiSlice\n</code></pre> Source code in <code>ngio/common/_roi.py</code> <pre><code>def union(self, other: \"RoiSlice\") -&gt; \"RoiSlice\":\n    self._is_compatible(other, \"RoiSlice union failed\")\n    start = min(self.start or 0, other.start or 0)\n    end = max(self.end or float(\"inf\"), other.end or float(\"inf\"))\n    length = end - start if end &gt; start else 0\n    if length == float(\"inf\"):\n        length = None\n    return RoiSlice(axis_name=self.axis_name, start=start, length=length)\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.RoiSlice.intersection","title":"intersection","text":"<pre><code>intersection(other: RoiSlice) -&gt; RoiSlice | None\n</code></pre> Source code in <code>ngio/common/_roi.py</code> <pre><code>def intersection(self, other: \"RoiSlice\") -&gt; \"RoiSlice | None\":\n    self._is_compatible(other, \"RoiSlice intersection failed\")\n    start = max(self.start or 0, other.start or 0)\n    end = min(self.end or float(\"inf\"), other.end or float(\"inf\"))\n    if end &lt;= start:\n        # No intersection\n        return None\n    length = end - start\n    if length == float(\"inf\"):\n        length = None\n    return RoiSlice(axis_name=self.axis_name, start=start, length=length)\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.RoiSlice.to_world","title":"to_world","text":"<pre><code>to_world(pixel_size: float) -&gt; RoiSlice\n</code></pre> Source code in <code>ngio/common/_roi.py</code> <pre><code>def to_world(self, pixel_size: float) -&gt; \"RoiSlice\":\n    start = (\n        pixel_to_world(self.start, pixel_size) if self.start is not None else None\n    )\n    length = (\n        pixel_to_world(self.length, pixel_size) if self.length is not None else None\n    )\n    return RoiSlice(axis_name=self.axis_name, start=start, length=length)\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.RoiSlice.to_pixel","title":"to_pixel","text":"<pre><code>to_pixel(pixel_size: float) -&gt; RoiSlice\n</code></pre> Source code in <code>ngio/common/_roi.py</code> <pre><code>def to_pixel(self, pixel_size: float) -&gt; \"RoiSlice\":\n    start = (\n        world_to_pixel(self.start, pixel_size) if self.start is not None else None\n    )\n    length = (\n        world_to_pixel(self.length, pixel_size) if self.length is not None else None\n    )\n    return RoiSlice(axis_name=self.axis_name, start=start, length=length)\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.RoiSlice.zoom","title":"zoom","text":"<pre><code>zoom(zoom_factor: float = 1.0) -&gt; RoiSlice\n</code></pre> Source code in <code>ngio/common/_roi.py</code> <pre><code>def zoom(self, zoom_factor: float = 1.0) -&gt; \"RoiSlice\":\n    if zoom_factor &lt;= 0:\n        raise NgioValueError(\"Zoom factor must be greater than 0\")\n    zoom_factor -= 1.0\n    if self.length is None:\n        return self\n\n    diff_length = self.length * zoom_factor\n    length = self.length + diff_length\n    start = max((self.start or 0) - (diff_length / 2), 0)\n    return RoiSlice(axis_name=self.axis_name, start=start, length=length)\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.compute_masking_roi","title":"compute_masking_roi","text":"<pre><code>compute_masking_roi(\n    segmentation: ndarray | Array,\n    pixel_size: PixelSize,\n    axes_order: Sequence[str],\n) -&gt; list[Roi]\n</code></pre> <p>Compute ROIs for each label in a segmentation.</p> <p>This function expects a 2D, 3D, or 4D segmentation array. The axes order should match the segmentation dimensions.</p> <p>Parameters:</p> <ul> <li> <code>segmentation</code>               (<code>ndarray | Array</code>)           \u2013            <p>The segmentation array (2D, 3D, or 4D).</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize</code>)           \u2013            <p>The pixel size metadata for coordinate conversion.</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str]</code>)           \u2013            <p>The order of axes in the segmentation (e.g., 'zyx' or 'yx').</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Roi]</code>           \u2013            <p>A list of Roi objects, one for each unique label in the segmentation.</p> </li> </ul> Source code in <code>ngio/common/_masking_roi.py</code> <pre><code>def compute_masking_roi(\n    segmentation: np.ndarray | da.Array,\n    pixel_size: PixelSize,\n    axes_order: Sequence[str],\n) -&gt; list[Roi]:\n    \"\"\"Compute ROIs for each label in a segmentation.\n\n    This function expects a 2D, 3D, or 4D segmentation array.\n    The axes order should match the segmentation dimensions.\n\n    Args:\n        segmentation: The segmentation array (2D, 3D, or 4D).\n        pixel_size: The pixel size metadata for coordinate conversion.\n        axes_order: The order of axes in the segmentation (e.g., 'zyx' or 'yx').\n\n    Returns:\n        A list of Roi objects, one for each unique label in the segmentation.\n    \"\"\"\n    if segmentation.ndim not in [2, 3, 4]:\n        raise NgioValueError(\"Only 2D, 3D, and 4D segmentations are supported.\")\n\n    if len(axes_order) != segmentation.ndim:\n        raise NgioValueError(\n            \"The length of axes_order must match the number of dimensions \"\n            \"of the segmentation.\"\n        )\n\n    if isinstance(segmentation, da.Array):\n        slices = lazy_compute_slices(segmentation)\n    else:\n        slices = compute_slices(segmentation)\n\n    rois = []\n    for label, slice_ in slices.items():\n        assert len(slice_) == len(axes_order)\n        slices = dict(zip(axes_order, slice_, strict=True))\n        roi = Roi.from_values(\n            name=str(label), slices=slices, label=label, space=\"pixel\"\n        )\n        roi = roi.to_world(pixel_size=pixel_size)\n        rois.append(roi)\n    return rois\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.consolidate_pyramid","title":"consolidate_pyramid","text":"<pre><code>consolidate_pyramid(\n    source: Array,\n    targets: list[Array],\n    order: InterpolationOrder = \"linear\",\n    mode: Literal[\"dask\", \"numpy\", \"coarsen\"] = \"dask\",\n) -&gt; None\n</code></pre> <p>Consolidate the Zarr array.</p> Source code in <code>ngio/common/_pyramid.py</code> <pre><code>def consolidate_pyramid(\n    source: zarr.Array,\n    targets: list[zarr.Array],\n    order: InterpolationOrder = \"linear\",\n    mode: Literal[\"dask\", \"numpy\", \"coarsen\"] = \"dask\",\n) -&gt; None:\n    \"\"\"Consolidate the Zarr array.\"\"\"\n    processed = [source]\n    to_be_processed = targets\n\n    while to_be_processed:\n        source_id, target_id = _find_closest_arrays(processed, to_be_processed)\n\n        source_image = processed[source_id]\n        target_image = to_be_processed.pop(target_id)\n\n        on_disk_zoom(\n            source=source_image,\n            target=target_image,\n            mode=mode,\n            order=order,\n        )\n        processed.append(target_image)\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.on_disk_zoom","title":"on_disk_zoom","text":"<pre><code>on_disk_zoom(\n    source: Array,\n    target: Array,\n    order: InterpolationOrder = \"linear\",\n    mode: Literal[\"dask\", \"numpy\", \"coarsen\"] = \"dask\",\n) -&gt; None\n</code></pre> <p>Apply a zoom operation from a source zarr array to a target zarr array.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>Array</code>)           \u2013            <p>The source array to zoom.</p> </li> <li> <code>target</code>               (<code>Array</code>)           \u2013            <p>The target array to save the zoomed result to.</p> </li> <li> <code>order</code>               (<code>InterpolationOrder</code>, default:                   <code>'linear'</code> )           \u2013            <p>The order of interpolation. Defaults to \"linear\".</p> </li> <li> <code>mode</code>               (<code>Literal['dask', 'numpy', 'coarsen']</code>, default:                   <code>'dask'</code> )           \u2013            <p>The mode to use. Defaults to \"dask\".</p> </li> </ul> Source code in <code>ngio/common/_pyramid.py</code> <pre><code>def on_disk_zoom(\n    source: zarr.Array,\n    target: zarr.Array,\n    order: InterpolationOrder = \"linear\",\n    mode: Literal[\"dask\", \"numpy\", \"coarsen\"] = \"dask\",\n) -&gt; None:\n    \"\"\"Apply a zoom operation from a source zarr array to a target zarr array.\n\n    Args:\n        source (zarr.Array): The source array to zoom.\n        target (zarr.Array): The target array to save the zoomed result to.\n        order (InterpolationOrder): The order of interpolation. Defaults to \"linear\".\n        mode (Literal[\"dask\", \"numpy\", \"coarsen\"]): The mode to use. Defaults to \"dask\".\n    \"\"\"\n    if not isinstance(source, zarr.Array):\n        raise NgioValueError(\"source must be a zarr array\")\n\n    if not isinstance(target, zarr.Array):\n        raise NgioValueError(\"target must be a zarr array\")\n\n    if source.dtype != target.dtype:\n        raise NgioValueError(\"source and target must have the same dtype\")\n\n    match mode:\n        case \"numpy\":\n            return _on_disk_numpy_zoom(source, target, order)\n        case \"dask\":\n            return _on_disk_dask_zoom(source, target, order)\n        case \"coarsen\":\n            return _on_disk_coarsen(\n                source,\n                target,\n            )\n        case _:\n            raise NgioValueError(\"mode must be either 'dask', 'numpy' or 'coarsen'\")\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.dask_zoom","title":"dask_zoom","text":"<pre><code>dask_zoom(\n    source_array: Array,\n    scale: tuple[float | int, ...] | None = None,\n    target_shape: tuple[int, ...] | None = None,\n    order: InterpolationOrder = \"linear\",\n) -&gt; Array\n</code></pre> <p>Dask implementation of zooming an array.</p> <p>Only one of scale or target_shape must be provided.</p> <p>Parameters:</p> <ul> <li> <code>source_array</code>               (<code>Array</code>)           \u2013            <p>The source array to zoom.</p> </li> <li> <code>scale</code>               (<code>tuple[int, ...] | None</code>, default:                   <code>None</code> )           \u2013            <p>The scale factor to zoom by.</p> </li> <li> <code>target_shape</code>               (<code>(tuple[int, ...], None)</code>, default:                   <code>None</code> )           \u2013            <p>The target shape to zoom to.</p> </li> <li> <code>order</code>               (<code>Literal['nearest', 'linear', 'cubic']</code>, default:                   <code>'linear'</code> )           \u2013            <p>The order of interpolation. Defaults to \"linear\".</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array</code>           \u2013            <p>da.Array: The zoomed array.</p> </li> </ul> Source code in <code>ngio/common/_zoom.py</code> <pre><code>def dask_zoom(\n    source_array: da.Array,\n    scale: tuple[float | int, ...] | None = None,\n    target_shape: tuple[int, ...] | None = None,\n    order: InterpolationOrder = \"linear\",\n) -&gt; da.Array:\n    \"\"\"Dask implementation of zooming an array.\n\n    Only one of scale or target_shape must be provided.\n\n    Args:\n        source_array (da.Array): The source array to zoom.\n        scale (tuple[int, ...] | None): The scale factor to zoom by.\n        target_shape (tuple[int, ...], None): The target shape to zoom to.\n        order (Literal[\"nearest\", \"linear\", \"cubic\"]): The order of interpolation.\n            Defaults to \"linear\".\n\n    Returns:\n        da.Array: The zoomed array.\n    \"\"\"\n    # This function follow the implementation from:\n    # https://github.com/ome/ome-zarr-py/blob/master/ome_zarr/dask_utils.py\n    # The module was contributed by Andreas Eisenbarth @aeisenbarth\n    # See https://github.com/toloudis/ome-zarr-py/pull/\n    _scale, _target_shape = _zoom_inputs_check(\n        source_array=source_array, scale=scale, target_shape=target_shape\n    )\n\n    # Rechunk to better match the scaling operation\n    source_chunks = np.array(source_array.chunksize)  # type: ignore (da.Array.chunksize is a tuple of ints)\n    better_source_chunks = np.maximum(1, np.round(source_chunks * _scale) / _scale)\n    better_source_chunks = better_source_chunks.astype(int)\n    source_array = source_array.rechunk(better_source_chunks)  # type: ignore (better_source_chunks is a valid input for rechunk)\n\n    # Calculate the block output shape\n    block_output_shape = tuple(np.ceil(better_source_chunks * _scale).astype(int))\n\n    zoom_wrapper = partial(\n        fast_zoom,\n        zoom=_scale,\n        order=order_to_int(order),\n        mode=\"grid-constant\",\n        grid_mode=True,\n    )\n\n    out_array = da.map_blocks(\n        zoom_wrapper, source_array, chunks=block_output_shape, dtype=source_array.dtype\n    )\n\n    # Slice and rechunk to target\n    slices = tuple(slice(0, ts, 1) for ts in _target_shape)\n    out_array = out_array[slices]\n    return out_array\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.numpy_zoom","title":"numpy_zoom","text":"<pre><code>numpy_zoom(\n    source_array: ndarray,\n    scale: tuple[int | float, ...] | None = None,\n    target_shape: tuple[int, ...] | None = None,\n    order: InterpolationOrder = \"linear\",\n) -&gt; ndarray\n</code></pre> <p>Numpy implementation of zooming an array.</p> <p>Only one of scale or target_shape must be provided.</p> <p>Parameters:</p> <ul> <li> <code>source_array</code>               (<code>ndarray</code>)           \u2013            <p>The source array to zoom.</p> </li> <li> <code>scale</code>               (<code>tuple[int, ...] | None</code>, default:                   <code>None</code> )           \u2013            <p>The scale factor to zoom by.</p> </li> <li> <code>target_shape</code>               (<code>(tuple[int, ...], None)</code>, default:                   <code>None</code> )           \u2013            <p>The target shape to zoom to.</p> </li> <li> <code>order</code>               (<code>Literal[0, 1, 2]</code>, default:                   <code>'linear'</code> )           \u2013            <p>The order of interpolation. Defaults to 1.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: The zoomed array</p> </li> </ul> Source code in <code>ngio/common/_zoom.py</code> <pre><code>def numpy_zoom(\n    source_array: np.ndarray,\n    scale: tuple[int | float, ...] | None = None,\n    target_shape: tuple[int, ...] | None = None,\n    order: InterpolationOrder = \"linear\",\n) -&gt; np.ndarray:\n    \"\"\"Numpy implementation of zooming an array.\n\n    Only one of scale or target_shape must be provided.\n\n    Args:\n        source_array (np.ndarray): The source array to zoom.\n        scale (tuple[int, ...] | None): The scale factor to zoom by.\n        target_shape (tuple[int, ...], None): The target shape to zoom to.\n        order (Literal[0, 1, 2]): The order of interpolation. Defaults to 1.\n\n    Returns:\n        np.ndarray: The zoomed array\n    \"\"\"\n    _scale, _ = _zoom_inputs_check(\n        source_array=source_array, scale=scale, target_shape=target_shape\n    )\n\n    out_array = fast_zoom(\n        source_array,\n        zoom=_scale,\n        order=order_to_int(order),\n        mode=\"grid-constant\",\n        grid_mode=True,\n    )\n    assert isinstance(out_array, np.ndarray)\n    return out_array\n</code></pre>"},{"location":"api/ngio/hcs/","title":"ngio.hcs API documentation","text":""},{"location":"api/ngio/hcs/#ngio.hcs","title":"ngio.hcs","text":"<p>OME-Zarr HCS objects models.</p>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate","title":"OmeZarrPlate","text":"<pre><code>OmeZarrPlate(\n    group_handler: ZarrGroupHandler,\n    table_container: TablesContainer | None = None,\n)\n</code></pre> <p>A class to handle the Plate Sequence in an OME-Zarr file.</p> <p>Initialize the LabelGroupHandler.</p> <p>Parameters:</p> <ul> <li> <code>group_handler</code>               (<code>ZarrGroupHandler</code>)           \u2013            <p>The Zarr group handler that contains the Plate.</p> </li> <li> <code>table_container</code>               (<code>TablesContainer | None</code>, default:                   <code>None</code> )           \u2013            <p>The tables container that contains plate level tables.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def __init__(\n    self,\n    group_handler: ZarrGroupHandler,\n    table_container: TablesContainer | None = None,\n) -&gt; None:\n    \"\"\"Initialize the LabelGroupHandler.\n\n    Args:\n        group_handler: The Zarr group handler that contains the Plate.\n        table_container: The tables container that contains plate level tables.\n    \"\"\"\n    self._group_handler = group_handler\n    self._meta_handler = PlateMetaHandler(group_handler)\n    self._tables_container = table_container\n    self._wells_cache: NgioCache[OmeZarrWell] = NgioCache(\n        use_cache=self._group_handler.use_cache\n    )\n    self._images_cache: NgioCache[OmeZarrContainer] = NgioCache(\n        use_cache=self._group_handler.use_cache\n    )\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.meta_handler","title":"meta_handler  <code>property</code>","text":"<pre><code>meta_handler\n</code></pre> <p>Return the metadata handler.</p>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.meta","title":"meta  <code>property</code>","text":"<pre><code>meta\n</code></pre> <p>Return the metadata.</p>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.columns","title":"columns  <code>property</code>","text":"<pre><code>columns: list[str]\n</code></pre> <p>Return the number of columns in the plate.</p>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.rows","title":"rows  <code>property</code>","text":"<pre><code>rows: list[str]\n</code></pre> <p>Return the number of rows in the plate.</p>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.acquisitions_names","title":"acquisitions_names  <code>property</code>","text":"<pre><code>acquisitions_names: list[str | None]\n</code></pre> <p>Return the acquisitions in the plate.</p>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.acquisition_ids","title":"acquisition_ids  <code>property</code>","text":"<pre><code>acquisition_ids: list[int]\n</code></pre> <p>Return the acquisitions ids in the plate.</p>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.tables_container","title":"tables_container  <code>property</code>","text":"<pre><code>tables_container: TablesContainer\n</code></pre> <p>Return the tables container.</p>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.wells_paths","title":"wells_paths","text":"<pre><code>wells_paths() -&gt; list[str]\n</code></pre> <p>Return the wells paths in the plate.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def wells_paths(self) -&gt; list[str]:\n    \"\"\"Return the wells paths in the plate.\"\"\"\n    return self.meta.wells_paths\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.images_paths_async","title":"images_paths_async  <code>async</code>","text":"<pre><code>images_paths_async(\n    acquisition: int | None = None,\n) -&gt; list[str]\n</code></pre> <p>Return the images paths in the plate asynchronously.</p> <p>If acquisition is None, return all images paths in the plate. Else, return the images paths in the plate for the given acquisition.</p> <p>Parameters:</p> <ul> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>async def images_paths_async(self, acquisition: int | None = None) -&gt; list[str]:\n    \"\"\"Return the images paths in the plate asynchronously.\n\n    If acquisition is None, return all images paths in the plate.\n    Else, return the images paths in the plate for the given acquisition.\n\n    Args:\n        acquisition (int | None): The acquisition id to filter the images.\n    \"\"\"\n    wells = await self.get_wells_async()\n    paths = []\n    for well_path, well in wells.items():\n        for img_path in well.paths(acquisition):\n            paths.append(f\"{well_path}/{img_path}\")\n    return paths\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.images_paths","title":"images_paths","text":"<pre><code>images_paths(acquisition: int | None = None) -&gt; list[str]\n</code></pre> <p>Return the images paths in the plate.</p> <p>If acquisition is None, return all images paths in the plate. Else, return the images paths in the plate for the given acquisition.</p> <p>Parameters:</p> <ul> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def images_paths(self, acquisition: int | None = None) -&gt; list[str]:\n    \"\"\"Return the images paths in the plate.\n\n    If acquisition is None, return all images paths in the plate.\n    Else, return the images paths in the plate for the given acquisition.\n\n    Args:\n        acquisition (int | None): The acquisition id to filter the images.\n    \"\"\"\n    wells = self.get_wells()\n    images = []\n    for well_path, well in wells.items():\n        for img_path in well.paths(acquisition):\n            images.append(f\"{well_path}/{img_path}\")\n    return images\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.well_images_paths","title":"well_images_paths","text":"<pre><code>well_images_paths(\n    row: str,\n    column: int | str,\n    acquisition: int | None = None,\n) -&gt; list[str]\n</code></pre> <p>Return the images paths in a well.</p> <p>If acquisition is None, return all images paths in the well. Else, return the images paths in the well for the given acquisition.</p> <p>Parameters:</p> <ul> <li> <code>row</code>               (<code>str</code>)           \u2013            <p>The row of the well.</p> </li> <li> <code>column</code>               (<code>int | str</code>)           \u2013            <p>The column of the well.</p> </li> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def well_images_paths(\n    self, row: str, column: int | str, acquisition: int | None = None\n) -&gt; list[str]:\n    \"\"\"Return the images paths in a well.\n\n    If acquisition is None, return all images paths in the well.\n    Else, return the images paths in the well for the given acquisition.\n\n    Args:\n        row (str): The row of the well.\n        column (int | str): The column of the well.\n        acquisition (int | None): The acquisition id to filter the images.\n    \"\"\"\n    images = []\n    well = self.get_well(row=row, column=column)\n    for path in well.paths(acquisition):\n        images.append(self._image_path(row=row, column=column, path=path))\n    return images\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.get_image_acquisition_id","title":"get_image_acquisition_id","text":"<pre><code>get_image_acquisition_id(\n    row: str, column: int | str, image_path: str\n) -&gt; int | None\n</code></pre> <p>Get the acquisition id of an image in a well.</p> <p>Parameters:</p> <ul> <li> <code>row</code>               (<code>str</code>)           \u2013            <p>The row of the well.</p> </li> <li> <code>column</code>               (<code>int | str</code>)           \u2013            <p>The column of the well.</p> </li> <li> <code>image_path</code>               (<code>str</code>)           \u2013            <p>The path of the image.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int | None</code>           \u2013            <p>int | None: The acquisition id of the image.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_image_acquisition_id(\n    self, row: str, column: int | str, image_path: str\n) -&gt; int | None:\n    \"\"\"Get the acquisition id of an image in a well.\n\n    Args:\n        row (str): The row of the well.\n        column (int | str): The column of the well.\n        image_path (str): The path of the image.\n\n    Returns:\n        int | None: The acquisition id of the image.\n    \"\"\"\n    well = self.get_well(row=row, column=column)\n    return well.get_image_acquisition_id(image_path=image_path)\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.get_well","title":"get_well","text":"<pre><code>get_well(row: str, column: int | str) -&gt; OmeZarrWell\n</code></pre> <p>Get a well from the plate.</p> <p>Parameters:</p> <ul> <li> <code>row</code>               (<code>str</code>)           \u2013            <p>The row of the well.</p> </li> <li> <code>column</code>               (<code>int | str</code>)           \u2013            <p>The column of the well.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OmeZarrWell</code> (              <code>OmeZarrWell</code> )          \u2013            <p>The well.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_well(self, row: str, column: int | str) -&gt; OmeZarrWell:\n    \"\"\"Get a well from the plate.\n\n    Args:\n        row (str): The row of the well.\n        column (int | str): The column of the well.\n\n    Returns:\n        OmeZarrWell: The well.\n    \"\"\"\n    well_path = self._well_path(row=row, column=column)\n    return self._get_well(well_path=well_path)\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.get_wells_async","title":"get_wells_async  <code>async</code>","text":"<pre><code>get_wells_async() -&gt; dict[str, OmeZarrWell]\n</code></pre> <p>Get all wells in the plate asynchronously.</p> <p>This method processes wells in parallel for improved performance when working with a large number of wells.</p> <p>Returns:</p> <ul> <li> <code>dict[str, OmeZarrWell]</code>           \u2013            <p>dict[str, OmeZarrWell]: A dictionary of wells, where the key is the well path and the value is the well object.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>async def get_wells_async(self) -&gt; dict[str, OmeZarrWell]:\n    \"\"\"Get all wells in the plate asynchronously.\n\n    This method processes wells in parallel for improved performance\n    when working with a large number of wells.\n\n    Returns:\n        dict[str, OmeZarrWell]: A dictionary of wells, where the key is the well\n            path and the value is the well object.\n    \"\"\"\n    wells, tasks = {}, []\n    for well_path in self.wells_paths():\n        task = asyncio.to_thread(\n            lambda well_path: (well_path, self._get_well(well_path)), well_path\n        )\n        tasks.append(task)\n\n    results = await asyncio.gather(*tasks)\n    for well_path, well in results:\n        wells[well_path] = well\n\n    return wells\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.get_wells","title":"get_wells","text":"<pre><code>get_wells() -&gt; dict[str, OmeZarrWell]\n</code></pre> <p>Get all wells in the plate.</p> <p>Returns:</p> <ul> <li> <code>dict[str, OmeZarrWell]</code>           \u2013            <p>dict[str, OmeZarrWell]: A dictionary of wells, where the key is the well path and the value is the well object.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_wells(self) -&gt; dict[str, OmeZarrWell]:\n    \"\"\"Get all wells in the plate.\n\n    Returns:\n        dict[str, OmeZarrWell]: A dictionary of wells, where the key is the well\n            path and the value is the well object.\n    \"\"\"\n    wells = {}\n    for well_path in self.wells_paths():\n        wells[well_path] = self._get_well(well_path)\n    return wells\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.get_images_async","title":"get_images_async  <code>async</code>","text":"<pre><code>get_images_async(\n    acquisition: int | None = None,\n) -&gt; dict[str, OmeZarrContainer]\n</code></pre> <p>Get all images in the plate asynchronously.</p> <p>This method processes images in parallel for improved performance when working with a large number of images.</p> <p>Parameters:</p> <ul> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, OmeZarrContainer]</code>           \u2013            <p>dict[str, OmeZarrContainer]: A dictionary of images, where the key is the image path and the value is the image object.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>async def get_images_async(\n    self, acquisition: int | None = None\n) -&gt; dict[str, OmeZarrContainer]:\n    \"\"\"Get all images in the plate asynchronously.\n\n    This method processes images in parallel for improved performance\n    when working with a large number of images.\n\n    Args:\n        acquisition: The acquisition id to filter the images.\n\n    Returns:\n        dict[str, OmeZarrContainer]: A dictionary of images, where the key is the\n            image path and the value is the image object.\n    \"\"\"\n    paths = await self.images_paths_async(acquisition=acquisition)\n\n    images, tasks = {}, []\n    for image_path in paths:\n        task = asyncio.to_thread(\n            lambda image_path: (image_path, self._get_image(image_path)), image_path\n        )\n        tasks.append(task)\n\n    results = await asyncio.gather(*tasks)\n\n    for image_path, image in results:\n        images[image_path] = image\n    return images\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.get_images","title":"get_images","text":"<pre><code>get_images(\n    acquisition: int | None = None,\n) -&gt; dict[str, OmeZarrContainer]\n</code></pre> <p>Get all images in the plate.</p> <p>Parameters:</p> <ul> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_images(self, acquisition: int | None = None) -&gt; dict[str, OmeZarrContainer]:\n    \"\"\"Get all images in the plate.\n\n    Args:\n        acquisition: The acquisition id to filter the images.\n    \"\"\"\n    paths = self.images_paths(acquisition=acquisition)\n    images = {}\n    for image_path in paths:\n        images[image_path] = self._get_image(image_path)\n\n    return images\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.get_image","title":"get_image","text":"<pre><code>get_image(\n    row: str, column: int | str, image_path: str\n) -&gt; OmeZarrContainer\n</code></pre> <p>Get an image from the plate.</p> <p>Parameters:</p> <ul> <li> <code>row</code>               (<code>str</code>)           \u2013            <p>The row of the well.</p> </li> <li> <code>column</code>               (<code>int | str</code>)           \u2013            <p>The column of the well.</p> </li> <li> <code>image_path</code>               (<code>str</code>)           \u2013            <p>The path of the image.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OmeZarrContainer</code> (              <code>OmeZarrContainer</code> )          \u2013            <p>The image.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_image(\n    self, row: str, column: int | str, image_path: str\n) -&gt; OmeZarrContainer:\n    \"\"\"Get an image from the plate.\n\n    Args:\n        row (str): The row of the well.\n        column (int | str): The column of the well.\n        image_path (str): The path of the image.\n\n    Returns:\n        OmeZarrContainer: The image.\n    \"\"\"\n    image_path = self._image_path(row=row, column=column, path=image_path)\n    return self._get_image(image_path)\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.get_image_store","title":"get_image_store","text":"<pre><code>get_image_store(\n    row: str, column: int | str, image_path: str\n) -&gt; StoreOrGroup\n</code></pre> <p>Get the image store from the plate.</p> <p>Parameters:</p> <ul> <li> <code>row</code>               (<code>str</code>)           \u2013            <p>The row of the well.</p> </li> <li> <code>column</code>               (<code>int | str</code>)           \u2013            <p>The column of the well.</p> </li> <li> <code>image_path</code>               (<code>str</code>)           \u2013            <p>The path of the image.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_image_store(\n    self, row: str, column: int | str, image_path: str\n) -&gt; StoreOrGroup:\n    \"\"\"Get the image store from the plate.\n\n    Args:\n        row (str): The row of the well.\n        column (int | str): The column of the well.\n        image_path (str): The path of the image.\n    \"\"\"\n    well = self.get_well(row=row, column=column)\n    return well.get_image_store(image_path=image_path)\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.get_well_images","title":"get_well_images","text":"<pre><code>get_well_images(\n    row: str,\n    column: str | int,\n    acquisition: int | None = None,\n) -&gt; dict[str, OmeZarrContainer]\n</code></pre> <p>Get all images in a well.</p> <p>Parameters:</p> <ul> <li> <code>row</code>               (<code>str</code>)           \u2013            <p>The row of the well.</p> </li> <li> <code>column</code>               (<code>str | int</code>)           \u2013            <p>The column of the well.</p> </li> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_well_images(\n    self, row: str, column: str | int, acquisition: int | None = None\n) -&gt; dict[str, OmeZarrContainer]:\n    \"\"\"Get all images in a well.\n\n    Args:\n        row: The row of the well.\n        column: The column of the well.\n        acquisition: The acquisition id to filter the images.\n    \"\"\"\n    images = {}\n    for image_paths in self.well_images_paths(\n        row=row, column=column, acquisition=acquisition\n    ):\n        group_handler = self._group_handler.get_handler(image_paths)\n        images[image_paths] = OmeZarrContainer(group_handler)\n    return images\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.atomic_add_image","title":"atomic_add_image","text":"<pre><code>atomic_add_image(\n    row: str,\n    column: int | str,\n    image_path: str,\n    acquisition_id: int | None = None,\n    acquisition_name: str | None = None,\n) -&gt; str\n</code></pre> <p>Parallel safe version of add_image.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def atomic_add_image(\n    self,\n    row: str,\n    column: int | str,\n    image_path: str,\n    acquisition_id: int | None = None,\n    acquisition_name: str | None = None,\n) -&gt; str:\n    \"\"\"Parallel safe version of add_image.\"\"\"\n    if image_path is None:\n        raise ValueError(\n            \"Image path cannot be None for atomic add_image. \"\n            \"If your intent is to add a well, use add_well instead.\"\n        )\n    path = self._add_image(\n        row=row,\n        column=column,\n        image_path=image_path,\n        acquisition_id=acquisition_id,\n        acquisition_name=acquisition_name,\n        atomic=True,\n    )\n    return path\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.add_image","title":"add_image","text":"<pre><code>add_image(\n    row: str,\n    column: int | str,\n    image_path: str,\n    acquisition_id: int | None = None,\n    acquisition_name: str | None = None,\n) -&gt; str\n</code></pre> <p>Add an image to an ome-zarr plate.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def add_image(\n    self,\n    row: str,\n    column: int | str,\n    image_path: str,\n    acquisition_id: int | None = None,\n    acquisition_name: str | None = None,\n) -&gt; str:\n    \"\"\"Add an image to an ome-zarr plate.\"\"\"\n    if image_path is None:\n        raise ValueError(\n            \"Image path cannot be None for atomic add_image. \"\n            \"If your intent is to add a well, use add_well instead.\"\n        )\n    path = self._add_image(\n        row=row,\n        column=column,\n        image_path=image_path,\n        acquisition_id=acquisition_id,\n        acquisition_name=acquisition_name,\n        atomic=False,\n    )\n    return path\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.add_well","title":"add_well","text":"<pre><code>add_well(row: str, column: int | str) -&gt; OmeZarrWell\n</code></pre> <p>Add a well to an ome-zarr plate.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def add_well(\n    self,\n    row: str,\n    column: int | str,\n) -&gt; OmeZarrWell:\n    \"\"\"Add a well to an ome-zarr plate.\"\"\"\n    _ = self._add_image(\n        row=row,\n        column=column,\n        image_path=None,\n        acquisition_id=None,\n        acquisition_name=None,\n        atomic=False,\n    )\n    return self.get_well(row=row, column=column)\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.add_column","title":"add_column","text":"<pre><code>add_column(column: int | str) -&gt; OmeZarrPlate\n</code></pre> <p>Add a column to an ome-zarr plate.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def add_column(\n    self,\n    column: int | str,\n) -&gt; \"OmeZarrPlate\":\n    \"\"\"Add a column to an ome-zarr plate.\"\"\"\n    meta, _ = self.meta.add_column(column)\n    self.meta_handler.update_meta(meta)\n    self.meta_handler._group_handler.clean_cache()\n    return self\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.add_row","title":"add_row","text":"<pre><code>add_row(row: str) -&gt; OmeZarrPlate\n</code></pre> <p>Add a row to an ome-zarr plate.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def add_row(\n    self,\n    row: str,\n) -&gt; \"OmeZarrPlate\":\n    \"\"\"Add a row to an ome-zarr plate.\"\"\"\n    meta, _ = self.meta.add_row(row)\n    self.meta_handler.update_meta(meta)\n    self.meta_handler._group_handler.clean_cache()\n    return self\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.add_acquisition","title":"add_acquisition","text":"<pre><code>add_acquisition(\n    acquisition_id: int, acquisition_name: str\n) -&gt; OmeZarrPlate\n</code></pre> <p>Add an acquisition to an ome-zarr plate.</p> <p>Be aware that this is not a parallel safe operation.</p> <p>Parameters:</p> <ul> <li> <code>acquisition_id</code>               (<code>int</code>)           \u2013            <p>The acquisition id.</p> </li> <li> <code>acquisition_name</code>               (<code>str</code>)           \u2013            <p>The acquisition name.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def add_acquisition(\n    self,\n    acquisition_id: int,\n    acquisition_name: str,\n) -&gt; \"OmeZarrPlate\":\n    \"\"\"Add an acquisition to an ome-zarr plate.\n\n    Be aware that this is not a parallel safe operation.\n\n    Args:\n        acquisition_id (int): The acquisition id.\n        acquisition_name (str): The acquisition name.\n    \"\"\"\n    meta = self.meta.add_acquisition(\n        acquisition_id=acquisition_id, acquisition_name=acquisition_name\n    )\n    self.meta_handler.update_meta(meta)\n    self.meta_handler._group_handler.clean_cache()\n    return self\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.atomic_remove_image","title":"atomic_remove_image","text":"<pre><code>atomic_remove_image(\n    row: str, column: int | str, image_path: str\n)\n</code></pre> <p>Parallel safe version of remove_image.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def atomic_remove_image(\n    self,\n    row: str,\n    column: int | str,\n    image_path: str,\n):\n    \"\"\"Parallel safe version of remove_image.\"\"\"\n    return self._remove_image(\n        row=row,\n        column=column,\n        image_path=image_path,\n        atomic=True,\n    )\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.remove_image","title":"remove_image","text":"<pre><code>remove_image(row: str, column: int | str, image_path: str)\n</code></pre> <p>Remove an image from an ome-zarr plate.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def remove_image(\n    self,\n    row: str,\n    column: int | str,\n    image_path: str,\n):\n    \"\"\"Remove an image from an ome-zarr plate.\"\"\"\n    return self._remove_image(\n        row=row,\n        column=column,\n        image_path=image_path,\n        atomic=False,\n    )\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.derive_plate","title":"derive_plate","text":"<pre><code>derive_plate(\n    store: StoreOrGroup,\n    plate_name: str | None = None,\n    version: NgffVersions | None = None,\n    ngff_version: NgffVersions = DefaultNgffVersion,\n    keep_acquisitions: bool = False,\n    cache: bool = False,\n    overwrite: bool = False,\n) -&gt; OmeZarrPlate\n</code></pre> <p>Derive a new OME-Zarr plate from an existing one.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group that stores the plate.</p> </li> <li> <code>plate_name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the new plate.</p> </li> <li> <code>version</code>               (<code>NgffVersion | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Please use 'ngff_version' instead.</p> </li> <li> <code>ngff_version</code>               (<code>NgffVersion</code>, default:                   <code>DefaultNgffVersion</code> )           \u2013            <p>The NGFF version to use for the new plate.</p> </li> <li> <code>keep_acquisitions</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to keep the acquisitions in the new plate.</p> </li> <li> <code>cache</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use a cache for the zarr group metadata.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to overwrite the existing plate.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def derive_plate(\n    self,\n    store: StoreOrGroup,\n    plate_name: str | None = None,\n    version: NgffVersions | None = None,\n    ngff_version: NgffVersions = DefaultNgffVersion,\n    keep_acquisitions: bool = False,\n    cache: bool = False,\n    overwrite: bool = False,\n) -&gt; \"OmeZarrPlate\":\n    \"\"\"Derive a new OME-Zarr plate from an existing one.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group that stores the plate.\n        plate_name (str | None): The name of the new plate.\n        version (NgffVersion | None): Deprecated. Please use 'ngff_version' instead.\n        ngff_version (NgffVersion): The NGFF version to use for the new plate.\n        keep_acquisitions (bool): Whether to keep the acquisitions in the new plate.\n        cache (bool): Whether to use a cache for the zarr group metadata.\n        overwrite (bool): Whether to overwrite the existing plate.\n    \"\"\"\n    return derive_ome_zarr_plate(\n        ome_zarr_plate=self,\n        store=store,\n        plate_name=plate_name,\n        ngff_version=ngff_version,\n        version=version,\n        keep_acquisitions=keep_acquisitions,\n        cache=cache,\n        overwrite=overwrite,\n    )\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.list_tables","title":"list_tables","text":"<pre><code>list_tables(\n    filter_types: TypedTable | str | None = None,\n) -&gt; list[str]\n</code></pre> <p>List all tables in the image.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def list_tables(self, filter_types: TypedTable | str | None = None) -&gt; list[str]:\n    \"\"\"List all tables in the image.\"\"\"\n    _tables_container = self._get_tables_container(create_mode=False)\n    if _tables_container is None:\n        return []\n    return self.tables_container.list(filter_types=filter_types)\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.list_roi_tables","title":"list_roi_tables","text":"<pre><code>list_roi_tables() -&gt; list[str]\n</code></pre> <p>List all ROI tables in the image.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def list_roi_tables(self) -&gt; list[str]:\n    \"\"\"List all ROI tables in the image.\"\"\"\n    roi = self.tables_container.list(\n        filter_types=\"roi_table\",\n    )\n    masking_roi = self.tables_container.list(\n        filter_types=\"masking_roi_table\",\n    )\n    return roi + masking_roi\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.get_roi_table","title":"get_roi_table","text":"<pre><code>get_roi_table(name: str) -&gt; RoiTable\n</code></pre> <p>Get a ROI table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_roi_table(self, name: str) -&gt; RoiTable:\n    \"\"\"Get a ROI table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, RoiTable):\n        raise NgioValueError(f\"Table {name} is not a ROI table. Got {type(table)}\")\n    return table\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.get_masking_roi_table","title":"get_masking_roi_table","text":"<pre><code>get_masking_roi_table(name: str) -&gt; MaskingRoiTable\n</code></pre> <p>Get a masking ROI table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_masking_roi_table(self, name: str) -&gt; MaskingRoiTable:\n    \"\"\"Get a masking ROI table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, MaskingRoiTable):\n        raise NgioValueError(\n            f\"Table {name} is not a masking ROI table. Got {type(table)}\"\n        )\n    return table\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.get_feature_table","title":"get_feature_table","text":"<pre><code>get_feature_table(name: str) -&gt; FeatureTable\n</code></pre> <p>Get a feature table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_feature_table(self, name: str) -&gt; FeatureTable:\n    \"\"\"Get a feature table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, FeatureTable):\n        raise NgioValueError(\n            f\"Table {name} is not a feature table. Got {type(table)}\"\n        )\n    return table\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.get_generic_roi_table","title":"get_generic_roi_table","text":"<pre><code>get_generic_roi_table(name: str) -&gt; GenericRoiTable\n</code></pre> <p>Get a generic ROI table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_generic_roi_table(self, name: str) -&gt; GenericRoiTable:\n    \"\"\"Get a generic ROI table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, GenericRoiTable):\n        raise NgioValueError(\n            f\"Table {name} is not a generic ROI table. Got {type(table)}\"\n        )\n    return table\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.get_condition_table","title":"get_condition_table","text":"<pre><code>get_condition_table(name: str) -&gt; ConditionTable\n</code></pre> <p>Get a condition table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_condition_table(self, name: str) -&gt; ConditionTable:\n    \"\"\"Get a condition table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, ConditionTable):\n        raise NgioValueError(\n            f\"Table {name} is not a condition table. Got {type(table)}\"\n        )\n    return table\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.get_table","title":"get_table","text":"<pre><code>get_table(\n    name: str, check_type: TypedTable | None = None\n) -&gt; Table\n</code></pre> <p>Get a table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> <li> <code>check_type</code>               (<code>TypedTable | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Please use 'get_table_as' instead, or one of the type specific get_*table() methods.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_table(self, name: str, check_type: TypedTable | None = None) -&gt; Table:\n    \"\"\"Get a table from the image.\n\n    Args:\n        name (str): The name of the table.\n        check_type (TypedTable | None): Deprecated. Please use\n            'get_table_as' instead, or one of the type specific\n            get_*table() methods.\n\n    \"\"\"\n    if check_type is not None:\n        logger.warning(\n            \"The 'check_type' argument is deprecated and will be removed in \"\n            \"ngio=0.6. Please use 'get_table_as' instead or one of the \"\n            \"type specific get_*table() methods.\"\n        )\n    return self.tables_container.get(name=name, strict=False)\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.get_table_as","title":"get_table_as","text":"<pre><code>get_table_as(\n    name: str,\n    table_cls: type[TableType],\n    backend: TableBackend | None = None,\n) -&gt; TableType\n</code></pre> <p>Get a table from the image as a specific type.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> <li> <code>table_cls</code>               (<code>type[TableType]</code>)           \u2013            <p>The type of the table.</p> </li> <li> <code>backend</code>               (<code>TableBackend | None</code>, default:                   <code>None</code> )           \u2013            <p>The backend to use. If None, the default backend is used.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_table_as(\n    self,\n    name: str,\n    table_cls: type[TableType],\n    backend: TableBackend | None = None,\n) -&gt; TableType:\n    \"\"\"Get a table from the image as a specific type.\n\n    Args:\n        name (str): The name of the table.\n        table_cls (type[TableType]): The type of the table.\n        backend (TableBackend | None): The backend to use. If None,\n            the default backend is used.\n    \"\"\"\n    return self.tables_container.get_as(\n        name=name,\n        table_cls=table_cls,\n        backend=backend,\n    )\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.add_table","title":"add_table","text":"<pre><code>add_table(\n    name: str,\n    table: Table,\n    backend: TableBackend = DefaultTableBackend,\n    overwrite: bool = False,\n) -&gt; None\n</code></pre> <p>Add a table to the image.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def add_table(\n    self,\n    name: str,\n    table: Table,\n    backend: TableBackend = DefaultTableBackend,\n    overwrite: bool = False,\n) -&gt; None:\n    \"\"\"Add a table to the image.\"\"\"\n    self.tables_container.add(\n        name=name, table=table, backend=backend, overwrite=overwrite\n    )\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.delete_table","title":"delete_table","text":"<pre><code>delete_table(name: str, missing_ok: bool = False) -&gt; None\n</code></pre> <p>Delete a table from the group.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table to delete.</p> </li> <li> <code>missing_ok</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, do not raise an error if the table does not exist.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def delete_table(self, name: str, missing_ok: bool = False) -&gt; None:\n    \"\"\"Delete a table from the group.\n\n    Args:\n        name (str): The name of the table to delete.\n        missing_ok (bool): If True, do not raise an error if the table does not\n            exist.\n\n    \"\"\"\n    table_container = self._get_tables_container(create_mode=False)\n    if table_container is None and missing_ok:\n        return\n    if table_container is None:\n        raise NgioValueError(\n            f\"No tables found in the image, cannot delete {name}. \"\n            \"Set missing_ok=True to ignore this error.\"\n        )\n    table_container.delete(name=name, missing_ok=missing_ok)\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.list_image_tables","title":"list_image_tables","text":"<pre><code>list_image_tables(\n    acquisition: int | None = None,\n    filter_types: str | None = None,\n    mode: Literal[\"common\", \"all\"] = \"common\",\n) -&gt; list[str]\n</code></pre> <p>List all image tables in the image.</p> <p>Parameters:</p> <ul> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> <li> <code>filter_types</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The type of tables to filter. If None, return all tables. Defaults to None.</p> </li> <li> <code>mode</code>               (<code>Literal['common', 'all']</code>, default:                   <code>'common'</code> )           \u2013            <p>The mode to use for listing the tables. If 'common', return only common tables between all images. If 'all', return all tables. Defaults to 'common'.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def list_image_tables(\n    self,\n    acquisition: int | None = None,\n    filter_types: str | None = None,\n    mode: Literal[\"common\", \"all\"] = \"common\",\n) -&gt; list[str]:\n    \"\"\"List all image tables in the image.\n\n    Args:\n        acquisition (int | None): The acquisition id to filter the images.\n        filter_types (str | None): The type of tables to filter. If None,\n            return all tables. Defaults to None.\n        mode (Literal[\"common\", \"all\"]): The mode to use for listing the tables.\n            If 'common', return only common tables between all images.\n            If 'all', return all tables. Defaults to 'common'.\n    \"\"\"\n    images = tuple(self.get_images(acquisition=acquisition).values())\n    return list_image_tables(\n        images=images,\n        filter_types=filter_types,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.list_image_tables_async","title":"list_image_tables_async  <code>async</code>","text":"<pre><code>list_image_tables_async(\n    acquisition: int | None = None,\n    filter_types: str | None = None,\n    mode: Literal[\"common\", \"all\"] = \"common\",\n) -&gt; list[str]\n</code></pre> <p>List all image tables in the image asynchronously.</p> <p>Parameters:</p> <ul> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> <li> <code>filter_types</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The type of tables to filter. If None, return all tables. Defaults to None.</p> </li> <li> <code>mode</code>               (<code>Literal['common', 'all']</code>, default:                   <code>'common'</code> )           \u2013            <p>The mode to use for listing the tables. If 'common', return only common tables between all images. If 'all', return all tables. Defaults to 'common'.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>async def list_image_tables_async(\n    self,\n    acquisition: int | None = None,\n    filter_types: str | None = None,\n    mode: Literal[\"common\", \"all\"] = \"common\",\n) -&gt; list[str]:\n    \"\"\"List all image tables in the image asynchronously.\n\n    Args:\n        acquisition (int | None): The acquisition id to filter the images.\n        filter_types (str | None): The type of tables to filter. If None,\n            return all tables. Defaults to None.\n        mode (Literal[\"common\", \"all\"]): The mode to use for listing the tables.\n            If 'common', return only common tables between all images.\n            If 'all', return all tables. Defaults to 'common'.\n    \"\"\"\n    images = await self.get_images_async(acquisition=acquisition)\n    images = tuple(images.values())\n    return await list_image_tables_async(\n        images=images,\n        filter_types=filter_types,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.concatenate_image_tables","title":"concatenate_image_tables","text":"<pre><code>concatenate_image_tables(\n    name: str,\n    acquisition: int | None = None,\n    strict: bool = True,\n    index_key: str | None = None,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; Table\n</code></pre> <p>Concatenate tables from all images in the plate.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table to concatenate.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The key to use for the index of the concatenated table.</p> </li> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, raise an error if the table is not found in the image.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>If a string is provided, a new index column will be created new_index_pattern = {row}{column}{path_in_well}_{label}</p> </li> <li> <code>mode</code>               (<code>Literal['eager', 'lazy']</code>, default:                   <code>'eager'</code> )           \u2013            <p>The mode to use for concatenation. Can be 'eager' or 'lazy'. if 'eager', the table will be loaded into memory. if 'lazy', the table will be loaded as a lazy frame.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def concatenate_image_tables(\n    self,\n    name: str,\n    acquisition: int | None = None,\n    strict: bool = True,\n    index_key: str | None = None,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; Table:\n    \"\"\"Concatenate tables from all images in the plate.\n\n    Args:\n        name: The name of the table to concatenate.\n        index_key: The key to use for the index of the concatenated table.\n        acquisition: The acquisition id to filter the images.\n        strict: If True, raise an error if the table is not found in the image.\n        index_key: If a string is provided, a new index column will be created\n            new_index_pattern = {row}_{column}_{path_in_well}_{label}\n        mode: The mode to use for concatenation. Can be 'eager' or 'lazy'.\n            if 'eager', the table will be loaded into memory.\n            if 'lazy', the table will be loaded as a lazy frame.\n    \"\"\"\n    images = self.get_images(acquisition=acquisition)\n    extras = _build_extras(tuple(images.keys()))\n    return concatenate_image_tables(\n        images=tuple(images.values()),\n        extras=extras,\n        name=name,\n        index_key=index_key,\n        strict=strict,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.concatenate_image_tables_as","title":"concatenate_image_tables_as","text":"<pre><code>concatenate_image_tables_as(\n    name: str,\n    table_cls: type[TableType],\n    acquisition: int | None = None,\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; TableType\n</code></pre> <p>Concatenate tables from all images in the plate as a specific type.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table to concatenate.</p> </li> <li> <code>table_cls</code>               (<code>type[TableType]</code>)           \u2013            <p>The type of the table to concatenate.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The key to use for the index of the concatenated table.</p> </li> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>If a string is provided, a new index column will be created new_index_pattern = {row}{column}{path_in_well}_{label}</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, raise an error if the table is not found in the image.</p> </li> <li> <code>mode</code>               (<code>Literal['eager', 'lazy']</code>, default:                   <code>'eager'</code> )           \u2013            <p>The mode to use for concatenation. Can be 'eager' or 'lazy'. if 'eager', the table will be loaded into memory. if 'lazy', the table will be loaded as a lazy frame.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def concatenate_image_tables_as(\n    self,\n    name: str,\n    table_cls: type[TableType],\n    acquisition: int | None = None,\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; TableType:\n    \"\"\"Concatenate tables from all images in the plate as a specific type.\n\n    Args:\n        name: The name of the table to concatenate.\n        table_cls: The type of the table to concatenate.\n        index_key: The key to use for the index of the concatenated table.\n        acquisition: The acquisition id to filter the images.\n        index_key: If a string is provided, a new index column will be created\n            new_index_pattern = {row}_{column}_{path_in_well}_{label}\n        strict: If True, raise an error if the table is not found in the image.\n        mode: The mode to use for concatenation. Can be 'eager' or 'lazy'.\n            if 'eager', the table will be loaded into memory.\n            if 'lazy', the table will be loaded as a lazy frame.\n    \"\"\"\n    images = self.get_images(acquisition=acquisition)\n    extras = _build_extras(tuple(images.keys()))\n    return concatenate_image_tables_as(\n        images=tuple(images.values()),\n        extras=extras,\n        name=name,\n        table_cls=table_cls,\n        index_key=index_key,\n        strict=strict,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.concatenate_image_tables_async","title":"concatenate_image_tables_async  <code>async</code>","text":"<pre><code>concatenate_image_tables_async(\n    name: str,\n    acquisition: int | None = None,\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; Table\n</code></pre> <p>Concatenate tables from all images in the plate asynchronously.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table to concatenate.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The key to use for the index of the concatenated table.</p> </li> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>If a string is provided, a new index column will be created new_index_pattern = {row}{column}{path_in_well}_{label}</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, raise an error if the table is not found in the image.</p> </li> <li> <code>mode</code>               (<code>Literal['eager', 'lazy']</code>, default:                   <code>'eager'</code> )           \u2013            <p>The mode to use for concatenation. Can be 'eager' or 'lazy'. if 'eager', the table will be loaded into memory. if 'lazy', the table will be loaded as a lazy frame.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>async def concatenate_image_tables_async(\n    self,\n    name: str,\n    acquisition: int | None = None,\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; Table:\n    \"\"\"Concatenate tables from all images in the plate asynchronously.\n\n    Args:\n        name: The name of the table to concatenate.\n        index_key: The key to use for the index of the concatenated table.\n        acquisition: The acquisition id to filter the images.\n        index_key: If a string is provided, a new index column will be created\n            new_index_pattern = {row}_{column}_{path_in_well}_{label}\n        strict: If True, raise an error if the table is not found in the image.\n        mode: The mode to use for concatenation. Can be 'eager' or 'lazy'.\n            if 'eager', the table will be loaded into memory.\n            if 'lazy', the table will be loaded as a lazy frame.\n    \"\"\"\n    images = await self.get_images_async(acquisition=acquisition)\n    extras = _build_extras(tuple(images.keys()))\n    return await concatenate_image_tables_async(\n        images=tuple(images.values()),\n        extras=extras,\n        name=name,\n        index_key=index_key,\n        strict=strict,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.concatenate_image_tables_as_async","title":"concatenate_image_tables_as_async  <code>async</code>","text":"<pre><code>concatenate_image_tables_as_async(\n    name: str,\n    table_cls: type[TableType],\n    acquisition: int | None = None,\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; TableType\n</code></pre> <p>Concatenate tables from all images in the plate as a specific type.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table to concatenate.</p> </li> <li> <code>table_cls</code>               (<code>type[TableType]</code>)           \u2013            <p>The type of the table to concatenate.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The key to use for the index of the concatenated table.</p> </li> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>If a string is provided, a new index column will be created new_index_pattern = {row}{column}{path_in_well}_{label}</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, raise an error if the table is not found in the image.</p> </li> <li> <code>mode</code>               (<code>Literal['eager', 'lazy']</code>, default:                   <code>'eager'</code> )           \u2013            <p>The mode to use for concatenation. Can be 'eager' or 'lazy'. if 'eager', the table will be loaded into memory. if 'lazy', the table will be loaded as a lazy frame.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>async def concatenate_image_tables_as_async(\n    self,\n    name: str,\n    table_cls: type[TableType],\n    acquisition: int | None = None,\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; TableType:\n    \"\"\"Concatenate tables from all images in the plate as a specific type.\n\n    Args:\n        name: The name of the table to concatenate.\n        table_cls: The type of the table to concatenate.\n        index_key: The key to use for the index of the concatenated table.\n        acquisition: The acquisition id to filter the images.\n        index_key: If a string is provided, a new index column will be created\n            new_index_pattern = {row}_{column}_{path_in_well}_{label}\n        strict: If True, raise an error if the table is not found in the image.\n        mode: The mode to use for concatenation. Can be 'eager' or 'lazy'.\n            if 'eager', the table will be loaded into memory.\n            if 'lazy', the table will be loaded as a lazy frame.\n    \"\"\"\n    images = await self.get_images_async(acquisition=acquisition)\n    extras = _build_extras(tuple(images.keys()))\n    return await concatenate_image_tables_as_async(\n        images=tuple(images.values()),\n        extras=extras,\n        name=name,\n        table_cls=table_cls,\n        index_key=index_key,\n        strict=strict,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrWell","title":"OmeZarrWell","text":"<pre><code>OmeZarrWell(group_handler: ZarrGroupHandler)\n</code></pre> <p>A class to handle the Well Sequence in an OME-Zarr file.</p> <p>Initialize the LabelGroupHandler.</p> <p>Parameters:</p> <ul> <li> <code>group_handler</code>               (<code>ZarrGroupHandler</code>)           \u2013            <p>The Zarr group handler that contains the Well.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def __init__(self, group_handler: ZarrGroupHandler) -&gt; None:\n    \"\"\"Initialize the LabelGroupHandler.\n\n    Args:\n        group_handler: The Zarr group handler that contains the Well.\n    \"\"\"\n    self._group_handler = group_handler\n    self._meta_handler = WellMetaHandler(group_handler)\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrWell.meta_handler","title":"meta_handler  <code>property</code>","text":"<pre><code>meta_handler\n</code></pre> <p>Return the metadata handler.</p>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrWell.meta","title":"meta  <code>property</code>","text":"<pre><code>meta\n</code></pre> <p>Return the metadata.</p>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrWell.acquisition_ids","title":"acquisition_ids  <code>property</code>","text":"<pre><code>acquisition_ids: list[int]\n</code></pre> <p>Return the acquisitions ids in the well.</p>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrWell.paths","title":"paths","text":"<pre><code>paths(acquisition: int | None = None) -&gt; list[str]\n</code></pre> <p>Return the images paths in the well.</p> <p>If acquisition is None, return all images paths in the well. Else, return the images paths in the well for the given acquisition.</p> <p>Parameters:</p> <ul> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def paths(self, acquisition: int | None = None) -&gt; list[str]:\n    \"\"\"Return the images paths in the well.\n\n    If acquisition is None, return all images paths in the well.\n    Else, return the images paths in the well for the given acquisition.\n\n    Args:\n        acquisition (int | None): The acquisition id to filter the images.\n    \"\"\"\n    return self.meta.paths(acquisition)\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrWell.get_image_store","title":"get_image_store","text":"<pre><code>get_image_store(image_path: str) -&gt; StoreOrGroup\n</code></pre> <p>Get the image store from the well.</p> <p>Parameters:</p> <ul> <li> <code>image_path</code>               (<code>str</code>)           \u2013            <p>The path of the image.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_image_store(self, image_path: str) -&gt; StoreOrGroup:\n    \"\"\"Get the image store from the well.\n\n    Args:\n        image_path (str): The path of the image.\n    \"\"\"\n    return self._group_handler.get_group(image_path, create_mode=True)\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrWell.get_image_acquisition_id","title":"get_image_acquisition_id","text":"<pre><code>get_image_acquisition_id(image_path: str) -&gt; int | None\n</code></pre> <p>Get the acquisition id of an image in the well.</p> <p>Parameters:</p> <ul> <li> <code>image_path</code>               (<code>str</code>)           \u2013            <p>The path of the image.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int | None</code>           \u2013            <p>int | None: The acquisition id of the image.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_image_acquisition_id(self, image_path: str) -&gt; int | None:\n    \"\"\"Get the acquisition id of an image in the well.\n\n    Args:\n        image_path (str): The path of the image.\n\n    Returns:\n        int | None: The acquisition id of the image.\n    \"\"\"\n    return self.meta.get_image_acquisition_id(image_path=image_path)\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrWell.get_image","title":"get_image","text":"<pre><code>get_image(image_path: str) -&gt; OmeZarrContainer\n</code></pre> <p>Get an image from the well.</p> <p>Parameters:</p> <ul> <li> <code>image_path</code>               (<code>str</code>)           \u2013            <p>The path of the image.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OmeZarrContainer</code> (              <code>OmeZarrContainer</code> )          \u2013            <p>The image.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_image(self, image_path: str) -&gt; OmeZarrContainer:\n    \"\"\"Get an image from the well.\n\n    Args:\n        image_path (str): The path of the image.\n\n    Returns:\n        OmeZarrContainer: The image.\n    \"\"\"\n    handler = self._group_handler.get_handler(image_path)\n    return OmeZarrContainer(handler)\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrWell.atomic_add_image","title":"atomic_add_image","text":"<pre><code>atomic_add_image(\n    image_path: str,\n    acquisition_id: int | None = None,\n    strict: bool = True,\n) -&gt; StoreOrGroup\n</code></pre> <p>Parallel safe version of add_image.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def atomic_add_image(\n    self,\n    image_path: str,\n    acquisition_id: int | None = None,\n    strict: bool = True,\n) -&gt; StoreOrGroup:\n    \"\"\"Parallel safe version of add_image.\"\"\"\n    return self._add_image(\n        image_path=image_path,\n        acquisition_id=acquisition_id,\n        atomic=True,\n        strict=strict,\n    )\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrWell.add_image","title":"add_image","text":"<pre><code>add_image(\n    image_path: str,\n    acquisition_id: int | None = None,\n    strict: bool = True,\n) -&gt; StoreOrGroup\n</code></pre> <p>Add an image to an ome-zarr well.</p> <p>Parameters:</p> <ul> <li> <code>image_path</code>               (<code>str</code>)           \u2013            <p>The path of the image.</p> </li> <li> <code>acquisition_id</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to check if the acquisition id is already exists in the well. Defaults to True. If False this might lead to acquisition in a well that does not exist at the plate level.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def add_image(\n    self,\n    image_path: str,\n    acquisition_id: int | None = None,\n    strict: bool = True,\n) -&gt; StoreOrGroup:\n    \"\"\"Add an image to an ome-zarr well.\n\n    Args:\n        image_path (str): The path of the image.\n        acquisition_id (int | None): The acquisition id to filter the images.\n        strict (bool): Whether to check if the acquisition id is already exists\n            in the well. Defaults to True. If False this might lead to\n            acquisition in a well that does not exist at the plate level.\n    \"\"\"\n    return self._add_image(\n        image_path=image_path,\n        acquisition_id=acquisition_id,\n        atomic=False,\n        strict=strict,\n    )\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.create_empty_plate","title":"create_empty_plate","text":"<pre><code>create_empty_plate(\n    store: StoreOrGroup,\n    name: str,\n    images: list[ImageInWellPath] | None = None,\n    version: NgffVersions | None = None,\n    ngff_version: NgffVersions = DefaultNgffVersion,\n    cache: bool = False,\n    overwrite: bool = False,\n) -&gt; OmeZarrPlate\n</code></pre> <p>Initialize and create an empty OME-Zarr plate.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group that stores the plate.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the plate.</p> </li> <li> <code>images</code>               (<code>list[ImageInWellPath] | None</code>, default:                   <code>None</code> )           \u2013            <p>A list of images to add to the plate. If None, no images are added. Defaults to None.</p> </li> <li> <code>version</code>               (<code>NgffVersion | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Please use 'ngff_version' instead.</p> </li> <li> <code>ngff_version</code>               (<code>NgffVersion</code>, default:                   <code>DefaultNgffVersion</code> )           \u2013            <p>The NGFF version to use for the new plate.</p> </li> <li> <code>cache</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use a cache for the zarr group metadata.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to overwrite the existing plate.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def create_empty_plate(\n    store: StoreOrGroup,\n    name: str,\n    images: list[ImageInWellPath] | None = None,\n    version: NgffVersions | None = None,\n    ngff_version: NgffVersions = DefaultNgffVersion,\n    cache: bool = False,\n    overwrite: bool = False,\n) -&gt; OmeZarrPlate:\n    \"\"\"Initialize and create an empty OME-Zarr plate.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group that stores the plate.\n        name (str): The name of the plate.\n        images (list[ImageInWellPath] | None): A list of images to add to the plate.\n            If None, no images are added. Defaults to None.\n        version (NgffVersion | None): Deprecated. Please use 'ngff_version' instead.\n        ngff_version (NgffVersion): The NGFF version to use for the new plate.\n        cache (bool): Whether to use a cache for the zarr group metadata.\n        overwrite (bool): Whether to overwrite the existing plate.\n    \"\"\"\n    if version is not None:\n        logger.warning(\n            \"The 'version' argument is deprecated and will be removed in ngio=0.6. \"\n            \"Please use 'ngff_version' instead.\"\n        )\n        ngff_version = version\n    plate_meta = NgioPlateMeta.default_init(\n        name=name,\n        ngff_version=ngff_version,\n    )\n    group_handler = _create_empty_plate_from_meta(\n        store=store,\n        meta=plate_meta,\n        overwrite=overwrite,\n    )\n\n    if images is not None:\n        plate = OmeZarrPlate(group_handler)\n        for image in images:\n            plate.add_image(\n                row=image.row,\n                column=image.column,\n                image_path=image.path,\n                acquisition_id=image.acquisition_id,\n                acquisition_name=image.acquisition_name,\n            )\n    return open_ome_zarr_plate(\n        store=store,\n        cache=cache,\n        mode=\"r+\",\n    )\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.create_empty_well","title":"create_empty_well","text":"<pre><code>create_empty_well(\n    store: StoreOrGroup,\n    version: NgffVersions | None = None,\n    ngff_version: NgffVersions = DefaultNgffVersion,\n    cache: bool = False,\n    overwrite: bool = False,\n) -&gt; OmeZarrWell\n</code></pre> <p>Create an empty OME-Zarr well.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group that stores the well.</p> </li> <li> <code>version</code>               (<code>NgffVersion | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Please use 'ngff_version' instead.</p> </li> <li> <code>ngff_version</code>               (<code>NgffVersion</code>, default:                   <code>DefaultNgffVersion</code> )           \u2013            <p>The version of the new well.</p> </li> <li> <code>cache</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use a cache for the zarr group metadata.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to overwrite the existing well.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def create_empty_well(\n    store: StoreOrGroup,\n    version: NgffVersions | None = None,\n    ngff_version: NgffVersions = DefaultNgffVersion,\n    cache: bool = False,\n    overwrite: bool = False,\n) -&gt; OmeZarrWell:\n    \"\"\"Create an empty OME-Zarr well.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group that stores the well.\n        version (NgffVersion | None): Deprecated. Please use 'ngff_version' instead.\n        ngff_version (NgffVersion): The version of the new well.\n        cache (bool): Whether to use a cache for the zarr group metadata.\n        overwrite (bool): Whether to overwrite the existing well.\n    \"\"\"\n    if version is not None:\n        logger.warning(\n            \"The 'version' argument is deprecated and will be removed in ngio=0.6. \"\n            \"Please use 'ngff_version' instead.\"\n        )\n        ngff_version = version\n    group_handler = ZarrGroupHandler(\n        store=store, cache=True, mode=\"w\" if overwrite else \"w-\"\n    )\n    update_ngio_well_meta(\n        group_handler, NgioWellMeta.default_init(ngff_version=ngff_version)\n    )\n\n    return open_ome_zarr_well(\n        store=store,\n        cache=cache,\n        mode=\"r+\",\n    )\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.open_ome_zarr_plate","title":"open_ome_zarr_plate","text":"<pre><code>open_ome_zarr_plate(\n    store: StoreOrGroup,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n) -&gt; OmeZarrPlate\n</code></pre> <p>Open an OME-Zarr plate.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group that stores the plate.</p> </li> <li> <code>cache</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use a cache for the zarr group metadata.</p> </li> <li> <code>mode</code>               (<code>AccessModeLiteral</code>, default:                   <code>'r+'</code> )           \u2013            <p>The access mode for the image. Defaults to \"r+\".</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def open_ome_zarr_plate(\n    store: StoreOrGroup,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n) -&gt; OmeZarrPlate:\n    \"\"\"Open an OME-Zarr plate.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group that stores the plate.\n        cache (bool): Whether to use a cache for the zarr group metadata.\n        mode (AccessModeLiteral): The\n            access mode for the image. Defaults to \"r+\".\n    \"\"\"\n    group_handler = ZarrGroupHandler(store=store, cache=cache, mode=mode)\n    return OmeZarrPlate(group_handler)\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.open_ome_zarr_well","title":"open_ome_zarr_well","text":"<pre><code>open_ome_zarr_well(\n    store: StoreOrGroup,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n) -&gt; OmeZarrWell\n</code></pre> <p>Open an OME-Zarr well.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group that stores the plate.</p> </li> <li> <code>cache</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use a cache for the zarr group metadata.</p> </li> <li> <code>mode</code>               (<code>AccessModeLiteral</code>, default:                   <code>'r+'</code> )           \u2013            <p>The access mode for the image. Defaults to \"r+\".</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def open_ome_zarr_well(\n    store: StoreOrGroup,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n) -&gt; OmeZarrWell:\n    \"\"\"Open an OME-Zarr well.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group that stores the plate.\n        cache (bool): Whether to use a cache for the zarr group metadata.\n        mode (AccessModeLiteral): The access mode for the image. Defaults to \"r+\".\n    \"\"\"\n    group_handler = ZarrGroupHandler(\n        store=store,\n        cache=cache,\n        mode=mode,\n    )\n    return OmeZarrWell(group_handler)\n</code></pre>"},{"location":"api/ngio/images/","title":"ngio.images API documentation","text":""},{"location":"api/ngio/images/#ngio.images","title":"ngio.images","text":"<p>OME-Zarr object models.</p>"},{"location":"api/ngio/images/#ngio.images.ChannelSelectionModel","title":"ChannelSelectionModel","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for channel selection.</p> <p>This model is used to select a channel by label, wavelength ID, or index.</p> Properties <p>identifier (str): Unique identifier for the channel.     This can be a channel label, wavelength ID, or index. mode (Literal[\"label\", \"wavelength_id\", \"index\"]): Specifies how to     interpret the identifier. Can be \"label\", \"wavelength_id\", or     \"index\" (must be an integer).</p>"},{"location":"api/ngio/images/#ngio.images.ChannelSelectionModel.mode","title":"mode  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mode: Literal['label', 'wavelength_id', 'index'] = 'label'\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.ChannelSelectionModel.identifier","title":"identifier  <code>instance-attribute</code>","text":"<pre><code>identifier: str\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.ChannelSelectionModel.check_channel_selection","title":"check_channel_selection","text":"<pre><code>check_channel_selection()\n</code></pre> Source code in <code>ngio/images/_image.py</code> <pre><code>@model_validator(mode=\"after\")\ndef check_channel_selection(self):\n    if self.mode == \"index\":\n        try:\n            int(self.identifier)\n        except ValueError as e:\n            raise ValueError(\n                \"Identifier must be an integer when mode is 'index'\"\n            ) from e\n    return self\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Image","title":"Image","text":"<pre><code>Image(\n    group_handler: ZarrGroupHandler,\n    path: str,\n    meta_handler: ImageMetaHandler,\n)\n</code></pre> <p>               Bases: <code>AbstractImage</code></p> <p>A class to handle a single image (or level) in an OME-Zarr image.</p> <p>This class is meant to be subclassed by specific image types.</p> <p>Initialize the Image at a single level.</p> <p>Parameters:</p> <ul> <li> <code>group_handler</code>               (<code>ZarrGroupHandler</code>)           \u2013            <p>The Zarr group handler.</p> </li> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path to the image in the ome_zarr file.</p> </li> <li> <code>meta_handler</code>               (<code>ImageMetaHandler</code>)           \u2013            <p>The image metadata handler.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def __init__(\n    self,\n    group_handler: ZarrGroupHandler,\n    path: str,\n    meta_handler: ImageMetaHandler,\n) -&gt; None:\n    \"\"\"Initialize the Image at a single level.\n\n    Args:\n        group_handler: The Zarr group handler.\n        path: The path to the image in the ome_zarr file.\n        meta_handler: The image metadata handler.\n\n    \"\"\"\n    super().__init__(\n        group_handler=group_handler, path=path, meta_handler=meta_handler\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Image.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Return the path of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Image.dataset","title":"dataset  <code>property</code>","text":"<pre><code>dataset: Dataset\n</code></pre> <p>Return the dataset of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Image.dimensions","title":"dimensions  <code>property</code>","text":"<pre><code>dimensions: Dimensions\n</code></pre> <p>Return the dimensions of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Image.pixel_size","title":"pixel_size  <code>property</code>","text":"<pre><code>pixel_size: PixelSize\n</code></pre> <p>Return the pixel size of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Image.axes_handler","title":"axes_handler  <code>property</code>","text":"<pre><code>axes_handler: AxesHandler\n</code></pre> <p>Return the axes handler of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Image.axes_setup","title":"axes_setup  <code>property</code>","text":"<pre><code>axes_setup: AxesSetup\n</code></pre> <p>Return the axes setup of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Image.axes","title":"axes  <code>property</code>","text":"<pre><code>axes: tuple[str, ...]\n</code></pre> <p>Return the axes of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Image.zarr_array","title":"zarr_array  <code>property</code>","text":"<pre><code>zarr_array: Array\n</code></pre> <p>Return the Zarr array.</p>"},{"location":"api/ngio/images/#ngio.images.Image.shape","title":"shape  <code>property</code>","text":"<pre><code>shape: tuple[int, ...]\n</code></pre> <p>Return the shape of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Image.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype: str\n</code></pre> <p>Return the dtype of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Image.chunks","title":"chunks  <code>property</code>","text":"<pre><code>chunks: tuple[int, ...]\n</code></pre> <p>Return the chunks of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Image.is_3d","title":"is_3d  <code>property</code>","text":"<pre><code>is_3d: bool\n</code></pre> <p>Return True if the image is 3D.</p>"},{"location":"api/ngio/images/#ngio.images.Image.is_2d","title":"is_2d  <code>property</code>","text":"<pre><code>is_2d: bool\n</code></pre> <p>Return True if the image is 2D.</p>"},{"location":"api/ngio/images/#ngio.images.Image.is_time_series","title":"is_time_series  <code>property</code>","text":"<pre><code>is_time_series: bool\n</code></pre> <p>Return True if the image is a time series.</p>"},{"location":"api/ngio/images/#ngio.images.Image.is_2d_time_series","title":"is_2d_time_series  <code>property</code>","text":"<pre><code>is_2d_time_series: bool\n</code></pre> <p>Return True if the image is a 2D time series.</p>"},{"location":"api/ngio/images/#ngio.images.Image.is_3d_time_series","title":"is_3d_time_series  <code>property</code>","text":"<pre><code>is_3d_time_series: bool\n</code></pre> <p>Return True if the image is a 3D time series.</p>"},{"location":"api/ngio/images/#ngio.images.Image.is_multi_channels","title":"is_multi_channels  <code>property</code>","text":"<pre><code>is_multi_channels: bool\n</code></pre> <p>Return True if the image is multichannel.</p>"},{"location":"api/ngio/images/#ngio.images.Image.space_unit","title":"space_unit  <code>property</code>","text":"<pre><code>space_unit: str | None\n</code></pre> <p>Return the space unit of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Image.time_unit","title":"time_unit  <code>property</code>","text":"<pre><code>time_unit: str | None\n</code></pre> <p>Return the time unit of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Image.meta_handler","title":"meta_handler  <code>property</code>","text":"<pre><code>meta_handler: ImageMetaHandler\n</code></pre> <p>Return the metadata handler.</p>"},{"location":"api/ngio/images/#ngio.images.Image.meta","title":"meta  <code>property</code>","text":"<pre><code>meta: NgioImageMeta\n</code></pre> <p>Return the metadata.</p>"},{"location":"api/ngio/images/#ngio.images.Image.channels_meta","title":"channels_meta  <code>property</code>","text":"<pre><code>channels_meta: ChannelsMeta\n</code></pre> <p>Return the channels metadata.</p>"},{"location":"api/ngio/images/#ngio.images.Image.channel_labels","title":"channel_labels  <code>property</code>","text":"<pre><code>channel_labels: list[str]\n</code></pre> <p>Return the channels of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Image.wavelength_ids","title":"wavelength_ids  <code>property</code>","text":"<pre><code>wavelength_ids: list[str | None]\n</code></pre> <p>Return the list of wavelength of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Image.num_channels","title":"num_channels  <code>property</code>","text":"<pre><code>num_channels: int\n</code></pre> <p>Return the number of channels.</p>"},{"location":"api/ngio/images/#ngio.images.Image.has_axis","title":"has_axis","text":"<pre><code>has_axis(axis: str) -&gt; bool\n</code></pre> <p>Return True if the image has the given axis.</p> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def has_axis(self, axis: str) -&gt; bool:\n    \"\"\"Return True if the image has the given axis.\"\"\"\n    return self.axes_handler.has_axis(axis)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Image.set_axes_unit","title":"set_axes_unit","text":"<pre><code>set_axes_unit(\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n) -&gt; None\n</code></pre> <p>Set the axes unit of the image.</p> <p>Parameters:</p> <ul> <li> <code>space_unit</code>               (<code>SpaceUnits</code>, default:                   <code>DefaultSpaceUnit</code> )           \u2013            <p>The space unit of the image.</p> </li> <li> <code>time_unit</code>               (<code>TimeUnits</code>, default:                   <code>DefaultTimeUnit</code> )           \u2013            <p>The time unit of the image.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def set_axes_unit(\n    self,\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n) -&gt; None:\n    \"\"\"Set the axes unit of the image.\n\n    Args:\n        space_unit (SpaceUnits): The space unit of the image.\n        time_unit (TimeUnits): The time unit of the image.\n    \"\"\"\n    meta = self._meta_handler.get_meta()\n    meta = meta.to_units(space_unit=space_unit, time_unit=time_unit)\n    self._meta_handler.update_meta(meta)  # type: ignore\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Image.set_axes_names","title":"set_axes_names","text":"<pre><code>set_axes_names(axes_names: Sequence[str]) -&gt; None\n</code></pre> <p>Set the axes names of the label.</p> <p>Parameters:</p> <ul> <li> <code>axes_names</code>               (<code>Sequence[str]</code>)           \u2013            <p>The axes names to set.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def set_axes_names(self, axes_names: Sequence[str]) -&gt; None:\n    \"\"\"Set the axes names of the label.\n\n    Args:\n        axes_names (Sequence[str]): The axes names to set.\n    \"\"\"\n    meta = self._meta_handler.get_meta()\n    meta = meta.rename_axes(axes_names=axes_names)\n    self._meta_handler._axes_setup = meta.axes_handler.axes_setup\n    self._meta_handler.update_meta(meta)  # type: ignore\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Image.set_name","title":"set_name","text":"<pre><code>set_name(name: str) -&gt; None\n</code></pre> <p>Set the name of the image in the metadata.</p> <p>This does not change the group name or any paths.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the image.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def set_name(\n    self,\n    name: str,\n) -&gt; None:\n    \"\"\"Set the name of the image in the metadata.\n\n    This does not change the group name or any paths.\n\n    Args:\n        name (str): The name of the image.\n    \"\"\"\n    meta = self._meta_handler.get_meta()\n    meta = meta.rename_image(name=name)\n    self._meta_handler.update_meta(meta)  # type: ignore\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Image.roi","title":"roi","text":"<pre><code>roi(name: str | None = 'image') -&gt; Roi\n</code></pre> <p>Return the ROI covering the entire image.</p> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def roi(self, name: str | None = \"image\") -&gt; Roi:\n    \"\"\"Return the ROI covering the entire image.\"\"\"\n    slices = {}\n    for ax_name in [\"t\", \"z\", \"y\", \"x\"]:\n        axis_size = self.dimensions.get(ax_name, default=None)\n        if axis_size is None:\n            continue\n        slices[ax_name] = slice(0, axis_size)\n    roi_px = Roi.from_values(name=name, slices=slices, space=\"pixel\")\n    return roi_px.to_world(pixel_size=self.pixel_size)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Image.build_image_roi_table","title":"build_image_roi_table","text":"<pre><code>build_image_roi_table(\n    name: str | None = \"image\",\n) -&gt; RoiTable\n</code></pre> <p>Build the ROI table containing the ROI covering the entire image.</p> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def build_image_roi_table(self, name: str | None = \"image\") -&gt; RoiTable:\n    \"\"\"Build the ROI table containing the ROI covering the entire image.\"\"\"\n    return RoiTable(rois=[self.roi(name=name)])\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Image.require_dimensions_match","title":"require_dimensions_match","text":"<pre><code>require_dimensions_match(\n    other: AbstractImage, allow_singleton: bool = False\n) -&gt; None\n</code></pre> <p>Assert that two images have matching spatial dimensions.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>AbstractImage</code>)           \u2013            <p>The other image to compare to.</p> </li> <li> <code>allow_singleton</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, allow singleton dimensions to be compatible with non-singleton dimensions.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NgioValueError</code>             \u2013            <p>If the images do not have compatible dimensions.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def require_dimensions_match(\n    self,\n    other: \"AbstractImage\",\n    allow_singleton: bool = False,\n) -&gt; None:\n    \"\"\"Assert that two images have matching spatial dimensions.\n\n    Args:\n        other: The other image to compare to.\n        allow_singleton: If True, allow singleton dimensions to be\n            compatible with non-singleton dimensions.\n\n    Raises:\n        NgioValueError: If the images do not have compatible dimensions.\n    \"\"\"\n    self.dimensions.require_dimensions_match(\n        other.dimensions, allow_singleton=allow_singleton\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Image.check_if_dimensions_match","title":"check_if_dimensions_match","text":"<pre><code>check_if_dimensions_match(\n    other: AbstractImage, allow_singleton: bool = False\n) -&gt; bool\n</code></pre> <p>Check if two images have matching spatial dimensions.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>AbstractImage</code>)           \u2013            <p>The other image to compare to.</p> </li> <li> <code>allow_singleton</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, allow singleton dimensions to be compatible with non-singleton dimensions.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the images have matching dimensions, False otherwise.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def check_if_dimensions_match(\n    self,\n    other: \"AbstractImage\",\n    allow_singleton: bool = False,\n) -&gt; bool:\n    \"\"\"Check if two images have matching spatial dimensions.\n\n    Args:\n        other: The other image to compare to.\n        allow_singleton: If True, allow singleton dimensions to be\n            compatible with non-singleton dimensions.\n\n    Returns:\n        bool: True if the images have matching dimensions, False otherwise.\n    \"\"\"\n    return self.dimensions.check_if_dimensions_match(\n        other.dimensions, allow_singleton=allow_singleton\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Image.require_axes_match","title":"require_axes_match","text":"<pre><code>require_axes_match(other: AbstractImage) -&gt; None\n</code></pre> <p>Assert that two images have compatible axes.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>AbstractImage</code>)           \u2013            <p>The other image to compare to.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NgioValueError</code>             \u2013            <p>If the images do not have compatible axes.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def require_axes_match(\n    self,\n    other: \"AbstractImage\",\n) -&gt; None:\n    \"\"\"Assert that two images have compatible axes.\n\n    Args:\n        other: The other image to compare to.\n\n    Raises:\n        NgioValueError: If the images do not have compatible axes.\n    \"\"\"\n    self.dimensions.require_axes_match(other.dimensions)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Image.check_if_axes_match","title":"check_if_axes_match","text":"<pre><code>check_if_axes_match(other: AbstractImage) -&gt; bool\n</code></pre> <p>Check if two images have compatible axes.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>AbstractImage</code>)           \u2013            <p>The other image to compare to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the images have compatible axes, False otherwise.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def check_if_axes_match(\n    self,\n    other: \"AbstractImage\",\n) -&gt; bool:\n    \"\"\"Check if two images have compatible axes.\n\n    Args:\n        other: The other image to compare to.\n\n    Returns:\n        bool: True if the images have compatible axes, False otherwise.\n\n    \"\"\"\n    return self.dimensions.check_if_axes_match(other.dimensions)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Image.require_rescalable","title":"require_rescalable","text":"<pre><code>require_rescalable(other: AbstractImage) -&gt; None\n</code></pre> <p>Assert that two images can be rescaled to each other.</p> <p>For this to be true, the images must have the same axes, and the pixel sizes must be compatible (i.e. one can be scaled to the other).</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>AbstractImage</code>)           \u2013            <p>The other image to compare to.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NgioValueError</code>             \u2013            <p>If the images cannot be scaled to each other.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def require_rescalable(\n    self,\n    other: \"AbstractImage\",\n) -&gt; None:\n    \"\"\"Assert that two images can be rescaled to each other.\n\n    For this to be true, the images must have the same axes, and\n    the pixel sizes must be compatible (i.e. one can be scaled to the other).\n\n    Args:\n        other: The other image to compare to.\n\n    Raises:\n        NgioValueError: If the images cannot be scaled to each other.\n    \"\"\"\n    self.dimensions.require_rescalable(other.dimensions)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Image.check_if_rescalable","title":"check_if_rescalable","text":"<pre><code>check_if_rescalable(other: AbstractImage) -&gt; bool\n</code></pre> <p>Check if two images can be rescaled to each other.</p> <p>For this to be true, the images must have the same axes, and the pixel sizes must be compatible (i.e. one can be scaled to the other).</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>AbstractImage</code>)           \u2013            <p>The other image to compare to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the images can be rescaled to each other, False otherwise.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def check_if_rescalable(\n    self,\n    other: \"AbstractImage\",\n) -&gt; bool:\n    \"\"\"Check if two images can be rescaled to each other.\n\n    For this to be true, the images must have the same axes, and\n    the pixel sizes must be compatible (i.e. one can be scaled to the other).\n\n    Args:\n        other: The other image to compare to.\n\n    Returns:\n        bool: True if the images can be rescaled to each other, False otherwise.\n    \"\"\"\n    return self.dimensions.check_if_rescalable(other.dimensions)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Image.get_channel_idx","title":"get_channel_idx","text":"<pre><code>get_channel_idx(\n    channel_label: str | None = None,\n    wavelength_id: str | None = None,\n) -&gt; int\n</code></pre> <p>Get the index of a channel by its label or wavelength ID.</p> Source code in <code>ngio/images/_image.py</code> <pre><code>def get_channel_idx(\n    self, channel_label: str | None = None, wavelength_id: str | None = None\n) -&gt; int:\n    \"\"\"Get the index of a channel by its label or wavelength ID.\"\"\"\n    return self.channels_meta.get_channel_idx(\n        channel_label=channel_label, wavelength_id=wavelength_id\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Image.get_as_numpy","title":"get_as_numpy","text":"<pre><code>get_as_numpy(\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: slice | int | Sequence[int] | None,\n) -&gt; ndarray\n</code></pre> <p>Get the image as a numpy array.</p> <p>Parameters:</p> <ul> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Select a specific channel by label. If None, all channels are returned. Alternatively, you can slice arbitrary channels using the slice_kwargs (c=[0, 2]).</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The order of the axes to return the array.</p> </li> <li> <code>transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>The transforms to apply to the array.</p> </li> <li> <code>**slicing_kwargs</code>               (<code>slice | int | Sequence[int] | None</code>, default:                   <code>{}</code> )           \u2013            <p>The slices to get the array.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The array of the region of interest.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def get_as_numpy(\n    self,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: slice | int | Sequence[int] | None,\n) -&gt; np.ndarray:\n    \"\"\"Get the image as a numpy array.\n\n    Args:\n        channel_selection: Select a specific channel by label.\n            If None, all channels are returned.\n            Alternatively, you can slice arbitrary channels\n            using the slice_kwargs (c=[0, 2]).\n        axes_order: The order of the axes to return the array.\n        transforms: The transforms to apply to the array.\n        **slicing_kwargs: The slices to get the array.\n\n    Returns:\n        The array of the region of interest.\n    \"\"\"\n    _slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self, channel_selection=channel_selection, slicing_dict=slicing_kwargs\n    )\n    return self._get_as_numpy(\n        axes_order=axes_order, transforms=transforms, **_slicing_kwargs\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Image.get_roi_as_numpy","title":"get_roi_as_numpy","text":"<pre><code>get_roi_as_numpy(\n    roi: Roi,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; ndarray\n</code></pre> <p>Get the image as a numpy array for a region of interest.</p> <p>Parameters:</p> <ul> <li> <code>roi</code>               (<code>Roi</code>)           \u2013            <p>The region of interest to get the array.</p> </li> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Select a what subset of channels to return. If None, all channels are returned.</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The order of the axes to return the array.</p> </li> <li> <code>transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>The transforms to apply to the array.</p> </li> <li> <code>**slicing_kwargs</code>               (<code>SlicingInputType</code>, default:                   <code>{}</code> )           \u2013            <p>The slices to get the array.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The array of the region of interest.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def get_roi_as_numpy(\n    self,\n    roi: Roi,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; np.ndarray:\n    \"\"\"Get the image as a numpy array for a region of interest.\n\n    Args:\n        roi: The region of interest to get the array.\n        channel_selection: Select a what subset of channels to return.\n            If None, all channels are returned.\n        axes_order: The order of the axes to return the array.\n        transforms: The transforms to apply to the array.\n        **slicing_kwargs: The slices to get the array.\n\n    Returns:\n        The array of the region of interest.\n    \"\"\"\n    _slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self, channel_selection=channel_selection, slicing_dict=slicing_kwargs\n    )\n    return self._get_roi_as_numpy(\n        roi=roi, axes_order=axes_order, transforms=transforms, **_slicing_kwargs\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Image.get_as_dask","title":"get_as_dask","text":"<pre><code>get_as_dask(\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; Array\n</code></pre> <p>Get the image as a dask array.</p> <p>Parameters:</p> <ul> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Select a what subset of channels to return. If None, all channels are returned.</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The order of the axes to return the array.</p> </li> <li> <code>transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>The transforms to apply to the array.</p> </li> <li> <code>**slicing_kwargs</code>               (<code>SlicingInputType</code>, default:                   <code>{}</code> )           \u2013            <p>The slices to get the array.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array</code>           \u2013            <p>The dask array of the region of interest.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def get_as_dask(\n    self,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; da.Array:\n    \"\"\"Get the image as a dask array.\n\n    Args:\n        channel_selection: Select a what subset of channels to return.\n            If None, all channels are returned.\n        axes_order: The order of the axes to return the array.\n        transforms: The transforms to apply to the array.\n        **slicing_kwargs: The slices to get the array.\n\n    Returns:\n        The dask array of the region of interest.\n    \"\"\"\n    _slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self, channel_selection=channel_selection, slicing_dict=slicing_kwargs\n    )\n    return self._get_as_dask(\n        axes_order=axes_order, transforms=transforms, **_slicing_kwargs\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Image.get_roi_as_dask","title":"get_roi_as_dask","text":"<pre><code>get_roi_as_dask(\n    roi: Roi,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; Array\n</code></pre> <p>Get the image as a dask array for a region of interest.</p> <p>Parameters:</p> <ul> <li> <code>roi</code>               (<code>Roi</code>)           \u2013            <p>The region of interest to get the array.</p> </li> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Select a what subset of channels to return. If None, all channels are returned.</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The order of the axes to return the array.</p> </li> <li> <code>transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>The transforms to apply to the array.</p> </li> <li> <code>**slicing_kwargs</code>               (<code>SlicingInputType</code>, default:                   <code>{}</code> )           \u2013            <p>The slices to get the array.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array</code>           \u2013            <p>The dask array of the region of interest.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def get_roi_as_dask(\n    self,\n    roi: Roi,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; da.Array:\n    \"\"\"Get the image as a dask array for a region of interest.\n\n    Args:\n        roi: The region of interest to get the array.\n        channel_selection: Select a what subset of channels to return.\n            If None, all channels are returned.\n        axes_order: The order of the axes to return the array.\n        transforms: The transforms to apply to the array.\n        **slicing_kwargs: The slices to get the array.\n\n    Returns:\n        The dask array of the region of interest.\n    \"\"\"\n    _slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self, channel_selection=channel_selection, slicing_dict=slicing_kwargs\n    )\n    return self._get_roi_as_dask(\n        roi=roi, axes_order=axes_order, transforms=transforms, **_slicing_kwargs\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Image.get_array","title":"get_array","text":"<pre><code>get_array(\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    mode: Literal[\"numpy\", \"dask\"] = \"numpy\",\n    **slicing_kwargs: SlicingInputType,\n) -&gt; ndarray | Array\n</code></pre> <p>Get the image as a zarr array.</p> <p>Parameters:</p> <ul> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Select a what subset of channels to return. If None, all channels are returned.</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The order of the axes to return the array.</p> </li> <li> <code>transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>The transforms to apply to the array.</p> </li> <li> <code>mode</code>               (<code>Literal['numpy', 'dask']</code>, default:                   <code>'numpy'</code> )           \u2013            <p>The object type to return. Can be \"dask\", \"numpy\".</p> </li> <li> <code>**slicing_kwargs</code>               (<code>SlicingInputType</code>, default:                   <code>{}</code> )           \u2013            <p>The slices to get the array.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray | Array</code>           \u2013            <p>The zarr array of the region of interest.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def get_array(\n    self,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    mode: Literal[\"numpy\", \"dask\"] = \"numpy\",\n    **slicing_kwargs: SlicingInputType,\n) -&gt; np.ndarray | da.Array:\n    \"\"\"Get the image as a zarr array.\n\n    Args:\n        channel_selection: Select a what subset of channels to return.\n            If None, all channels are returned.\n        axes_order: The order of the axes to return the array.\n        transforms: The transforms to apply to the array.\n        mode: The object type to return.\n            Can be \"dask\", \"numpy\".\n        **slicing_kwargs: The slices to get the array.\n\n    Returns:\n        The zarr array of the region of interest.\n    \"\"\"\n    _slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self, channel_selection=channel_selection, slicing_dict=slicing_kwargs\n    )\n    return self._get_array(\n        axes_order=axes_order, mode=mode, transforms=transforms, **_slicing_kwargs\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Image.get_roi","title":"get_roi","text":"<pre><code>get_roi(\n    roi: Roi,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    mode: Literal[\"numpy\", \"dask\"] = \"numpy\",\n    **slicing_kwargs: SlicingInputType,\n) -&gt; ndarray | Array\n</code></pre> <p>Get the image as a zarr array for a region of interest.</p> <p>Parameters:</p> <ul> <li> <code>roi</code>               (<code>Roi</code>)           \u2013            <p>The region of interest to get the array.</p> </li> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Select a what subset of channels to return. If None, all channels are returned.</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The order of the axes to return the array.</p> </li> <li> <code>transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>The transforms to apply to the array.</p> </li> <li> <code>mode</code>               (<code>Literal['numpy', 'dask']</code>, default:                   <code>'numpy'</code> )           \u2013            <p>The object type to return. Can be \"dask\", \"numpy\".</p> </li> <li> <code>**slicing_kwargs</code>               (<code>SlicingInputType</code>, default:                   <code>{}</code> )           \u2013            <p>The slices to get the array.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray | Array</code>           \u2013            <p>The zarr array of the region of interest.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def get_roi(\n    self,\n    roi: Roi,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    mode: Literal[\"numpy\", \"dask\"] = \"numpy\",\n    **slicing_kwargs: SlicingInputType,\n) -&gt; np.ndarray | da.Array:\n    \"\"\"Get the image as a zarr array for a region of interest.\n\n    Args:\n        roi: The region of interest to get the array.\n        channel_selection: Select a what subset of channels to return.\n            If None, all channels are returned.\n        axes_order: The order of the axes to return the array.\n        transforms: The transforms to apply to the array.\n        mode: The object type to return.\n            Can be \"dask\", \"numpy\".\n        **slicing_kwargs: The slices to get the array.\n\n    Returns:\n        The zarr array of the region of interest.\n    \"\"\"\n    _slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self, channel_selection=channel_selection, slicing_dict=slicing_kwargs\n    )\n    return self._get_roi(\n        roi=roi,\n        axes_order=axes_order,\n        mode=mode,\n        transforms=transforms,\n        **_slicing_kwargs,\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Image.set_array","title":"set_array","text":"<pre><code>set_array(\n    patch: ndarray | Array,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; None\n</code></pre> <p>Set the image array.</p> <p>Parameters:</p> <ul> <li> <code>patch</code>               (<code>ndarray | Array</code>)           \u2013            <p>The array to set.</p> </li> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Select a what subset of channels to return. If None, all channels are set.</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The order of the axes to set the array.</p> </li> <li> <code>transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>The transforms to apply to the array.</p> </li> <li> <code>**slicing_kwargs</code>               (<code>SlicingInputType</code>, default:                   <code>{}</code> )           \u2013            <p>The slices to set the array.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def set_array(\n    self,\n    patch: np.ndarray | da.Array,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; None:\n    \"\"\"Set the image array.\n\n    Args:\n        patch: The array to set.\n        channel_selection: Select a what subset of channels to return.\n            If None, all channels are set.\n        axes_order: The order of the axes to set the array.\n        transforms: The transforms to apply to the array.\n        **slicing_kwargs: The slices to set the array.\n    \"\"\"\n    _slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self, channel_selection=channel_selection, slicing_dict=slicing_kwargs\n    )\n    self._set_array(\n        patch=patch, axes_order=axes_order, transforms=transforms, **_slicing_kwargs\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Image.set_roi","title":"set_roi","text":"<pre><code>set_roi(\n    roi: Roi,\n    patch: ndarray | Array,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; None\n</code></pre> <p>Set the image array for a region of interest.</p> <p>Parameters:</p> <ul> <li> <code>roi</code>               (<code>Roi</code>)           \u2013            <p>The region of interest to set the array.</p> </li> <li> <code>patch</code>               (<code>ndarray | Array</code>)           \u2013            <p>The array to set.</p> </li> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Select a what subset of channels to return.</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The order of the axes to set the array.</p> </li> <li> <code>transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>The transforms to apply to the array.</p> </li> <li> <code>**slicing_kwargs</code>               (<code>SlicingInputType</code>, default:                   <code>{}</code> )           \u2013            <p>The slices to set the array.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def set_roi(\n    self,\n    roi: Roi,\n    patch: np.ndarray | da.Array,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; None:\n    \"\"\"Set the image array for a region of interest.\n\n    Args:\n        roi: The region of interest to set the array.\n        patch: The array to set.\n        channel_selection: Select a what subset of channels to return.\n        axes_order: The order of the axes to set the array.\n        transforms: The transforms to apply to the array.\n        **slicing_kwargs: The slices to set the array.\n    \"\"\"\n    _slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self, channel_selection=channel_selection, slicing_dict=slicing_kwargs\n    )\n    self._set_roi(\n        roi=roi,\n        patch=patch,\n        axes_order=axes_order,\n        transforms=transforms,\n        **_slicing_kwargs,\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Image.consolidate","title":"consolidate","text":"<pre><code>consolidate(\n    order: InterpolationOrder = \"linear\",\n    mode: Literal[\"dask\", \"numpy\", \"coarsen\"] = \"dask\",\n) -&gt; None\n</code></pre> <p>Consolidate the label on disk.</p> Source code in <code>ngio/images/_image.py</code> <pre><code>def consolidate(\n    self,\n    order: InterpolationOrder = \"linear\",\n    mode: Literal[\"dask\", \"numpy\", \"coarsen\"] = \"dask\",\n) -&gt; None:\n    \"\"\"Consolidate the label on disk.\"\"\"\n    self._consolidate(order=order, mode=mode)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.ImagesContainer","title":"ImagesContainer","text":"<pre><code>ImagesContainer(\n    group_handler: ZarrGroupHandler,\n    axes_setup: AxesSetup | None,\n    version: NgffVersions | None = None,\n    validate_paths: bool = True,\n)\n</code></pre> <p>A class to handle the /images group in an OME-NGFF file.</p> <p>Initialize the ImagesContainer.</p> Source code in <code>ngio/images/_image.py</code> <pre><code>def __init__(\n    self,\n    group_handler: ZarrGroupHandler,\n    axes_setup: AxesSetup | None,\n    version: NgffVersions | None = None,\n    validate_paths: bool = True,\n) -&gt; None:\n    \"\"\"Initialize the ImagesContainer.\"\"\"\n    self._group_handler = group_handler\n    self._meta_handler = ImageMetaHandler(\n        group_handler=group_handler, axes_setup=axes_setup, version=version\n    )\n    if validate_paths:\n        for level_path in self._meta_handler.get_meta().paths:\n            self.get(path=level_path)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.ImagesContainer.meta","title":"meta  <code>property</code>","text":"<pre><code>meta: NgioImageMeta\n</code></pre> <p>Return the metadata.</p>"},{"location":"api/ngio/images/#ngio.images.ImagesContainer.channels_meta","title":"channels_meta  <code>property</code>","text":"<pre><code>channels_meta: ChannelsMeta\n</code></pre> <p>Return the channels metadata.</p>"},{"location":"api/ngio/images/#ngio.images.ImagesContainer.axes_setup","title":"axes_setup  <code>property</code>","text":"<pre><code>axes_setup: AxesSetup\n</code></pre> <p>Return the axes setup.</p>"},{"location":"api/ngio/images/#ngio.images.ImagesContainer.level_paths","title":"level_paths  <code>property</code>","text":"<pre><code>level_paths: list[str]\n</code></pre> <p>Return the paths of the levels in the image.</p>"},{"location":"api/ngio/images/#ngio.images.ImagesContainer.levels_paths","title":"levels_paths  <code>property</code>","text":"<pre><code>levels_paths: list[str]\n</code></pre> <p>Deprecated: use 'level_paths' instead.</p>"},{"location":"api/ngio/images/#ngio.images.ImagesContainer.levels","title":"levels  <code>property</code>","text":"<pre><code>levels: int\n</code></pre> <p>Return the number of levels in the image.</p>"},{"location":"api/ngio/images/#ngio.images.ImagesContainer.is_3d","title":"is_3d  <code>property</code>","text":"<pre><code>is_3d: bool\n</code></pre> <p>Return True if the image is 3D.</p>"},{"location":"api/ngio/images/#ngio.images.ImagesContainer.is_2d","title":"is_2d  <code>property</code>","text":"<pre><code>is_2d: bool\n</code></pre> <p>Return True if the image is 2D.</p>"},{"location":"api/ngio/images/#ngio.images.ImagesContainer.is_time_series","title":"is_time_series  <code>property</code>","text":"<pre><code>is_time_series: bool\n</code></pre> <p>Return True if the image is a time series.</p>"},{"location":"api/ngio/images/#ngio.images.ImagesContainer.is_2d_time_series","title":"is_2d_time_series  <code>property</code>","text":"<pre><code>is_2d_time_series: bool\n</code></pre> <p>Return True if the image is a 2D time series.</p>"},{"location":"api/ngio/images/#ngio.images.ImagesContainer.is_3d_time_series","title":"is_3d_time_series  <code>property</code>","text":"<pre><code>is_3d_time_series: bool\n</code></pre> <p>Return True if the image is a 3D time series.</p>"},{"location":"api/ngio/images/#ngio.images.ImagesContainer.is_multi_channels","title":"is_multi_channels  <code>property</code>","text":"<pre><code>is_multi_channels: bool\n</code></pre> <p>Return True if the image is multichannel.</p>"},{"location":"api/ngio/images/#ngio.images.ImagesContainer.space_unit","title":"space_unit  <code>property</code>","text":"<pre><code>space_unit: str | None\n</code></pre> <p>Return the space unit of the image.</p>"},{"location":"api/ngio/images/#ngio.images.ImagesContainer.time_unit","title":"time_unit  <code>property</code>","text":"<pre><code>time_unit: str | None\n</code></pre> <p>Return the time unit of the image.</p>"},{"location":"api/ngio/images/#ngio.images.ImagesContainer.channel_labels","title":"channel_labels  <code>property</code>","text":"<pre><code>channel_labels: list[str]\n</code></pre> <p>Return the channels of the image.</p>"},{"location":"api/ngio/images/#ngio.images.ImagesContainer.wavelength_ids","title":"wavelength_ids  <code>property</code>","text":"<pre><code>wavelength_ids: list[str | None]\n</code></pre> <p>Return the list of wavelength of the image.</p>"},{"location":"api/ngio/images/#ngio.images.ImagesContainer.num_channels","title":"num_channels  <code>property</code>","text":"<pre><code>num_channels: int\n</code></pre> <p>Return the number of channels.</p>"},{"location":"api/ngio/images/#ngio.images.ImagesContainer.get_channel_idx","title":"get_channel_idx","text":"<pre><code>get_channel_idx(\n    channel_label: str | None = None,\n    wavelength_id: str | None = None,\n) -&gt; int\n</code></pre> <p>Get the index of a channel by its label or wavelength ID.</p> Source code in <code>ngio/images/_image.py</code> <pre><code>def get_channel_idx(\n    self, channel_label: str | None = None, wavelength_id: str | None = None\n) -&gt; int:\n    \"\"\"Get the index of a channel by its label or wavelength ID.\"\"\"\n    return self.channels_meta.get_channel_idx(\n        channel_label=channel_label, wavelength_id=wavelength_id\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.ImagesContainer.set_channel_meta","title":"set_channel_meta","text":"<pre><code>set_channel_meta(\n    channel_meta: ChannelsMeta | None = None,\n    labels: Sequence[str | None] | int | None = None,\n    wavelength_id: Sequence[str | None] | None = None,\n    start: Sequence[float | None] | None = None,\n    end: Sequence[float | None] | None = None,\n    percentiles: tuple[float, float] | None = None,\n    colors: Sequence[str | None] | None = None,\n    active: Sequence[bool | None] | None = None,\n    **omero_kwargs: dict,\n) -&gt; None\n</code></pre> <p>Create a ChannelsMeta object with the default unit.</p> <p>Parameters:</p> <ul> <li> <code>channel_meta</code>               (<code>ChannelsMeta | None</code>, default:                   <code>None</code> )           \u2013            <p>The channels metadata to set. If none, it will fall back to the deprecated parameters.</p> </li> <li> <code>labels</code>               (<code>Sequence[str | None] | int</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. The list of channels names in the image. If an integer is provided, the channels will be named \"channel_i\".</p> </li> <li> <code>wavelength_id</code>               (<code>Sequence[str | None]</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. The wavelength ID of the channel. If None, the wavelength ID will be the same as the channel name.</p> </li> <li> <code>start</code>               (<code>Sequence[float | None]</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. The start value for each channel. If None, the start value will be computed from the image.</p> </li> <li> <code>end</code>               (<code>Sequence[float | None]</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. The end value for each channel. If None, the end value will be computed from the image.</p> </li> <li> <code>percentiles</code>               (<code>tuple[float, float] | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. The start and end percentiles for each channel. If None, the percentiles will not be computed.</p> </li> <li> <code>colors</code>               (<code>Sequence[str | None]</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. The list of colors for the channels. If None, the colors will be random.</p> </li> <li> <code>active</code>               (<code>Sequence[bool | None]</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Whether the channel should be shown by default.</p> </li> <li> <code>omero_kwargs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Deprecated. Extra fields to store in the omero attributes.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def set_channel_meta(\n    self,\n    channel_meta: ChannelsMeta | None = None,\n    labels: Sequence[str | None] | int | None = None,\n    wavelength_id: Sequence[str | None] | None = None,\n    start: Sequence[float | None] | None = None,\n    end: Sequence[float | None] | None = None,\n    percentiles: tuple[float, float] | None = None,\n    colors: Sequence[str | None] | None = None,\n    active: Sequence[bool | None] | None = None,\n    **omero_kwargs: dict,\n) -&gt; None:\n    \"\"\"Create a ChannelsMeta object with the default unit.\n\n    Args:\n        channel_meta (ChannelsMeta | None): The channels metadata to set.\n            If none, it will fall back to the deprecated parameters.\n        labels(Sequence[str | None] | int): Deprecated. The list of channels names\n            in the image. If an integer is provided, the channels will\n            be named \"channel_i\".\n        wavelength_id(Sequence[str | None]): Deprecated. The wavelength ID of the\n            channel. If None, the wavelength ID will be the same as\n            the channel name.\n        start(Sequence[float | None]): Deprecated. The start value for each channel.\n            If None, the start value will be computed from the image.\n        end(Sequence[float | None]): Deprecated. The end value for each channel.\n            If None, the end value will be computed from the image.\n        percentiles(tuple[float, float] | None): Deprecated. The start and end\n            percentiles for each channel. If None, the percentiles will\n            not be computed.\n        colors(Sequence[str | None]): Deprecated. The list of colors for the\n            channels. If None, the colors will be random.\n        active (Sequence[bool | None]): Deprecated. Whether the channel should\n            be shown by default.\n        omero_kwargs(dict): Deprecated. Extra fields to store in the omero\n            attributes.\n    \"\"\"\n    _is_legacy = any(\n        param is not None\n        for param in [\n            labels,\n            wavelength_id,\n            start,\n            end,\n            percentiles,\n            colors,\n            active,\n        ]\n    )\n    if _is_legacy:\n        logger.warning(\n            \"The following parameters are deprecated and will be removed in \"\n            \"ngio=0.6: labels, wavelength_id, start, end, percentiles, \"\n            \"colors, active, omero_kwargs. Please use the \"\n            \"'channel_meta' parameter instead.\"\n        )\n        self._set_channel_meta_legacy(\n            labels=labels,\n            wavelength_id=wavelength_id,\n            start=start,\n            end=end,\n            percentiles=percentiles,\n            colors=colors,\n            active=active,\n            **omero_kwargs,\n        )\n        return None\n    self._set_channel_meta(channel_meta)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.ImagesContainer.set_channel_labels","title":"set_channel_labels","text":"<pre><code>set_channel_labels(labels: Sequence[str]) -&gt; None\n</code></pre> <p>Update the labels of the channels.</p> <p>Parameters:</p> <ul> <li> <code>labels</code>               (<code>Sequence[str]</code>)           \u2013            <p>The new labels for the channels.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def set_channel_labels(\n    self,\n    labels: Sequence[str],\n) -&gt; None:\n    \"\"\"Update the labels of the channels.\n\n    Args:\n        labels (Sequence[str]): The new labels for the channels.\n    \"\"\"\n    channels_meta = self.channels_meta\n    if len(labels) != len(channels_meta.channels):\n        raise NgioValueError(\n            \"The number of labels must match the number of channels.\"\n        )\n    new_channels = []\n    for label, ch in zip(labels, channels_meta.channels, strict=True):\n        channel = ch.model_copy(update={\"label\": label})\n        new_channels.append(channel)\n    new_meta = channels_meta.model_copy(update={\"channels\": new_channels})\n    self._set_channel_meta(new_meta)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.ImagesContainer.set_channel_colors","title":"set_channel_colors","text":"<pre><code>set_channel_colors(colors: Sequence[str]) -&gt; None\n</code></pre> <p>Update the colors of the channels.</p> <p>Parameters:</p> <ul> <li> <code>colors</code>               (<code>Sequence[str]</code>)           \u2013            <p>The new colors for the channels.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def set_channel_colors(\n    self,\n    colors: Sequence[str],\n) -&gt; None:\n    \"\"\"Update the colors of the channels.\n\n    Args:\n        colors (Sequence[str]): The new colors for the channels.\n    \"\"\"\n    channel_meta = self.channels_meta\n    if len(colors) != len(channel_meta.channels):\n        raise NgioValueError(\n            \"The number of colors must match the number of channels.\"\n        )\n    new_channels = []\n    for color, ch in zip(colors, channel_meta.channels, strict=True):\n        ch_visualisation = ch.channel_visualisation.model_copy(\n            update={\"color\": color}\n        )\n        channel = ch.model_copy(update={\"channel_visualisation\": ch_visualisation})\n        new_channels.append(channel)\n    new_meta = channel_meta.model_copy(update={\"channels\": new_channels})\n    self._set_channel_meta(new_meta)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.ImagesContainer.set_channel_percentiles","title":"set_channel_percentiles","text":"<pre><code>set_channel_percentiles(\n    start_percentile: float = 0.1,\n    end_percentile: float = 99.9,\n) -&gt; None\n</code></pre> <p>Deprecated: Update the channel windows using percentiles.</p> <p>Parameters:</p> <ul> <li> <code>start_percentile</code>               (<code>float</code>, default:                   <code>0.1</code> )           \u2013            <p>The start percentile.</p> </li> <li> <code>end_percentile</code>               (<code>float</code>, default:                   <code>99.9</code> )           \u2013            <p>The end percentile.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def set_channel_percentiles(\n    self,\n    start_percentile: float = 0.1,\n    end_percentile: float = 99.9,\n) -&gt; None:\n    \"\"\"Deprecated: Update the channel windows using percentiles.\n\n    Args:\n        start_percentile (float): The start percentile.\n        end_percentile (float): The end percentile.\n    \"\"\"\n    logger.warning(\n        \"The 'set_channel_percentiles' method is deprecated and will be removed in \"\n        \"ngio=0.6. Please use 'set_channel_windows_with_percentiles' instead.\"\n    )\n    self.set_channel_windows_with_percentiles(\n        percentiles=(start_percentile, end_percentile)\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.ImagesContainer.set_channel_windows","title":"set_channel_windows","text":"<pre><code>set_channel_windows(\n    starts_ends: Sequence[tuple[float, float]],\n    min_max: Sequence[tuple[float, float]] | None = None,\n) -&gt; None\n</code></pre> <p>Update the channel windows.</p> <p>These values are used by viewers to set the display range of each channel.</p> <p>Parameters:</p> <ul> <li> <code>starts_ends</code>               (<code>Sequence[tuple[float, float]]</code>)           \u2013            <p>The start and end values for each channel.</p> </li> <li> <code>min_max</code>               (<code>Sequence[tuple[float, float]] | None</code>, default:                   <code>None</code> )           \u2013            <p>The min and max values for each channel. If None, the min and max values will not be updated.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def set_channel_windows(\n    self,\n    starts_ends: Sequence[tuple[float, float]],\n    min_max: Sequence[tuple[float, float]] | None = None,\n) -&gt; None:\n    \"\"\"Update the channel windows.\n\n    These values are used by viewers to set the display\n    range of each channel.\n\n    Args:\n        starts_ends (Sequence[tuple[float, float]]): The start and end values\n            for each channel.\n        min_max (Sequence[tuple[float, float]] | None): The min and max values\n            for each channel. If None, the min and max values will not be updated.\n    \"\"\"\n    current_channels = self.channels_meta.channels\n    if len(starts_ends) != len(current_channels):\n        raise NgioValueError(\n            \"The number of start-end pairs must match the number of channels.\"\n        )\n    if min_max is not None and len(min_max) != len(current_channels):\n        raise NgioValueError(\n            \"The number of min-max pairs must match the number of channels.\"\n        )\n    if min_max is None:\n        min_max_ = [None] * len(current_channels)\n    else:\n        min_max_ = list(min_max)\n    channels = []\n    for se, mm, ch in zip(\n        starts_ends, min_max_, self.channels_meta.channels, strict=True\n    ):\n        updates = {\"start\": se[0], \"end\": se[1]}\n        if mm is not None:\n            updates.update({\"min\": mm[0], \"max\": mm[1]})\n        channel_visualisation = ch.channel_visualisation.model_copy(update=updates)\n        channel = ch.model_copy(\n            update={\"channel_visualisation\": channel_visualisation}\n        )\n        channels.append(channel)\n    new_meta = ChannelsMeta(channels=channels)\n    meta = self.meta\n    meta.set_channels_meta(new_meta)\n    self._meta_handler.update_meta(meta)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.ImagesContainer.set_channel_windows_with_percentiles","title":"set_channel_windows_with_percentiles","text":"<pre><code>set_channel_windows_with_percentiles(\n    percentiles: tuple[float, float]\n    | list[tuple[float, float]] = (0.1, 99.9),\n) -&gt; None\n</code></pre> <p>Update the channel windows using percentiles.</p> <p>Parameters:</p> <ul> <li> <code>percentiles</code>               (<code>tuple[float, float] | list[tuple[float, float]]</code>, default:                   <code>(0.1, 99.9)</code> )           \u2013            <p>The start and end percentiles for each channel. If a single tuple is provided, the same percentiles will be used for all channels.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def set_channel_windows_with_percentiles(\n    self,\n    percentiles: tuple[float, float] | list[tuple[float, float]] = (0.1, 99.9),\n) -&gt; None:\n    \"\"\"Update the channel windows using percentiles.\n\n    Args:\n        percentiles (tuple[float, float] | list[tuple[float, float]]):\n            The start and end percentiles for each channel.\n            If a single tuple is provided,\n            the same percentiles will be used for all channels.\n    \"\"\"\n    low_res_dataset = self.meta.get_lowest_resolution_dataset()\n    ref_image = self.get(path=low_res_dataset.path)\n    starts_ends = compute_image_percentile(ref_image, percentiles=percentiles)\n    self.set_channel_windows(starts_ends=starts_ends)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.ImagesContainer.set_axes_unit","title":"set_axes_unit","text":"<pre><code>set_axes_unit(\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n) -&gt; None\n</code></pre> <p>Set the axes unit of the image.</p> <p>Parameters:</p> <ul> <li> <code>space_unit</code>               (<code>SpaceUnits</code>, default:                   <code>DefaultSpaceUnit</code> )           \u2013            <p>The space unit of the image.</p> </li> <li> <code>time_unit</code>               (<code>TimeUnits</code>, default:                   <code>DefaultTimeUnit</code> )           \u2013            <p>The time unit of the image.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def set_axes_unit(\n    self,\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n) -&gt; None:\n    \"\"\"Set the axes unit of the image.\n\n    Args:\n        space_unit (SpaceUnits): The space unit of the image.\n        time_unit (TimeUnits): The time unit of the image.\n    \"\"\"\n    self.get().set_axes_unit(space_unit=space_unit, time_unit=time_unit)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.ImagesContainer.set_axes_names","title":"set_axes_names","text":"<pre><code>set_axes_names(axes_names: Sequence[str]) -&gt; None\n</code></pre> <p>Set the axes names of the image.</p> <p>Parameters:</p> <ul> <li> <code>axes_names</code>               (<code>Sequence[str]</code>)           \u2013            <p>The axes names of the image.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def set_axes_names(\n    self,\n    axes_names: Sequence[str],\n) -&gt; None:\n    \"\"\"Set the axes names of the image.\n\n    Args:\n        axes_names (Sequence[str]): The axes names of the image.\n    \"\"\"\n    image = self.get()\n    image.set_axes_names(axes_names=axes_names)\n    self._meta_handler._axes_setup = image.meta.axes_handler.axes_setup\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.ImagesContainer.set_name","title":"set_name","text":"<pre><code>set_name(name: str) -&gt; None\n</code></pre> <p>Set the name of the image in the metadata.</p> <p>This does not change the group name or any paths.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the image.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def set_name(\n    self,\n    name: str,\n) -&gt; None:\n    \"\"\"Set the name of the image in the metadata.\n\n    This does not change the group name or any paths.\n\n    Args:\n        name (str): The name of the image.\n    \"\"\"\n    self.get().set_name(name=name)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.ImagesContainer.derive","title":"derive","text":"<pre><code>derive(\n    store: StoreOrGroup,\n    ref_path: str | None = None,\n    shape: Sequence[int] | None = None,\n    pixelsize: float | tuple[float, float] | None = None,\n    z_spacing: float | None = None,\n    time_spacing: float | None = None,\n    name: str | None = None,\n    translation: Sequence[float] | None = None,\n    channels_meta: Sequence[str | Channel] | None = None,\n    channels_policy: Literal[\"same\", \"squeeze\", \"singleton\"]\n    | int = \"same\",\n    ngff_version: NgffVersions | None = None,\n    chunks: ChunksLike | None = None,\n    shards: ShardsLike | None = None,\n    dtype: str = \"uint16\",\n    dimension_separator: Literal[\".\", \"/\"] = \"/\",\n    compressors: CompressorLike = \"auto\",\n    extra_array_kwargs: Mapping[str, Any] | None = None,\n    overwrite: bool = False,\n    labels: Sequence[str] | None = None,\n    pixel_size: PixelSize | None = None,\n) -&gt; ImagesContainer\n</code></pre> <p>Create an empty OME-Zarr image from an existing image.</p> <p>If a kwarg is not provided, the value from the reference image will be used.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group to create the image in.</p> </li> <li> <code>ref_path</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the reference image in the image container.</p> </li> <li> <code>shape</code>               (<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The shape of the new image.</p> </li> <li> <code>pixelsize</code>               (<code>float | tuple[float, float] | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the new image.</p> </li> <li> <code>z_spacing</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>The z spacing of the new image.</p> </li> <li> <code>time_spacing</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>The time spacing of the new image.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the new image.</p> </li> <li> <code>translation</code>               (<code>Sequence[float] | None</code>, default:                   <code>None</code> )           \u2013            <p>The translation for each axis at the highest resolution level. Defaults to None.</p> </li> <li> <code>channels_meta</code>               (<code>Sequence[str | Channel] | None</code>, default:                   <code>None</code> )           \u2013            <p>The channels metadata of the new image.</p> </li> <li> <code>channels_policy</code>               (<code>Literal['same', 'squeeze', 'singleton'] | int</code>, default:                   <code>'same'</code> )           \u2013            <p>Possible policies: - If \"squeeze\", the channels axis will be removed (no matter its size). - If \"same\", the channels axis will be kept as is (if it exists). - If \"singleton\", the channels axis will be set to size 1. - If an integer is provided, the channels axis will be changed to have     that size.</p> </li> <li> <code>ngff_version</code>               (<code>NgffVersions | None</code>, default:                   <code>None</code> )           \u2013            <p>The NGFF version to use.</p> </li> <li> <code>chunks</code>               (<code>ChunksLike | None</code>, default:                   <code>None</code> )           \u2013            <p>The chunk shape of the new image.</p> </li> <li> <code>shards</code>               (<code>ShardsLike | None</code>, default:                   <code>None</code> )           \u2013            <p>The shard shape of the new image.</p> </li> <li> <code>dtype</code>               (<code>str | None</code>, default:                   <code>'uint16'</code> )           \u2013            <p>The data type of the new image.</p> </li> <li> <code>dimension_separator</code>               (<code>Literal['.', '/'] | None</code>, default:                   <code>'/'</code> )           \u2013            <p>The separator to use for dimensions.</p> </li> <li> <code>compressors</code>               (<code>CompressorLike | None</code>, default:                   <code>'auto'</code> )           \u2013            <p>The compressors to use.</p> </li> <li> <code>extra_array_kwargs</code>               (<code>Mapping[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Extra arguments to pass to the zarr array creation.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to overwrite an existing image.</p> </li> <li> <code>labels</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The labels of the new image. This argument is deprecated please use channels_meta instead.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the new image. This argument is deprecated please use pixelsize, z_spacing, and time_spacing instead.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ImagesContainer</code> (              <code>ImagesContainer</code> )          \u2013            <p>The new derived image.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def derive(\n    self,\n    store: StoreOrGroup,\n    ref_path: str | None = None,\n    # Metadata parameters\n    shape: Sequence[int] | None = None,\n    pixelsize: float | tuple[float, float] | None = None,\n    z_spacing: float | None = None,\n    time_spacing: float | None = None,\n    name: str | None = None,\n    translation: Sequence[float] | None = None,\n    channels_meta: Sequence[str | Channel] | None = None,\n    channels_policy: Literal[\"same\", \"squeeze\", \"singleton\"] | int = \"same\",\n    ngff_version: NgffVersions | None = None,\n    # Zarr Array parameters\n    chunks: ChunksLike | None = None,\n    shards: ShardsLike | None = None,\n    dtype: str = \"uint16\",\n    dimension_separator: Literal[\".\", \"/\"] = \"/\",\n    compressors: CompressorLike = \"auto\",\n    extra_array_kwargs: Mapping[str, Any] | None = None,\n    overwrite: bool = False,\n    # Deprecated arguments\n    labels: Sequence[str] | None = None,\n    pixel_size: PixelSize | None = None,\n) -&gt; \"ImagesContainer\":\n    \"\"\"Create an empty OME-Zarr image from an existing image.\n\n    If a kwarg is not provided, the value from the reference image will be used.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group to create the image in.\n        ref_path (str | None): The path to the reference image in the image\n            container.\n        shape (Sequence[int] | None): The shape of the new image.\n        pixelsize (float | tuple[float, float] | None): The pixel size of the new\n            image.\n        z_spacing (float | None): The z spacing of the new image.\n        time_spacing (float | None): The time spacing of the new image.\n        name (str | None): The name of the new image.\n        translation (Sequence[float] | None): The translation for each axis\n            at the highest resolution level. Defaults to None.\n        channels_meta (Sequence[str | Channel] | None): The channels metadata\n            of the new image.\n        channels_policy (Literal[\"same\", \"squeeze\", \"singleton\"] | int):\n            Possible policies:\n            - If \"squeeze\", the channels axis will be removed (no matter its size).\n            - If \"same\", the channels axis will be kept as is (if it exists).\n            - If \"singleton\", the channels axis will be set to size 1.\n            - If an integer is provided, the channels axis will be changed to have\n                that size.\n        ngff_version (NgffVersions | None): The NGFF version to use.\n        chunks (ChunksLike | None): The chunk shape of the new image.\n        shards (ShardsLike | None): The shard shape of the new image.\n        dtype (str | None): The data type of the new image.\n        dimension_separator (Literal[\".\", \"/\"] | None): The separator to use for\n            dimensions.\n        compressors (CompressorLike | None): The compressors to use.\n        extra_array_kwargs (Mapping[str, Any] | None): Extra arguments to pass to\n            the zarr array creation.\n        overwrite (bool): Whether to overwrite an existing image.\n        labels (Sequence[str] | None): The labels of the new image.\n            This argument is deprecated please use channels_meta instead.\n        pixel_size (PixelSize | None): The pixel size of the new image.\n            This argument is deprecated please use pixelsize, z_spacing,\n            and time_spacing instead.\n\n    Returns:\n        ImagesContainer: The new derived image.\n\n    \"\"\"\n    return derive_image_container(\n        image_container=self,\n        store=store,\n        ref_path=ref_path,\n        shape=shape,\n        pixelsize=pixelsize,\n        z_spacing=z_spacing,\n        time_spacing=time_spacing,\n        name=name,\n        translation=translation,\n        channels_meta=channels_meta,\n        channels_policy=channels_policy,\n        ngff_version=ngff_version,\n        chunks=chunks,\n        shards=shards,\n        dtype=dtype,\n        dimension_separator=dimension_separator,\n        compressors=compressors,\n        extra_array_kwargs=extra_array_kwargs,\n        overwrite=overwrite,\n        labels=labels,\n        pixel_size=pixel_size,\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.ImagesContainer.get","title":"get","text":"<pre><code>get(\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; Image\n</code></pre> <p>Get an image at a specific level.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the image in the ome_zarr file.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the image.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Only used if the pixel size is provided. If True, the pixel size must match the image pixel size exactly. If False, the closest pixel size level will be returned.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def get(\n    self,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; Image:\n    \"\"\"Get an image at a specific level.\n\n    Args:\n        path (str | None): The path to the image in the ome_zarr file.\n        pixel_size (PixelSize | None): The pixel size of the image.\n        strict (bool): Only used if the pixel size is provided. If True, the\n            pixel size must match the image pixel size exactly. If False, the\n            closest pixel size level will be returned.\n\n    \"\"\"\n    dataset = self._meta_handler.get_meta().get_dataset(\n        path=path, pixel_size=pixel_size, strict=strict\n    )\n    return Image(\n        group_handler=self._group_handler,\n        path=dataset.path,\n        meta_handler=self._meta_handler,\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Label","title":"Label","text":"<pre><code>Label(\n    group_handler: ZarrGroupHandler,\n    path: str,\n    meta_handler: LabelMetaHandler,\n)\n</code></pre> <p>               Bases: <code>AbstractImage</code></p> <p>Placeholder class for a label.</p> <p>Initialize the Image at a single level.</p> <p>Parameters:</p> <ul> <li> <code>group_handler</code>               (<code>ZarrGroupHandler</code>)           \u2013            <p>The Zarr group handler.</p> </li> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path to the image in the ome_zarr file.</p> </li> <li> <code>meta_handler</code>               (<code>LabelMetaHandler</code>)           \u2013            <p>The image metadata handler.</p> </li> </ul> Source code in <code>ngio/images/_label.py</code> <pre><code>def __init__(\n    self,\n    group_handler: ZarrGroupHandler,\n    path: str,\n    meta_handler: LabelMetaHandler,\n) -&gt; None:\n    \"\"\"Initialize the Image at a single level.\n\n    Args:\n        group_handler: The Zarr group handler.\n        path: The path to the image in the ome_zarr file.\n        meta_handler: The image metadata handler.\n\n    \"\"\"\n    super().__init__(\n        group_handler=group_handler, path=path, meta_handler=meta_handler\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Label.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Return the path of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Label.dataset","title":"dataset  <code>property</code>","text":"<pre><code>dataset: Dataset\n</code></pre> <p>Return the dataset of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Label.dimensions","title":"dimensions  <code>property</code>","text":"<pre><code>dimensions: Dimensions\n</code></pre> <p>Return the dimensions of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Label.pixel_size","title":"pixel_size  <code>property</code>","text":"<pre><code>pixel_size: PixelSize\n</code></pre> <p>Return the pixel size of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Label.axes_handler","title":"axes_handler  <code>property</code>","text":"<pre><code>axes_handler: AxesHandler\n</code></pre> <p>Return the axes handler of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Label.axes_setup","title":"axes_setup  <code>property</code>","text":"<pre><code>axes_setup: AxesSetup\n</code></pre> <p>Return the axes setup of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Label.axes","title":"axes  <code>property</code>","text":"<pre><code>axes: tuple[str, ...]\n</code></pre> <p>Return the axes of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Label.zarr_array","title":"zarr_array  <code>property</code>","text":"<pre><code>zarr_array: Array\n</code></pre> <p>Return the Zarr array.</p>"},{"location":"api/ngio/images/#ngio.images.Label.shape","title":"shape  <code>property</code>","text":"<pre><code>shape: tuple[int, ...]\n</code></pre> <p>Return the shape of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Label.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype: str\n</code></pre> <p>Return the dtype of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Label.chunks","title":"chunks  <code>property</code>","text":"<pre><code>chunks: tuple[int, ...]\n</code></pre> <p>Return the chunks of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Label.is_3d","title":"is_3d  <code>property</code>","text":"<pre><code>is_3d: bool\n</code></pre> <p>Return True if the image is 3D.</p>"},{"location":"api/ngio/images/#ngio.images.Label.is_2d","title":"is_2d  <code>property</code>","text":"<pre><code>is_2d: bool\n</code></pre> <p>Return True if the image is 2D.</p>"},{"location":"api/ngio/images/#ngio.images.Label.is_time_series","title":"is_time_series  <code>property</code>","text":"<pre><code>is_time_series: bool\n</code></pre> <p>Return True if the image is a time series.</p>"},{"location":"api/ngio/images/#ngio.images.Label.is_2d_time_series","title":"is_2d_time_series  <code>property</code>","text":"<pre><code>is_2d_time_series: bool\n</code></pre> <p>Return True if the image is a 2D time series.</p>"},{"location":"api/ngio/images/#ngio.images.Label.is_3d_time_series","title":"is_3d_time_series  <code>property</code>","text":"<pre><code>is_3d_time_series: bool\n</code></pre> <p>Return True if the image is a 3D time series.</p>"},{"location":"api/ngio/images/#ngio.images.Label.is_multi_channels","title":"is_multi_channels  <code>property</code>","text":"<pre><code>is_multi_channels: bool\n</code></pre> <p>Return True if the image is multichannel.</p>"},{"location":"api/ngio/images/#ngio.images.Label.space_unit","title":"space_unit  <code>property</code>","text":"<pre><code>space_unit: str | None\n</code></pre> <p>Return the space unit of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Label.time_unit","title":"time_unit  <code>property</code>","text":"<pre><code>time_unit: str | None\n</code></pre> <p>Return the time unit of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Label.get_as_numpy","title":"get_as_numpy  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_as_numpy = _get_as_numpy\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Label.get_as_dask","title":"get_as_dask  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_as_dask = _get_as_dask\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Label.get_array","title":"get_array  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_array = _get_array\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Label.get_roi_as_numpy","title":"get_roi_as_numpy  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_roi_as_numpy = _get_roi_as_numpy\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Label.get_roi_as_dask","title":"get_roi_as_dask  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_roi_as_dask = _get_roi_as_dask\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Label.get_roi","title":"get_roi  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_roi = _get_roi\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Label.set_array","title":"set_array  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>set_array = _set_array\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Label.set_roi","title":"set_roi  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>set_roi = _set_roi\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Label.meta_handler","title":"meta_handler  <code>property</code>","text":"<pre><code>meta_handler: LabelMetaHandler\n</code></pre> <p>Return the metadata handler.</p>"},{"location":"api/ngio/images/#ngio.images.Label.meta","title":"meta  <code>property</code>","text":"<pre><code>meta: NgioLabelMeta\n</code></pre> <p>Return the metadata.</p>"},{"location":"api/ngio/images/#ngio.images.Label.has_axis","title":"has_axis","text":"<pre><code>has_axis(axis: str) -&gt; bool\n</code></pre> <p>Return True if the image has the given axis.</p> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def has_axis(self, axis: str) -&gt; bool:\n    \"\"\"Return True if the image has the given axis.\"\"\"\n    return self.axes_handler.has_axis(axis)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Label.set_axes_unit","title":"set_axes_unit","text":"<pre><code>set_axes_unit(\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n) -&gt; None\n</code></pre> <p>Set the axes unit of the image.</p> <p>Parameters:</p> <ul> <li> <code>space_unit</code>               (<code>SpaceUnits</code>, default:                   <code>DefaultSpaceUnit</code> )           \u2013            <p>The space unit of the image.</p> </li> <li> <code>time_unit</code>               (<code>TimeUnits</code>, default:                   <code>DefaultTimeUnit</code> )           \u2013            <p>The time unit of the image.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def set_axes_unit(\n    self,\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n) -&gt; None:\n    \"\"\"Set the axes unit of the image.\n\n    Args:\n        space_unit (SpaceUnits): The space unit of the image.\n        time_unit (TimeUnits): The time unit of the image.\n    \"\"\"\n    meta = self._meta_handler.get_meta()\n    meta = meta.to_units(space_unit=space_unit, time_unit=time_unit)\n    self._meta_handler.update_meta(meta)  # type: ignore\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Label.set_axes_names","title":"set_axes_names","text":"<pre><code>set_axes_names(axes_names: Sequence[str]) -&gt; None\n</code></pre> <p>Set the axes names of the label.</p> <p>Parameters:</p> <ul> <li> <code>axes_names</code>               (<code>Sequence[str]</code>)           \u2013            <p>The axes names to set.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def set_axes_names(self, axes_names: Sequence[str]) -&gt; None:\n    \"\"\"Set the axes names of the label.\n\n    Args:\n        axes_names (Sequence[str]): The axes names to set.\n    \"\"\"\n    meta = self._meta_handler.get_meta()\n    meta = meta.rename_axes(axes_names=axes_names)\n    self._meta_handler._axes_setup = meta.axes_handler.axes_setup\n    self._meta_handler.update_meta(meta)  # type: ignore\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Label.set_name","title":"set_name","text":"<pre><code>set_name(name: str) -&gt; None\n</code></pre> <p>Set the name of the image in the metadata.</p> <p>This does not change the group name or any paths.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the image.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def set_name(\n    self,\n    name: str,\n) -&gt; None:\n    \"\"\"Set the name of the image in the metadata.\n\n    This does not change the group name or any paths.\n\n    Args:\n        name (str): The name of the image.\n    \"\"\"\n    meta = self._meta_handler.get_meta()\n    meta = meta.rename_image(name=name)\n    self._meta_handler.update_meta(meta)  # type: ignore\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Label.roi","title":"roi","text":"<pre><code>roi(name: str | None = 'image') -&gt; Roi\n</code></pre> <p>Return the ROI covering the entire image.</p> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def roi(self, name: str | None = \"image\") -&gt; Roi:\n    \"\"\"Return the ROI covering the entire image.\"\"\"\n    slices = {}\n    for ax_name in [\"t\", \"z\", \"y\", \"x\"]:\n        axis_size = self.dimensions.get(ax_name, default=None)\n        if axis_size is None:\n            continue\n        slices[ax_name] = slice(0, axis_size)\n    roi_px = Roi.from_values(name=name, slices=slices, space=\"pixel\")\n    return roi_px.to_world(pixel_size=self.pixel_size)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Label.build_image_roi_table","title":"build_image_roi_table","text":"<pre><code>build_image_roi_table(\n    name: str | None = \"image\",\n) -&gt; RoiTable\n</code></pre> <p>Build the ROI table containing the ROI covering the entire image.</p> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def build_image_roi_table(self, name: str | None = \"image\") -&gt; RoiTable:\n    \"\"\"Build the ROI table containing the ROI covering the entire image.\"\"\"\n    return RoiTable(rois=[self.roi(name=name)])\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Label.require_dimensions_match","title":"require_dimensions_match","text":"<pre><code>require_dimensions_match(\n    other: AbstractImage, allow_singleton: bool = False\n) -&gt; None\n</code></pre> <p>Assert that two images have matching spatial dimensions.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>AbstractImage</code>)           \u2013            <p>The other image to compare to.</p> </li> <li> <code>allow_singleton</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, allow singleton dimensions to be compatible with non-singleton dimensions.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NgioValueError</code>             \u2013            <p>If the images do not have compatible dimensions.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def require_dimensions_match(\n    self,\n    other: \"AbstractImage\",\n    allow_singleton: bool = False,\n) -&gt; None:\n    \"\"\"Assert that two images have matching spatial dimensions.\n\n    Args:\n        other: The other image to compare to.\n        allow_singleton: If True, allow singleton dimensions to be\n            compatible with non-singleton dimensions.\n\n    Raises:\n        NgioValueError: If the images do not have compatible dimensions.\n    \"\"\"\n    self.dimensions.require_dimensions_match(\n        other.dimensions, allow_singleton=allow_singleton\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Label.check_if_dimensions_match","title":"check_if_dimensions_match","text":"<pre><code>check_if_dimensions_match(\n    other: AbstractImage, allow_singleton: bool = False\n) -&gt; bool\n</code></pre> <p>Check if two images have matching spatial dimensions.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>AbstractImage</code>)           \u2013            <p>The other image to compare to.</p> </li> <li> <code>allow_singleton</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, allow singleton dimensions to be compatible with non-singleton dimensions.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the images have matching dimensions, False otherwise.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def check_if_dimensions_match(\n    self,\n    other: \"AbstractImage\",\n    allow_singleton: bool = False,\n) -&gt; bool:\n    \"\"\"Check if two images have matching spatial dimensions.\n\n    Args:\n        other: The other image to compare to.\n        allow_singleton: If True, allow singleton dimensions to be\n            compatible with non-singleton dimensions.\n\n    Returns:\n        bool: True if the images have matching dimensions, False otherwise.\n    \"\"\"\n    return self.dimensions.check_if_dimensions_match(\n        other.dimensions, allow_singleton=allow_singleton\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Label.require_axes_match","title":"require_axes_match","text":"<pre><code>require_axes_match(other: AbstractImage) -&gt; None\n</code></pre> <p>Assert that two images have compatible axes.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>AbstractImage</code>)           \u2013            <p>The other image to compare to.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NgioValueError</code>             \u2013            <p>If the images do not have compatible axes.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def require_axes_match(\n    self,\n    other: \"AbstractImage\",\n) -&gt; None:\n    \"\"\"Assert that two images have compatible axes.\n\n    Args:\n        other: The other image to compare to.\n\n    Raises:\n        NgioValueError: If the images do not have compatible axes.\n    \"\"\"\n    self.dimensions.require_axes_match(other.dimensions)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Label.check_if_axes_match","title":"check_if_axes_match","text":"<pre><code>check_if_axes_match(other: AbstractImage) -&gt; bool\n</code></pre> <p>Check if two images have compatible axes.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>AbstractImage</code>)           \u2013            <p>The other image to compare to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the images have compatible axes, False otherwise.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def check_if_axes_match(\n    self,\n    other: \"AbstractImage\",\n) -&gt; bool:\n    \"\"\"Check if two images have compatible axes.\n\n    Args:\n        other: The other image to compare to.\n\n    Returns:\n        bool: True if the images have compatible axes, False otherwise.\n\n    \"\"\"\n    return self.dimensions.check_if_axes_match(other.dimensions)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Label.require_rescalable","title":"require_rescalable","text":"<pre><code>require_rescalable(other: AbstractImage) -&gt; None\n</code></pre> <p>Assert that two images can be rescaled to each other.</p> <p>For this to be true, the images must have the same axes, and the pixel sizes must be compatible (i.e. one can be scaled to the other).</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>AbstractImage</code>)           \u2013            <p>The other image to compare to.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NgioValueError</code>             \u2013            <p>If the images cannot be scaled to each other.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def require_rescalable(\n    self,\n    other: \"AbstractImage\",\n) -&gt; None:\n    \"\"\"Assert that two images can be rescaled to each other.\n\n    For this to be true, the images must have the same axes, and\n    the pixel sizes must be compatible (i.e. one can be scaled to the other).\n\n    Args:\n        other: The other image to compare to.\n\n    Raises:\n        NgioValueError: If the images cannot be scaled to each other.\n    \"\"\"\n    self.dimensions.require_rescalable(other.dimensions)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Label.check_if_rescalable","title":"check_if_rescalable","text":"<pre><code>check_if_rescalable(other: AbstractImage) -&gt; bool\n</code></pre> <p>Check if two images can be rescaled to each other.</p> <p>For this to be true, the images must have the same axes, and the pixel sizes must be compatible (i.e. one can be scaled to the other).</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>AbstractImage</code>)           \u2013            <p>The other image to compare to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the images can be rescaled to each other, False otherwise.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def check_if_rescalable(\n    self,\n    other: \"AbstractImage\",\n) -&gt; bool:\n    \"\"\"Check if two images can be rescaled to each other.\n\n    For this to be true, the images must have the same axes, and\n    the pixel sizes must be compatible (i.e. one can be scaled to the other).\n\n    Args:\n        other: The other image to compare to.\n\n    Returns:\n        bool: True if the images can be rescaled to each other, False otherwise.\n    \"\"\"\n    return self.dimensions.check_if_rescalable(other.dimensions)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Label.build_masking_roi_table","title":"build_masking_roi_table","text":"<pre><code>build_masking_roi_table(\n    axes_order: Sequence[str] | None = None,\n) -&gt; MaskingRoiTable\n</code></pre> <p>Compute the masking ROI table.</p> Source code in <code>ngio/images/_label.py</code> <pre><code>def build_masking_roi_table(\n    self, axes_order: Sequence[str] | None = None\n) -&gt; MaskingRoiTable:\n    \"\"\"Compute the masking ROI table.\"\"\"\n    return build_masking_roi_table(self, axes_order=axes_order)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Label.consolidate","title":"consolidate","text":"<pre><code>consolidate(\n    mode: Literal[\"dask\", \"numpy\", \"coarsen\"] = \"dask\",\n) -&gt; None\n</code></pre> <p>Consolidate the label on disk.</p> Source code in <code>ngio/images/_label.py</code> <pre><code>def consolidate(\n    self,\n    mode: Literal[\"dask\", \"numpy\", \"coarsen\"] = \"dask\",\n) -&gt; None:\n    \"\"\"Consolidate the label on disk.\"\"\"\n    self._consolidate(\n        order=\"nearest\",\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.LabelsContainer","title":"LabelsContainer","text":"<pre><code>LabelsContainer(\n    group_handler: ZarrGroupHandler,\n    axes_setup: AxesSetup | None = None,\n    ngff_version: NgffVersions | None = None,\n)\n</code></pre> <p>A class to handle the /labels group in an OME-NGFF file.</p> <p>Initialize the LabelGroupHandler.</p> Source code in <code>ngio/images/_label.py</code> <pre><code>def __init__(\n    self,\n    group_handler: ZarrGroupHandler,\n    axes_setup: AxesSetup | None = None,\n    ngff_version: NgffVersions | None = None,\n) -&gt; None:\n    \"\"\"Initialize the LabelGroupHandler.\"\"\"\n    self._group_handler = group_handler\n    self._axes_setup = axes_setup or AxesSetup()\n    # If the group is empty, initialize the metadata\n    try:\n        self._meta_handler = LabelsGroupMetaHandler(group_handler)\n    except NgioValidationError:\n        if ngff_version is None:\n            raise NgioValueError(\n                \"The /labels group is missing metadata. \"\n                \"Please provide the ngff_version to initialize it.\"\n            ) from None\n        meta = NgioLabelsGroupMeta(labels=[], version=ngff_version)\n        update_ngio_labels_group_meta(\n            group_handler=group_handler,\n            ngio_meta=meta,\n        )\n        self._group_handler = self._group_handler.reopen_handler()\n        self._meta_handler = LabelsGroupMetaHandler(group_handler)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.LabelsContainer.meta","title":"meta  <code>property</code>","text":"<pre><code>meta: NgioLabelsGroupMeta\n</code></pre> <p>Return the metadata.</p>"},{"location":"api/ngio/images/#ngio.images.LabelsContainer.axes_setup","title":"axes_setup  <code>property</code>","text":"<pre><code>axes_setup: AxesSetup\n</code></pre> <p>Return the axes setup.</p>"},{"location":"api/ngio/images/#ngio.images.LabelsContainer.list","title":"list","text":"<pre><code>list() -&gt; list[str]\n</code></pre> <p>Return the list of label names in the group.</p> Source code in <code>ngio/images/_label.py</code> <pre><code>def list(self) -&gt; list[str]:\n    \"\"\"Return the list of label names in the group.\"\"\"\n    return self.meta.labels\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.LabelsContainer.get","title":"get","text":"<pre><code>get(\n    name: str,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; Label\n</code></pre> <p>Get a label from the group.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the label.</p> </li> <li> <code>path</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the image in the ome_zarr file.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the image.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Only used if the pixel size is provided. If True, the pixel size must match the image pixel size exactly. If False, the closest pixel size level will be returned.</p> </li> </ul> Source code in <code>ngio/images/_label.py</code> <pre><code>def get(\n    self,\n    name: str,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; Label:\n    \"\"\"Get a label from the group.\n\n    Args:\n        name (str): The name of the label.\n        path (str | None): The path to the image in the ome_zarr file.\n        pixel_size (PixelSize | None): The pixel size of the image.\n        strict (bool): Only used if the pixel size is provided. If True, the\n            pixel size must match the image pixel size exactly. If False, the\n            closest pixel size level will be returned.\n\n    \"\"\"\n    if name not in self.list():\n        raise NgioValueError(\n            f\"Label '{name}' not found in the Labels group. \"\n            f\"Available labels: {self.list()}\"\n        )\n\n    group_handler = self._group_handler.get_handler(name)\n    label_meta_handler = LabelMetaHandler(group_handler, axes_setup=self.axes_setup)\n    path = (\n        label_meta_handler.get_meta()\n        .get_dataset(path=path, pixel_size=pixel_size, strict=strict)\n        .path\n    )\n    return Label(\n        group_handler=group_handler,\n        path=path,\n        meta_handler=label_meta_handler,\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.LabelsContainer.delete","title":"delete","text":"<pre><code>delete(name: str, missing_ok: bool = False) -&gt; None\n</code></pre> <p>Delete a label from the group.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the label to delete.</p> </li> <li> <code>missing_ok</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, do not raise an error if the label does not exist.</p> </li> </ul> Source code in <code>ngio/images/_label.py</code> <pre><code>def delete(self, name: str, missing_ok: bool = False) -&gt; None:\n    \"\"\"Delete a label from the group.\n\n    Args:\n        name (str): The name of the label to delete.\n        missing_ok (bool): If True, do not raise an error if the label does not\n            exist.\n\n    \"\"\"\n    existing_labels = self.list()\n    if name not in existing_labels:\n        if missing_ok:\n            return\n        raise NgioValueError(\n            f\"Label '{name}' not found in the Labels group. \"\n            f\"Available labels: {existing_labels}\"\n        )\n\n    self._group_handler.delete_group(name)\n    existing_labels.remove(name)\n    update_meta = NgioLabelsGroupMeta(\n        labels=existing_labels, version=self.meta.version\n    )\n    self._meta_handler.update_meta(update_meta)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.LabelsContainer.derive","title":"derive","text":"<pre><code>derive(\n    name: str,\n    ref_image: Image | Label,\n    shape: Sequence[int] | None = None,\n    pixelsize: float | tuple[float, float] | None = None,\n    z_spacing: float | None = None,\n    time_spacing: float | None = None,\n    translation: Sequence[float] | None = None,\n    channels_policy: Literal[\"same\", \"squeeze\", \"singleton\"]\n    | int = \"squeeze\",\n    ngff_version: NgffVersions | None = None,\n    chunks: ChunksLike | None = None,\n    shards: ShardsLike | None = None,\n    dtype: str | None = None,\n    dimension_separator: Literal[\".\", \"/\"] | None = None,\n    compressors: CompressorLike | None = None,\n    extra_array_kwargs: Mapping[str, Any] | None = None,\n    overwrite: bool = False,\n    labels: Sequence[str] | None = None,\n    pixel_size: PixelSize | None = None,\n) -&gt; Label\n</code></pre> <p>Create an empty OME-Zarr label from an existing image or label.</p> <p>If a kwarg is not provided, the value from the reference image will be used.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the new label.</p> </li> <li> <code>ref_image</code>               (<code>Image | Label</code>)           \u2013            <p>The reference image to derive the new label from.</p> </li> <li> <code>shape</code>               (<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The shape of the new label.</p> </li> <li> <code>pixelsize</code>               (<code>float | tuple[float, float] | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the new label.</p> </li> <li> <code>z_spacing</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>The z spacing of the new label.</p> </li> <li> <code>time_spacing</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>The time spacing of the new label.</p> </li> <li> <code>translation</code>               (<code>Sequence[float] | None</code>, default:                   <code>None</code> )           \u2013            <p>The translation for each axis at the highest resolution level. Defaults to None.</p> </li> <li> <code>channels_policy</code>               (<code>Literal['squeeze', 'same', 'singleton'] | int</code>, default:                   <code>'squeeze'</code> )           \u2013            <p>Possible policies: - If \"squeeze\", the channels axis will be removed (no matter its size). - If \"same\", the channels axis will be kept as is (if it exists). - If \"singleton\", the channels axis will be set to size 1. - If an integer is provided, the channels axis will be changed to have     that size.</p> </li> <li> <code>ngff_version</code>               (<code>NgffVersions | None</code>, default:                   <code>None</code> )           \u2013            <p>The NGFF version to use.</p> </li> <li> <code>chunks</code>               (<code>ChunksLike | None</code>, default:                   <code>None</code> )           \u2013            <p>The chunk shape of the new label.</p> </li> <li> <code>shards</code>               (<code>ShardsLike | None</code>, default:                   <code>None</code> )           \u2013            <p>The shard shape of the new label.</p> </li> <li> <code>dtype</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The data type of the new label.</p> </li> <li> <code>dimension_separator</code>               (<code>Literal['.', '/'] | None</code>, default:                   <code>None</code> )           \u2013            <p>The separator to use for dimensions.</p> </li> <li> <code>compressors</code>               (<code>CompressorLike | None</code>, default:                   <code>None</code> )           \u2013            <p>The compressors to use.</p> </li> <li> <code>extra_array_kwargs</code>               (<code>Mapping[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Extra arguments to pass to the zarr array creation.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to overwrite an existing label.</p> </li> <li> <code>labels</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. This argument is deprecated, please use channels_meta instead.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. The pixel size of the new label. This argument is deprecated, please use pixelsize, z_spacing, and time_spacing instead.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Label</code> (              <code>Label</code> )          \u2013            <p>The new derived label.</p> </li> </ul> Source code in <code>ngio/images/_label.py</code> <pre><code>def derive(\n    self,\n    name: str,\n    ref_image: Image | Label,\n    # Metadata parameters\n    shape: Sequence[int] | None = None,\n    pixelsize: float | tuple[float, float] | None = None,\n    z_spacing: float | None = None,\n    time_spacing: float | None = None,\n    translation: Sequence[float] | None = None,\n    channels_policy: Literal[\"same\", \"squeeze\", \"singleton\"] | int = \"squeeze\",\n    ngff_version: NgffVersions | None = None,\n    # Zarr Array parameters\n    chunks: ChunksLike | None = None,\n    shards: ShardsLike | None = None,\n    dtype: str | None = None,\n    dimension_separator: Literal[\".\", \"/\"] | None = None,\n    compressors: CompressorLike | None = None,\n    extra_array_kwargs: Mapping[str, Any] | None = None,\n    overwrite: bool = False,\n    # Deprecated arguments\n    labels: Sequence[str] | None = None,\n    pixel_size: PixelSize | None = None,\n) -&gt; \"Label\":\n    \"\"\"Create an empty OME-Zarr label from an existing image or label.\n\n    If a kwarg is not provided, the value from the reference image will be used.\n\n    Args:\n        name (str): The name of the new label.\n        ref_image (Image | Label): The reference image to derive the new label from.\n        shape (Sequence[int] | None): The shape of the new label.\n        pixelsize (float | tuple[float, float] | None): The pixel size of the new\n            label.\n        z_spacing (float | None): The z spacing of the new label.\n        time_spacing (float | None): The time spacing of the new label.\n        translation (Sequence[float] | None): The translation for each axis\n            at the highest resolution level. Defaults to None.\n        channels_policy (Literal[\"squeeze\", \"same\", \"singleton\"] | int):\n            Possible policies:\n            - If \"squeeze\", the channels axis will be removed (no matter its size).\n            - If \"same\", the channels axis will be kept as is (if it exists).\n            - If \"singleton\", the channels axis will be set to size 1.\n            - If an integer is provided, the channels axis will be changed to have\n                that size.\n        ngff_version (NgffVersions | None): The NGFF version to use.\n        chunks (ChunksLike | None): The chunk shape of the new label.\n        shards (ShardsLike | None): The shard shape of the new label.\n        dtype (str | None): The data type of the new label.\n        dimension_separator (Literal[\".\", \"/\"] | None): The separator to use for\n            dimensions.\n        compressors (CompressorLike | None): The compressors to use.\n        extra_array_kwargs (Mapping[str, Any] | None): Extra arguments to pass to\n            the zarr array creation.\n        overwrite (bool): Whether to overwrite an existing label.\n        labels (Sequence[str] | None): Deprecated. This argument is deprecated,\n            please use channels_meta instead.\n        pixel_size (PixelSize | None): Deprecated. The pixel size of the new label.\n            This argument is deprecated, please use pixelsize, z_spacing,\n            and time_spacing instead.\n\n    Returns:\n        Label: The new derived label.\n\n    \"\"\"\n    existing_labels = self.list()\n    if name in existing_labels and not overwrite:\n        raise NgioValueError(\n            f\"Label '{name}' already exists in the group. \"\n            \"Use overwrite=True to replace it.\"\n        )\n\n    label_group = self._group_handler.get_group(name, create_mode=True)\n    derive_label(\n        ref_image=ref_image,\n        store=label_group,\n        shape=shape,\n        pixelsize=pixelsize,\n        z_spacing=z_spacing,\n        time_spacing=time_spacing,\n        name=name,\n        translation=translation,\n        channels_policy=channels_policy,\n        ngff_version=ngff_version,\n        chunks=chunks,\n        shards=shards,\n        dtype=dtype,\n        dimension_separator=dimension_separator,\n        compressors=compressors,\n        extra_array_kwargs=extra_array_kwargs,\n        overwrite=overwrite,\n        labels=labels,\n        pixel_size=pixel_size,\n    )\n\n    if name not in existing_labels:\n        existing_labels.append(name)\n\n    update_meta = NgioLabelsGroupMeta(\n        labels=existing_labels, version=self.meta.version\n    )\n    self._meta_handler.update_meta(update_meta)\n    return self.get(name)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer","title":"OmeZarrContainer","text":"<pre><code>OmeZarrContainer(\n    group_handler: ZarrGroupHandler,\n    table_container: TablesContainer | None = None,\n    label_container: LabelsContainer | None = None,\n    axes_setup: AxesSetup | None = None,\n    validate_paths: bool = False,\n)\n</code></pre> <p>This class is an object representation of an OME-Zarr image.</p> It provides methods to access <ul> <li>The multiscale image metadata</li> <li>To open images at different levels of resolution</li> <li>To access labels and tables associated with the image.</li> <li>To derive new images, labels, and add tables to the image.</li> <li>To modify the image metadata, such as axes units and channel metadata.</li> </ul> <p>Attributes:</p> <ul> <li> <code>images_container</code>               (<code>ImagesContainer</code>)           \u2013            <p>The container for the images.</p> </li> <li> <code>labels_container</code>               (<code>LabelsContainer</code>)           \u2013            <p>The container for the labels.</p> </li> <li> <code>tables_container</code>               (<code>TablesContainer</code>)           \u2013            <p>The container for the tables.</p> </li> </ul> <p>Initialize the OmeZarrContainer.</p> <p>Parameters:</p> <ul> <li> <code>group_handler</code>               (<code>ZarrGroupHandler</code>)           \u2013            <p>The Zarr group handler.</p> </li> <li> <code>table_container</code>               (<code>TablesContainer | None</code>, default:                   <code>None</code> )           \u2013            <p>The tables container.</p> </li> <li> <code>label_container</code>               (<code>LabelsContainer | None</code>, default:                   <code>None</code> )           \u2013            <p>The labels container.</p> </li> <li> <code>axes_setup</code>               (<code>AxesSetup | None</code>, default:                   <code>None</code> )           \u2013            <p>Axes setup to load ome-zarr with non-standard axes configurations.</p> </li> <li> <code>validate_paths</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to validate the paths of the image multiscale</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def __init__(\n    self,\n    group_handler: ZarrGroupHandler,\n    table_container: TablesContainer | None = None,\n    label_container: LabelsContainer | None = None,\n    axes_setup: AxesSetup | None = None,\n    validate_paths: bool = False,\n) -&gt; None:\n    \"\"\"Initialize the OmeZarrContainer.\n\n    Args:\n        group_handler (ZarrGroupHandler): The Zarr group handler.\n        table_container (TablesContainer | None): The tables container.\n        label_container (LabelsContainer | None): The labels container.\n        axes_setup (AxesSetup | None): Axes setup to load ome-zarr with\n            non-standard axes configurations.\n        validate_paths (bool): Whether to validate the paths of the image multiscale\n    \"\"\"\n    self._group_handler = group_handler\n    self._images_container = ImagesContainer(\n        self._group_handler, axes_setup=axes_setup\n    )\n    self._labels_container = label_container\n    self._tables_container = table_container\n\n    if validate_paths:\n        for level_path in self._images_container.level_paths:\n            self.get_image(path=level_path)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.images_container","title":"images_container  <code>property</code>","text":"<pre><code>images_container: ImagesContainer\n</code></pre> <p>Return the images container.</p> <p>Returns:</p> <ul> <li> <code>ImagesContainer</code> (              <code>ImagesContainer</code> )          \u2013            <p>The images container.</p> </li> </ul>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.labels_container","title":"labels_container  <code>property</code>","text":"<pre><code>labels_container: LabelsContainer\n</code></pre> <p>Return the labels container.</p>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.tables_container","title":"tables_container  <code>property</code>","text":"<pre><code>tables_container: TablesContainer\n</code></pre> <p>Return the tables container.</p>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.meta","title":"meta  <code>property</code>","text":"<pre><code>meta: NgioImageMeta\n</code></pre> <p>Return the image metadata.</p>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.image_meta","title":"image_meta  <code>property</code>","text":"<pre><code>image_meta: NgioImageMeta\n</code></pre> <p>Return the image metadata.</p>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.axes_setup","title":"axes_setup  <code>property</code>","text":"<pre><code>axes_setup: AxesSetup\n</code></pre> <p>Return the axes setup.</p>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.levels","title":"levels  <code>property</code>","text":"<pre><code>levels: int\n</code></pre> <p>Return the number of levels in the image.</p>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.level_paths","title":"level_paths  <code>property</code>","text":"<pre><code>level_paths: list[str]\n</code></pre> <p>Return the paths of the levels in the image.</p>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.levels_paths","title":"levels_paths  <code>property</code>","text":"<pre><code>levels_paths: list[str]\n</code></pre> <p>Deprecated: use 'level_paths' instead.</p>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.is_3d","title":"is_3d  <code>property</code>","text":"<pre><code>is_3d: bool\n</code></pre> <p>Return True if the image is 3D.</p>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.is_2d","title":"is_2d  <code>property</code>","text":"<pre><code>is_2d: bool\n</code></pre> <p>Return True if the image is 2D.</p>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.is_time_series","title":"is_time_series  <code>property</code>","text":"<pre><code>is_time_series: bool\n</code></pre> <p>Return True if the image is a time series.</p>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.is_2d_time_series","title":"is_2d_time_series  <code>property</code>","text":"<pre><code>is_2d_time_series: bool\n</code></pre> <p>Return True if the image is a 2D time series.</p>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.is_3d_time_series","title":"is_3d_time_series  <code>property</code>","text":"<pre><code>is_3d_time_series: bool\n</code></pre> <p>Return True if the image is a 3D time series.</p>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.is_multi_channels","title":"is_multi_channels  <code>property</code>","text":"<pre><code>is_multi_channels: bool\n</code></pre> <p>Return True if the image is multichannel.</p>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.space_unit","title":"space_unit  <code>property</code>","text":"<pre><code>space_unit: str | None\n</code></pre> <p>Return the space unit of the image.</p>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.time_unit","title":"time_unit  <code>property</code>","text":"<pre><code>time_unit: str | None\n</code></pre> <p>Return the time unit of the image.</p>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.channel_labels","title":"channel_labels  <code>property</code>","text":"<pre><code>channel_labels: list[str]\n</code></pre> <p>Return the channels of the image.</p>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.wavelength_ids","title":"wavelength_ids  <code>property</code>","text":"<pre><code>wavelength_ids: list[str | None]\n</code></pre> <p>Return the list of wavelength of the image.</p>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.num_channels","title":"num_channels  <code>property</code>","text":"<pre><code>num_channels: int\n</code></pre> <p>Return the number of channels.</p>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.get_channel_idx","title":"get_channel_idx","text":"<pre><code>get_channel_idx(\n    channel_label: str | None = None,\n    wavelength_id: str | None = None,\n) -&gt; int\n</code></pre> <p>Get the index of a channel by its label or wavelength ID.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_channel_idx(\n    self, channel_label: str | None = None, wavelength_id: str | None = None\n) -&gt; int:\n    \"\"\"Get the index of a channel by its label or wavelength ID.\"\"\"\n    return self.images_container.get_channel_idx(\n        channel_label=channel_label, wavelength_id=wavelength_id\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.set_channel_meta","title":"set_channel_meta","text":"<pre><code>set_channel_meta(\n    channel_meta: ChannelsMeta | None = None,\n    labels: Sequence[str | None] | int | None = None,\n    wavelength_id: Sequence[str | None] | None = None,\n    start: Sequence[float | None] | None = None,\n    end: Sequence[float | None] | None = None,\n    percentiles: tuple[float, float] | None = None,\n    colors: Sequence[str | None] | None = None,\n    active: Sequence[bool | None] | None = None,\n    **omero_kwargs: dict,\n) -&gt; None\n</code></pre> <p>Create a ChannelsMeta object with the default unit.</p> <p>Parameters:</p> <ul> <li> <code>channel_meta</code>               (<code>ChannelsMeta | None</code>, default:                   <code>None</code> )           \u2013            <p>The channels metadata to set. If none, it will fall back to the deprecated parameters.</p> </li> <li> <code>labels</code>               (<code>Sequence[str | None] | int</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. The list of channels names in the image. If an integer is provided, the channels will be named \"channel_i\".</p> </li> <li> <code>wavelength_id</code>               (<code>Sequence[str | None]</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. The wavelength ID of the channel. If None, the wavelength ID will be the same as the channel name.</p> </li> <li> <code>start</code>               (<code>Sequence[float | None]</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. The start value for each channel. If None, the start value will be computed from the image.</p> </li> <li> <code>end</code>               (<code>Sequence[float | None]</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. The end value for each channel. If None, the end value will be computed from the image.</p> </li> <li> <code>percentiles</code>               (<code>tuple[float, float] | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. The start and end percentiles for each channel. If None, the percentiles will not be computed.</p> </li> <li> <code>colors</code>               (<code>Sequence[str | None]</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. The list of colors for the channels. If None, the colors will be random.</p> </li> <li> <code>active</code>               (<code>Sequence[bool | None]</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Whether the channel should be shown by default.</p> </li> <li> <code>omero_kwargs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Deprecated. Extra fields to store in the omero attributes.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def set_channel_meta(\n    self,\n    channel_meta: ChannelsMeta | None = None,\n    labels: Sequence[str | None] | int | None = None,\n    wavelength_id: Sequence[str | None] | None = None,\n    start: Sequence[float | None] | None = None,\n    end: Sequence[float | None] | None = None,\n    percentiles: tuple[float, float] | None = None,\n    colors: Sequence[str | None] | None = None,\n    active: Sequence[bool | None] | None = None,\n    **omero_kwargs: dict,\n) -&gt; None:\n    \"\"\"Create a ChannelsMeta object with the default unit.\n\n    Args:\n        channel_meta (ChannelsMeta | None): The channels metadata to set.\n            If none, it will fall back to the deprecated parameters.\n        labels(Sequence[str | None] | int): Deprecated. The list of channels names\n            in the image. If an integer is provided, the channels will\n            be named \"channel_i\".\n        wavelength_id(Sequence[str | None]): Deprecated. The wavelength ID of the\n            channel. If None, the wavelength ID will be the same as\n            the channel name.\n        start(Sequence[float | None]): Deprecated. The start value for each channel.\n            If None, the start value will be computed from the image.\n        end(Sequence[float | None]): Deprecated. The end value for each channel.\n            If None, the end value will be computed from the image.\n        percentiles(tuple[float, float] | None): Deprecated. The start and end\n            percentiles for each channel. If None, the percentiles will\n            not be computed.\n        colors(Sequence[str | None]): Deprecated. The list of colors for the\n            channels. If None, the colors will be random.\n        active (Sequence[bool | None]): Deprecated. Whether the channel should\n            be shown by default.\n        omero_kwargs(dict): Deprecated. Extra fields to store in the omero\n            attributes.\n    \"\"\"\n    self._images_container.set_channel_meta(\n        channel_meta=channel_meta,\n        labels=labels,\n        wavelength_id=wavelength_id,\n        start=start,\n        end=end,\n        percentiles=percentiles,\n        colors=colors,\n        active=active,\n        **omero_kwargs,\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.set_channel_labels","title":"set_channel_labels","text":"<pre><code>set_channel_labels(labels: Sequence[str]) -&gt; None\n</code></pre> <p>Update the labels of the channels.</p> <p>Parameters:</p> <ul> <li> <code>labels</code>               (<code>Sequence[str]</code>)           \u2013            <p>The new labels for the channels.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def set_channel_labels(\n    self,\n    labels: Sequence[str],\n) -&gt; None:\n    \"\"\"Update the labels of the channels.\n\n    Args:\n        labels (Sequence[str]): The new labels for the channels.\n    \"\"\"\n    self._images_container.set_channel_labels(labels=labels)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.set_channel_colors","title":"set_channel_colors","text":"<pre><code>set_channel_colors(colors: Sequence[str]) -&gt; None\n</code></pre> <p>Update the colors of the channels.</p> <p>Parameters:</p> <ul> <li> <code>colors</code>               (<code>Sequence[str]</code>)           \u2013            <p>The new colors for the channels.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def set_channel_colors(\n    self,\n    colors: Sequence[str],\n) -&gt; None:\n    \"\"\"Update the colors of the channels.\n\n    Args:\n        colors (Sequence[str]): The new colors for the channels.\n    \"\"\"\n    self._images_container.set_channel_colors(colors=colors)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.set_channel_percentiles","title":"set_channel_percentiles","text":"<pre><code>set_channel_percentiles(\n    start_percentile: float = 0.1,\n    end_percentile: float = 99.9,\n) -&gt; None\n</code></pre> <p>Deprecated: Update the channel windows using percentiles.</p> <p>Parameters:</p> <ul> <li> <code>start_percentile</code>               (<code>float</code>, default:                   <code>0.1</code> )           \u2013            <p>The start percentile.</p> </li> <li> <code>end_percentile</code>               (<code>float</code>, default:                   <code>99.9</code> )           \u2013            <p>The end percentile.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def set_channel_percentiles(\n    self,\n    start_percentile: float = 0.1,\n    end_percentile: float = 99.9,\n) -&gt; None:\n    \"\"\"Deprecated: Update the channel windows using percentiles.\n\n    Args:\n        start_percentile (float): The start percentile.\n        end_percentile (float): The end percentile.\n    \"\"\"\n    logger.warning(\n        \"The 'set_channel_percentiles' method is deprecated and will be removed in \"\n        \"ngio=0.6. Please use 'set_channel_windows_with_percentiles' instead.\"\n    )\n    self._images_container.set_channel_windows_with_percentiles(\n        percentiles=(start_percentile, end_percentile)\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.set_channel_windows","title":"set_channel_windows","text":"<pre><code>set_channel_windows(\n    starts_ends: Sequence[tuple[float, float]],\n    min_max: Sequence[tuple[float, float]] | None = None,\n) -&gt; None\n</code></pre> <p>Update the channel windows.</p> <p>These values are used by viewers to set the display range of each channel.</p> <p>Parameters:</p> <ul> <li> <code>starts_ends</code>               (<code>Sequence[tuple[float, float]]</code>)           \u2013            <p>The start and end values for each channel.</p> </li> <li> <code>min_max</code>               (<code>Sequence[tuple[float, float]] | None</code>, default:                   <code>None</code> )           \u2013            <p>The min and max values for each channel. If None, the min and max values will not be updated.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def set_channel_windows(\n    self,\n    starts_ends: Sequence[tuple[float, float]],\n    min_max: Sequence[tuple[float, float]] | None = None,\n) -&gt; None:\n    \"\"\"Update the channel windows.\n\n    These values are used by viewers to set the display\n    range of each channel.\n\n    Args:\n        starts_ends (Sequence[tuple[float, float]]): The start and end values\n            for each channel.\n        min_max (Sequence[tuple[float, float]] | None): The min and max values\n            for each channel. If None, the min and max values will not be updated.\n    \"\"\"\n    self._images_container.set_channel_windows(\n        starts_ends=starts_ends,\n        min_max=min_max,\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.set_channel_windows_with_percentiles","title":"set_channel_windows_with_percentiles","text":"<pre><code>set_channel_windows_with_percentiles(\n    percentiles: tuple[float, float]\n    | list[tuple[float, float]] = (0.1, 99.9),\n) -&gt; None\n</code></pre> <p>Update the channel windows using percentiles.</p> <p>Parameters:</p> <ul> <li> <code>percentiles</code>               (<code>tuple[float, float] | list[tuple[float, float]]</code>, default:                   <code>(0.1, 99.9)</code> )           \u2013            <p>The start and end percentiles for each channel. If a single tuple is provided, the same percentiles will be used for all channels.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def set_channel_windows_with_percentiles(\n    self,\n    percentiles: tuple[float, float] | list[tuple[float, float]] = (0.1, 99.9),\n) -&gt; None:\n    \"\"\"Update the channel windows using percentiles.\n\n    Args:\n        percentiles (tuple[float, float] | list[tuple[float, float]]):\n            The start and end percentiles for each channel.\n            If a single tuple is provided,\n            the same percentiles will be used for all channels.\n    \"\"\"\n    self._images_container.set_channel_windows_with_percentiles(\n        percentiles=percentiles\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.set_axes_units","title":"set_axes_units","text":"<pre><code>set_axes_units(\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n    set_labels: bool = True,\n) -&gt; None\n</code></pre> <p>Set the units of the image.</p> <p>Parameters:</p> <ul> <li> <code>space_unit</code>               (<code>SpaceUnits</code>, default:                   <code>DefaultSpaceUnit</code> )           \u2013            <p>The unit of space.</p> </li> <li> <code>time_unit</code>               (<code>TimeUnits</code>, default:                   <code>DefaultTimeUnit</code> )           \u2013            <p>The unit of time.</p> </li> <li> <code>set_labels</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to set the units for the labels as well.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def set_axes_units(\n    self,\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n    set_labels: bool = True,\n) -&gt; None:\n    \"\"\"Set the units of the image.\n\n    Args:\n        space_unit (SpaceUnits): The unit of space.\n        time_unit (TimeUnits): The unit of time.\n        set_labels (bool): Whether to set the units for the labels as well.\n    \"\"\"\n    if set_labels:\n        for label_name in self.list_labels():\n            label = self.get_label(label_name)\n            label.set_axes_unit(space_unit=space_unit, time_unit=time_unit)\n    self._images_container.set_axes_unit(space_unit=space_unit, time_unit=time_unit)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.set_axes_names","title":"set_axes_names","text":"<pre><code>set_axes_names(axes_names: Sequence[str]) -&gt; None\n</code></pre> <p>Set the axes names of the image.</p> <p>Parameters:</p> <ul> <li> <code>axes_names</code>               (<code>Sequence[str]</code>)           \u2013            <p>The axes names of the image.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def set_axes_names(\n    self,\n    axes_names: Sequence[str],\n) -&gt; None:\n    \"\"\"Set the axes names of the image.\n\n    Args:\n        axes_names (Sequence[str]): The axes names of the image.\n    \"\"\"\n    self._images_container.set_axes_names(axes_names=axes_names)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.set_name","title":"set_name","text":"<pre><code>set_name(name: str) -&gt; None\n</code></pre> <p>Set the name of the image in the metadata.</p> <p>This does not change the group name or any paths.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the image.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def set_name(\n    self,\n    name: str,\n) -&gt; None:\n    \"\"\"Set the name of the image in the metadata.\n\n    This does not change the group name or any paths.\n\n    Args:\n        name (str): The name of the image.\n    \"\"\"\n    self._images_container.set_name(name=name)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.get_image","title":"get_image","text":"<pre><code>get_image(\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; Image\n</code></pre> <p>Get an image at a specific level.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the image in the ome_zarr file.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the image.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Only used if the pixel size is provided. If True, the pixel size must match the image pixel size exactly. If False, the closest pixel size level will be returned.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_image(\n    self,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; Image:\n    \"\"\"Get an image at a specific level.\n\n    Args:\n        path (str | None): The path to the image in the ome_zarr file.\n        pixel_size (PixelSize | None): The pixel size of the image.\n        strict (bool): Only used if the pixel size is provided. If True, the\n            pixel size must match the image pixel size exactly. If False, the\n            closest pixel size level will be returned.\n\n    \"\"\"\n    return self._images_container.get(\n        path=path, pixel_size=pixel_size, strict=strict\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.get_masked_image","title":"get_masked_image","text":"<pre><code>get_masked_image(\n    masking_label_name: str | None = None,\n    masking_table_name: str | None = None,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; MaskedImage\n</code></pre> <p>Get a masked image at a specific level.</p> <p>Parameters:</p> <ul> <li> <code>masking_label_name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the masking label to use. If None, the masking table must be provided.</p> </li> <li> <code>masking_table_name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the masking table to use. If None, the masking label must be provided.</p> </li> <li> <code>path</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the image in the ome_zarr file. If None, the first level will be used.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the image. This is only used if path is None.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Only used if the pixel size is provided. If True, the pixel size must match the image pixel size exactly. If False, the closest pixel size level will be returned.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_masked_image(\n    self,\n    masking_label_name: str | None = None,\n    masking_table_name: str | None = None,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; MaskedImage:\n    \"\"\"Get a masked image at a specific level.\n\n    Args:\n        masking_label_name (str | None): The name of the masking label to use.\n            If None, the masking table must be provided.\n        masking_table_name (str | None): The name of the masking table to use.\n            If None, the masking label must be provided.\n        path (str | None): The path to the image in the ome_zarr file.\n            If None, the first level will be used.\n        pixel_size (PixelSize | None): The pixel size of the image.\n            This is only used if path is None.\n        strict (bool): Only used if the pixel size is provided. If True, the\n            pixel size must match the image pixel size exactly. If False, the\n            closest pixel size level will be returned.\n    \"\"\"\n    image = self.get_image(path=path, pixel_size=pixel_size, strict=strict)\n    masking_label, masking_table = self._find_matching_masking_label(\n        masking_label_name=masking_label_name,\n        masking_table_name=masking_table_name,\n        pixel_size=image.pixel_size,\n    )\n    return MaskedImage(\n        group_handler=image._group_handler,\n        path=image.path,\n        meta_handler=image.meta_handler,\n        label=masking_label,\n        masking_roi_table=masking_table,\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.derive_image","title":"derive_image","text":"<pre><code>derive_image(\n    store: StoreOrGroup,\n    ref_path: str | None = None,\n    shape: Sequence[int] | None = None,\n    pixelsize: float | tuple[float, float] | None = None,\n    z_spacing: float | None = None,\n    time_spacing: float | None = None,\n    name: str | None = None,\n    translation: Sequence[float] | None = None,\n    channels_policy: Literal[\"squeeze\", \"same\", \"singleton\"]\n    | int = \"same\",\n    channels_meta: Sequence[str | Channel] | None = None,\n    ngff_version: NgffVersions | None = None,\n    chunks: ChunksLike | None = None,\n    shards: ShardsLike | None = None,\n    dtype: str = \"uint16\",\n    dimension_separator: Literal[\".\", \"/\"] = \"/\",\n    compressors: CompressorLike = \"auto\",\n    extra_array_kwargs: Mapping[str, Any] | None = None,\n    overwrite: bool = False,\n    copy_labels: bool = False,\n    copy_tables: bool = False,\n    labels: Sequence[str] | None = None,\n    pixel_size: PixelSize | None = None,\n) -&gt; OmeZarrContainer\n</code></pre> <p>Derive a new OME-Zarr container from the current image.</p> <p>If a kwarg is not provided, the value from the reference image will be used.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group to create the image in.</p> </li> <li> <code>ref_path</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the reference image in the image container.</p> </li> <li> <code>shape</code>               (<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The shape of the new image.</p> </li> <li> <code>pixelsize</code>               (<code>float | tuple[float, float] | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the new image.</p> </li> <li> <code>z_spacing</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>The z spacing of the new image.</p> </li> <li> <code>time_spacing</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>The time spacing of the new image.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the new image.</p> </li> <li> <code>translation</code>               (<code>Sequence[float] | None</code>, default:                   <code>None</code> )           \u2013            <p>The translation for each axis at the highest resolution level. Defaults to None.</p> </li> <li> <code>channels_policy</code>               (<code>Literal['squeeze', 'same', 'singleton'] | int</code>, default:                   <code>'same'</code> )           \u2013            <p>Possible policies: - If \"squeeze\", the channels axis will be removed (no matter its size). - If \"same\", the channels axis will be kept as is (if it exists). - If \"singleton\", the channels axis will be set to size 1. - If an integer is provided, the channels axis will be changed to have     that size.</p> </li> <li> <code>channels_meta</code>               (<code>Sequence[str | Channel] | None</code>, default:                   <code>None</code> )           \u2013            <p>The channels metadata of the new image.</p> </li> <li> <code>ngff_version</code>               (<code>NgffVersions | None</code>, default:                   <code>None</code> )           \u2013            <p>The NGFF version to use.</p> </li> <li> <code>chunks</code>               (<code>ChunksLike | None</code>, default:                   <code>None</code> )           \u2013            <p>The chunk shape of the new image.</p> </li> <li> <code>shards</code>               (<code>ShardsLike | None</code>, default:                   <code>None</code> )           \u2013            <p>The shard shape of the new image.</p> </li> <li> <code>dtype</code>               (<code>str</code>, default:                   <code>'uint16'</code> )           \u2013            <p>The data type of the new image. Defaults to \"uint16\".</p> </li> <li> <code>dimension_separator</code>               (<code>Literal['.', '/']</code>, default:                   <code>'/'</code> )           \u2013            <p>The separator to use for dimensions. Defaults to \"/\".</p> </li> <li> <code>compressors</code>               (<code>CompressorLike</code>, default:                   <code>'auto'</code> )           \u2013            <p>The compressors to use. Defaults to \"auto\".</p> </li> <li> <code>extra_array_kwargs</code>               (<code>Mapping[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Extra arguments to pass to the zarr array creation.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to overwrite an existing image. Defaults to False.</p> </li> <li> <code>copy_labels</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to copy the labels from the current image. Defaults to False.</p> </li> <li> <code>copy_tables</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to copy the tables from the current image. Defaults to False.</p> </li> <li> <code>labels</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. This argument is deprecated, please use channels_meta instead.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. The pixel size of the new image. This argument is deprecated, please use pixelsize, z_spacing, and time_spacing instead.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OmeZarrContainer</code> (              <code>OmeZarrContainer</code> )          \u2013            <p>The new derived OME-Zarr container.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def derive_image(\n    self,\n    store: StoreOrGroup,\n    ref_path: str | None = None,\n    # Metadata parameters\n    shape: Sequence[int] | None = None,\n    pixelsize: float | tuple[float, float] | None = None,\n    z_spacing: float | None = None,\n    time_spacing: float | None = None,\n    name: str | None = None,\n    translation: Sequence[float] | None = None,\n    channels_policy: Literal[\"squeeze\", \"same\", \"singleton\"] | int = \"same\",\n    channels_meta: Sequence[str | Channel] | None = None,\n    ngff_version: NgffVersions | None = None,\n    # Zarr Array parameters\n    chunks: ChunksLike | None = None,\n    shards: ShardsLike | None = None,\n    dtype: str = \"uint16\",\n    dimension_separator: Literal[\".\", \"/\"] = \"/\",\n    compressors: CompressorLike = \"auto\",\n    extra_array_kwargs: Mapping[str, Any] | None = None,\n    overwrite: bool = False,\n    # Copy from current image\n    copy_labels: bool = False,\n    copy_tables: bool = False,\n    # Deprecated arguments\n    labels: Sequence[str] | None = None,\n    pixel_size: PixelSize | None = None,\n) -&gt; \"OmeZarrContainer\":\n    \"\"\"Derive a new OME-Zarr container from the current image.\n\n    If a kwarg is not provided, the value from the reference image will be used.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group to create the image in.\n        ref_path (str | None): The path to the reference image in the image\n            container.\n        shape (Sequence[int] | None): The shape of the new image.\n        pixelsize (float | tuple[float, float] | None): The pixel size of the new\n            image.\n        z_spacing (float | None): The z spacing of the new image.\n        time_spacing (float | None): The time spacing of the new image.\n        name (str | None): The name of the new image.\n        translation (Sequence[float] | None): The translation for each axis\n            at the highest resolution level. Defaults to None.\n        channels_policy (Literal[\"squeeze\", \"same\", \"singleton\"] | int): Possible\n            policies:\n            - If \"squeeze\", the channels axis will be removed (no matter its size).\n            - If \"same\", the channels axis will be kept as is (if it exists).\n            - If \"singleton\", the channels axis will be set to size 1.\n            - If an integer is provided, the channels axis will be changed to have\n                that size.\n        channels_meta (Sequence[str | Channel] | None): The channels metadata\n            of the new image.\n        ngff_version (NgffVersions | None): The NGFF version to use.\n        chunks (ChunksLike | None): The chunk shape of the new image.\n        shards (ShardsLike | None): The shard shape of the new image.\n        dtype (str): The data type of the new image. Defaults to \"uint16\".\n        dimension_separator (Literal[\".\", \"/\"]): The separator to use for\n            dimensions. Defaults to \"/\".\n        compressors (CompressorLike): The compressors to use. Defaults to \"auto\".\n        extra_array_kwargs (Mapping[str, Any] | None): Extra arguments to pass to\n            the zarr array creation.\n        overwrite (bool): Whether to overwrite an existing image. Defaults to False.\n        copy_labels (bool): Whether to copy the labels from the current image.\n            Defaults to False.\n        copy_tables (bool): Whether to copy the tables from the current image.\n            Defaults to False.\n        labels (Sequence[str] | None): Deprecated. This argument is deprecated,\n            please use channels_meta instead.\n        pixel_size (PixelSize | None): Deprecated. The pixel size of the new image.\n            This argument is deprecated, please use pixelsize, z_spacing,\n            and time_spacing instead.\n\n    Returns:\n        OmeZarrContainer: The new derived OME-Zarr container.\n\n    \"\"\"\n    new_container = self._images_container.derive(\n        store=store,\n        ref_path=ref_path,\n        shape=shape,\n        pixelsize=pixelsize,\n        z_spacing=z_spacing,\n        time_spacing=time_spacing,\n        name=name,\n        translation=translation,\n        channels_meta=channels_meta,\n        channels_policy=channels_policy,\n        ngff_version=ngff_version,\n        chunks=chunks,\n        shards=shards,\n        dtype=dtype,\n        dimension_separator=dimension_separator,\n        compressors=compressors,\n        extra_array_kwargs=extra_array_kwargs,\n        overwrite=overwrite,\n        labels=labels,\n        pixel_size=pixel_size,\n    )\n    new_ome_zarr = OmeZarrContainer(\n        group_handler=new_container._group_handler,\n        validate_paths=False,\n        axes_setup=new_container.meta.axes_handler.axes_setup,\n    )\n\n    if copy_labels:\n        self.labels_container._group_handler.copy_group(\n            new_ome_zarr.labels_container._group_handler.group\n        )\n\n    if copy_tables:\n        self.tables_container._group_handler.copy_group(\n            new_ome_zarr.tables_container._group_handler.group\n        )\n    return new_ome_zarr\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.list_tables","title":"list_tables","text":"<pre><code>list_tables(\n    filter_types: TypedTable | str | None = None,\n) -&gt; list[str]\n</code></pre> <p>List all tables in the image.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def list_tables(self, filter_types: TypedTable | str | None = None) -&gt; list[str]:\n    \"\"\"List all tables in the image.\"\"\"\n    table_container = self._get_tables_container(create_mode=False)\n    if table_container is None:\n        return []\n\n    return table_container.list(\n        filter_types=filter_types,\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.list_roi_tables","title":"list_roi_tables","text":"<pre><code>list_roi_tables() -&gt; list[str]\n</code></pre> <p>List all ROI tables in the image.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def list_roi_tables(self) -&gt; list[str]:\n    \"\"\"List all ROI tables in the image.\"\"\"\n    masking_roi = self.tables_container.list(\n        filter_types=\"masking_roi_table\",\n    )\n    roi = self.tables_container.list(\n        filter_types=\"roi_table\",\n    )\n    return masking_roi + roi\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.get_roi_table","title":"get_roi_table","text":"<pre><code>get_roi_table(name: str) -&gt; RoiTable\n</code></pre> <p>Get a ROI table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_roi_table(self, name: str) -&gt; RoiTable:\n    \"\"\"Get a ROI table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, RoiTable):\n        raise NgioValueError(f\"Table {name} is not a ROI table. Got {type(table)}\")\n    return table\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.get_masking_roi_table","title":"get_masking_roi_table","text":"<pre><code>get_masking_roi_table(name: str) -&gt; MaskingRoiTable\n</code></pre> <p>Get a masking ROI table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_masking_roi_table(self, name: str) -&gt; MaskingRoiTable:\n    \"\"\"Get a masking ROI table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, MaskingRoiTable):\n        raise NgioValueError(\n            f\"Table {name} is not a masking ROI table. Got {type(table)}\"\n        )\n    return table\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.get_feature_table","title":"get_feature_table","text":"<pre><code>get_feature_table(name: str) -&gt; FeatureTable\n</code></pre> <p>Get a feature table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_feature_table(self, name: str) -&gt; FeatureTable:\n    \"\"\"Get a feature table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, FeatureTable):\n        raise NgioValueError(\n            f\"Table {name} is not a feature table. Got {type(table)}\"\n        )\n    return table\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.get_generic_roi_table","title":"get_generic_roi_table","text":"<pre><code>get_generic_roi_table(name: str) -&gt; GenericRoiTable\n</code></pre> <p>Get a generic ROI table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_generic_roi_table(self, name: str) -&gt; GenericRoiTable:\n    \"\"\"Get a generic ROI table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, GenericRoiTable):\n        raise NgioValueError(\n            f\"Table {name} is not a generic ROI table. Got {type(table)}\"\n        )\n    return table\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.get_condition_table","title":"get_condition_table","text":"<pre><code>get_condition_table(name: str) -&gt; ConditionTable\n</code></pre> <p>Get a condition table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_condition_table(self, name: str) -&gt; ConditionTable:\n    \"\"\"Get a condition table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, ConditionTable):\n        raise NgioValueError(\n            f\"Table {name} is not a condition table. Got {type(table)}\"\n        )\n    return table\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.get_table","title":"get_table","text":"<pre><code>get_table(\n    name: str, check_type: TypedTable | None = None\n) -&gt; Table\n</code></pre> <p>Get a table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> <li> <code>check_type</code>               (<code>TypedTable | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Please use 'get_table_as' instead, or one of the type specific get_*table() methods.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_table(self, name: str, check_type: TypedTable | None = None) -&gt; Table:\n    \"\"\"Get a table from the image.\n\n    Args:\n        name (str): The name of the table.\n        check_type (TypedTable | None): Deprecated. Please use\n            'get_table_as' instead, or one of the type specific\n            get_*table() methods.\n\n    \"\"\"\n    if check_type is not None:\n        logger.warning(\n            \"The 'check_type' argument is deprecated and will be removed in \"\n            \"ngio=0.6. Please use 'get_table_as' instead or one of the \"\n            \"type specific get_*table() methods.\"\n        )\n    return self.tables_container.get(name=name, strict=False)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.get_table_as","title":"get_table_as","text":"<pre><code>get_table_as(\n    name: str,\n    table_cls: type[TableType],\n    backend: TableBackend | None = None,\n) -&gt; TableType\n</code></pre> <p>Get a table from the image as a specific type.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> <li> <code>table_cls</code>               (<code>type[TableType]</code>)           \u2013            <p>The type of the table.</p> </li> <li> <code>backend</code>               (<code>TableBackend | None</code>, default:                   <code>None</code> )           \u2013            <p>The backend to use. If None, the default backend is used.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_table_as(\n    self,\n    name: str,\n    table_cls: type[TableType],\n    backend: TableBackend | None = None,\n) -&gt; TableType:\n    \"\"\"Get a table from the image as a specific type.\n\n    Args:\n        name (str): The name of the table.\n        table_cls (type[TableType]): The type of the table.\n        backend (TableBackend | None): The backend to use. If None,\n            the default backend is used.\n    \"\"\"\n    return self.tables_container.get_as(\n        name=name,\n        table_cls=table_cls,\n        backend=backend,\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.build_image_roi_table","title":"build_image_roi_table","text":"<pre><code>build_image_roi_table(\n    name: str | None = \"image\",\n) -&gt; RoiTable\n</code></pre> <p>Compute the ROI table for an image.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def build_image_roi_table(self, name: str | None = \"image\") -&gt; RoiTable:\n    \"\"\"Compute the ROI table for an image.\"\"\"\n    return self.get_image().build_image_roi_table(name=name)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.build_masking_roi_table","title":"build_masking_roi_table","text":"<pre><code>build_masking_roi_table(label: str) -&gt; MaskingRoiTable\n</code></pre> <p>Compute the masking ROI table for a label.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def build_masking_roi_table(self, label: str) -&gt; MaskingRoiTable:\n    \"\"\"Compute the masking ROI table for a label.\"\"\"\n    return self.get_label(label).build_masking_roi_table()\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.add_table","title":"add_table","text":"<pre><code>add_table(\n    name: str,\n    table: Table,\n    backend: TableBackend = DefaultTableBackend,\n    overwrite: bool = False,\n) -&gt; None\n</code></pre> <p>Add a table to the image.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def add_table(\n    self,\n    name: str,\n    table: Table,\n    backend: TableBackend = DefaultTableBackend,\n    overwrite: bool = False,\n) -&gt; None:\n    \"\"\"Add a table to the image.\"\"\"\n    self.tables_container.add(\n        name=name, table=table, backend=backend, overwrite=overwrite\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.delete_table","title":"delete_table","text":"<pre><code>delete_table(name: str, missing_ok: bool = False) -&gt; None\n</code></pre> <p>Delete a table from the group.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table to delete.</p> </li> <li> <code>missing_ok</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, do not raise an error if the table does not exist.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def delete_table(self, name: str, missing_ok: bool = False) -&gt; None:\n    \"\"\"Delete a table from the group.\n\n    Args:\n        name (str): The name of the table to delete.\n        missing_ok (bool): If True, do not raise an error if the table does not\n            exist.\n\n    \"\"\"\n    table_container = self._get_tables_container(create_mode=False)\n    if table_container is None and missing_ok:\n        return\n    if table_container is None:\n        raise NgioValueError(\n            f\"No tables found in the image, cannot delete {name}. \"\n            \"Set missing_ok=True to ignore this error.\"\n        )\n    table_container.delete(name=name, missing_ok=missing_ok)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.list_labels","title":"list_labels","text":"<pre><code>list_labels() -&gt; list[str]\n</code></pre> <p>List all labels in the image.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def list_labels(self) -&gt; list[str]:\n    \"\"\"List all labels in the image.\"\"\"\n    label_container = self._get_labels_container(create_mode=False)\n    if label_container is None:\n        return []\n    return label_container.list()\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.get_label","title":"get_label","text":"<pre><code>get_label(\n    name: str,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; Label\n</code></pre> <p>Get a label from the group.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the label.</p> </li> <li> <code>path</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the image in the ome_zarr file.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the image.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Only used if the pixel size is provided. If True, the pixel size must match the image pixel size exactly. If False, the closest pixel size level will be returned.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_label(\n    self,\n    name: str,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; Label:\n    \"\"\"Get a label from the group.\n\n    Args:\n        name (str): The name of the label.\n        path (str | None): The path to the image in the ome_zarr file.\n        pixel_size (PixelSize | None): The pixel size of the image.\n        strict (bool): Only used if the pixel size is provided. If True, the\n            pixel size must match the image pixel size exactly. If False, the\n            closest pixel size level will be returned.\n    \"\"\"\n    return self.labels_container.get(\n        name=name, path=path, pixel_size=pixel_size, strict=strict\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.get_masked_label","title":"get_masked_label","text":"<pre><code>get_masked_label(\n    label_name: str,\n    masking_label_name: str | None = None,\n    masking_table_name: str | None = None,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; MaskedLabel\n</code></pre> <p>Get a masked image at a specific level.</p> <p>Parameters:</p> <ul> <li> <code>label_name</code>               (<code>str</code>)           \u2013            <p>The name of the label.</p> </li> <li> <code>masking_label_name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the masking label.</p> </li> <li> <code>masking_table_name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the masking table.</p> </li> <li> <code>path</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the image in the ome_zarr file.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the image.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Only used if the pixel size is provided. If True, the pixel size must match the image pixel size exactly. If False, the closest pixel size level will be returned.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_masked_label(\n    self,\n    label_name: str,\n    masking_label_name: str | None = None,\n    masking_table_name: str | None = None,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; MaskedLabel:\n    \"\"\"Get a masked image at a specific level.\n\n    Args:\n        label_name (str): The name of the label.\n        masking_label_name (str | None): The name of the masking label.\n        masking_table_name (str | None): The name of the masking table.\n        path (str | None): The path to the image in the ome_zarr file.\n        pixel_size (PixelSize | None): The pixel size of the image.\n        strict (bool): Only used if the pixel size is provided. If True, the\n            pixel size must match the image pixel size exactly. If False, the\n            closest pixel size level will be returned.\n    \"\"\"\n    label = self.get_label(\n        name=label_name, path=path, pixel_size=pixel_size, strict=strict\n    )\n    masking_label, masking_table = self._find_matching_masking_label(\n        masking_label_name=masking_label_name,\n        masking_table_name=masking_table_name,\n        pixel_size=pixel_size,\n    )\n    return MaskedLabel(\n        group_handler=label._group_handler,\n        path=label.path,\n        meta_handler=label.meta_handler,\n        label=masking_label,\n        masking_roi_table=masking_table,\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.delete_label","title":"delete_label","text":"<pre><code>delete_label(name: str, missing_ok: bool = False) -&gt; None\n</code></pre> <p>Delete a label from the group.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the label to delete.</p> </li> <li> <code>missing_ok</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, do not raise an error if the label does not exist.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def delete_label(self, name: str, missing_ok: bool = False) -&gt; None:\n    \"\"\"Delete a label from the group.\n\n    Args:\n        name (str): The name of the label to delete.\n        missing_ok (bool): If True, do not raise an error if the label does not\n            exist.\n\n    \"\"\"\n    label_container = self._get_labels_container(create_mode=False)\n    if label_container is None and missing_ok:\n        return\n    if label_container is None:\n        raise NgioValueError(\n            f\"No labels found in the image, cannot delete {name}. \"\n            \"Set missing_ok=True to ignore this error.\"\n        )\n    label_container.delete(name=name, missing_ok=missing_ok)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.derive_label","title":"derive_label","text":"<pre><code>derive_label(\n    name: str,\n    ref_image: Image | Label | None = None,\n    shape: Sequence[int] | None = None,\n    pixelsize: float | tuple[float, float] | None = None,\n    z_spacing: float | None = None,\n    time_spacing: float | None = None,\n    translation: Sequence[float] | None = None,\n    channels_policy: Literal[\"same\", \"squeeze\", \"singleton\"]\n    | int = \"squeeze\",\n    ngff_version: NgffVersions | None = None,\n    chunks: ChunksLike | None = None,\n    shards: ShardsLike | None = None,\n    dtype: str | None = None,\n    dimension_separator: Literal[\".\", \"/\"] | None = None,\n    compressors: CompressorLike | None = None,\n    extra_array_kwargs: Mapping[str, Any] | None = None,\n    overwrite: bool = False,\n    labels: Sequence[str] | None = None,\n    pixel_size: PixelSize | None = None,\n) -&gt; Label\n</code></pre> <p>Derive a new label from an existing image or label.</p> <p>If a kwarg is not provided, the value from the reference image will be used.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the new label.</p> </li> <li> <code>ref_image</code>               (<code>Image | Label | None</code>, default:                   <code>None</code> )           \u2013            <p>The reference image to derive the new label from. If None, the first level image will be used.</p> </li> <li> <code>shape</code>               (<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The shape of the new label.</p> </li> <li> <code>pixelsize</code>               (<code>float | tuple[float, float] | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the new label.</p> </li> <li> <code>z_spacing</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>The z spacing of the new label.</p> </li> <li> <code>time_spacing</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>The time spacing of the new label.</p> </li> <li> <code>translation</code>               (<code>Sequence[float] | None</code>, default:                   <code>None</code> )           \u2013            <p>The translation for each axis at the highest resolution level. Defaults to None.</p> </li> <li> <code>channels_policy</code>               (<code>Literal['same', 'squeeze', 'singleton'] | int</code>, default:                   <code>'squeeze'</code> )           \u2013            <p>Possible policies: - If \"squeeze\", the channels axis will be removed (no matter its size). - If \"same\", the channels axis will be kept as is (if it exists). - If \"singleton\", the channels axis will be set to size 1. - If an integer is provided, the channels axis will be changed to have     that size. Defaults to \"squeeze\".</p> </li> <li> <code>ngff_version</code>               (<code>NgffVersions | None</code>, default:                   <code>None</code> )           \u2013            <p>The NGFF version to use.</p> </li> <li> <code>chunks</code>               (<code>ChunksLike | None</code>, default:                   <code>None</code> )           \u2013            <p>The chunk shape of the new label.</p> </li> <li> <code>shards</code>               (<code>ShardsLike | None</code>, default:                   <code>None</code> )           \u2013            <p>The shard shape of the new label.</p> </li> <li> <code>dtype</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The data type of the new label.</p> </li> <li> <code>dimension_separator</code>               (<code>Literal['.', '/'] | None</code>, default:                   <code>None</code> )           \u2013            <p>The separator to use for dimensions.</p> </li> <li> <code>compressors</code>               (<code>CompressorLike | None</code>, default:                   <code>None</code> )           \u2013            <p>The compressors to use.</p> </li> <li> <code>extra_array_kwargs</code>               (<code>Mapping[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Extra arguments to pass to the zarr array creation.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to overwrite an existing label. Defaults to False.</p> </li> <li> <code>labels</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. This argument is deprecated, please use channels_meta instead.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. The pixel size of the new label. This argument is deprecated, please use pixelsize, z_spacing, and time_spacing instead.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Label</code> (              <code>Label</code> )          \u2013            <p>The new derived label.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def derive_label(\n    self,\n    name: str,\n    ref_image: Image | Label | None = None,\n    # Metadata parameters\n    shape: Sequence[int] | None = None,\n    pixelsize: float | tuple[float, float] | None = None,\n    z_spacing: float | None = None,\n    time_spacing: float | None = None,\n    translation: Sequence[float] | None = None,\n    channels_policy: Literal[\"same\", \"squeeze\", \"singleton\"] | int = \"squeeze\",\n    ngff_version: NgffVersions | None = None,\n    # Zarr Array parameters\n    chunks: ChunksLike | None = None,\n    shards: ShardsLike | None = None,\n    dtype: str | None = None,\n    dimension_separator: Literal[\".\", \"/\"] | None = None,\n    compressors: CompressorLike | None = None,\n    extra_array_kwargs: Mapping[str, Any] | None = None,\n    overwrite: bool = False,\n    # Deprecated arguments\n    labels: Sequence[str] | None = None,\n    pixel_size: PixelSize | None = None,\n) -&gt; \"Label\":\n    \"\"\"Derive a new label from an existing image or label.\n\n    If a kwarg is not provided, the value from the reference image will be used.\n\n    Args:\n        name (str): The name of the new label.\n        ref_image (Image | Label | None): The reference image to derive the new\n            label from. If None, the first level image will be used.\n        shape (Sequence[int] | None): The shape of the new label.\n        pixelsize (float | tuple[float, float] | None): The pixel size of the new\n            label.\n        z_spacing (float | None): The z spacing of the new label.\n        time_spacing (float | None): The time spacing of the new label.\n        translation (Sequence[float] | None): The translation for each axis\n            at the highest resolution level. Defaults to None.\n        channels_policy (Literal[\"same\", \"squeeze\", \"singleton\"] | int): Possible\n            policies:\n            - If \"squeeze\", the channels axis will be removed (no matter its size).\n            - If \"same\", the channels axis will be kept as is (if it exists).\n            - If \"singleton\", the channels axis will be set to size 1.\n            - If an integer is provided, the channels axis will be changed to have\n                that size.\n            Defaults to \"squeeze\".\n        ngff_version (NgffVersions | None): The NGFF version to use.\n        chunks (ChunksLike | None): The chunk shape of the new label.\n        shards (ShardsLike | None): The shard shape of the new label.\n        dtype (str | None): The data type of the new label.\n        dimension_separator (Literal[\".\", \"/\"] | None): The separator to use for\n            dimensions.\n        compressors (CompressorLike | None): The compressors to use.\n        extra_array_kwargs (Mapping[str, Any] | None): Extra arguments to pass to\n            the zarr array creation.\n        overwrite (bool): Whether to overwrite an existing label. Defaults to False.\n        labels (Sequence[str] | None): Deprecated. This argument is deprecated,\n            please use channels_meta instead.\n        pixel_size (PixelSize | None): Deprecated. The pixel size of the new label.\n            This argument is deprecated, please use pixelsize, z_spacing,\n            and time_spacing instead.\n\n    Returns:\n        Label: The new derived label.\n\n    \"\"\"\n    if ref_image is None:\n        ref_image = self.get_image()\n    return self.labels_container.derive(\n        name=name,\n        ref_image=ref_image,\n        shape=shape,\n        pixelsize=pixelsize,\n        z_spacing=z_spacing,\n        time_spacing=time_spacing,\n        translation=translation,\n        channels_policy=channels_policy,\n        ngff_version=ngff_version,\n        chunks=chunks,\n        shards=shards,\n        dtype=dtype,\n        dimension_separator=dimension_separator,\n        compressors=compressors,\n        extra_array_kwargs=extra_array_kwargs,\n        overwrite=overwrite,\n        labels=labels,\n        pixel_size=pixel_size,\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.create_synthetic_ome_zarr","title":"create_synthetic_ome_zarr","text":"<pre><code>create_synthetic_ome_zarr(\n    store: StoreOrGroup,\n    shape: Sequence[int],\n    reference_sample: AVAILABLE_SAMPLES\n    | SampleInfo = \"Cardiomyocyte\",\n    levels: int | list[str] = 5,\n    translation: Sequence[float] | None = None,\n    table_backend: TableBackend = DefaultTableBackend,\n    scaling_factors: Sequence[float]\n    | Literal[\"auto\"] = \"auto\",\n    axes_names: Sequence[str] | None = None,\n    channels_meta: Sequence[str | Channel] | None = None,\n    ngff_version: NgffVersions = DefaultNgffVersion,\n    chunks: ChunksLike = \"auto\",\n    shards: ShardsLike | None = None,\n    dimension_separator: Literal[\".\", \"/\"] = \"/\",\n    compressors: CompressorLike = \"auto\",\n    extra_array_kwargs: Mapping[str, Any] | None = None,\n    overwrite: bool = False,\n) -&gt; OmeZarrContainer\n</code></pre> <p>Create a synthetic OME-Zarr image with the given shape and metadata.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group to create the image in.</p> </li> <li> <code>shape</code>               (<code>Sequence[int]</code>)           \u2013            <p>The shape of the image.</p> </li> <li> <code>reference_sample</code>               (<code>AVAILABLE_SAMPLES | SampleInfo</code>, default:                   <code>'Cardiomyocyte'</code> )           \u2013            <p>The reference sample to use. Defaults to \"Cardiomyocyte\".</p> </li> <li> <code>levels</code>               (<code>int | list[str]</code>, default:                   <code>5</code> )           \u2013            <p>The number of levels in the pyramid or a list of level names. Defaults to 5.</p> </li> <li> <code>translation</code>               (<code>Sequence[float] | None</code>, default:                   <code>None</code> )           \u2013            <p>The translation for each axis at the highest resolution level. Defaults to None.</p> </li> <li> <code>table_backend</code>               (<code>TableBackend</code>, default:                   <code>DefaultTableBackend</code> )           \u2013            <p>Table backend to be used to store tables. Defaults to DefaultTableBackend.</p> </li> <li> <code>scaling_factors</code>               (<code>Sequence[float] | Literal['auto']</code>, default:                   <code>'auto'</code> )           \u2013            <p>The down-scaling factors for the pyramid levels. Defaults to \"auto\".</p> </li> <li> <code>axes_names</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The names of the axes. If None the canonical names are used. Defaults to None.</p> </li> <li> <code>channels_meta</code>               (<code>Sequence[str | Channel] | None</code>, default:                   <code>None</code> )           \u2013            <p>The channels metadata. Defaults to None.</p> </li> <li> <code>ngff_version</code>               (<code>NgffVersions</code>, default:                   <code>DefaultNgffVersion</code> )           \u2013            <p>The version of the OME-Zarr specification. Defaults to DefaultNgffVersion.</p> </li> <li> <code>chunks</code>               (<code>ChunksLike</code>, default:                   <code>'auto'</code> )           \u2013            <p>The chunk shape. Defaults to \"auto\".</p> </li> <li> <code>shards</code>               (<code>ShardsLike | None</code>, default:                   <code>None</code> )           \u2013            <p>The shard shape. Defaults to None.</p> </li> <li> <code>dimension_separator</code>               (<code>Literal['.', '/']</code>, default:                   <code>'/'</code> )           \u2013            <p>The separator to use for dimensions. Defaults to \"/\".</p> </li> <li> <code>compressors</code>               (<code>CompressorLike</code>, default:                   <code>'auto'</code> )           \u2013            <p>The compressors to use. Defaults to \"auto\".</p> </li> <li> <code>extra_array_kwargs</code>               (<code>Mapping[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Extra arguments to pass to the zarr array creation. Defaults to None.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to overwrite an existing image. Defaults to False.</p> </li> </ul> Source code in <code>ngio/images/_create_synt_container.py</code> <pre><code>def create_synthetic_ome_zarr(\n    store: StoreOrGroup,\n    shape: Sequence[int],\n    reference_sample: AVAILABLE_SAMPLES | SampleInfo = \"Cardiomyocyte\",\n    levels: int | list[str] = 5,\n    translation: Sequence[float] | None = None,\n    table_backend: TableBackend = DefaultTableBackend,\n    scaling_factors: Sequence[float] | Literal[\"auto\"] = \"auto\",\n    axes_names: Sequence[str] | None = None,\n    channels_meta: Sequence[str | Channel] | None = None,\n    ngff_version: NgffVersions = DefaultNgffVersion,\n    chunks: ChunksLike = \"auto\",\n    shards: ShardsLike | None = None,\n    dimension_separator: Literal[\".\", \"/\"] = \"/\",\n    compressors: CompressorLike = \"auto\",\n    extra_array_kwargs: Mapping[str, Any] | None = None,\n    overwrite: bool = False,\n) -&gt; OmeZarrContainer:\n    \"\"\"Create a synthetic OME-Zarr image with the given shape and metadata.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group to create the image in.\n        shape (Sequence[int]): The shape of the image.\n        reference_sample (AVAILABLE_SAMPLES | SampleInfo): The reference sample to use.\n            Defaults to \"Cardiomyocyte\".\n        levels (int | list[str]): The number of levels in the pyramid or a list of\n            level names. Defaults to 5.\n        translation (Sequence[float] | None): The translation for each axis\n            at the highest resolution level. Defaults to None.\n        table_backend (TableBackend): Table backend to be used to store tables.\n            Defaults to DefaultTableBackend.\n        scaling_factors (Sequence[float] | Literal[\"auto\"]): The down-scaling factors\n            for the pyramid levels. Defaults to \"auto\".\n        axes_names (Sequence[str] | None): The names of the axes. If None the\n            canonical names are used. Defaults to None.\n        channels_meta (Sequence[str | Channel] | None): The channels metadata.\n            Defaults to None.\n        ngff_version (NgffVersions): The version of the OME-Zarr specification.\n            Defaults to DefaultNgffVersion.\n        chunks (ChunksLike): The chunk shape. Defaults to \"auto\".\n        shards (ShardsLike | None): The shard shape. Defaults to None.\n        dimension_separator (Literal[\".\", \"/\"]): The separator to use for\n            dimensions. Defaults to \"/\".\n        compressors (CompressorLike): The compressors to use. Defaults to \"auto\".\n        extra_array_kwargs (Mapping[str, Any] | None): Extra arguments to pass to\n            the zarr array creation. Defaults to None.\n        overwrite (bool): Whether to overwrite an existing image. Defaults to False.\n    \"\"\"\n    if isinstance(reference_sample, str):\n        sample_info = get_sample_info(reference_sample)\n    else:\n        sample_info = reference_sample\n\n    raw = np.asarray(PIL.Image.open(sample_info.img_path))\n    raw = fit_to_shape(arr=raw, out_shape=tuple(shape))\n    raw = raw / np.max(raw) * (2**16 - 1)\n    raw = raw.astype(np.uint16)\n    ome_zarr = create_ome_zarr_from_array(\n        store=store,\n        array=raw,\n        pixelsize=sample_info.pixelsize,\n        z_spacing=sample_info.z_spacing,\n        time_spacing=sample_info.time_spacing,\n        levels=levels,\n        translation=translation,\n        space_unit=sample_info.space_unit,\n        time_unit=sample_info.time_unit,\n        axes_names=axes_names,\n        channels_meta=channels_meta,\n        scaling_factors=scaling_factors,\n        extra_array_kwargs=extra_array_kwargs,\n        name=sample_info.name,\n        chunks=chunks,\n        shards=shards,\n        overwrite=overwrite,\n        dimension_separator=dimension_separator,\n        compressors=compressors,\n        ngff_version=ngff_version,\n    )\n\n    image = ome_zarr.get_image()\n    well_table = image.build_image_roi_table()\n    ome_zarr.add_table(\"well_ROI_table\", table=well_table, backend=table_backend)\n\n    for label_info in sample_info.labels:\n        ome_zarr.derive_label(name=label_info.name)\n        label = ome_zarr.get_label(name=label_info.name)\n\n        ref_label = np.asarray(PIL.Image.open(label_info.label_path))\n        ref_label = ref_label.astype(label_info.dtype)\n\n        ref_label = fit_to_shape(\n            arr=ref_label,\n            out_shape=label.shape,\n            ensure_unique_info=label_info.ensure_unique_labels,\n        )\n        ref_label = ref_label.astype(np.uint32)\n        label.set_array(ref_label)\n        label.consolidate()\n\n        if label_info.create_masking_table:\n            masking_table = label.build_masking_roi_table()\n            ome_zarr.add_table(\n                name=f\"{label_info.name}_masking_table\",\n                table=masking_table,\n                backend=table_backend,\n            )\n\n    return ome_zarr\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.create_empty_ome_zarr","title":"create_empty_ome_zarr","text":"<pre><code>create_empty_ome_zarr(\n    store: StoreOrGroup,\n    shape: Sequence[int],\n    pixelsize: float | tuple[float, float] | None = None,\n    z_spacing: float = 1.0,\n    time_spacing: float = 1.0,\n    scaling_factors: Sequence[float]\n    | Literal[\"auto\"] = \"auto\",\n    levels: int | list[str] = 5,\n    translation: Sequence[float] | None = None,\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n    axes_names: Sequence[str] | None = None,\n    channels_meta: Sequence[str | Channel] | None = None,\n    name: str | None = None,\n    axes_setup: AxesSetup | None = None,\n    ngff_version: NgffVersions = DefaultNgffVersion,\n    chunks: ChunksLike = \"auto\",\n    shards: ShardsLike | None = None,\n    dtype: str = \"uint16\",\n    dimension_separator: Literal[\".\", \"/\"] = \"/\",\n    compressors: CompressorLike = \"auto\",\n    extra_array_kwargs: Mapping[str, Any] | None = None,\n    overwrite: bool = False,\n    xy_pixelsize: float | None = None,\n    xy_scaling_factor: float | None = None,\n    z_scaling_factor: float | None = None,\n    channel_labels: list[str] | None = None,\n    channel_wavelengths: list[str] | None = None,\n    channel_colors: Sequence[str] | None = None,\n    channel_active: Sequence[bool] | None = None,\n) -&gt; OmeZarrContainer\n</code></pre> <p>Create an empty OME-Zarr image with the given shape and metadata.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group to create the image in.</p> </li> <li> <code>shape</code>               (<code>Sequence[int]</code>)           \u2013            <p>The shape of the image.</p> </li> <li> <code>pixelsize</code>               (<code>float | tuple[float, float] | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size in x and y dimensions.</p> </li> <li> <code>z_spacing</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The spacing between z slices. Defaults to 1.0.</p> </li> <li> <code>time_spacing</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The spacing between time points. Defaults to 1.0.</p> </li> <li> <code>scaling_factors</code>               (<code>Sequence[float] | Literal['auto']</code>, default:                   <code>'auto'</code> )           \u2013            <p>The down-scaling factors for the pyramid levels. Defaults to \"auto\".</p> </li> <li> <code>levels</code>               (<code>int | list[str]</code>, default:                   <code>5</code> )           \u2013            <p>The number of levels in the pyramid or a list of level names. Defaults to 5.</p> </li> <li> <code>translation</code>               (<code>Sequence[float] | None</code>, default:                   <code>None</code> )           \u2013            <p>The translation for each axis. at the highest resolution level. Defaults to None.</p> </li> <li> <code>space_unit</code>               (<code>SpaceUnits</code>, default:                   <code>DefaultSpaceUnit</code> )           \u2013            <p>The unit of space. Defaults to DefaultSpaceUnit.</p> </li> <li> <code>time_unit</code>               (<code>TimeUnits</code>, default:                   <code>DefaultTimeUnit</code> )           \u2013            <p>The unit of time. Defaults to DefaultTimeUnit.</p> </li> <li> <code>axes_names</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The names of the axes. If None the canonical names are used. Defaults to None.</p> </li> <li> <code>channels_meta</code>               (<code>Sequence[str | Channel] | None</code>, default:                   <code>None</code> )           \u2013            <p>The channels metadata. Defaults to None.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the image. Defaults to None.</p> </li> <li> <code>axes_setup</code>               (<code>AxesSetup | None</code>, default:                   <code>None</code> )           \u2013            <p>Axes setup to create ome-zarr with non-standard axes configurations. Defaults to None.</p> </li> <li> <code>ngff_version</code>               (<code>NgffVersions</code>, default:                   <code>DefaultNgffVersion</code> )           \u2013            <p>The version of the OME-Zarr specification. Defaults to DefaultNgffVersion.</p> </li> <li> <code>chunks</code>               (<code>ChunksLike</code>, default:                   <code>'auto'</code> )           \u2013            <p>The chunk shape. Defaults to \"auto\".</p> </li> <li> <code>shards</code>               (<code>ShardsLike | None</code>, default:                   <code>None</code> )           \u2013            <p>The shard shape. Defaults to None.</p> </li> <li> <code>dtype</code>               (<code>str</code>, default:                   <code>'uint16'</code> )           \u2013            <p>The data type of the image. Defaults to \"uint16\".</p> </li> <li> <code>dimension_separator</code>               (<code>Literal['.', '/']</code>, default:                   <code>'/'</code> )           \u2013            <p>The dimension separator to use. Defaults to \"/\".</p> </li> <li> <code>compressors</code>               (<code>CompressorLike</code>, default:                   <code>'auto'</code> )           \u2013            <p>The compressor to use. Defaults to \"auto\".</p> </li> <li> <code>extra_array_kwargs</code>               (<code>Mapping[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Extra arguments to pass to the zarr array creation. Defaults to None.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to overwrite an existing image. Defaults to False.</p> </li> <li> <code>xy_pixelsize</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Use pixelsize instead.</p> </li> <li> <code>xy_scaling_factor</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Use scaling_factors instead.</p> </li> <li> <code>z_scaling_factor</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Use scaling_factors instead.</p> </li> <li> <code>channel_labels</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Use channels_meta instead.</p> </li> <li> <code>channel_wavelengths</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Use channels_meta instead.</p> </li> <li> <code>channel_colors</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Use channels_meta instead.</p> </li> <li> <code>channel_active</code>               (<code>Sequence[bool] | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Use channels_meta instead.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def create_empty_ome_zarr(\n    store: StoreOrGroup,\n    shape: Sequence[int],\n    pixelsize: float | tuple[float, float] | None = None,\n    z_spacing: float = 1.0,\n    time_spacing: float = 1.0,\n    scaling_factors: Sequence[float] | Literal[\"auto\"] = \"auto\",\n    levels: int | list[str] = 5,\n    translation: Sequence[float] | None = None,\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n    axes_names: Sequence[str] | None = None,\n    channels_meta: Sequence[str | Channel] | None = None,\n    name: str | None = None,\n    axes_setup: AxesSetup | None = None,\n    ngff_version: NgffVersions = DefaultNgffVersion,\n    chunks: ChunksLike = \"auto\",\n    shards: ShardsLike | None = None,\n    dtype: str = \"uint16\",\n    dimension_separator: Literal[\".\", \"/\"] = \"/\",\n    compressors: CompressorLike = \"auto\",\n    extra_array_kwargs: Mapping[str, Any] | None = None,\n    overwrite: bool = False,\n    # Deprecated arguments\n    xy_pixelsize: float | None = None,\n    xy_scaling_factor: float | None = None,\n    z_scaling_factor: float | None = None,\n    channel_labels: list[str] | None = None,\n    channel_wavelengths: list[str] | None = None,\n    channel_colors: Sequence[str] | None = None,\n    channel_active: Sequence[bool] | None = None,\n) -&gt; OmeZarrContainer:\n    \"\"\"Create an empty OME-Zarr image with the given shape and metadata.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group to create the image in.\n        shape (Sequence[int]): The shape of the image.\n        pixelsize (float | tuple[float, float] | None): The pixel size in x and y\n            dimensions.\n        z_spacing (float): The spacing between z slices. Defaults to 1.0.\n        time_spacing (float): The spacing between time points. Defaults to 1.0.\n        scaling_factors (Sequence[float] | Literal[\"auto\"]): The down-scaling factors\n            for the pyramid levels. Defaults to \"auto\".\n        levels (int | list[str]): The number of levels in the pyramid or a list of\n            level names. Defaults to 5.\n        translation (Sequence[float] | None): The translation for each axis.\n            at the highest resolution level. Defaults to None.\n        space_unit (SpaceUnits): The unit of space. Defaults to DefaultSpaceUnit.\n        time_unit (TimeUnits): The unit of time. Defaults to DefaultTimeUnit.\n        axes_names (Sequence[str] | None): The names of the axes. If None the\n            canonical names are used. Defaults to None.\n        channels_meta (Sequence[str | Channel] | None): The channels metadata.\n            Defaults to None.\n        name (str | None): The name of the image. Defaults to None.\n        axes_setup (AxesSetup | None): Axes setup to create ome-zarr with\n            non-standard axes configurations. Defaults to None.\n        ngff_version (NgffVersions): The version of the OME-Zarr specification.\n            Defaults to DefaultNgffVersion.\n        chunks (ChunksLike): The chunk shape. Defaults to \"auto\".\n        shards (ShardsLike | None): The shard shape. Defaults to None.\n        dtype (str): The data type of the image. Defaults to \"uint16\".\n        dimension_separator (Literal[\".\", \"/\"]): The dimension separator to use.\n            Defaults to \"/\".\n        compressors (CompressorLike): The compressor to use. Defaults to \"auto\".\n        extra_array_kwargs (Mapping[str, Any] | None): Extra arguments to pass to\n            the zarr array creation. Defaults to None.\n        overwrite (bool): Whether to overwrite an existing image. Defaults to False.\n        xy_pixelsize (float | None): Deprecated. Use pixelsize instead.\n        xy_scaling_factor (float | None): Deprecated. Use scaling_factors instead.\n        z_scaling_factor (float | None): Deprecated. Use scaling_factors instead.\n        channel_labels (list[str] | None): Deprecated. Use channels_meta instead.\n        channel_wavelengths (list[str] | None): Deprecated. Use channels_meta instead.\n        channel_colors (Sequence[str] | None): Deprecated. Use channels_meta instead.\n        channel_active (Sequence[bool] | None): Deprecated. Use channels_meta instead.\n    \"\"\"\n    if xy_pixelsize is not None:\n        logger.warning(\n            \"'xy_pixelsize' is deprecated and will be removed in ngio=0.6. \"\n            \"Please use 'pixelsize' instead.\"\n        )\n        pixelsize = xy_pixelsize\n    if xy_scaling_factor is not None or z_scaling_factor is not None:\n        logger.warning(\n            \"'xy_scaling_factor' and 'z_scaling_factor' are deprecated and will be \"\n            \"removed in ngio=0.6. Please use 'scaling_factors' instead.\"\n        )\n        xy_scaling_factor_ = xy_scaling_factor or 2.0\n        z_scaling_factor_ = z_scaling_factor or 1.0\n        if len(shape) == 2:\n            scaling_factors = (xy_scaling_factor_, xy_scaling_factor_)\n        else:\n            zyx_factors = (z_scaling_factor_, xy_scaling_factor_, xy_scaling_factor_)\n            scaling_factors = (1.0,) * (len(shape) - 3) + zyx_factors\n\n    if channel_labels is not None:\n        logger.warning(\n            \"'channel_labels' is deprecated and will be removed in ngio=0.6. \"\n            \"Please use 'channels_meta' instead.\"\n        )\n        channels_meta = channel_labels\n\n    if channel_wavelengths is not None:\n        logger.warning(\n            \"'channel_wavelengths' is deprecated and will be removed in ngio=0.6. \"\n            \"Please use 'channels_meta' instead.\"\n        )\n    if channel_colors is not None:\n        logger.warning(\n            \"'channel_colors' is deprecated and will be removed in ngio=0.6. \"\n            \"Please use 'channels_meta' instead.\"\n        )\n    if channel_active is not None:\n        logger.warning(\n            \"'channel_active' is deprecated and will be removed in ngio=0.6. \"\n            \"Please use 'channels_meta' instead.\"\n        )\n\n    if pixelsize is None:\n        raise NgioValueError(\"pixelsize must be provided.\")\n\n    handler, axes_setup = init_image_like(\n        store=store,\n        meta_type=NgioImageMeta,\n        shape=shape,\n        pixelsize=pixelsize,\n        z_spacing=z_spacing,\n        time_spacing=time_spacing,\n        scaling_factors=scaling_factors,\n        levels=levels,\n        translation=translation,\n        space_unit=space_unit,\n        time_unit=time_unit,\n        axes_names=axes_names,\n        channels_meta=channels_meta,\n        name=name,\n        axes_setup=axes_setup,\n        ngff_version=ngff_version,\n        chunks=chunks,\n        shards=shards,\n        dtype=dtype,\n        dimension_separator=dimension_separator,\n        compressors=compressors,\n        extra_array_kwargs=extra_array_kwargs,\n        overwrite=overwrite,\n    )\n\n    ome_zarr = OmeZarrContainer(group_handler=handler, axes_setup=axes_setup)\n    if (\n        channel_labels is not None\n        or channel_wavelengths is not None\n        or channel_colors is not None\n        or channel_active is not None\n    ):\n        # Deprecated way of setting channel metadata\n        # we set it here for backward compatibility\n        ome_zarr.set_channel_meta(\n            labels=channel_labels,\n            wavelength_id=channel_wavelengths,\n            percentiles=None,\n            colors=channel_colors,\n            active=channel_active,\n        )\n    return ome_zarr\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.create_ome_zarr_from_array","title":"create_ome_zarr_from_array","text":"<pre><code>create_ome_zarr_from_array(\n    store: StoreOrGroup,\n    array: ndarray,\n    pixelsize: float | tuple[float, float] | None = None,\n    z_spacing: float = 1.0,\n    time_spacing: float = 1.0,\n    scaling_factors: Sequence[float]\n    | Literal[\"auto\"] = \"auto\",\n    levels: int | list[str] = 5,\n    translation: Sequence[float] | None = None,\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n    axes_names: Sequence[str] | None = None,\n    channels_meta: Sequence[str | Channel] | None = None,\n    percentiles: tuple[float, float] = (0.1, 99.9),\n    name: str | None = None,\n    axes_setup: AxesSetup | None = None,\n    ngff_version: NgffVersions = DefaultNgffVersion,\n    chunks: ChunksLike = \"auto\",\n    shards: ShardsLike | None = None,\n    dimension_separator: Literal[\".\", \"/\"] = \"/\",\n    compressors: CompressorLike = \"auto\",\n    extra_array_kwargs: Mapping[str, Any] | None = None,\n    overwrite: bool = False,\n    xy_pixelsize: float | None = None,\n    xy_scaling_factor: float | None = None,\n    z_scaling_factor: float | None = None,\n    channel_labels: list[str] | None = None,\n    channel_wavelengths: list[str] | None = None,\n    channel_colors: Sequence[str] | None = None,\n    channel_active: Sequence[bool] | None = None,\n) -&gt; OmeZarrContainer\n</code></pre> <p>Create an OME-Zarr image from a numpy array.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group to create the image in.</p> </li> <li> <code>array</code>               (<code>ndarray</code>)           \u2013            <p>The image data.</p> </li> <li> <code>pixelsize</code>               (<code>float | tuple[float, float] | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size in x and y dimensions.</p> </li> <li> <code>z_spacing</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The spacing between z slices. Defaults to 1.0.</p> </li> <li> <code>time_spacing</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The spacing between time points. Defaults to 1.0.</p> </li> <li> <code>scaling_factors</code>               (<code>Sequence[float] | Literal['auto']</code>, default:                   <code>'auto'</code> )           \u2013            <p>The down-scaling factors for the pyramid levels. Defaults to \"auto\".</p> </li> <li> <code>levels</code>               (<code>int | list[str]</code>, default:                   <code>5</code> )           \u2013            <p>The number of levels in the pyramid or a list of level names. Defaults to 5.</p> </li> <li> <code>translation</code>               (<code>Sequence[float] | None</code>, default:                   <code>None</code> )           \u2013            <p>The translation for each axis. at the highest resolution level. Defaults to None.</p> </li> <li> <code>space_unit</code>               (<code>SpaceUnits</code>, default:                   <code>DefaultSpaceUnit</code> )           \u2013            <p>The unit of space. Defaults to DefaultSpaceUnit.</p> </li> <li> <code>time_unit</code>               (<code>TimeUnits</code>, default:                   <code>DefaultTimeUnit</code> )           \u2013            <p>The unit of time. Defaults to DefaultTimeUnit.</p> </li> <li> <code>axes_names</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The names of the axes. If None the canonical names are used. Defaults to None.</p> </li> <li> <code>channels_meta</code>               (<code>Sequence[str | Channel] | None</code>, default:                   <code>None</code> )           \u2013            <p>The channels metadata. Defaults to None.</p> </li> <li> <code>percentiles</code>               (<code>tuple[float, float]</code>, default:                   <code>(0.1, 99.9)</code> )           \u2013            <p>The percentiles of the channels for computing display ranges. Defaults to (0.1, 99.9).</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the image. Defaults to None.</p> </li> <li> <code>axes_setup</code>               (<code>AxesSetup | None</code>, default:                   <code>None</code> )           \u2013            <p>Axes setup to create ome-zarr with non-standard axes configurations. Defaults to None.</p> </li> <li> <code>ngff_version</code>               (<code>NgffVersions</code>, default:                   <code>DefaultNgffVersion</code> )           \u2013            <p>The version of the OME-Zarr specification. Defaults to DefaultNgffVersion.</p> </li> <li> <code>chunks</code>               (<code>ChunksLike</code>, default:                   <code>'auto'</code> )           \u2013            <p>The chunk shape. Defaults to \"auto\".</p> </li> <li> <code>shards</code>               (<code>ShardsLike | None</code>, default:                   <code>None</code> )           \u2013            <p>The shard shape. Defaults to None.</p> </li> <li> <code>dimension_separator</code>               (<code>Literal['.', '/']</code>, default:                   <code>'/'</code> )           \u2013            <p>The separator to use for dimensions. Defaults to \"/\".</p> </li> <li> <code>compressors</code>               (<code>CompressorLike</code>, default:                   <code>'auto'</code> )           \u2013            <p>The compressors to use. Defaults to \"auto\".</p> </li> <li> <code>extra_array_kwargs</code>               (<code>Mapping[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Extra arguments to pass to the zarr array creation. Defaults to None.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to overwrite an existing image. Defaults to False.</p> </li> <li> <code>xy_pixelsize</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Use pixelsize instead.</p> </li> <li> <code>xy_scaling_factor</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Use scaling_factors instead.</p> </li> <li> <code>z_scaling_factor</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Use scaling_factors instead.</p> </li> <li> <code>channel_labels</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Use channels_meta instead.</p> </li> <li> <code>channel_wavelengths</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Use channels_meta instead.</p> </li> <li> <code>channel_colors</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Use channels_meta instead.</p> </li> <li> <code>channel_active</code>               (<code>Sequence[bool] | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Use channels_meta instead.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def create_ome_zarr_from_array(\n    store: StoreOrGroup,\n    array: np.ndarray,\n    pixelsize: float | tuple[float, float] | None = None,\n    z_spacing: float = 1.0,\n    time_spacing: float = 1.0,\n    scaling_factors: Sequence[float] | Literal[\"auto\"] = \"auto\",\n    levels: int | list[str] = 5,\n    translation: Sequence[float] | None = None,\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n    axes_names: Sequence[str] | None = None,\n    channels_meta: Sequence[str | Channel] | None = None,\n    percentiles: tuple[float, float] = (0.1, 99.9),\n    name: str | None = None,\n    axes_setup: AxesSetup | None = None,\n    ngff_version: NgffVersions = DefaultNgffVersion,\n    chunks: ChunksLike = \"auto\",\n    shards: ShardsLike | None = None,\n    dimension_separator: Literal[\".\", \"/\"] = \"/\",\n    compressors: CompressorLike = \"auto\",\n    extra_array_kwargs: Mapping[str, Any] | None = None,\n    overwrite: bool = False,\n    # Deprecated arguments\n    xy_pixelsize: float | None = None,\n    xy_scaling_factor: float | None = None,\n    z_scaling_factor: float | None = None,\n    channel_labels: list[str] | None = None,\n    channel_wavelengths: list[str] | None = None,\n    channel_colors: Sequence[str] | None = None,\n    channel_active: Sequence[bool] | None = None,\n) -&gt; OmeZarrContainer:\n    \"\"\"Create an OME-Zarr image from a numpy array.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group to create the image in.\n        array (np.ndarray): The image data.\n        pixelsize (float | tuple[float, float] | None): The pixel size in x and y\n            dimensions.\n        z_spacing (float): The spacing between z slices. Defaults to 1.0.\n        time_spacing (float): The spacing between time points. Defaults to 1.0.\n        scaling_factors (Sequence[float] | Literal[\"auto\"]): The down-scaling factors\n            for the pyramid levels. Defaults to \"auto\".\n        levels (int | list[str]): The number of levels in the pyramid or a list of\n            level names. Defaults to 5.\n        translation (Sequence[float] | None): The translation for each axis.\n            at the highest resolution level. Defaults to None.\n        space_unit (SpaceUnits): The unit of space. Defaults to DefaultSpaceUnit.\n        time_unit (TimeUnits): The unit of time. Defaults to DefaultTimeUnit.\n        axes_names (Sequence[str] | None): The names of the axes. If None the\n            canonical names are used. Defaults to None.\n        channels_meta (Sequence[str | Channel] | None): The channels metadata.\n            Defaults to None.\n        percentiles (tuple[float, float]): The percentiles of the channels for\n            computing display ranges. Defaults to (0.1, 99.9).\n        name (str | None): The name of the image. Defaults to None.\n        axes_setup (AxesSetup | None): Axes setup to create ome-zarr with\n            non-standard axes configurations. Defaults to None.\n        ngff_version (NgffVersions): The version of the OME-Zarr specification.\n            Defaults to DefaultNgffVersion.\n        chunks (ChunksLike): The chunk shape. Defaults to \"auto\".\n        shards (ShardsLike | None): The shard shape. Defaults to None.\n        dimension_separator (Literal[\".\", \"/\"]): The separator to use for\n            dimensions. Defaults to \"/\".\n        compressors (CompressorLike): The compressors to use. Defaults to \"auto\".\n        extra_array_kwargs (Mapping[str, Any] | None): Extra arguments to pass to\n            the zarr array creation. Defaults to None.\n        overwrite (bool): Whether to overwrite an existing image. Defaults to False.\n        xy_pixelsize (float | None): Deprecated. Use pixelsize instead.\n        xy_scaling_factor (float | None): Deprecated. Use scaling_factors instead.\n        z_scaling_factor (float | None): Deprecated. Use scaling_factors instead.\n        channel_labels (list[str] | None): Deprecated. Use channels_meta instead.\n        channel_wavelengths (list[str] | None): Deprecated. Use channels_meta instead.\n        channel_colors (Sequence[str] | None): Deprecated. Use channels_meta instead.\n        channel_active (Sequence[bool] | None): Deprecated. Use channels_meta instead.\n    \"\"\"\n    if len(percentiles) != 2:\n        raise NgioValueError(\n            f\"'percentiles' must be a tuple of two values. Got {percentiles}\"\n        )\n    ome_zarr = create_empty_ome_zarr(\n        store=store,\n        shape=array.shape,\n        pixelsize=pixelsize,\n        z_spacing=z_spacing,\n        time_spacing=time_spacing,\n        scaling_factors=scaling_factors,\n        levels=levels,\n        translation=translation,\n        space_unit=space_unit,\n        time_unit=time_unit,\n        axes_names=axes_names,\n        channels_meta=channels_meta,\n        name=name,\n        axes_setup=axes_setup,\n        ngff_version=ngff_version,\n        chunks=chunks,\n        shards=shards,\n        dimension_separator=dimension_separator,\n        compressors=compressors,\n        extra_array_kwargs=extra_array_kwargs,\n        overwrite=overwrite,\n        xy_pixelsize=xy_pixelsize,\n        xy_scaling_factor=xy_scaling_factor,\n        z_scaling_factor=z_scaling_factor,\n        channel_labels=channel_labels,\n        channel_wavelengths=channel_wavelengths,\n        channel_colors=channel_colors,\n        channel_active=channel_active,\n    )\n    image = ome_zarr.get_image()\n    image.set_array(array)\n    image.consolidate()\n    ome_zarr.set_channel_windows_with_percentiles(percentiles=percentiles)\n    return ome_zarr\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.open_image","title":"open_image","text":"<pre><code>open_image(\n    store: StoreOrGroup,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = True,\n    axes_setup: AxesSetup | None = None,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n) -&gt; Image\n</code></pre> <p>Open a single level image from an OME-Zarr image.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group to create the image in.</p> </li> <li> <code>path</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the image in the ome_zarr file.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the image.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Only used if the pixel size is provided. If True, the     pixel size must match the image pixel size exactly. If False, the     closest pixel size level will be returned.</p> </li> <li> <code>axes_setup</code>               (<code>AxesSetup | None</code>, default:                   <code>None</code> )           \u2013            <p>Axes setup to load ome-zarr with non-standard axes configurations.</p> </li> <li> <code>cache</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use a cache for the zarr group metadata.</p> </li> <li> <code>mode</code>               (<code>AccessModeLiteral</code>, default:                   <code>'r+'</code> )           \u2013            <p>The access mode for the image. Defaults to \"r+\".</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def open_image(\n    store: StoreOrGroup,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = True,\n    axes_setup: AxesSetup | None = None,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n) -&gt; Image:\n    \"\"\"Open a single level image from an OME-Zarr image.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group to create the image in.\n        path (str | None): The path to the image in the ome_zarr file.\n        pixel_size (PixelSize | None): The pixel size of the image.\n        strict (bool): Only used if the pixel size is provided. If True, the\n                pixel size must match the image pixel size exactly. If False, the\n                closest pixel size level will be returned.\n        axes_setup (AxesSetup | None): Axes setup to load ome-zarr with\n            non-standard axes configurations.\n        cache (bool): Whether to use a cache for the zarr group metadata.\n        mode (AccessModeLiteral): The\n            access mode for the image. Defaults to \"r+\".\n    \"\"\"\n    group_handler = ZarrGroupHandler(store=store, cache=cache, mode=mode)\n    images_container = ImagesContainer(group_handler, axes_setup=axes_setup)\n    return images_container.get(\n        path=path,\n        pixel_size=pixel_size,\n        strict=strict,\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.open_label","title":"open_label","text":"<pre><code>open_label(\n    store: StoreOrGroup,\n    name: str | None = None,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = True,\n    axes_setup: AxesSetup | None = None,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n) -&gt; Label\n</code></pre> <p>Open a single level label from an OME-Zarr Label group.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group to create the image in.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the label. If None, we will try to open the store as a multiscale label.</p> </li> <li> <code>path</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the image in the ome_zarr file.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the image.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Only used if the pixel size is provided. If True, the pixel size must match the image pixel size exactly. If False, the closest pixel size level will be returned.</p> </li> <li> <code>axes_setup</code>               (<code>AxesSetup | None</code>, default:                   <code>None</code> )           \u2013            <p>Axes setup to load ome-zarr with non-standard axes configurations.</p> </li> <li> <code>cache</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use a cache for the zarr group metadata.</p> </li> <li> <code>mode</code>               (<code>AccessModeLiteral</code>, default:                   <code>'r+'</code> )           \u2013            <p>The access mode for the image. Defaults to \"r+\".</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def open_label(\n    store: StoreOrGroup,\n    name: str | None = None,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = True,\n    axes_setup: AxesSetup | None = None,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n) -&gt; Label:\n    \"\"\"Open a single level label from an OME-Zarr Label group.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group to create the image in.\n        name (str | None): The name of the label. If None,\n            we will try to open the store as a multiscale label.\n        path (str | None): The path to the image in the ome_zarr file.\n        pixel_size (PixelSize | None): The pixel size of the image.\n        strict (bool): Only used if the pixel size is provided. If True, the\n            pixel size must match the image pixel size exactly. If False, the\n            closest pixel size level will be returned.\n        axes_setup (AxesSetup | None): Axes setup to load ome-zarr with\n            non-standard axes configurations.\n        cache (bool): Whether to use a cache for the zarr group metadata.\n        mode (AccessModeLiteral): The access mode for the image. Defaults to \"r+\".\n\n    \"\"\"\n    group_handler = ZarrGroupHandler(store=store, cache=cache, mode=mode)\n    if name is None:\n        label_meta_handler = LabelMetaHandler(group_handler, axes_setup=axes_setup)\n        path = (\n            label_meta_handler.get_meta()\n            .get_dataset(path=path, pixel_size=pixel_size, strict=strict)\n            .path\n        )\n        return Label(group_handler, path, label_meta_handler)\n\n    labels_container = LabelsContainer(group_handler, axes_setup=axes_setup)\n    return labels_container.get(\n        name=name,\n        path=path,\n        pixel_size=pixel_size,\n        strict=strict,\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.open_ome_zarr_container","title":"open_ome_zarr_container","text":"<pre><code>open_ome_zarr_container(\n    store: StoreOrGroup,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n    axes_setup: AxesSetup | None = None,\n    validate_arrays: bool = True,\n) -&gt; OmeZarrContainer\n</code></pre> <p>Open an OME-Zarr image.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def open_ome_zarr_container(\n    store: StoreOrGroup,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n    axes_setup: AxesSetup | None = None,\n    validate_arrays: bool = True,\n) -&gt; OmeZarrContainer:\n    \"\"\"Open an OME-Zarr image.\"\"\"\n    handler = ZarrGroupHandler(store=store, cache=cache, mode=mode)\n    return OmeZarrContainer(\n        group_handler=handler,\n        validate_paths=validate_arrays,\n        axes_setup=axes_setup,\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.concatenate_image_tables","title":"concatenate_image_tables","text":"<pre><code>concatenate_image_tables(\n    images: Sequence[OmeZarrContainer],\n    extras: Sequence[dict[str, str]],\n    name: str,\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; Table\n</code></pre> <p>Concatenate tables from different images into a single table.</p> <p>Parameters:</p> <ul> <li> <code>images</code>               (<code>Sequence[OmeZarrContainer]</code>)           \u2013            <p>A collection of images.</p> </li> <li> <code>extras</code>               (<code>Sequence[dict[str, str]]</code>)           \u2013            <p>A collection of extras dictionaries for each image. this will be added as columns to the table, and will be concatenated with the table index to create a new index.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table to concatenate.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The key to use for the index of the concatenated table.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, raise an error if the table is not found in the image.</p> </li> <li> <code>mode</code>               (<code>Literal['eager', 'lazy']</code>, default:                   <code>'eager'</code> )           \u2013            <p>The mode to use for concatenation. Can be 'eager' or 'lazy'. if 'eager', the table will be loaded into memory. if 'lazy', the table will be loaded as a lazy frame.</p> </li> </ul> Source code in <code>ngio/images/_table_ops.py</code> <pre><code>def concatenate_image_tables(\n    images: Sequence[OmeZarrContainer],\n    extras: Sequence[dict[str, str]],\n    name: str,\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; Table:\n    \"\"\"Concatenate tables from different images into a single table.\n\n    Args:\n        images: A collection of images.\n        extras: A collection of extras dictionaries for each image.\n            this will be added as columns to the table, and will be\n            concatenated with the table index to create a new index.\n        name: The name of the table to concatenate.\n        index_key: The key to use for the index of the concatenated table.\n        strict: If True, raise an error if the table is not found in the image.\n        mode: The mode to use for concatenation. Can be 'eager' or 'lazy'.\n            if 'eager', the table will be loaded into memory.\n            if 'lazy', the table will be loaded as a lazy frame.\n    \"\"\"\n    return _concatenate_image_tables(\n        images=images,\n        extras=extras,\n        name=name,\n        table_cls=None,\n        index_key=index_key,\n        strict=strict,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.concatenate_image_tables_as","title":"concatenate_image_tables_as","text":"<pre><code>concatenate_image_tables_as(\n    images: Sequence[OmeZarrContainer],\n    extras: Sequence[dict[str, str]],\n    name: str,\n    table_cls: type[TableType],\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; TableType\n</code></pre> <p>Concatenate tables from different images into a single table.</p> <p>Parameters:</p> <ul> <li> <code>images</code>               (<code>Sequence[OmeZarrContainer]</code>)           \u2013            <p>A collection of images.</p> </li> <li> <code>extras</code>               (<code>Sequence[dict[str, str]]</code>)           \u2013            <p>A collection of extras dictionaries for each image. this will be added as columns to the table, and will be concatenated with the table index to create a new index.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table to concatenate.</p> </li> <li> <code>table_cls</code>               (<code>type[TableType]</code>)           \u2013            <p>The output will be casted to this class, if the new table_cls is compatible with the table_cls of the input tables.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The key to use for the index of the concatenated table.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, raise an error if the table is not found in the image.</p> </li> <li> <code>mode</code>               (<code>Literal['eager', 'lazy']</code>, default:                   <code>'eager'</code> )           \u2013            <p>The mode to use for concatenation. Can be 'eager' or 'lazy'. if 'eager', the table will be loaded into memory. if 'lazy', the table will be loaded as a lazy frame.</p> </li> </ul> Source code in <code>ngio/images/_table_ops.py</code> <pre><code>def concatenate_image_tables_as(\n    images: Sequence[OmeZarrContainer],\n    extras: Sequence[dict[str, str]],\n    name: str,\n    table_cls: type[TableType],\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; TableType:\n    \"\"\"Concatenate tables from different images into a single table.\n\n    Args:\n        images: A collection of images.\n        extras: A collection of extras dictionaries for each image.\n            this will be added as columns to the table, and will be\n            concatenated with the table index to create a new index.\n        name: The name of the table to concatenate.\n        table_cls: The output will be casted to this class, if the new table_cls is\n            compatible with the table_cls of the input tables.\n        index_key: The key to use for the index of the concatenated table.\n        strict: If True, raise an error if the table is not found in the image.\n        mode: The mode to use for concatenation. Can be 'eager' or 'lazy'.\n            if 'eager', the table will be loaded into memory.\n            if 'lazy', the table will be loaded as a lazy frame.\n    \"\"\"\n    table = _concatenate_image_tables(\n        images=images,\n        extras=extras,\n        name=name,\n        table_cls=table_cls,\n        index_key=index_key,\n        strict=strict,\n        mode=mode,\n    )\n    if not isinstance(table, table_cls):\n        raise ValueError(f\"Table is not of type {table_cls}. Got {type(table)}\")\n    return table\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.concatenate_image_tables_as_async","title":"concatenate_image_tables_as_async  <code>async</code>","text":"<pre><code>concatenate_image_tables_as_async(\n    images: Sequence[OmeZarrContainer],\n    extras: Sequence[dict[str, str]],\n    name: str,\n    table_cls: type[TableType],\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; TableType\n</code></pre> <p>Concatenate tables from different images into a single table.</p> <p>Parameters:</p> <ul> <li> <code>images</code>               (<code>Sequence[OmeZarrContainer]</code>)           \u2013            <p>A collection of images.</p> </li> <li> <code>extras</code>               (<code>Sequence[dict[str, str]]</code>)           \u2013            <p>A collection of extras dictionaries for each image. this will be added as columns to the table, and will be concatenated with the table index to create a new index.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table to concatenate.</p> </li> <li> <code>table_cls</code>               (<code>type[TableType]</code>)           \u2013            <p>The output will be casted to this class, if the new table_cls is compatible with the table_cls of the input tables.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The key to use for the index of the concatenated table.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, raise an error if the table is not found in the image.</p> </li> <li> <code>mode</code>               (<code>Literal['eager', 'lazy']</code>, default:                   <code>'eager'</code> )           \u2013            <p>The mode to use for concatenation. Can be 'eager' or 'lazy'. if 'eager', the table will be loaded into memory. if 'lazy', the table will be loaded as a lazy frame.</p> </li> </ul> Source code in <code>ngio/images/_table_ops.py</code> <pre><code>async def concatenate_image_tables_as_async(\n    images: Sequence[OmeZarrContainer],\n    extras: Sequence[dict[str, str]],\n    name: str,\n    table_cls: type[TableType],\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; TableType:\n    \"\"\"Concatenate tables from different images into a single table.\n\n    Args:\n        images: A collection of images.\n        extras: A collection of extras dictionaries for each image.\n            this will be added as columns to the table, and will be\n            concatenated with the table index to create a new index.\n        name: The name of the table to concatenate.\n        table_cls: The output will be casted to this class, if the new table_cls is\n            compatible with the table_cls of the input tables.\n        index_key: The key to use for the index of the concatenated table.\n        strict: If True, raise an error if the table is not found in the image.\n        mode: The mode to use for concatenation. Can be 'eager' or 'lazy'.\n            if 'eager', the table will be loaded into memory.\n            if 'lazy', the table will be loaded as a lazy frame.\n    \"\"\"\n    table = await _concatenate_image_tables_async(\n        images=images,\n        extras=extras,\n        name=name,\n        table_cls=table_cls,\n        index_key=index_key,\n        strict=strict,\n        mode=mode,\n    )\n    if not isinstance(table, table_cls):\n        raise ValueError(f\"Table is not of type {table_cls}. Got {type(table)}\")\n    return table\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.concatenate_image_tables_async","title":"concatenate_image_tables_async  <code>async</code>","text":"<pre><code>concatenate_image_tables_async(\n    images: Sequence[OmeZarrContainer],\n    extras: Sequence[dict[str, str]],\n    name: str,\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; Table\n</code></pre> <p>Concatenate tables from different images into a single table.</p> <p>Parameters:</p> <ul> <li> <code>images</code>               (<code>Sequence[OmeZarrContainer]</code>)           \u2013            <p>A collection of images.</p> </li> <li> <code>extras</code>               (<code>Sequence[dict[str, str]]</code>)           \u2013            <p>A collection of extras dictionaries for each image. this will be added as columns to the table, and will be concatenated with the table index to create a new index.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table to concatenate.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The key to use for the index of the concatenated table.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, raise an error if the table is not found in the image.</p> </li> <li> <code>mode</code>               (<code>Literal['eager', 'lazy']</code>, default:                   <code>'eager'</code> )           \u2013            <p>The mode to use for concatenation. Can be 'eager' or 'lazy'. if 'eager', the table will be loaded into memory. if 'lazy', the table will be loaded as a lazy frame.</p> </li> </ul> Source code in <code>ngio/images/_table_ops.py</code> <pre><code>async def concatenate_image_tables_async(\n    images: Sequence[OmeZarrContainer],\n    extras: Sequence[dict[str, str]],\n    name: str,\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; Table:\n    \"\"\"Concatenate tables from different images into a single table.\n\n    Args:\n        images: A collection of images.\n        extras: A collection of extras dictionaries for each image.\n            this will be added as columns to the table, and will be\n            concatenated with the table index to create a new index.\n        name: The name of the table to concatenate.\n        index_key: The key to use for the index of the concatenated table.\n        strict: If True, raise an error if the table is not found in the image.\n        mode: The mode to use for concatenation. Can be 'eager' or 'lazy'.\n            if 'eager', the table will be loaded into memory.\n            if 'lazy', the table will be loaded as a lazy frame.\n    \"\"\"\n    return await _concatenate_image_tables_async(\n        images=images,\n        extras=extras,\n        name=name,\n        table_cls=None,\n        index_key=index_key,\n        strict=strict,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.conctatenate_tables","title":"conctatenate_tables","text":"<pre><code>conctatenate_tables(\n    tables: Sequence[TableWithExtras],\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n    index_key: str | None = None,\n    table_cls: type[TableType] | None = None,\n) -&gt; Table\n</code></pre> <p>Concatenate tables from different plates into a single table.</p> Source code in <code>ngio/images/_table_ops.py</code> <pre><code>def conctatenate_tables(\n    tables: Sequence[TableWithExtras],\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n    index_key: str | None = None,\n    table_cls: type[TableType] | None = None,\n) -&gt; Table:\n    \"\"\"Concatenate tables from different plates into a single table.\"\"\"\n    if len(tables) == 0:\n        raise ValueError(\"No tables to concatenate.\")\n\n    table0 = next(iter(tables)).table\n\n    if mode == \"lazy\":\n        concatenated_table = _pl_concat(tables=tables, index_key=index_key)\n    elif mode == \"eager\":\n        concatenated_table = _pd_concat(tables=tables, index_key=index_key)\n    else:\n        raise ValueError(f\"Unknown mode: {mode}. Use 'eager' or 'lazy'.\")\n\n    meta = table0.meta\n    meta.index_key = index_key\n    meta.index_type = \"str\"\n\n    if table_cls is not None:\n        return table_cls.from_table_data(\n            table_data=concatenated_table,\n            meta=meta,\n        )\n    return table0.from_table_data(\n        table_data=concatenated_table,\n        meta=meta,\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.list_image_tables","title":"list_image_tables","text":"<pre><code>list_image_tables(\n    images: Sequence[OmeZarrContainer],\n    filter_types: str | None = None,\n    mode: Literal[\"common\", \"all\"] = \"common\",\n) -&gt; list[str]\n</code></pre> <p>List all table names in the images.</p> <p>Parameters:</p> <ul> <li> <code>images</code>               (<code>Sequence[OmeZarrContainer]</code>)           \u2013            <p>A collection of images.</p> </li> <li> <code>filter_types</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The type of tables to filter. If None, return all tables. Defaults to None.</p> </li> <li> <code>mode</code>               (<code>Literal['common', 'all']</code>, default:                   <code>'common'</code> )           \u2013            <p>Whether to return only common tables between all images or all tables. Defaults to \"common\".</p> </li> </ul> Source code in <code>ngio/images/_table_ops.py</code> <pre><code>def list_image_tables(\n    images: Sequence[OmeZarrContainer],\n    filter_types: str | None = None,\n    mode: Literal[\"common\", \"all\"] = \"common\",\n) -&gt; list[str]:\n    \"\"\"List all table names in the images.\n\n    Args:\n        images: A collection of images.\n        filter_types (str | None): The type of tables to filter. If None,\n            return all tables. Defaults to None.\n        mode (Literal[\"common\", \"all\"]): Whether to return only common tables\n            between all images or all tables. Defaults to \"common\".\n    \"\"\"\n    tables_names = []\n    for image in images:\n        tables = image.list_tables(filter_types=filter_types)\n        tables_names.append(tables)\n\n    return _tables_names_coalesce(\n        tables_names=tables_names,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.list_image_tables_async","title":"list_image_tables_async  <code>async</code>","text":"<pre><code>list_image_tables_async(\n    images: Sequence[OmeZarrContainer],\n    filter_types: str | None = None,\n    mode: Literal[\"common\", \"all\"] = \"common\",\n) -&gt; list[str]\n</code></pre> <p>List all image tables in the image asynchronously.</p> <p>Parameters:</p> <ul> <li> <code>images</code>               (<code>Sequence[OmeZarrContainer]</code>)           \u2013            <p>A collection of images.</p> </li> <li> <code>filter_types</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The type of tables to filter. If None, return all tables. Defaults to None.</p> </li> <li> <code>mode</code>               (<code>Literal['common', 'all']</code>, default:                   <code>'common'</code> )           \u2013            <p>Whether to return only common tables between all images or all tables. Defaults to \"common\".</p> </li> </ul> Source code in <code>ngio/images/_table_ops.py</code> <pre><code>async def list_image_tables_async(\n    images: Sequence[OmeZarrContainer],\n    filter_types: str | None = None,\n    mode: Literal[\"common\", \"all\"] = \"common\",\n) -&gt; list[str]:\n    \"\"\"List all image tables in the image asynchronously.\n\n    Args:\n        images: A collection of images.\n        filter_types (str | None): The type of tables to filter. If None,\n            return all tables. Defaults to None.\n        mode (Literal[\"common\", \"all\"]): Whether to return only common tables\n            between all images or all tables. Defaults to \"common\".\n    \"\"\"\n    images_ids = []\n\n    # key table name, value list of paths\n    def process_image(\n        image: OmeZarrContainer, filter_types: str | None = None\n    ) -&gt; list[str]:\n        tables = image.list_tables(filter_types=filter_types)\n        return tables\n\n    tasks = []\n    for i, image in enumerate(images):\n        images_ids.append(i)\n        task = asyncio.to_thread(process_image, image, filter_types=filter_types)\n        tasks.append(task)\n\n    tables_names = await asyncio.gather(*tasks)\n    return _tables_names_coalesce(\n        tables_names=tables_names,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/ngio/io_pipes/","title":"ngio.io_pipes API documentation","text":""},{"location":"api/ngio/io_pipes/#ngio.io_pipes","title":"ngio.io_pipes","text":"<p>I/O pipes for reading and writing data from zarr to numpy and dask arrays.</p> <p>There are 3 main types of I/O pipes: - Standard I/O pipes: NumpyGetter, NumpySetter, DaskGetter, DaskSetter:     These pipes read and write data from simple integer indexing and slicing. - ROI I/O pipes: NumpyRoiGetter, NumpyRoiSetter, DaskRoiGetter, DaskRoiSetter:     These pipes read and write data from a region of interest (ROI) defined in physical     coordinates. - Masked I/O pipes: NumpyGetterMasked, NumpySetterMasked, DaskGetterMasked,     DaskSetterMasked: These pipes like the ROI pipes read and write data     from a region of interest (ROI). However they also load a boolean mask     from a label zarr array to mask the data being read or written.</p> <p>All the io pipes are structured in the same way.</p> <p>When reading data the order of operations is: - Step 1: Slice the zarr array to load only the data needed into memory. - Step 2: Apply axes operations to reorder, squeeze or expand the axes.     To match the user desired axes order. - Step 3: Apply any additional transforms to the data.</p> <p>When writing data the order of operations is the reverse.</p> <p>The Transforms must implement the TransformProtocol. They should be stateless and only depend on the input array and the slicing and axes ops. This allows them to be easily reused between different I/O pipes.</p>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.SlicingInputType","title":"SlicingInputType  <code>module-attribute</code>","text":"<pre><code>SlicingInputType: TypeAlias = (\n    slice | Sequence[int] | int | None\n)\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.SlicingType","title":"SlicingType  <code>module-attribute</code>","text":"<pre><code>SlicingType: TypeAlias = slice | list[int] | int\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DaskGetter","title":"DaskGetter","text":"<pre><code>DaskGetter(\n    *,\n    zarr_array: Array,\n    dimensions: Dimensions,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    slicing_dict: dict[str, SlicingInputType] | None = None,\n    remove_channel_selection: bool = False,\n    roi: Roi | None = None,\n)\n</code></pre> <p>               Bases: <code>DataGetter[Array]</code></p> <p>Build a pipe to get a numpy or dask array from a zarr array.</p> Source code in <code>ngio/io_pipes/_io_pipes.py</code> <pre><code>def __init__(\n    self,\n    *,\n    zarr_array: zarr.Array,\n    dimensions: Dimensions,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    slicing_dict: dict[str, SlicingInputType] | None = None,\n    remove_channel_selection: bool = False,\n    roi: Roi | None = None,\n) -&gt; None:\n    \"\"\"Build a pipe to get a numpy or dask array from a zarr array.\"\"\"\n    slicing_ops, axes_ops = setup_io_pipe(\n        dimensions=dimensions,\n        slicing_dict=slicing_dict,\n        axes_order=axes_order,\n        remove_channel_selection=remove_channel_selection,\n    )\n    super().__init__(\n        zarr_array=zarr_array,\n        slicing_ops=slicing_ops,\n        axes_ops=axes_ops,\n        transforms=transforms,\n        roi=roi,\n    )\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DaskGetter.zarr_array","title":"zarr_array  <code>property</code>","text":"<pre><code>zarr_array: Array\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DaskGetter.slicing_ops","title":"slicing_ops  <code>property</code>","text":"<pre><code>slicing_ops: SlicingOps\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DaskGetter.axes_ops","title":"axes_ops  <code>property</code>","text":"<pre><code>axes_ops: AxesOps\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DaskGetter.transforms","title":"transforms  <code>property</code>","text":"<pre><code>transforms: Sequence[TransformProtocol] | None\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DaskGetter.roi","title":"roi  <code>property</code>","text":"<pre><code>roi: Roi\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DaskGetter.get","title":"get","text":"<pre><code>get() -&gt; Array\n</code></pre> <p>Get a dask array from the zarr array with ops.</p> <p>The order of operations is: * get slice will load the data from the zarr array * get axes ops will reorder, squeeze or expand the axes * get transform will apply any additional transforms</p> Source code in <code>ngio/io_pipes/_io_pipes.py</code> <pre><code>def get(self) -&gt; DaskArray:\n    \"\"\"Get a dask array from the zarr array with ops.\n\n    The order of operations is:\n    * get slice will load the data from the zarr array\n    * get axes ops will reorder, squeeze or expand the axes\n    * get transform will apply any additional transforms\n\n    \"\"\"\n    array = get_slice_as_dask(self._zarr_array, slicing_ops=self._slicing_ops)\n    array = get_as_dask_axes_ops(array, axes_ops=self._axes_ops)\n    array = get_as_dask_transform(\n        array,\n        slicing_ops=self._slicing_ops,\n        axes_ops=self._axes_ops,\n        transforms=self._transforms,\n    )\n    return array\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DaskSetter","title":"DaskSetter","text":"<pre><code>DaskSetter(\n    *,\n    zarr_array: Array,\n    dimensions: Dimensions,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    slicing_dict: dict[str, SlicingInputType] | None = None,\n    remove_channel_selection: bool = False,\n    roi: Roi | None = None,\n)\n</code></pre> <p>               Bases: <code>DataSetter[Array]</code></p> <p>Build a pipe to get a numpy or dask array from a zarr array.</p> Source code in <code>ngio/io_pipes/_io_pipes.py</code> <pre><code>def __init__(\n    self,\n    *,\n    zarr_array: zarr.Array,\n    dimensions: Dimensions,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    slicing_dict: dict[str, SlicingInputType] | None = None,\n    remove_channel_selection: bool = False,\n    roi: Roi | None = None,\n) -&gt; None:\n    \"\"\"Build a pipe to get a numpy or dask array from a zarr array.\"\"\"\n    slicing_ops, axes_ops = setup_io_pipe(\n        dimensions=dimensions,\n        slicing_dict=slicing_dict,\n        axes_order=axes_order,\n        remove_channel_selection=remove_channel_selection,\n    )\n    super().__init__(\n        zarr_array=zarr_array,\n        slicing_ops=slicing_ops,\n        axes_ops=axes_ops,\n        transforms=transforms,\n        roi=roi,\n    )\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DaskSetter.zarr_array","title":"zarr_array  <code>property</code>","text":"<pre><code>zarr_array: Array\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DaskSetter.slicing_ops","title":"slicing_ops  <code>property</code>","text":"<pre><code>slicing_ops: SlicingOps\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DaskSetter.axes_ops","title":"axes_ops  <code>property</code>","text":"<pre><code>axes_ops: AxesOps\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DaskSetter.transforms","title":"transforms  <code>property</code>","text":"<pre><code>transforms: Sequence[TransformProtocol] | None\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DaskSetter.roi","title":"roi  <code>property</code>","text":"<pre><code>roi: Roi\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DaskSetter.set","title":"set","text":"<pre><code>set(patch: Array) -&gt; None\n</code></pre> <p>Get a dask array from the zarr array with ops.</p> Source code in <code>ngio/io_pipes/_io_pipes.py</code> <pre><code>def set(self, patch: DaskArray) -&gt; None:\n    \"\"\"Get a dask array from the zarr array with ops.\"\"\"\n    patch = set_as_dask_transform(\n        array=patch,\n        slicing_ops=self._slicing_ops,\n        axes_ops=self._axes_ops,\n        transforms=self._transforms,\n    )\n    patch = set_as_dask_axes_ops(\n        array=patch,\n        axes_ops=self._axes_ops,\n    )\n    set_slice_as_dask(\n        zarr_array=self._zarr_array,\n        patch=patch,\n        slicing_ops=self._slicing_ops,\n    )\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DataGetter","title":"DataGetter","text":"<pre><code>DataGetter(\n    zarr_array: Array,\n    slicing_ops: SlicingOps,\n    axes_ops: AxesOps,\n    transforms: Sequence[TransformProtocol] | None = None,\n    roi: Roi | None = None,\n)\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> Source code in <code>ngio/io_pipes/_io_pipes.py</code> <pre><code>def __init__(\n    self,\n    zarr_array: zarr.Array,\n    slicing_ops: SlicingOps,\n    axes_ops: AxesOps,\n    transforms: Sequence[TransformProtocol] | None = None,\n    roi: Roi | None = None,\n) -&gt; None:\n    self._zarr_array = zarr_array\n    self._slicing_ops = slicing_ops\n    self._axes_ops = axes_ops\n    self._transforms = transforms\n    self._roi = roi\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DataGetter.zarr_array","title":"zarr_array  <code>property</code>","text":"<pre><code>zarr_array: Array\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DataGetter.slicing_ops","title":"slicing_ops  <code>property</code>","text":"<pre><code>slicing_ops: SlicingOps\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DataGetter.axes_ops","title":"axes_ops  <code>property</code>","text":"<pre><code>axes_ops: AxesOps\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DataGetter.transforms","title":"transforms  <code>property</code>","text":"<pre><code>transforms: Sequence[TransformProtocol] | None\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DataGetter.roi","title":"roi  <code>property</code>","text":"<pre><code>roi: Roi\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DataGetter.get","title":"get  <code>abstractmethod</code>","text":"<pre><code>get() -&gt; T\n</code></pre> Source code in <code>ngio/io_pipes/_io_pipes.py</code> <pre><code>@abstractmethod\ndef get(self) -&gt; T:\n    pass\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DataSetter","title":"DataSetter","text":"<pre><code>DataSetter(\n    zarr_array: Array,\n    slicing_ops: SlicingOps,\n    axes_ops: AxesOps,\n    transforms: Sequence[TransformProtocol] | None = None,\n    roi: Roi | None = None,\n)\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> Source code in <code>ngio/io_pipes/_io_pipes.py</code> <pre><code>def __init__(\n    self,\n    zarr_array: zarr.Array,\n    slicing_ops: SlicingOps,\n    axes_ops: AxesOps,\n    transforms: Sequence[TransformProtocol] | None = None,\n    roi: Roi | None = None,\n) -&gt; None:\n    self._zarr_array = zarr_array\n    self._slicing_ops = slicing_ops\n    self._axes_ops = axes_ops\n    self._transforms = transforms\n    self._roi = roi\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DataSetter.zarr_array","title":"zarr_array  <code>property</code>","text":"<pre><code>zarr_array: Array\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DataSetter.slicing_ops","title":"slicing_ops  <code>property</code>","text":"<pre><code>slicing_ops: SlicingOps\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DataSetter.axes_ops","title":"axes_ops  <code>property</code>","text":"<pre><code>axes_ops: AxesOps\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DataSetter.transforms","title":"transforms  <code>property</code>","text":"<pre><code>transforms: Sequence[TransformProtocol] | None\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DataSetter.roi","title":"roi  <code>property</code>","text":"<pre><code>roi: Roi\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DataSetter.set","title":"set  <code>abstractmethod</code>","text":"<pre><code>set(patch: T) -&gt; None\n</code></pre> Source code in <code>ngio/io_pipes/_io_pipes.py</code> <pre><code>@abstractmethod\ndef set(self, patch: T) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.NumpyGetter","title":"NumpyGetter","text":"<pre><code>NumpyGetter(\n    *,\n    zarr_array: Array,\n    dimensions: Dimensions,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    slicing_dict: dict[str, SlicingInputType] | None = None,\n    remove_channel_selection: bool = False,\n    roi: Roi | None = None,\n)\n</code></pre> <p>               Bases: <code>DataGetter[ndarray]</code></p> <p>Build a pipe to get a numpy or dask array from a zarr array.</p> Source code in <code>ngio/io_pipes/_io_pipes.py</code> <pre><code>def __init__(\n    self,\n    *,\n    zarr_array: zarr.Array,\n    dimensions: Dimensions,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    slicing_dict: dict[str, SlicingInputType] | None = None,\n    remove_channel_selection: bool = False,\n    roi: Roi | None = None,\n) -&gt; None:\n    \"\"\"Build a pipe to get a numpy or dask array from a zarr array.\"\"\"\n    slicing_ops, axes_ops = setup_io_pipe(\n        dimensions=dimensions,\n        slicing_dict=slicing_dict,\n        axes_order=axes_order,\n        remove_channel_selection=remove_channel_selection,\n    )\n    super().__init__(\n        zarr_array=zarr_array,\n        slicing_ops=slicing_ops,\n        axes_ops=axes_ops,\n        transforms=transforms,\n        roi=roi,\n    )\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.NumpyGetter.zarr_array","title":"zarr_array  <code>property</code>","text":"<pre><code>zarr_array: Array\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.NumpyGetter.slicing_ops","title":"slicing_ops  <code>property</code>","text":"<pre><code>slicing_ops: SlicingOps\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.NumpyGetter.axes_ops","title":"axes_ops  <code>property</code>","text":"<pre><code>axes_ops: AxesOps\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.NumpyGetter.transforms","title":"transforms  <code>property</code>","text":"<pre><code>transforms: Sequence[TransformProtocol] | None\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.NumpyGetter.roi","title":"roi  <code>property</code>","text":"<pre><code>roi: Roi\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.NumpyGetter.get","title":"get","text":"<pre><code>get() -&gt; ndarray\n</code></pre> <p>Get a numpy array from the zarr array with ops.</p> Source code in <code>ngio/io_pipes/_io_pipes.py</code> <pre><code>def get(self) -&gt; np.ndarray:\n    \"\"\"Get a numpy array from the zarr array with ops.\"\"\"\n    array = get_slice_as_numpy(self._zarr_array, slicing_ops=self._slicing_ops)\n    array = get_as_numpy_axes_ops(array, axes_ops=self._axes_ops)\n    array = get_as_numpy_transform(\n        array,\n        slicing_ops=self._slicing_ops,\n        axes_ops=self._axes_ops,\n        transforms=self._transforms,\n    )\n    return array\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.NumpySetter","title":"NumpySetter","text":"<pre><code>NumpySetter(\n    *,\n    zarr_array: Array,\n    dimensions: Dimensions,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    slicing_dict: dict[str, SlicingInputType] | None = None,\n    remove_channel_selection: bool = False,\n    roi: Roi | None = None,\n)\n</code></pre> <p>               Bases: <code>DataSetter[ndarray]</code></p> <p>Build a pipe to get a numpy or dask array from a zarr array.</p> Source code in <code>ngio/io_pipes/_io_pipes.py</code> <pre><code>def __init__(\n    self,\n    *,\n    zarr_array: zarr.Array,\n    dimensions: Dimensions,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    slicing_dict: dict[str, SlicingInputType] | None = None,\n    remove_channel_selection: bool = False,\n    roi: Roi | None = None,\n) -&gt; None:\n    \"\"\"Build a pipe to get a numpy or dask array from a zarr array.\"\"\"\n    slicing_ops, axes_ops = setup_io_pipe(\n        dimensions=dimensions,\n        slicing_dict=slicing_dict,\n        axes_order=axes_order,\n        remove_channel_selection=remove_channel_selection,\n    )\n    super().__init__(\n        zarr_array=zarr_array,\n        slicing_ops=slicing_ops,\n        axes_ops=axes_ops,\n        transforms=transforms,\n        roi=roi,\n    )\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.NumpySetter.zarr_array","title":"zarr_array  <code>property</code>","text":"<pre><code>zarr_array: Array\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.NumpySetter.slicing_ops","title":"slicing_ops  <code>property</code>","text":"<pre><code>slicing_ops: SlicingOps\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.NumpySetter.axes_ops","title":"axes_ops  <code>property</code>","text":"<pre><code>axes_ops: AxesOps\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.NumpySetter.transforms","title":"transforms  <code>property</code>","text":"<pre><code>transforms: Sequence[TransformProtocol] | None\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.NumpySetter.roi","title":"roi  <code>property</code>","text":"<pre><code>roi: Roi\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.NumpySetter.set","title":"set","text":"<pre><code>set(patch: ndarray) -&gt; None\n</code></pre> <p>Get a numpy array from the zarr array with ops.</p> Source code in <code>ngio/io_pipes/_io_pipes.py</code> <pre><code>def set(self, patch: np.ndarray) -&gt; None:\n    \"\"\"Get a numpy array from the zarr array with ops.\"\"\"\n    patch = set_as_numpy_transform(\n        array=patch,\n        slicing_ops=self._slicing_ops,\n        axes_ops=self._axes_ops,\n        transforms=self._transforms,\n    )\n    patch = set_as_numpy_axes_ops(\n        array=patch,\n        axes_ops=self._axes_ops,\n    )\n    set_slice_as_numpy(\n        zarr_array=self._zarr_array,\n        patch=patch,\n        slicing_ops=self._slicing_ops,\n    )\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DaskGetterMasked","title":"DaskGetterMasked","text":"<pre><code>DaskGetterMasked(\n    *,\n    zarr_array: Array,\n    dimensions: Dimensions,\n    label_zarr_array: Array,\n    label_dimensions: Dimensions,\n    roi: Roi,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    label_transforms: Sequence[TransformProtocol]\n    | None = None,\n    slicing_dict: dict[str, SlicingInputType] | None = None,\n    label_slicing_dict: dict[str, SlicingInputType]\n    | None = None,\n    fill_value: int | float = 0,\n    allow_rescaling: bool = True,\n    remove_channel_selection: bool = False,\n)\n</code></pre> <p>               Bases: <code>DataGetter[Array]</code></p> <p>Prepare slice kwargs for getting a masked array.</p> Source code in <code>ngio/io_pipes/_io_pipes_masked.py</code> <pre><code>def __init__(\n    self,\n    *,\n    zarr_array: zarr.Array,\n    dimensions: Dimensions,\n    label_zarr_array: zarr.Array,\n    label_dimensions: Dimensions,\n    roi: Roi,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    label_transforms: Sequence[TransformProtocol] | None = None,\n    slicing_dict: dict[str, SlicingInputType] | None = None,\n    label_slicing_dict: dict[str, SlicingInputType] | None = None,\n    fill_value: int | float = 0,\n    allow_rescaling: bool = True,\n    remove_channel_selection: bool = False,\n):\n    \"\"\"Prepare slice kwargs for getting a masked array.\"\"\"\n    _data_getter, _label_data_getter, slicing_dict = _setup_dask_getters(\n        zarr_array=zarr_array,\n        dimensions=dimensions,\n        label_zarr_array=label_zarr_array,\n        label_dimensions=label_dimensions,\n        roi=roi,\n        axes_order=axes_order,\n        transforms=transforms,\n        label_transforms=label_transforms,\n        slicing_dict=slicing_dict,\n        label_slicing_dict=label_slicing_dict,\n        allow_rescaling=allow_rescaling,\n        remove_channel_selection=remove_channel_selection,\n    )\n    self._data_getter = _data_getter\n    self._label_data_getter = _label_data_getter\n    self._label_id = roi.label\n    self._fill_value = fill_value\n    super().__init__(\n        zarr_array=zarr_array,\n        slicing_ops=self._data_getter.slicing_ops,\n        axes_ops=self._data_getter.axes_ops,\n        transforms=self._data_getter.transforms,\n        roi=roi,\n    )\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DaskGetterMasked.zarr_array","title":"zarr_array  <code>property</code>","text":"<pre><code>zarr_array: Array\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DaskGetterMasked.slicing_ops","title":"slicing_ops  <code>property</code>","text":"<pre><code>slicing_ops: SlicingOps\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DaskGetterMasked.axes_ops","title":"axes_ops  <code>property</code>","text":"<pre><code>axes_ops: AxesOps\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DaskGetterMasked.transforms","title":"transforms  <code>property</code>","text":"<pre><code>transforms: Sequence[TransformProtocol] | None\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DaskGetterMasked.roi","title":"roi  <code>property</code>","text":"<pre><code>roi: Roi\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DaskGetterMasked.label_id","title":"label_id  <code>property</code>","text":"<pre><code>label_id: int | None\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DaskGetterMasked.get","title":"get","text":"<pre><code>get() -&gt; Array\n</code></pre> Source code in <code>ngio/io_pipes/_io_pipes_masked.py</code> <pre><code>def get(self) -&gt; DaskArray:\n    data = self._data_getter()\n    label_data = self._label_data_getter()\n    data_shape = tuple(int(dim) for dim in data.shape)\n    bool_mask = _dask_label_to_bool_mask(\n        label_data=label_data,\n        label=self.label_id,\n        data_shape=data_shape,\n        label_axes=self._label_data_getter.axes_ops.output_axes,\n        data_axes=self._data_getter.axes_ops.output_axes,\n    )\n    if bool_mask.shape != data.shape:\n        bool_mask = da.broadcast_to(bool_mask, data.shape)\n    masked_data = da.where(bool_mask, data, self._fill_value)\n    return masked_data\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DaskSetterMasked","title":"DaskSetterMasked","text":"<pre><code>DaskSetterMasked(\n    *,\n    zarr_array: Array,\n    dimensions: Dimensions,\n    label_zarr_array: Array,\n    label_dimensions: Dimensions,\n    roi: Roi,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    label_transforms: Sequence[TransformProtocol]\n    | None = None,\n    slicing_dict: dict[str, SlicingInputType] | None = None,\n    label_slicing_dict: dict[str, SlicingInputType]\n    | None = None,\n    allow_rescaling: bool = True,\n    remove_channel_selection: bool = False,\n)\n</code></pre> <p>               Bases: <code>DataSetter[Array]</code></p> <p>Prepare slice kwargs for setting a masked array.</p> Source code in <code>ngio/io_pipes/_io_pipes_masked.py</code> <pre><code>def __init__(\n    self,\n    *,\n    zarr_array: zarr.Array,\n    dimensions: Dimensions,\n    label_zarr_array: zarr.Array,\n    label_dimensions: Dimensions,\n    roi: Roi,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    label_transforms: Sequence[TransformProtocol] | None = None,\n    slicing_dict: dict[str, SlicingInputType] | None = None,\n    label_slicing_dict: dict[str, SlicingInputType] | None = None,\n    allow_rescaling: bool = True,\n    remove_channel_selection: bool = False,\n):\n    \"\"\"Prepare slice kwargs for setting a masked array.\"\"\"\n    _data_getter, _label_data_getter, slicing_dict = _setup_dask_getters(\n        zarr_array=zarr_array,\n        dimensions=dimensions,\n        label_zarr_array=label_zarr_array,\n        label_dimensions=label_dimensions,\n        roi=roi,\n        axes_order=axes_order,\n        transforms=transforms,\n        label_transforms=label_transforms,\n        slicing_dict=slicing_dict,\n        label_slicing_dict=label_slicing_dict,\n        allow_rescaling=allow_rescaling,\n        remove_channel_selection=remove_channel_selection,\n    )\n    self._data_getter = _data_getter\n    self._label_data_getter = _label_data_getter\n\n    self._label_id = roi.label\n\n    self._data_setter = DaskSetter(\n        zarr_array=zarr_array,\n        dimensions=dimensions,\n        axes_order=axes_order,\n        transforms=transforms,\n        slicing_dict=slicing_dict,\n        remove_channel_selection=remove_channel_selection,\n    )\n\n    super().__init__(\n        zarr_array=zarr_array,\n        slicing_ops=self._data_setter.slicing_ops,\n        axes_ops=self._data_setter.axes_ops,\n        transforms=self._data_setter.transforms,\n        roi=roi,\n    )\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DaskSetterMasked.zarr_array","title":"zarr_array  <code>property</code>","text":"<pre><code>zarr_array: Array\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DaskSetterMasked.slicing_ops","title":"slicing_ops  <code>property</code>","text":"<pre><code>slicing_ops: SlicingOps\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DaskSetterMasked.axes_ops","title":"axes_ops  <code>property</code>","text":"<pre><code>axes_ops: AxesOps\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DaskSetterMasked.transforms","title":"transforms  <code>property</code>","text":"<pre><code>transforms: Sequence[TransformProtocol] | None\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DaskSetterMasked.roi","title":"roi  <code>property</code>","text":"<pre><code>roi: Roi\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DaskSetterMasked.label_id","title":"label_id  <code>property</code>","text":"<pre><code>label_id: int | None\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DaskSetterMasked.set","title":"set","text":"<pre><code>set(patch: Array) -&gt; None\n</code></pre> Source code in <code>ngio/io_pipes/_io_pipes_masked.py</code> <pre><code>def set(self, patch: DaskArray) -&gt; None:\n    data = self._data_getter()\n    label_data = self._label_data_getter()\n    data_shape = tuple(int(dim) for dim in data.shape)\n\n    bool_mask = _dask_label_to_bool_mask(\n        label_data=label_data,\n        label=self.label_id,\n        data_shape=data_shape,\n        label_axes=self._label_data_getter.axes_ops.output_axes,\n        data_axes=self._data_getter.axes_ops.output_axes,\n    )\n    if bool_mask.shape != data.shape:\n        bool_mask = da.broadcast_to(bool_mask, data.shape)\n    masked_patch = da.where(bool_mask, patch, data)\n    self._data_setter(masked_patch)\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.NumpyGetterMasked","title":"NumpyGetterMasked","text":"<pre><code>NumpyGetterMasked(\n    *,\n    zarr_array: Array,\n    dimensions: Dimensions,\n    label_zarr_array: Array,\n    label_dimensions: Dimensions,\n    roi: Roi,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    label_transforms: Sequence[TransformProtocol]\n    | None = None,\n    slicing_dict: dict[str, SlicingInputType] | None = None,\n    label_slicing_dict: dict[str, SlicingInputType]\n    | None = None,\n    fill_value: int | float = 0,\n    allow_rescaling: bool = True,\n    remove_channel_selection: bool = False,\n)\n</code></pre> <p>               Bases: <code>DataGetter[ndarray]</code></p> <p>Prepare slice kwargs for getting a masked array.</p> Source code in <code>ngio/io_pipes/_io_pipes_masked.py</code> <pre><code>def __init__(\n    self,\n    *,\n    zarr_array: zarr.Array,\n    dimensions: Dimensions,\n    label_zarr_array: zarr.Array,\n    label_dimensions: Dimensions,\n    roi: Roi,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    label_transforms: Sequence[TransformProtocol] | None = None,\n    slicing_dict: dict[str, SlicingInputType] | None = None,\n    label_slicing_dict: dict[str, SlicingInputType] | None = None,\n    fill_value: int | float = 0,\n    allow_rescaling: bool = True,\n    remove_channel_selection: bool = False,\n):\n    \"\"\"Prepare slice kwargs for getting a masked array.\"\"\"\n    data_getter, label_data_getter, slicing_dict = _setup_numpy_getters(\n        zarr_array=zarr_array,\n        dimensions=dimensions,\n        label_zarr_array=label_zarr_array,\n        label_dimensions=label_dimensions,\n        roi=roi,\n        axes_order=axes_order,\n        transforms=transforms,\n        label_transforms=label_transforms,\n        slicing_dict=slicing_dict,\n        label_slicing_dict=label_slicing_dict,\n        allow_rescaling=allow_rescaling,\n        remove_channel_selection=remove_channel_selection,\n    )\n    self._data_getter = data_getter\n    self._label_data_getter = label_data_getter\n\n    self._label_id = roi.label\n    self._fill_value = fill_value\n    super().__init__(\n        zarr_array=zarr_array,\n        slicing_ops=self._data_getter.slicing_ops,\n        axes_ops=self._data_getter.axes_ops,\n        transforms=self._data_getter.transforms,\n        roi=roi,\n    )\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.NumpyGetterMasked.zarr_array","title":"zarr_array  <code>property</code>","text":"<pre><code>zarr_array: Array\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.NumpyGetterMasked.slicing_ops","title":"slicing_ops  <code>property</code>","text":"<pre><code>slicing_ops: SlicingOps\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.NumpyGetterMasked.axes_ops","title":"axes_ops  <code>property</code>","text":"<pre><code>axes_ops: AxesOps\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.NumpyGetterMasked.transforms","title":"transforms  <code>property</code>","text":"<pre><code>transforms: Sequence[TransformProtocol] | None\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.NumpyGetterMasked.roi","title":"roi  <code>property</code>","text":"<pre><code>roi: Roi\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.NumpyGetterMasked.label_id","title":"label_id  <code>property</code>","text":"<pre><code>label_id: int | None\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.NumpyGetterMasked.get","title":"get","text":"<pre><code>get() -&gt; ndarray\n</code></pre> <p>Get the masked data as a numpy array.</p> Source code in <code>ngio/io_pipes/_io_pipes_masked.py</code> <pre><code>def get(self) -&gt; np.ndarray:\n    \"\"\"Get the masked data as a numpy array.\"\"\"\n    data = self._data_getter()\n    label_data = self._label_data_getter()\n    bool_mask = _numpy_label_to_bool_mask(\n        label_data=label_data,\n        label=self.label_id,\n        data_shape=data.shape,\n        label_axes=self._label_data_getter.axes_ops.output_axes,\n        data_axes=self._data_getter.axes_ops.output_axes,\n    )\n    if bool_mask.shape != data.shape:\n        bool_mask = np.broadcast_to(bool_mask, data.shape)\n    masked_data = np.where(bool_mask, data, self._fill_value)\n    return masked_data\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.NumpySetterMasked","title":"NumpySetterMasked","text":"<pre><code>NumpySetterMasked(\n    *,\n    zarr_array: Array,\n    dimensions: Dimensions,\n    label_zarr_array: Array,\n    label_dimensions: Dimensions,\n    roi: Roi,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    label_transforms: Sequence[TransformProtocol]\n    | None = None,\n    slicing_dict: dict[str, SlicingInputType] | None = None,\n    label_slicing_dict: dict[str, SlicingInputType]\n    | None = None,\n    allow_rescaling: bool = True,\n    remove_channel_selection: bool = False,\n)\n</code></pre> <p>               Bases: <code>DataSetter[ndarray]</code></p> <p>Prepare slice kwargs for setting a masked array.</p> Source code in <code>ngio/io_pipes/_io_pipes_masked.py</code> <pre><code>def __init__(\n    self,\n    *,\n    zarr_array: zarr.Array,\n    dimensions: Dimensions,\n    label_zarr_array: zarr.Array,\n    label_dimensions: Dimensions,\n    roi: Roi,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    label_transforms: Sequence[TransformProtocol] | None = None,\n    slicing_dict: dict[str, SlicingInputType] | None = None,\n    label_slicing_dict: dict[str, SlicingInputType] | None = None,\n    allow_rescaling: bool = True,\n    remove_channel_selection: bool = False,\n):\n    \"\"\"Prepare slice kwargs for setting a masked array.\"\"\"\n    _data_getter, _label_data_getter, slicing_dict = _setup_numpy_getters(\n        zarr_array=zarr_array,\n        dimensions=dimensions,\n        label_zarr_array=label_zarr_array,\n        label_dimensions=label_dimensions,\n        roi=roi,\n        axes_order=axes_order,\n        transforms=transforms,\n        label_transforms=label_transforms,\n        slicing_dict=slicing_dict,\n        label_slicing_dict=label_slicing_dict,\n        allow_rescaling=allow_rescaling,\n        remove_channel_selection=remove_channel_selection,\n    )\n    self._data_getter = _data_getter\n    self._label_data_getter = _label_data_getter\n    self._label_id = roi.label\n\n    self._data_setter = NumpySetter(\n        zarr_array=zarr_array,\n        dimensions=dimensions,\n        axes_order=axes_order,\n        transforms=transforms,\n        slicing_dict=slicing_dict,\n        remove_channel_selection=remove_channel_selection,\n    )\n    super().__init__(\n        zarr_array=zarr_array,\n        slicing_ops=self._data_setter.slicing_ops,\n        axes_ops=self._data_setter.axes_ops,\n        transforms=self._data_setter.transforms,\n        roi=roi,\n    )\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.NumpySetterMasked.zarr_array","title":"zarr_array  <code>property</code>","text":"<pre><code>zarr_array: Array\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.NumpySetterMasked.slicing_ops","title":"slicing_ops  <code>property</code>","text":"<pre><code>slicing_ops: SlicingOps\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.NumpySetterMasked.axes_ops","title":"axes_ops  <code>property</code>","text":"<pre><code>axes_ops: AxesOps\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.NumpySetterMasked.transforms","title":"transforms  <code>property</code>","text":"<pre><code>transforms: Sequence[TransformProtocol] | None\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.NumpySetterMasked.roi","title":"roi  <code>property</code>","text":"<pre><code>roi: Roi\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.NumpySetterMasked.label_id","title":"label_id  <code>property</code>","text":"<pre><code>label_id: int | None\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.NumpySetterMasked.set","title":"set","text":"<pre><code>set(patch: ndarray) -&gt; None\n</code></pre> Source code in <code>ngio/io_pipes/_io_pipes_masked.py</code> <pre><code>def set(self, patch: np.ndarray) -&gt; None:\n    data = self._data_getter()\n    label_data = self._label_data_getter()\n\n    bool_mask = _numpy_label_to_bool_mask(\n        label_data=label_data,\n        label=self.label_id,\n        data_shape=data.shape,\n        label_axes=self._label_data_getter.axes_ops.output_axes,\n        data_axes=self._data_getter.axes_ops.output_axes,\n    )\n    if bool_mask.shape != data.shape:\n        bool_mask = np.broadcast_to(bool_mask, data.shape)\n    masked_patch = np.where(bool_mask, patch, data)\n    self._data_setter(masked_patch)\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DaskRoiGetter","title":"DaskRoiGetter","text":"<pre><code>DaskRoiGetter(\n    *,\n    zarr_array: Array,\n    dimensions: Dimensions,\n    roi: Roi,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    slicing_dict: dict[str, SlicingInputType] | None = None,\n    remove_channel_selection: bool = False,\n)\n</code></pre> <p>               Bases: <code>DaskGetter</code></p> Source code in <code>ngio/io_pipes/_io_pipes_roi.py</code> <pre><code>def __init__(\n    self,\n    *,\n    zarr_array: zarr.Array,\n    dimensions: Dimensions,\n    roi: Roi,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    slicing_dict: dict[str, SlicingInputType] | None = None,\n    remove_channel_selection: bool = False,\n) -&gt; None:\n    input_slice_kwargs = roi_to_slicing_dict(\n        roi=roi,\n        pixel_size=dimensions.pixel_size,\n        slicing_dict=slicing_dict,\n    )\n    super().__init__(\n        zarr_array=zarr_array,\n        dimensions=dimensions,\n        axes_order=axes_order,\n        transforms=transforms,\n        slicing_dict=input_slice_kwargs,\n        remove_channel_selection=remove_channel_selection,\n        roi=roi,\n    )\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DaskRoiGetter.zarr_array","title":"zarr_array  <code>property</code>","text":"<pre><code>zarr_array: Array\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DaskRoiGetter.slicing_ops","title":"slicing_ops  <code>property</code>","text":"<pre><code>slicing_ops: SlicingOps\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DaskRoiGetter.axes_ops","title":"axes_ops  <code>property</code>","text":"<pre><code>axes_ops: AxesOps\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DaskRoiGetter.transforms","title":"transforms  <code>property</code>","text":"<pre><code>transforms: Sequence[TransformProtocol] | None\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DaskRoiGetter.roi","title":"roi  <code>property</code>","text":"<pre><code>roi: Roi\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DaskRoiGetter.get","title":"get","text":"<pre><code>get() -&gt; Array\n</code></pre> <p>Get a dask array from the zarr array with ops.</p> <p>The order of operations is: * get slice will load the data from the zarr array * get axes ops will reorder, squeeze or expand the axes * get transform will apply any additional transforms</p> Source code in <code>ngio/io_pipes/_io_pipes.py</code> <pre><code>def get(self) -&gt; DaskArray:\n    \"\"\"Get a dask array from the zarr array with ops.\n\n    The order of operations is:\n    * get slice will load the data from the zarr array\n    * get axes ops will reorder, squeeze or expand the axes\n    * get transform will apply any additional transforms\n\n    \"\"\"\n    array = get_slice_as_dask(self._zarr_array, slicing_ops=self._slicing_ops)\n    array = get_as_dask_axes_ops(array, axes_ops=self._axes_ops)\n    array = get_as_dask_transform(\n        array,\n        slicing_ops=self._slicing_ops,\n        axes_ops=self._axes_ops,\n        transforms=self._transforms,\n    )\n    return array\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DaskRoiSetter","title":"DaskRoiSetter","text":"<pre><code>DaskRoiSetter(\n    *,\n    zarr_array: Array,\n    dimensions: Dimensions,\n    roi: Roi,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    slicing_dict: dict[str, SlicingInputType] | None = None,\n    remove_channel_selection: bool = False,\n)\n</code></pre> <p>               Bases: <code>DaskSetter</code></p> Source code in <code>ngio/io_pipes/_io_pipes_roi.py</code> <pre><code>def __init__(\n    self,\n    *,\n    zarr_array: zarr.Array,\n    dimensions: Dimensions,\n    roi: Roi,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    slicing_dict: dict[str, SlicingInputType] | None = None,\n    remove_channel_selection: bool = False,\n) -&gt; None:\n    input_slice_kwargs = roi_to_slicing_dict(\n        roi=roi,\n        pixel_size=dimensions.pixel_size,\n        slicing_dict=slicing_dict,\n    )\n    super().__init__(\n        zarr_array=zarr_array,\n        dimensions=dimensions,\n        axes_order=axes_order,\n        transforms=transforms,\n        slicing_dict=input_slice_kwargs,\n        remove_channel_selection=remove_channel_selection,\n        roi=roi,\n    )\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DaskRoiSetter.zarr_array","title":"zarr_array  <code>property</code>","text":"<pre><code>zarr_array: Array\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DaskRoiSetter.slicing_ops","title":"slicing_ops  <code>property</code>","text":"<pre><code>slicing_ops: SlicingOps\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DaskRoiSetter.axes_ops","title":"axes_ops  <code>property</code>","text":"<pre><code>axes_ops: AxesOps\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DaskRoiSetter.transforms","title":"transforms  <code>property</code>","text":"<pre><code>transforms: Sequence[TransformProtocol] | None\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DaskRoiSetter.roi","title":"roi  <code>property</code>","text":"<pre><code>roi: Roi\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.DaskRoiSetter.set","title":"set","text":"<pre><code>set(patch: Array) -&gt; None\n</code></pre> <p>Get a dask array from the zarr array with ops.</p> Source code in <code>ngio/io_pipes/_io_pipes.py</code> <pre><code>def set(self, patch: DaskArray) -&gt; None:\n    \"\"\"Get a dask array from the zarr array with ops.\"\"\"\n    patch = set_as_dask_transform(\n        array=patch,\n        slicing_ops=self._slicing_ops,\n        axes_ops=self._axes_ops,\n        transforms=self._transforms,\n    )\n    patch = set_as_dask_axes_ops(\n        array=patch,\n        axes_ops=self._axes_ops,\n    )\n    set_slice_as_dask(\n        zarr_array=self._zarr_array,\n        patch=patch,\n        slicing_ops=self._slicing_ops,\n    )\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.NumpyRoiGetter","title":"NumpyRoiGetter","text":"<pre><code>NumpyRoiGetter(\n    *,\n    zarr_array: Array,\n    dimensions: Dimensions,\n    roi: Roi,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    slicing_dict: dict[str, SlicingInputType] | None = None,\n    remove_channel_selection: bool = False,\n)\n</code></pre> <p>               Bases: <code>NumpyGetter</code></p> Source code in <code>ngio/io_pipes/_io_pipes_roi.py</code> <pre><code>def __init__(\n    self,\n    *,\n    zarr_array: zarr.Array,\n    dimensions: Dimensions,\n    roi: Roi,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    slicing_dict: dict[str, SlicingInputType] | None = None,\n    remove_channel_selection: bool = False,\n) -&gt; None:\n    input_slice_kwargs = roi_to_slicing_dict(\n        roi=roi,\n        pixel_size=dimensions.pixel_size,\n        slicing_dict=slicing_dict,\n    )\n    super().__init__(\n        zarr_array=zarr_array,\n        dimensions=dimensions,\n        axes_order=axes_order,\n        transforms=transforms,\n        slicing_dict=input_slice_kwargs,\n        remove_channel_selection=remove_channel_selection,\n        roi=roi,\n    )\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.NumpyRoiGetter.zarr_array","title":"zarr_array  <code>property</code>","text":"<pre><code>zarr_array: Array\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.NumpyRoiGetter.slicing_ops","title":"slicing_ops  <code>property</code>","text":"<pre><code>slicing_ops: SlicingOps\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.NumpyRoiGetter.axes_ops","title":"axes_ops  <code>property</code>","text":"<pre><code>axes_ops: AxesOps\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.NumpyRoiGetter.transforms","title":"transforms  <code>property</code>","text":"<pre><code>transforms: Sequence[TransformProtocol] | None\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.NumpyRoiGetter.roi","title":"roi  <code>property</code>","text":"<pre><code>roi: Roi\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.NumpyRoiGetter.get","title":"get","text":"<pre><code>get() -&gt; ndarray\n</code></pre> <p>Get a numpy array from the zarr array with ops.</p> Source code in <code>ngio/io_pipes/_io_pipes.py</code> <pre><code>def get(self) -&gt; np.ndarray:\n    \"\"\"Get a numpy array from the zarr array with ops.\"\"\"\n    array = get_slice_as_numpy(self._zarr_array, slicing_ops=self._slicing_ops)\n    array = get_as_numpy_axes_ops(array, axes_ops=self._axes_ops)\n    array = get_as_numpy_transform(\n        array,\n        slicing_ops=self._slicing_ops,\n        axes_ops=self._axes_ops,\n        transforms=self._transforms,\n    )\n    return array\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.NumpyRoiSetter","title":"NumpyRoiSetter","text":"<pre><code>NumpyRoiSetter(\n    *,\n    zarr_array: Array,\n    dimensions: Dimensions,\n    roi: Roi,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    slicing_dict: dict[str, SlicingInputType] | None = None,\n    remove_channel_selection: bool = False,\n)\n</code></pre> <p>               Bases: <code>NumpySetter</code></p> Source code in <code>ngio/io_pipes/_io_pipes_roi.py</code> <pre><code>def __init__(\n    self,\n    *,\n    zarr_array: zarr.Array,\n    dimensions: Dimensions,\n    roi: Roi,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    slicing_dict: dict[str, SlicingInputType] | None = None,\n    remove_channel_selection: bool = False,\n) -&gt; None:\n    input_slice_kwargs = roi_to_slicing_dict(\n        roi=roi,\n        pixel_size=dimensions.pixel_size,\n        slicing_dict=slicing_dict,\n    )\n    super().__init__(\n        zarr_array=zarr_array,\n        dimensions=dimensions,\n        axes_order=axes_order,\n        transforms=transforms,\n        slicing_dict=input_slice_kwargs,\n        remove_channel_selection=remove_channel_selection,\n        roi=roi,\n    )\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.NumpyRoiSetter.zarr_array","title":"zarr_array  <code>property</code>","text":"<pre><code>zarr_array: Array\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.NumpyRoiSetter.slicing_ops","title":"slicing_ops  <code>property</code>","text":"<pre><code>slicing_ops: SlicingOps\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.NumpyRoiSetter.axes_ops","title":"axes_ops  <code>property</code>","text":"<pre><code>axes_ops: AxesOps\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.NumpyRoiSetter.transforms","title":"transforms  <code>property</code>","text":"<pre><code>transforms: Sequence[TransformProtocol] | None\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.NumpyRoiSetter.roi","title":"roi  <code>property</code>","text":"<pre><code>roi: Roi\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.NumpyRoiSetter.set","title":"set","text":"<pre><code>set(patch: ndarray) -&gt; None\n</code></pre> <p>Get a numpy array from the zarr array with ops.</p> Source code in <code>ngio/io_pipes/_io_pipes.py</code> <pre><code>def set(self, patch: np.ndarray) -&gt; None:\n    \"\"\"Get a numpy array from the zarr array with ops.\"\"\"\n    patch = set_as_numpy_transform(\n        array=patch,\n        slicing_ops=self._slicing_ops,\n        axes_ops=self._axes_ops,\n        transforms=self._transforms,\n    )\n    patch = set_as_numpy_axes_ops(\n        array=patch,\n        axes_ops=self._axes_ops,\n    )\n    set_slice_as_numpy(\n        zarr_array=self._zarr_array,\n        patch=patch,\n        slicing_ops=self._slicing_ops,\n    )\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.SlicingOps","title":"SlicingOps","text":"<p>               Bases: <code>BaseModel</code></p> <p>Class to hold slicing operations.</p>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.SlicingOps.on_disk_axes","title":"on_disk_axes  <code>instance-attribute</code>","text":"<pre><code>on_disk_axes: tuple[str, ...]\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.SlicingOps.on_disk_shape","title":"on_disk_shape  <code>instance-attribute</code>","text":"<pre><code>on_disk_shape: tuple[int, ...]\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.SlicingOps.on_disk_chunks","title":"on_disk_chunks  <code>instance-attribute</code>","text":"<pre><code>on_disk_chunks: tuple[int, ...]\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.SlicingOps.slicing_tuple","title":"slicing_tuple  <code>instance-attribute</code>","text":"<pre><code>slicing_tuple: tuple[SlicingType, ...]\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.SlicingOps.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(\n    extra=\"forbid\", arbitrary_types_allowed=True\n)\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.SlicingOps.normalized_slicing_tuple","title":"normalized_slicing_tuple  <code>property</code>","text":"<pre><code>normalized_slicing_tuple: tuple[SlicingType, ...]\n</code></pre> <p>Normalize the slicing tuple to be within the array shape boundaries.</p>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.SlicingOps.slice_axes","title":"slice_axes  <code>property</code>","text":"<pre><code>slice_axes: tuple[str, ...]\n</code></pre> <p>The axes after slicing.</p>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.SlicingOps.slice_chunks","title":"slice_chunks","text":"<pre><code>slice_chunks() -&gt; set[tuple[int, ...]]\n</code></pre> <p>The required to read or write the slice.</p> Source code in <code>ngio/io_pipes/_ops_slices.py</code> <pre><code>def slice_chunks(self) -&gt; set[tuple[int, ...]]:\n    \"\"\"The required to read or write the slice.\"\"\"\n    return compute_slice_chunks(\n        shape=self.on_disk_shape,\n        chunks=self.on_disk_chunks,\n        slicing_tuple=self.normalized_slicing_tuple,\n    )\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.SlicingOps.get","title":"get","text":"<pre><code>get(ax_name: str, normalize: bool = False) -&gt; SlicingType\n</code></pre> <p>Get the slicing tuple.</p> Source code in <code>ngio/io_pipes/_ops_slices.py</code> <pre><code>def get(self, ax_name: str, normalize: bool = False) -&gt; SlicingType:\n    \"\"\"Get the slicing tuple.\"\"\"\n    slicing_tuple = (\n        self.slicing_tuple if not normalize else self.normalized_slicing_tuple\n    )\n    if ax_name not in self.on_disk_axes:\n        return slice(None)\n    ax_index = self.on_disk_axes.index(ax_name)\n    return slicing_tuple[ax_index]\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.TransformProtocol","title":"TransformProtocol","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for a generic transform.</p>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.TransformProtocol.get_as_numpy_transform","title":"get_as_numpy_transform","text":"<pre><code>get_as_numpy_transform(\n    array: ndarray,\n    slicing_ops: SlicingOps,\n    axes_ops: AxesOps,\n) -&gt; ndarray\n</code></pre> <p>A transformation to be applied after loading a numpy array.</p> Source code in <code>ngio/io_pipes/_ops_transforms.py</code> <pre><code>def get_as_numpy_transform(\n    self, array: np.ndarray, slicing_ops: SlicingOps, axes_ops: AxesOps\n) -&gt; np.ndarray:\n    \"\"\"A transformation to be applied after loading a numpy array.\"\"\"\n    ...\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.TransformProtocol.get_as_dask_transform","title":"get_as_dask_transform","text":"<pre><code>get_as_dask_transform(\n    array: Array, slicing_ops: SlicingOps, axes_ops: AxesOps\n) -&gt; Array\n</code></pre> <p>A transformation to be applied after loading a dask array.</p> Source code in <code>ngio/io_pipes/_ops_transforms.py</code> <pre><code>def get_as_dask_transform(\n    self, array: da.Array, slicing_ops: SlicingOps, axes_ops: AxesOps\n) -&gt; da.Array:\n    \"\"\"A transformation to be applied after loading a dask array.\"\"\"\n    ...\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.TransformProtocol.set_as_numpy_transform","title":"set_as_numpy_transform","text":"<pre><code>set_as_numpy_transform(\n    array: ndarray,\n    slicing_ops: SlicingOps,\n    axes_ops: AxesOps,\n) -&gt; ndarray\n</code></pre> <p>A transformation to be applied before writing a numpy array.</p> Source code in <code>ngio/io_pipes/_ops_transforms.py</code> <pre><code>def set_as_numpy_transform(\n    self, array: np.ndarray, slicing_ops: SlicingOps, axes_ops: AxesOps\n) -&gt; np.ndarray:\n    \"\"\"A transformation to be applied before writing a numpy array.\"\"\"\n    ...\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.TransformProtocol.set_as_dask_transform","title":"set_as_dask_transform","text":"<pre><code>set_as_dask_transform(\n    array: Array, slicing_ops: SlicingOps, axes_ops: AxesOps\n) -&gt; Array\n</code></pre> <p>A transformation to be applied before writing a dask array.</p> Source code in <code>ngio/io_pipes/_ops_transforms.py</code> <pre><code>def set_as_dask_transform(\n    self, array: da.Array, slicing_ops: SlicingOps, axes_ops: AxesOps\n) -&gt; da.Array:\n    \"\"\"A transformation to be applied before writing a dask array.\"\"\"\n    ...\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.dask_match_shape","title":"dask_match_shape","text":"<pre><code>dask_match_shape(\n    array: Array,\n    reference_shape: tuple[int, ...],\n    array_axes: Sequence[str],\n    reference_axes: Sequence[str],\n    tolerance: int = 1,\n    pad_mode: str = \"constant\",\n    pad_values: int | float = 0,\n) -&gt; Array\n</code></pre> <p>Match the shape of a dask array to a reference shape.</p> <p>This function will reshape, pad, trim and broadcast the input array to match the reference shape. If the shapes cannot be matched within the specified tolerance, an error is raised.</p> <p>The reference axes must be a superset of the array axes, and the order of the axes must be the same.</p> <p>Parameters:</p> <ul> <li> <code>array</code>               (<code>Array</code>)           \u2013            <p>The input array to be reshaped.</p> </li> <li> <code>reference_shape</code>               (<code>tuple[int, ...]</code>)           \u2013            <p>The target shape to match.</p> </li> <li> <code>array_axes</code>               (<code>Sequence[str]</code>)           \u2013            <p>The axes names of the input array.</p> </li> <li> <code>reference_axes</code>               (<code>Sequence[str]</code>)           \u2013            <p>The axes names of the reference shape.</p> </li> <li> <code>tolerance</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum number of pixels by which dimensions can differ when matching shapes.</p> </li> <li> <code>pad_mode</code>               (<code>str</code>, default:                   <code>'constant'</code> )           \u2013            <p>The mode to use for padding. See numpy.pad for options.</p> </li> <li> <code>pad_values</code>               (<code>int | float</code>, default:                   <code>0</code> )           \u2013            <p>The constant value to use for padding if pad_mode is 'constant'.</p> </li> </ul> Source code in <code>ngio/io_pipes/_match_shape.py</code> <pre><code>def dask_match_shape(\n    array: da.Array,\n    reference_shape: tuple[int, ...],\n    array_axes: Sequence[str],\n    reference_axes: Sequence[str],\n    tolerance: int = 1,\n    pad_mode: str = \"constant\",\n    pad_values: int | float = 0,\n) -&gt; da.Array:\n    \"\"\"Match the shape of a dask array to a reference shape.\n\n    This function will reshape, pad, trim and broadcast the input array\n    to match the reference shape. If the shapes cannot be matched within\n    the specified tolerance, an error is raised.\n\n    The reference axes must be a superset of the array axes, and the order\n    of the axes must be the same.\n\n    Args:\n        array (da.Array): The input array to be reshaped.\n        reference_shape (tuple[int, ...]): The target shape to match.\n        array_axes (Sequence[str]): The axes names of the input array.\n        reference_axes (Sequence[str]): The axes names of the reference shape.\n        tolerance (int): The maximum number of pixels by which dimensions\n            can differ when matching shapes.\n        pad_mode (str): The mode to use for padding. See numpy.pad for options.\n        pad_values (int | float): The constant value to use for padding if\n            pad_mode is 'constant'.\n    \"\"\"\n    array_shape = tuple(int(s) for s in array.shape)\n    _check_axes(\n        array_shape=array_shape,\n        reference_shape=reference_shape,\n        array_axes=array_axes,\n        reference_axes=reference_axes,\n    )\n    if array_shape == reference_shape:\n        # Shapes already match\n        return array\n    array_axes = list(array_axes)\n    reference_axes = list(reference_axes)\n\n    reshape_tuple, actions = _compute_reshape_and_actions(\n        array_shape=tuple(int(s) for s in array.shape),\n        reference_shape=reference_shape,\n        array_axes=array_axes,\n        reference_axes=reference_axes,\n        tolerance=tolerance,\n    )\n    array = da.reshape(array, reshape_tuple)\n    array = _dask_pad(\n        array=array,\n        actions=actions,\n        target_shape=reference_shape,\n        pad_mode=pad_mode,\n        constant_values=pad_values,\n    )\n    array = _dask_trim(array=array, actions=actions, target_shape=reference_shape)\n    return array\n</code></pre>"},{"location":"api/ngio/io_pipes/#ngio.io_pipes.numpy_match_shape","title":"numpy_match_shape","text":"<pre><code>numpy_match_shape(\n    array: ndarray,\n    reference_shape: tuple[int, ...],\n    array_axes: Sequence[str],\n    reference_axes: Sequence[str],\n    tolerance: int = 1,\n    pad_mode: str = \"constant\",\n    pad_values: int | float = 0,\n)\n</code></pre> <p>Match the shape of a numpy array to a reference shape.</p> <p>This function will reshape, pad, trim and broadcast the input array to match the reference shape. If the shapes cannot be matched within the specified tolerance, an error is raised.</p> <p>The reference axes must be a superset of the array axes, and the order of the axes must be the same.</p> <p>Parameters:</p> <ul> <li> <code>array</code>               (<code>ndarray</code>)           \u2013            <p>The input array to be reshaped.</p> </li> <li> <code>reference_shape</code>               (<code>tuple[int, ...]</code>)           \u2013            <p>The target shape to match.</p> </li> <li> <code>array_axes</code>               (<code>Sequence[str]</code>)           \u2013            <p>The axes names of the input array.</p> </li> <li> <code>reference_axes</code>               (<code>Sequence[str]</code>)           \u2013            <p>The axes names of the reference shape.</p> </li> <li> <code>tolerance</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum number of pixels by which dimensions can differ when matching shapes.</p> </li> <li> <code>pad_mode</code>               (<code>str</code>, default:                   <code>'constant'</code> )           \u2013            <p>The mode to use for padding. See numpy.pad for options.</p> </li> <li> <code>pad_values</code>               (<code>int | float</code>, default:                   <code>0</code> )           \u2013            <p>The constant value to use for padding if pad_mode is 'constant'.</p> </li> </ul> Source code in <code>ngio/io_pipes/_match_shape.py</code> <pre><code>def numpy_match_shape(\n    array: np.ndarray,\n    reference_shape: tuple[int, ...],\n    array_axes: Sequence[str],\n    reference_axes: Sequence[str],\n    tolerance: int = 1,\n    pad_mode: str = \"constant\",\n    pad_values: int | float = 0,\n):\n    \"\"\"Match the shape of a numpy array to a reference shape.\n\n    This function will reshape, pad, trim and broadcast the input array\n    to match the reference shape. If the shapes cannot be matched within\n    the specified tolerance, an error is raised.\n\n    The reference axes must be a superset of the array axes, and the order\n    of the axes must be the same.\n\n    Args:\n        array (np.ndarray): The input array to be reshaped.\n        reference_shape (tuple[int, ...]): The target shape to match.\n        array_axes (Sequence[str]): The axes names of the input array.\n        reference_axes (Sequence[str]): The axes names of the reference shape.\n        tolerance (int): The maximum number of pixels by which dimensions\n            can differ when matching shapes.\n        pad_mode (str): The mode to use for padding. See numpy.pad for options.\n        pad_values (int | float): The constant value to use for padding if\n            pad_mode is 'constant'.\n    \"\"\"\n    _check_axes(\n        array_shape=array.shape,\n        reference_shape=reference_shape,\n        array_axes=array_axes,\n        reference_axes=reference_axes,\n    )\n    if array.shape == reference_shape:\n        # Shapes already match\n        return array\n\n    array_axes = list(array_axes)\n    reference_axes = list(reference_axes)\n\n    reshape_tuple, actions = _compute_reshape_and_actions(\n        array_shape=array.shape,\n        reference_shape=reference_shape,\n        array_axes=array_axes,\n        reference_axes=reference_axes,\n        tolerance=tolerance,\n    )\n    array = array.reshape(reshape_tuple)\n    array = _numpy_pad(\n        array=array,\n        actions=actions,\n        target_shape=reference_shape,\n        pad_mode=pad_mode,\n        constant_values=pad_values,\n    )\n    array = _numpy_trim(array=array, actions=actions, target_shape=reference_shape)\n    return array\n</code></pre>"},{"location":"api/ngio/iterators/","title":"ngio.iterators API documentation","text":""},{"location":"api/ngio/iterators/#ngio.experimental.iterators","title":"ngio.experimental.iterators","text":"<p>This file is part of NGIO, a library for working with OME-Zarr data.</p>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.FeatureExtractorIterator","title":"FeatureExtractorIterator","text":"<pre><code>FeatureExtractorIterator(\n    input_image: Image,\n    input_label: Label,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    input_transforms: Sequence[TransformProtocol]\n    | None = None,\n    label_transforms: Sequence[TransformProtocol]\n    | None = None,\n)\n</code></pre> <p>               Bases: <code>AbstractIteratorBuilder[NumpyPipeType, DaskPipeType]</code></p> <p>Base class for iterators over ROIs.</p> <p>Initialize the iterator with a ROI table and input/output images.</p> <p>Parameters:</p> <ul> <li> <code>input_image</code>               (<code>Image</code>)           \u2013            <p>The input image to be used as input for the segmentation.</p> </li> <li> <code>input_label</code>               (<code>Label</code>)           \u2013            <p>The input label with the segmentation masks.</p> </li> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Optional selection of channels to use for the segmentation.</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional axes order for the segmentation.</p> </li> <li> <code>input_transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional transforms to apply to the input image.</p> </li> <li> <code>label_transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional transforms to apply to the output label.</p> </li> </ul> Source code in <code>ngio/experimental/iterators/_feature.py</code> <pre><code>def __init__(\n    self,\n    input_image: Image,\n    input_label: Label,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    input_transforms: Sequence[TransformProtocol] | None = None,\n    label_transforms: Sequence[TransformProtocol] | None = None,\n) -&gt; None:\n    \"\"\"Initialize the iterator with a ROI table and input/output images.\n\n    Args:\n        input_image (Image): The input image to be used as input for the\n            segmentation.\n        input_label (Label): The input label with the segmentation masks.\n        channel_selection (ChannelSlicingInputType): Optional\n            selection of channels to use for the segmentation.\n        axes_order (Sequence[str] | None): Optional axes order for the\n            segmentation.\n        input_transforms (Sequence[TransformProtocol] | None): Optional\n            transforms to apply to the input image.\n        label_transforms (Sequence[TransformProtocol] | None): Optional\n            transforms to apply to the output label.\n    \"\"\"\n    self._input = input_image\n    self._input_label = input_label\n    self._ref_image = input_image\n    self._rois = input_image.build_image_roi_table(name=None).rois()\n\n    # Set iteration parameters\n    self._input_slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self._input, channel_selection=channel_selection, slicing_dict={}\n    )\n    self._channel_selection = channel_selection\n    self._axes_order = axes_order\n    self._input_transforms = input_transforms\n    self._label_transforms = label_transforms\n\n    self._input.require_axes_match(self._input_label)\n    self._input.require_rescalable(self._input_label)\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.FeatureExtractorIterator.rois","title":"rois  <code>property</code>","text":"<pre><code>rois: list[Roi]\n</code></pre> <p>Get the list of ROIs for the iterator.</p>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.FeatureExtractorIterator.ref_image","title":"ref_image  <code>property</code>","text":"<pre><code>ref_image: AbstractImage\n</code></pre> <p>Get the reference image for the iterator.</p>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.FeatureExtractorIterator.grid","title":"grid","text":"<pre><code>grid(\n    size_x: int | None = None,\n    size_y: int | None = None,\n    size_z: int | None = None,\n    size_t: int | None = None,\n    stride_x: int | None = None,\n    stride_y: int | None = None,\n    stride_z: int | None = None,\n    stride_t: int | None = None,\n    base_name: str = \"\",\n) -&gt; Self\n</code></pre> <p>Create a grid of ROIs based on the input image dimensions.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def grid(\n    self,\n    size_x: int | None = None,\n    size_y: int | None = None,\n    size_z: int | None = None,\n    size_t: int | None = None,\n    stride_x: int | None = None,\n    stride_y: int | None = None,\n    stride_z: int | None = None,\n    stride_t: int | None = None,\n    base_name: str = \"\",\n) -&gt; Self:\n    \"\"\"Create a grid of ROIs based on the input image dimensions.\"\"\"\n    rois = grid(\n        rois=self.rois,\n        ref_image=self.ref_image,\n        size_x=size_x,\n        size_y=size_y,\n        size_z=size_z,\n        size_t=size_t,\n        stride_x=stride_x,\n        stride_y=stride_y,\n        stride_z=stride_z,\n        stride_t=stride_t,\n        base_name=base_name,\n    )\n    return self._new_from_rois(rois)\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.FeatureExtractorIterator.by_yx","title":"by_yx","text":"<pre><code>by_yx() -&gt; Self\n</code></pre> <p>Return a new iterator that iterates over ROIs by YX coordinates.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def by_yx(self) -&gt; Self:\n    \"\"\"Return a new iterator that iterates over ROIs by YX coordinates.\"\"\"\n    rois = by_yx(self.rois, self.ref_image)\n    return self._new_from_rois(rois)\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.FeatureExtractorIterator.by_zyx","title":"by_zyx","text":"<pre><code>by_zyx(strict: bool = True) -&gt; Self\n</code></pre> <p>Return a new iterator that iterates over ROIs by ZYX coordinates.</p> <p>Parameters:</p> <ul> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, only iterate over ZYX if a Z axis is present and not of size 1.</p> </li> </ul> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def by_zyx(self, strict: bool = True) -&gt; Self:\n    \"\"\"Return a new iterator that iterates over ROIs by ZYX coordinates.\n\n    Args:\n        strict (bool): If True, only iterate over ZYX if a Z axis\n            is present and not of size 1.\n\n    \"\"\"\n    rois = by_zyx(self.rois, self.ref_image, strict=strict)\n    return self._new_from_rois(rois)\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.FeatureExtractorIterator.by_chunks","title":"by_chunks","text":"<pre><code>by_chunks(overlap_xy: int = 0, overlap_z: int = 0) -&gt; Self\n</code></pre> <p>Return a new iterator that iterates over ROIs by chunks.</p> <p>Parameters:</p> <ul> <li> <code>overlap_xy</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Overlap in XY dimensions.</p> </li> <li> <code>overlap_z</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Overlap in Z dimension.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SegmentationIterator</code> (              <code>Self</code> )          \u2013            <p>A new iterator with chunked ROIs.</p> </li> </ul> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def by_chunks(self, overlap_xy: int = 0, overlap_z: int = 0) -&gt; Self:\n    \"\"\"Return a new iterator that iterates over ROIs by chunks.\n\n    Args:\n        overlap_xy (int): Overlap in XY dimensions.\n        overlap_z (int): Overlap in Z dimension.\n\n    Returns:\n        SegmentationIterator: A new iterator with chunked ROIs.\n    \"\"\"\n    rois = by_chunks(\n        self.rois, self.ref_image, overlap_xy=overlap_xy, overlap_z=overlap_z\n    )\n    return self._new_from_rois(rois)\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.FeatureExtractorIterator.product","title":"product","text":"<pre><code>product(other: list[Roi] | GenericRoiTable) -&gt; Self\n</code></pre> <p>Cartesian product of the current ROIs with an arbitrary list of ROIs.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def product(self, other: list[Roi] | GenericRoiTable) -&gt; Self:\n    \"\"\"Cartesian product of the current ROIs with an arbitrary list of ROIs.\"\"\"\n    if isinstance(other, GenericRoiTable):\n        other = other.rois()\n    rois = rois_product(self.rois, other)\n    return self._new_from_rois(rois)\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.FeatureExtractorIterator.iter","title":"iter","text":"<pre><code>iter(\n    lazy: Literal[True],\n    data_mode: Literal[\"numpy\"],\n    iterator_mode: Literal[\"readwrite\"],\n) -&gt; Generator[\n    tuple[\n        DataGetterProtocol[NumpyPipeType],\n        DataSetterProtocol[NumpyPipeType],\n    ]\n]\n</code></pre><pre><code>iter(\n    lazy: Literal[True],\n    data_mode: Literal[\"numpy\"],\n    iterator_mode: Literal[\"readonly\"] = ...,\n) -&gt; Generator[DataGetterProtocol[NumpyPipeType]]\n</code></pre><pre><code>iter(\n    lazy: Literal[True],\n    data_mode: Literal[\"dask\"],\n    iterator_mode: Literal[\"readwrite\"],\n) -&gt; Generator[\n    tuple[\n        DataGetterProtocol[DaskPipeType],\n        DataSetterProtocol[DaskPipeType],\n    ]\n]\n</code></pre><pre><code>iter(\n    lazy: Literal[True],\n    data_mode: Literal[\"dask\"],\n    iterator_mode: Literal[\"readonly\"] = ...,\n) -&gt; Generator[DataGetterProtocol[DaskPipeType]]\n</code></pre><pre><code>iter(\n    lazy: Literal[False],\n    data_mode: Literal[\"numpy\"],\n    iterator_mode: Literal[\"readwrite\"],\n) -&gt; Generator[\n    tuple[NumpyPipeType, DataSetterProtocol[NumpyPipeType]]\n]\n</code></pre><pre><code>iter(\n    lazy: Literal[False],\n    data_mode: Literal[\"numpy\"],\n    iterator_mode: Literal[\"readonly\"] = ...,\n) -&gt; Generator[NumpyPipeType]\n</code></pre><pre><code>iter(\n    lazy: Literal[False],\n    data_mode: Literal[\"dask\"],\n    iterator_mode: Literal[\"readwrite\"],\n) -&gt; Generator[\n    tuple[DaskPipeType, DataSetterProtocol[DaskPipeType]]\n]\n</code></pre><pre><code>iter(\n    lazy: Literal[False],\n    data_mode: Literal[\"dask\"],\n    iterator_mode: Literal[\"readonly\"] = ...,\n) -&gt; Generator[DaskPipeType]\n</code></pre> <pre><code>iter(\n    lazy: bool = False,\n    data_mode: Literal[\"numpy\", \"dask\"] = \"dask\",\n    iterator_mode: Literal[\n        \"readwrite\", \"readonly\"\n    ] = \"readwrite\",\n) -&gt; Generator\n</code></pre> <p>Create an iterator over the pixels of the ROIs.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def iter(\n    self,\n    lazy: bool = False,\n    data_mode: Literal[\"numpy\", \"dask\"] = \"dask\",\n    iterator_mode: Literal[\"readwrite\", \"readonly\"] = \"readwrite\",\n) -&gt; Generator:\n    \"\"\"Create an iterator over the pixels of the ROIs.\"\"\"\n    if data_mode == \"numpy\":\n        getters = self._numpy_getters_generator()\n        setters = self._numpy_setters_generator()\n    elif data_mode == \"dask\":\n        getters = self._dask_getters_generator()\n        setters = self._dask_setters_generator()\n    else:\n        raise NgioValueError(f\"Invalid mode: {data_mode}\")\n\n    if iterator_mode == \"readonly\":\n        if lazy:\n            return getters\n        else:\n            return (getter() for getter in getters)\n    if lazy:\n        return self._read_and_write_generator(getters, setters)\n    else:\n        gen = self._read_and_write_generator(getters, setters)\n        return ((getter(), setter) for getter, setter in gen)\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.FeatureExtractorIterator.map_as_numpy","title":"map_as_numpy","text":"<pre><code>map_as_numpy(\n    func: Callable[[NumpyPipeType], NumpyPipeType],\n    mapper: MapperProtocol[NumpyPipeType] | None = None,\n) -&gt; None\n</code></pre> <p>Apply a transformation function to the ROI pixels.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def map_as_numpy(\n    self,\n    func: Callable[[NumpyPipeType], NumpyPipeType],\n    mapper: MapperProtocol[NumpyPipeType] | None = None,\n) -&gt; None:\n    \"\"\"Apply a transformation function to the ROI pixels.\"\"\"\n    if mapper is None:\n        _mapper = BasicMapper[NumpyPipeType]()\n    else:\n        _mapper = mapper\n\n    _mapper(\n        func=func,\n        getters=self._numpy_getters_generator(),\n        setters=self._numpy_setters_generator(),\n    )\n    self.post_consolidate()\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.FeatureExtractorIterator.map_as_dask","title":"map_as_dask","text":"<pre><code>map_as_dask(\n    func: Callable[[DaskPipeType], DaskPipeType],\n    mapper: MapperProtocol[DaskPipeType] | None = None,\n) -&gt; None\n</code></pre> <p>Apply a transformation function to the ROI pixels.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def map_as_dask(\n    self,\n    func: Callable[[DaskPipeType], DaskPipeType],\n    mapper: MapperProtocol[DaskPipeType] | None = None,\n) -&gt; None:\n    \"\"\"Apply a transformation function to the ROI pixels.\"\"\"\n    if mapper is None:\n        _mapper = BasicMapper[DaskPipeType]()\n    else:\n        _mapper = mapper\n\n    _mapper(\n        func=func,\n        getters=self._dask_getters_generator(),\n        setters=self._dask_setters_generator(),\n    )\n    self.post_consolidate()\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.FeatureExtractorIterator.check_if_regions_overlap","title":"check_if_regions_overlap","text":"<pre><code>check_if_regions_overlap() -&gt; bool\n</code></pre> <p>Check if any of the ROIs overlap logically.</p> <p>If two ROIs cover the same pixel, they are considered to overlap. This does not consider chunking or other storage details.</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if any ROIs overlap. False otherwise.</p> </li> </ul> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def check_if_regions_overlap(self) -&gt; bool:\n    \"\"\"Check if any of the ROIs overlap logically.\n\n    If two ROIs cover the same pixel, they are considered to overlap.\n    This does not consider chunking or other storage details.\n\n    Returns:\n        bool: True if any ROIs overlap. False otherwise.\n    \"\"\"\n    if len(self.rois) &lt; 2:\n        # Less than 2 ROIs cannot overlap\n        return False\n\n    slicing_tuples = (\n        g.slicing_ops.normalized_slicing_tuple\n        for g in self._numpy_getters_generator()\n    )\n    x = check_if_regions_overlap(slicing_tuples)\n    return x\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.FeatureExtractorIterator.require_no_regions_overlap","title":"require_no_regions_overlap","text":"<pre><code>require_no_regions_overlap() -&gt; None\n</code></pre> <p>Ensure that the Iterator's ROIs do not overlap.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def require_no_regions_overlap(self) -&gt; None:\n    \"\"\"Ensure that the Iterator's ROIs do not overlap.\"\"\"\n    if self.check_if_regions_overlap():\n        raise NgioValueError(\"Some rois overlap.\")\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.FeatureExtractorIterator.check_if_chunks_overlap","title":"check_if_chunks_overlap","text":"<pre><code>check_if_chunks_overlap() -&gt; bool\n</code></pre> <p>Check if any of the ROIs overlap in terms of chunks.</p> <p>If two ROIs cover the same chunk, they are considered to overlap in chunks. This does not consider pixel-level overlaps.</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if any ROIs overlap in chunks, False otherwise.</p> </li> </ul> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def check_if_chunks_overlap(self) -&gt; bool:\n    \"\"\"Check if any of the ROIs overlap in terms of chunks.\n\n    If two ROIs cover the same chunk, they are considered to overlap in chunks.\n    This does not consider pixel-level overlaps.\n\n    Returns:\n        bool: True if any ROIs overlap in chunks, False otherwise.\n    \"\"\"\n    from ngio.io_pipes._ops_slices_utils import check_if_chunks_overlap\n\n    if len(self.rois) &lt; 2:\n        # Less than 2 ROIs cannot overlap\n        return False\n\n    slicing_tuples = (\n        g.slicing_ops.normalized_slicing_tuple\n        for g in self._numpy_getters_generator()\n    )\n    shape = self.ref_image.shape\n    chunks = self.ref_image.chunks\n    return check_if_chunks_overlap(slicing_tuples, shape, chunks)\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.FeatureExtractorIterator.require_no_chunks_overlap","title":"require_no_chunks_overlap","text":"<pre><code>require_no_chunks_overlap() -&gt; None\n</code></pre> <p>Ensure that the ROIs do not overlap in terms of chunks.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def require_no_chunks_overlap(self) -&gt; None:\n    \"\"\"Ensure that the ROIs do not overlap in terms of chunks.\"\"\"\n    if self.check_if_chunks_overlap():\n        raise NgioValueError(\"Some rois overlap in chunks.\")\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.FeatureExtractorIterator.get_init_kwargs","title":"get_init_kwargs","text":"<pre><code>get_init_kwargs() -&gt; dict\n</code></pre> <p>Return the initialization arguments for the iterator.</p> Source code in <code>ngio/experimental/iterators/_feature.py</code> <pre><code>def get_init_kwargs(self) -&gt; dict:\n    \"\"\"Return the initialization arguments for the iterator.\"\"\"\n    return {\n        \"input_image\": self._input,\n        \"input_label\": self._input_label,\n        \"channel_selection\": self._channel_selection,\n        \"axes_order\": self._axes_order,\n        \"input_transforms\": self._input_transforms,\n        \"label_transforms\": self._label_transforms,\n    }\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.FeatureExtractorIterator.build_numpy_getter","title":"build_numpy_getter","text":"<pre><code>build_numpy_getter(roi: Roi) -&gt; NumpyFeatureGetter\n</code></pre> Source code in <code>ngio/experimental/iterators/_feature.py</code> <pre><code>def build_numpy_getter(self, roi: Roi) -&gt; NumpyFeatureGetter:\n    data_getter = NumpyRoiGetter(\n        zarr_array=self._input.zarr_array,\n        dimensions=self._input.dimensions,\n        axes_order=self._axes_order,\n        transforms=self._input_transforms,\n        roi=roi,\n        slicing_dict=self._input_slicing_kwargs,\n    )\n    label_getter = NumpyRoiGetter(\n        zarr_array=self._input_label.zarr_array,\n        dimensions=self._input_label.dimensions,\n        axes_order=self._axes_order,\n        transforms=self._label_transforms,\n        roi=roi,\n        remove_channel_selection=True,\n    )\n    return NumpyFeatureGetter(data_getter, label_getter)\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.FeatureExtractorIterator.build_dask_getter","title":"build_dask_getter","text":"<pre><code>build_dask_getter(roi: Roi) -&gt; DaskFeatureGetter\n</code></pre> Source code in <code>ngio/experimental/iterators/_feature.py</code> <pre><code>def build_dask_getter(self, roi: Roi) -&gt; DaskFeatureGetter:\n    data_getter = DaskRoiGetter(\n        zarr_array=self._input.zarr_array,\n        dimensions=self._input.dimensions,\n        axes_order=self._axes_order,\n        transforms=self._input_transforms,\n        roi=roi,\n        slicing_dict=self._input_slicing_kwargs,\n    )\n    label_getter = DaskRoiGetter(\n        zarr_array=self._input_label.zarr_array,\n        dimensions=self._input_label.dimensions,\n        axes_order=self._axes_order,\n        transforms=self._label_transforms,\n        roi=roi,\n        remove_channel_selection=True,\n    )\n    return DaskFeatureGetter(data_getter, label_getter)\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.FeatureExtractorIterator.build_numpy_setter","title":"build_numpy_setter","text":"<pre><code>build_numpy_setter(roi: Roi) -&gt; None\n</code></pre> Source code in <code>ngio/experimental/iterators/_feature.py</code> <pre><code>def build_numpy_setter(self, roi: Roi) -&gt; None:\n    return None\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.FeatureExtractorIterator.build_dask_setter","title":"build_dask_setter","text":"<pre><code>build_dask_setter(roi: Roi) -&gt; None\n</code></pre> Source code in <code>ngio/experimental/iterators/_feature.py</code> <pre><code>def build_dask_setter(self, roi: Roi) -&gt; None:\n    return None\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.FeatureExtractorIterator.post_consolidate","title":"post_consolidate","text":"<pre><code>post_consolidate()\n</code></pre> Source code in <code>ngio/experimental/iterators/_feature.py</code> <pre><code>def post_consolidate(self):\n    pass\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.FeatureExtractorIterator.iter_as_numpy","title":"iter_as_numpy","text":"<pre><code>iter_as_numpy()\n</code></pre> <p>Create an iterator over the pixels of the ROIs.</p> Source code in <code>ngio/experimental/iterators/_feature.py</code> <pre><code>def iter_as_numpy(self):  # type: ignore[override]\n    \"\"\"Create an iterator over the pixels of the ROIs.\"\"\"\n    return self.iter(lazy=False, data_mode=\"numpy\", iterator_mode=\"readonly\")\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.FeatureExtractorIterator.iter_as_dask","title":"iter_as_dask","text":"<pre><code>iter_as_dask()\n</code></pre> <p>Create an iterator over the pixels of the ROIs.</p> Source code in <code>ngio/experimental/iterators/_feature.py</code> <pre><code>def iter_as_dask(self):  # type: ignore[override]\n    \"\"\"Create an iterator over the pixels of the ROIs.\"\"\"\n    return self.iter(lazy=False, data_mode=\"dask\", iterator_mode=\"readonly\")\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.ImageProcessingIterator","title":"ImageProcessingIterator","text":"<pre><code>ImageProcessingIterator(\n    input_image: Image,\n    output_image: Image,\n    input_channel_selection: ChannelSlicingInputType = None,\n    output_channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    input_transforms: Sequence[TransformProtocol]\n    | None = None,\n    output_transforms: Sequence[TransformProtocol]\n    | None = None,\n)\n</code></pre> <p>               Bases: <code>AbstractIteratorBuilder[ndarray, Array]</code></p> <p>Base class for iterators over ROIs.</p> <p>Initialize the iterator with a ROI table and input/output images.</p> <p>Parameters:</p> <ul> <li> <code>input_image</code>               (<code>Image</code>)           \u2013            <p>The input image to be used as input for the segmentation.</p> </li> <li> <code>output_image</code>               (<code>Image</code>)           \u2013            <p>The image where the ROIs will be written.</p> </li> <li> <code>input_channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Optional selection of channels to use for the input image.</p> </li> <li> <code>output_channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Optional selection of channels to use for the output image.</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional axes order for the segmentation.</p> </li> <li> <code>input_transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional transforms to apply to the input image.</p> </li> <li> <code>output_transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional transforms to apply to the output label.</p> </li> </ul> Source code in <code>ngio/experimental/iterators/_image_processing.py</code> <pre><code>def __init__(\n    self,\n    input_image: Image,\n    output_image: Image,\n    input_channel_selection: ChannelSlicingInputType = None,\n    output_channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    input_transforms: Sequence[TransformProtocol] | None = None,\n    output_transforms: Sequence[TransformProtocol] | None = None,\n) -&gt; None:\n    \"\"\"Initialize the iterator with a ROI table and input/output images.\n\n    Args:\n        input_image (Image): The input image to be used as input for the\n            segmentation.\n        output_image (Image): The image where the ROIs will be written.\n        input_channel_selection (ChannelSlicingInputType): Optional\n            selection of channels to use for the input image.\n        output_channel_selection (ChannelSlicingInputType): Optional\n            selection of channels to use for the output image.\n        axes_order (Sequence[str] | None): Optional axes order for the\n            segmentation.\n        input_transforms (Sequence[TransformProtocol] | None): Optional\n            transforms to apply to the input image.\n        output_transforms (Sequence[TransformProtocol] | None): Optional\n            transforms to apply to the output label.\n    \"\"\"\n    self._input = input_image\n    self._output = output_image\n    self._ref_image = input_image\n    self._rois = input_image.build_image_roi_table(name=None).rois()\n\n    # Set iteration parameters\n    self._input_slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self._input,\n        channel_selection=input_channel_selection,\n        slicing_dict={},\n    )\n    self._output_slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self._output,\n        channel_selection=output_channel_selection,\n        slicing_dict={},\n    )\n    self._input_channel_selection = input_channel_selection\n    self._output_channel_selection = output_channel_selection\n    self._axes_order = axes_order\n    self._input_transforms = input_transforms\n    self._output_transforms = output_transforms\n\n    self._input.require_dimensions_match(self._output, allow_singleton=True)\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.ImageProcessingIterator.rois","title":"rois  <code>property</code>","text":"<pre><code>rois: list[Roi]\n</code></pre> <p>Get the list of ROIs for the iterator.</p>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.ImageProcessingIterator.ref_image","title":"ref_image  <code>property</code>","text":"<pre><code>ref_image: AbstractImage\n</code></pre> <p>Get the reference image for the iterator.</p>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.ImageProcessingIterator.grid","title":"grid","text":"<pre><code>grid(\n    size_x: int | None = None,\n    size_y: int | None = None,\n    size_z: int | None = None,\n    size_t: int | None = None,\n    stride_x: int | None = None,\n    stride_y: int | None = None,\n    stride_z: int | None = None,\n    stride_t: int | None = None,\n    base_name: str = \"\",\n) -&gt; Self\n</code></pre> <p>Create a grid of ROIs based on the input image dimensions.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def grid(\n    self,\n    size_x: int | None = None,\n    size_y: int | None = None,\n    size_z: int | None = None,\n    size_t: int | None = None,\n    stride_x: int | None = None,\n    stride_y: int | None = None,\n    stride_z: int | None = None,\n    stride_t: int | None = None,\n    base_name: str = \"\",\n) -&gt; Self:\n    \"\"\"Create a grid of ROIs based on the input image dimensions.\"\"\"\n    rois = grid(\n        rois=self.rois,\n        ref_image=self.ref_image,\n        size_x=size_x,\n        size_y=size_y,\n        size_z=size_z,\n        size_t=size_t,\n        stride_x=stride_x,\n        stride_y=stride_y,\n        stride_z=stride_z,\n        stride_t=stride_t,\n        base_name=base_name,\n    )\n    return self._new_from_rois(rois)\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.ImageProcessingIterator.by_yx","title":"by_yx","text":"<pre><code>by_yx() -&gt; Self\n</code></pre> <p>Return a new iterator that iterates over ROIs by YX coordinates.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def by_yx(self) -&gt; Self:\n    \"\"\"Return a new iterator that iterates over ROIs by YX coordinates.\"\"\"\n    rois = by_yx(self.rois, self.ref_image)\n    return self._new_from_rois(rois)\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.ImageProcessingIterator.by_zyx","title":"by_zyx","text":"<pre><code>by_zyx(strict: bool = True) -&gt; Self\n</code></pre> <p>Return a new iterator that iterates over ROIs by ZYX coordinates.</p> <p>Parameters:</p> <ul> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, only iterate over ZYX if a Z axis is present and not of size 1.</p> </li> </ul> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def by_zyx(self, strict: bool = True) -&gt; Self:\n    \"\"\"Return a new iterator that iterates over ROIs by ZYX coordinates.\n\n    Args:\n        strict (bool): If True, only iterate over ZYX if a Z axis\n            is present and not of size 1.\n\n    \"\"\"\n    rois = by_zyx(self.rois, self.ref_image, strict=strict)\n    return self._new_from_rois(rois)\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.ImageProcessingIterator.by_chunks","title":"by_chunks","text":"<pre><code>by_chunks(overlap_xy: int = 0, overlap_z: int = 0) -&gt; Self\n</code></pre> <p>Return a new iterator that iterates over ROIs by chunks.</p> <p>Parameters:</p> <ul> <li> <code>overlap_xy</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Overlap in XY dimensions.</p> </li> <li> <code>overlap_z</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Overlap in Z dimension.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SegmentationIterator</code> (              <code>Self</code> )          \u2013            <p>A new iterator with chunked ROIs.</p> </li> </ul> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def by_chunks(self, overlap_xy: int = 0, overlap_z: int = 0) -&gt; Self:\n    \"\"\"Return a new iterator that iterates over ROIs by chunks.\n\n    Args:\n        overlap_xy (int): Overlap in XY dimensions.\n        overlap_z (int): Overlap in Z dimension.\n\n    Returns:\n        SegmentationIterator: A new iterator with chunked ROIs.\n    \"\"\"\n    rois = by_chunks(\n        self.rois, self.ref_image, overlap_xy=overlap_xy, overlap_z=overlap_z\n    )\n    return self._new_from_rois(rois)\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.ImageProcessingIterator.product","title":"product","text":"<pre><code>product(other: list[Roi] | GenericRoiTable) -&gt; Self\n</code></pre> <p>Cartesian product of the current ROIs with an arbitrary list of ROIs.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def product(self, other: list[Roi] | GenericRoiTable) -&gt; Self:\n    \"\"\"Cartesian product of the current ROIs with an arbitrary list of ROIs.\"\"\"\n    if isinstance(other, GenericRoiTable):\n        other = other.rois()\n    rois = rois_product(self.rois, other)\n    return self._new_from_rois(rois)\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.ImageProcessingIterator.iter","title":"iter","text":"<pre><code>iter(\n    lazy: Literal[True],\n    data_mode: Literal[\"numpy\"],\n    iterator_mode: Literal[\"readwrite\"],\n) -&gt; Generator[\n    tuple[\n        DataGetterProtocol[NumpyPipeType],\n        DataSetterProtocol[NumpyPipeType],\n    ]\n]\n</code></pre><pre><code>iter(\n    lazy: Literal[True],\n    data_mode: Literal[\"numpy\"],\n    iterator_mode: Literal[\"readonly\"] = ...,\n) -&gt; Generator[DataGetterProtocol[NumpyPipeType]]\n</code></pre><pre><code>iter(\n    lazy: Literal[True],\n    data_mode: Literal[\"dask\"],\n    iterator_mode: Literal[\"readwrite\"],\n) -&gt; Generator[\n    tuple[\n        DataGetterProtocol[DaskPipeType],\n        DataSetterProtocol[DaskPipeType],\n    ]\n]\n</code></pre><pre><code>iter(\n    lazy: Literal[True],\n    data_mode: Literal[\"dask\"],\n    iterator_mode: Literal[\"readonly\"] = ...,\n) -&gt; Generator[DataGetterProtocol[DaskPipeType]]\n</code></pre><pre><code>iter(\n    lazy: Literal[False],\n    data_mode: Literal[\"numpy\"],\n    iterator_mode: Literal[\"readwrite\"],\n) -&gt; Generator[\n    tuple[NumpyPipeType, DataSetterProtocol[NumpyPipeType]]\n]\n</code></pre><pre><code>iter(\n    lazy: Literal[False],\n    data_mode: Literal[\"numpy\"],\n    iterator_mode: Literal[\"readonly\"] = ...,\n) -&gt; Generator[NumpyPipeType]\n</code></pre><pre><code>iter(\n    lazy: Literal[False],\n    data_mode: Literal[\"dask\"],\n    iterator_mode: Literal[\"readwrite\"],\n) -&gt; Generator[\n    tuple[DaskPipeType, DataSetterProtocol[DaskPipeType]]\n]\n</code></pre><pre><code>iter(\n    lazy: Literal[False],\n    data_mode: Literal[\"dask\"],\n    iterator_mode: Literal[\"readonly\"] = ...,\n) -&gt; Generator[DaskPipeType]\n</code></pre> <pre><code>iter(\n    lazy: bool = False,\n    data_mode: Literal[\"numpy\", \"dask\"] = \"dask\",\n    iterator_mode: Literal[\n        \"readwrite\", \"readonly\"\n    ] = \"readwrite\",\n) -&gt; Generator\n</code></pre> <p>Create an iterator over the pixels of the ROIs.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def iter(\n    self,\n    lazy: bool = False,\n    data_mode: Literal[\"numpy\", \"dask\"] = \"dask\",\n    iterator_mode: Literal[\"readwrite\", \"readonly\"] = \"readwrite\",\n) -&gt; Generator:\n    \"\"\"Create an iterator over the pixels of the ROIs.\"\"\"\n    if data_mode == \"numpy\":\n        getters = self._numpy_getters_generator()\n        setters = self._numpy_setters_generator()\n    elif data_mode == \"dask\":\n        getters = self._dask_getters_generator()\n        setters = self._dask_setters_generator()\n    else:\n        raise NgioValueError(f\"Invalid mode: {data_mode}\")\n\n    if iterator_mode == \"readonly\":\n        if lazy:\n            return getters\n        else:\n            return (getter() for getter in getters)\n    if lazy:\n        return self._read_and_write_generator(getters, setters)\n    else:\n        gen = self._read_and_write_generator(getters, setters)\n        return ((getter(), setter) for getter, setter in gen)\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.ImageProcessingIterator.iter_as_numpy","title":"iter_as_numpy","text":"<pre><code>iter_as_numpy()\n</code></pre> <p>Create an iterator over the pixels of the ROIs.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def iter_as_numpy(\n    self,\n):\n    \"\"\"Create an iterator over the pixels of the ROIs.\"\"\"\n    return self.iter(lazy=False, data_mode=\"numpy\", iterator_mode=\"readwrite\")\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.ImageProcessingIterator.iter_as_dask","title":"iter_as_dask","text":"<pre><code>iter_as_dask()\n</code></pre> <p>Create an iterator over the pixels of the ROIs.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def iter_as_dask(\n    self,\n):\n    \"\"\"Create an iterator over the pixels of the ROIs.\"\"\"\n    return self.iter(lazy=False, data_mode=\"dask\", iterator_mode=\"readwrite\")\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.ImageProcessingIterator.map_as_numpy","title":"map_as_numpy","text":"<pre><code>map_as_numpy(\n    func: Callable[[NumpyPipeType], NumpyPipeType],\n    mapper: MapperProtocol[NumpyPipeType] | None = None,\n) -&gt; None\n</code></pre> <p>Apply a transformation function to the ROI pixels.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def map_as_numpy(\n    self,\n    func: Callable[[NumpyPipeType], NumpyPipeType],\n    mapper: MapperProtocol[NumpyPipeType] | None = None,\n) -&gt; None:\n    \"\"\"Apply a transformation function to the ROI pixels.\"\"\"\n    if mapper is None:\n        _mapper = BasicMapper[NumpyPipeType]()\n    else:\n        _mapper = mapper\n\n    _mapper(\n        func=func,\n        getters=self._numpy_getters_generator(),\n        setters=self._numpy_setters_generator(),\n    )\n    self.post_consolidate()\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.ImageProcessingIterator.map_as_dask","title":"map_as_dask","text":"<pre><code>map_as_dask(\n    func: Callable[[DaskPipeType], DaskPipeType],\n    mapper: MapperProtocol[DaskPipeType] | None = None,\n) -&gt; None\n</code></pre> <p>Apply a transformation function to the ROI pixels.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def map_as_dask(\n    self,\n    func: Callable[[DaskPipeType], DaskPipeType],\n    mapper: MapperProtocol[DaskPipeType] | None = None,\n) -&gt; None:\n    \"\"\"Apply a transformation function to the ROI pixels.\"\"\"\n    if mapper is None:\n        _mapper = BasicMapper[DaskPipeType]()\n    else:\n        _mapper = mapper\n\n    _mapper(\n        func=func,\n        getters=self._dask_getters_generator(),\n        setters=self._dask_setters_generator(),\n    )\n    self.post_consolidate()\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.ImageProcessingIterator.check_if_regions_overlap","title":"check_if_regions_overlap","text":"<pre><code>check_if_regions_overlap() -&gt; bool\n</code></pre> <p>Check if any of the ROIs overlap logically.</p> <p>If two ROIs cover the same pixel, they are considered to overlap. This does not consider chunking or other storage details.</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if any ROIs overlap. False otherwise.</p> </li> </ul> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def check_if_regions_overlap(self) -&gt; bool:\n    \"\"\"Check if any of the ROIs overlap logically.\n\n    If two ROIs cover the same pixel, they are considered to overlap.\n    This does not consider chunking or other storage details.\n\n    Returns:\n        bool: True if any ROIs overlap. False otherwise.\n    \"\"\"\n    if len(self.rois) &lt; 2:\n        # Less than 2 ROIs cannot overlap\n        return False\n\n    slicing_tuples = (\n        g.slicing_ops.normalized_slicing_tuple\n        for g in self._numpy_getters_generator()\n    )\n    x = check_if_regions_overlap(slicing_tuples)\n    return x\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.ImageProcessingIterator.require_no_regions_overlap","title":"require_no_regions_overlap","text":"<pre><code>require_no_regions_overlap() -&gt; None\n</code></pre> <p>Ensure that the Iterator's ROIs do not overlap.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def require_no_regions_overlap(self) -&gt; None:\n    \"\"\"Ensure that the Iterator's ROIs do not overlap.\"\"\"\n    if self.check_if_regions_overlap():\n        raise NgioValueError(\"Some rois overlap.\")\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.ImageProcessingIterator.check_if_chunks_overlap","title":"check_if_chunks_overlap","text":"<pre><code>check_if_chunks_overlap() -&gt; bool\n</code></pre> <p>Check if any of the ROIs overlap in terms of chunks.</p> <p>If two ROIs cover the same chunk, they are considered to overlap in chunks. This does not consider pixel-level overlaps.</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if any ROIs overlap in chunks, False otherwise.</p> </li> </ul> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def check_if_chunks_overlap(self) -&gt; bool:\n    \"\"\"Check if any of the ROIs overlap in terms of chunks.\n\n    If two ROIs cover the same chunk, they are considered to overlap in chunks.\n    This does not consider pixel-level overlaps.\n\n    Returns:\n        bool: True if any ROIs overlap in chunks, False otherwise.\n    \"\"\"\n    from ngio.io_pipes._ops_slices_utils import check_if_chunks_overlap\n\n    if len(self.rois) &lt; 2:\n        # Less than 2 ROIs cannot overlap\n        return False\n\n    slicing_tuples = (\n        g.slicing_ops.normalized_slicing_tuple\n        for g in self._numpy_getters_generator()\n    )\n    shape = self.ref_image.shape\n    chunks = self.ref_image.chunks\n    return check_if_chunks_overlap(slicing_tuples, shape, chunks)\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.ImageProcessingIterator.require_no_chunks_overlap","title":"require_no_chunks_overlap","text":"<pre><code>require_no_chunks_overlap() -&gt; None\n</code></pre> <p>Ensure that the ROIs do not overlap in terms of chunks.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def require_no_chunks_overlap(self) -&gt; None:\n    \"\"\"Ensure that the ROIs do not overlap in terms of chunks.\"\"\"\n    if self.check_if_chunks_overlap():\n        raise NgioValueError(\"Some rois overlap in chunks.\")\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.ImageProcessingIterator.get_init_kwargs","title":"get_init_kwargs","text":"<pre><code>get_init_kwargs() -&gt; dict\n</code></pre> <p>Return the initialization arguments for the iterator.</p> Source code in <code>ngio/experimental/iterators/_image_processing.py</code> <pre><code>def get_init_kwargs(self) -&gt; dict:\n    \"\"\"Return the initialization arguments for the iterator.\"\"\"\n    return {\n        \"input_image\": self._input,\n        \"output_image\": self._output,\n        \"input_channel_selection\": self._input_channel_selection,\n        \"output_channel_selection\": self._output_channel_selection,\n        \"axes_order\": self._axes_order,\n        \"input_transforms\": self._input_transforms,\n        \"output_transforms\": self._output_transforms,\n    }\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.ImageProcessingIterator.build_numpy_getter","title":"build_numpy_getter","text":"<pre><code>build_numpy_getter(roi: Roi) -&gt; DataGetterProtocol[ndarray]\n</code></pre> Source code in <code>ngio/experimental/iterators/_image_processing.py</code> <pre><code>def build_numpy_getter(self, roi: Roi) -&gt; DataGetterProtocol[np.ndarray]:\n    return NumpyRoiGetter(\n        zarr_array=self._input.zarr_array,\n        dimensions=self._input.dimensions,\n        roi=roi,\n        axes_order=self._axes_order,\n        transforms=self._input_transforms,\n        slicing_dict=self._input_slicing_kwargs,\n    )\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.ImageProcessingIterator.build_numpy_setter","title":"build_numpy_setter","text":"<pre><code>build_numpy_setter(roi: Roi) -&gt; DataSetterProtocol[ndarray]\n</code></pre> Source code in <code>ngio/experimental/iterators/_image_processing.py</code> <pre><code>def build_numpy_setter(self, roi: Roi) -&gt; DataSetterProtocol[np.ndarray]:\n    return NumpyRoiSetter(\n        zarr_array=self._output.zarr_array,\n        dimensions=self._output.dimensions,\n        roi=roi,\n        axes_order=self._axes_order,\n        transforms=self._output_transforms,\n        slicing_dict=self._output_slicing_kwargs,\n    )\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.ImageProcessingIterator.build_dask_getter","title":"build_dask_getter","text":"<pre><code>build_dask_getter(roi: Roi) -&gt; DataGetterProtocol[Array]\n</code></pre> Source code in <code>ngio/experimental/iterators/_image_processing.py</code> <pre><code>def build_dask_getter(self, roi: Roi) -&gt; DataGetterProtocol[da.Array]:\n    return DaskRoiGetter(\n        zarr_array=self._input.zarr_array,\n        dimensions=self._input.dimensions,\n        roi=roi,\n        axes_order=self._axes_order,\n        transforms=self._input_transforms,\n        slicing_dict=self._input_slicing_kwargs,\n    )\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.ImageProcessingIterator.build_dask_setter","title":"build_dask_setter","text":"<pre><code>build_dask_setter(roi: Roi) -&gt; DataSetterProtocol[Array]\n</code></pre> Source code in <code>ngio/experimental/iterators/_image_processing.py</code> <pre><code>def build_dask_setter(self, roi: Roi) -&gt; DataSetterProtocol[da.Array]:\n    return DaskRoiSetter(\n        zarr_array=self._output.zarr_array,\n        dimensions=self._output.dimensions,\n        roi=roi,\n        axes_order=self._axes_order,\n        transforms=self._output_transforms,\n        slicing_dict=self._output_slicing_kwargs,\n    )\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.ImageProcessingIterator.post_consolidate","title":"post_consolidate","text":"<pre><code>post_consolidate()\n</code></pre> Source code in <code>ngio/experimental/iterators/_image_processing.py</code> <pre><code>def post_consolidate(self):\n    self._output.consolidate()\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator","title":"MaskedSegmentationIterator","text":"<pre><code>MaskedSegmentationIterator(\n    input_image: MaskedImage,\n    output_label: Label,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    input_transforms: Sequence[TransformProtocol]\n    | None = None,\n    output_transforms: Sequence[TransformProtocol]\n    | None = None,\n)\n</code></pre> <p>               Bases: <code>SegmentationIterator</code></p> <p>Base class for iterators over ROIs.</p> <p>Initialize the iterator with a ROI table and input/output images.</p> <p>Parameters:</p> <ul> <li> <code>input_image</code>               (<code>MaskedImage</code>)           \u2013            <p>The input image to be used as input for the segmentation.</p> </li> <li> <code>output_label</code>               (<code>Label</code>)           \u2013            <p>The label image where the ROIs will be written.</p> </li> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Optional selection of channels to use for the segmentation.</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional axes order for the segmentation.</p> </li> <li> <code>input_transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional transforms to apply to the input image.</p> </li> <li> <code>output_transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional transforms to apply to the output label.</p> </li> </ul> Source code in <code>ngio/experimental/iterators/_segmentation.py</code> <pre><code>def __init__(\n    self,\n    input_image: MaskedImage,\n    output_label: Label,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    input_transforms: Sequence[TransformProtocol] | None = None,\n    output_transforms: Sequence[TransformProtocol] | None = None,\n) -&gt; None:\n    \"\"\"Initialize the iterator with a ROI table and input/output images.\n\n    Args:\n        input_image (MaskedImage): The input image to be used as input for the\n            segmentation.\n        output_label (Label): The label image where the ROIs will be written.\n        channel_selection (ChannelSlicingInputType): Optional\n            selection of channels to use for the segmentation.\n        axes_order (Sequence[str] | None): Optional axes order for the\n            segmentation.\n        input_transforms (Sequence[TransformProtocol] | None): Optional\n            transforms to apply to the input image.\n        output_transforms (Sequence[TransformProtocol] | None): Optional\n            transforms to apply to the output label.\n    \"\"\"\n    self._input = input_image\n    self._output = output_label\n\n    self._ref_image = input_image\n    self._set_rois(input_image._masking_roi_table.rois())\n\n    # Set iteration parameters\n    self._input_slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self._input, channel_selection=channel_selection, slicing_dict={}\n    )\n    self._channel_selection = channel_selection\n    self._axes_order = axes_order\n    self._input_transforms = input_transforms\n    self._output_transforms = output_transforms\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator.rois","title":"rois  <code>property</code>","text":"<pre><code>rois: list[Roi]\n</code></pre> <p>Get the list of ROIs for the iterator.</p>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator.ref_image","title":"ref_image  <code>property</code>","text":"<pre><code>ref_image: AbstractImage\n</code></pre> <p>Get the reference image for the iterator.</p>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator.grid","title":"grid","text":"<pre><code>grid(\n    size_x: int | None = None,\n    size_y: int | None = None,\n    size_z: int | None = None,\n    size_t: int | None = None,\n    stride_x: int | None = None,\n    stride_y: int | None = None,\n    stride_z: int | None = None,\n    stride_t: int | None = None,\n    base_name: str = \"\",\n) -&gt; Self\n</code></pre> <p>Create a grid of ROIs based on the input image dimensions.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def grid(\n    self,\n    size_x: int | None = None,\n    size_y: int | None = None,\n    size_z: int | None = None,\n    size_t: int | None = None,\n    stride_x: int | None = None,\n    stride_y: int | None = None,\n    stride_z: int | None = None,\n    stride_t: int | None = None,\n    base_name: str = \"\",\n) -&gt; Self:\n    \"\"\"Create a grid of ROIs based on the input image dimensions.\"\"\"\n    rois = grid(\n        rois=self.rois,\n        ref_image=self.ref_image,\n        size_x=size_x,\n        size_y=size_y,\n        size_z=size_z,\n        size_t=size_t,\n        stride_x=stride_x,\n        stride_y=stride_y,\n        stride_z=stride_z,\n        stride_t=stride_t,\n        base_name=base_name,\n    )\n    return self._new_from_rois(rois)\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator.by_yx","title":"by_yx","text":"<pre><code>by_yx() -&gt; Self\n</code></pre> <p>Return a new iterator that iterates over ROIs by YX coordinates.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def by_yx(self) -&gt; Self:\n    \"\"\"Return a new iterator that iterates over ROIs by YX coordinates.\"\"\"\n    rois = by_yx(self.rois, self.ref_image)\n    return self._new_from_rois(rois)\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator.by_zyx","title":"by_zyx","text":"<pre><code>by_zyx(strict: bool = True) -&gt; Self\n</code></pre> <p>Return a new iterator that iterates over ROIs by ZYX coordinates.</p> <p>Parameters:</p> <ul> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, only iterate over ZYX if a Z axis is present and not of size 1.</p> </li> </ul> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def by_zyx(self, strict: bool = True) -&gt; Self:\n    \"\"\"Return a new iterator that iterates over ROIs by ZYX coordinates.\n\n    Args:\n        strict (bool): If True, only iterate over ZYX if a Z axis\n            is present and not of size 1.\n\n    \"\"\"\n    rois = by_zyx(self.rois, self.ref_image, strict=strict)\n    return self._new_from_rois(rois)\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator.by_chunks","title":"by_chunks","text":"<pre><code>by_chunks(overlap_xy: int = 0, overlap_z: int = 0) -&gt; Self\n</code></pre> <p>Return a new iterator that iterates over ROIs by chunks.</p> <p>Parameters:</p> <ul> <li> <code>overlap_xy</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Overlap in XY dimensions.</p> </li> <li> <code>overlap_z</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Overlap in Z dimension.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SegmentationIterator</code> (              <code>Self</code> )          \u2013            <p>A new iterator with chunked ROIs.</p> </li> </ul> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def by_chunks(self, overlap_xy: int = 0, overlap_z: int = 0) -&gt; Self:\n    \"\"\"Return a new iterator that iterates over ROIs by chunks.\n\n    Args:\n        overlap_xy (int): Overlap in XY dimensions.\n        overlap_z (int): Overlap in Z dimension.\n\n    Returns:\n        SegmentationIterator: A new iterator with chunked ROIs.\n    \"\"\"\n    rois = by_chunks(\n        self.rois, self.ref_image, overlap_xy=overlap_xy, overlap_z=overlap_z\n    )\n    return self._new_from_rois(rois)\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator.product","title":"product","text":"<pre><code>product(other: list[Roi] | GenericRoiTable) -&gt; Self\n</code></pre> <p>Cartesian product of the current ROIs with an arbitrary list of ROIs.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def product(self, other: list[Roi] | GenericRoiTable) -&gt; Self:\n    \"\"\"Cartesian product of the current ROIs with an arbitrary list of ROIs.\"\"\"\n    if isinstance(other, GenericRoiTable):\n        other = other.rois()\n    rois = rois_product(self.rois, other)\n    return self._new_from_rois(rois)\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator.iter","title":"iter","text":"<pre><code>iter(\n    lazy: Literal[True],\n    data_mode: Literal[\"numpy\"],\n    iterator_mode: Literal[\"readwrite\"],\n) -&gt; Generator[\n    tuple[\n        DataGetterProtocol[NumpyPipeType],\n        DataSetterProtocol[NumpyPipeType],\n    ]\n]\n</code></pre><pre><code>iter(\n    lazy: Literal[True],\n    data_mode: Literal[\"numpy\"],\n    iterator_mode: Literal[\"readonly\"] = ...,\n) -&gt; Generator[DataGetterProtocol[NumpyPipeType]]\n</code></pre><pre><code>iter(\n    lazy: Literal[True],\n    data_mode: Literal[\"dask\"],\n    iterator_mode: Literal[\"readwrite\"],\n) -&gt; Generator[\n    tuple[\n        DataGetterProtocol[DaskPipeType],\n        DataSetterProtocol[DaskPipeType],\n    ]\n]\n</code></pre><pre><code>iter(\n    lazy: Literal[True],\n    data_mode: Literal[\"dask\"],\n    iterator_mode: Literal[\"readonly\"] = ...,\n) -&gt; Generator[DataGetterProtocol[DaskPipeType]]\n</code></pre><pre><code>iter(\n    lazy: Literal[False],\n    data_mode: Literal[\"numpy\"],\n    iterator_mode: Literal[\"readwrite\"],\n) -&gt; Generator[\n    tuple[NumpyPipeType, DataSetterProtocol[NumpyPipeType]]\n]\n</code></pre><pre><code>iter(\n    lazy: Literal[False],\n    data_mode: Literal[\"numpy\"],\n    iterator_mode: Literal[\"readonly\"] = ...,\n) -&gt; Generator[NumpyPipeType]\n</code></pre><pre><code>iter(\n    lazy: Literal[False],\n    data_mode: Literal[\"dask\"],\n    iterator_mode: Literal[\"readwrite\"],\n) -&gt; Generator[\n    tuple[DaskPipeType, DataSetterProtocol[DaskPipeType]]\n]\n</code></pre><pre><code>iter(\n    lazy: Literal[False],\n    data_mode: Literal[\"dask\"],\n    iterator_mode: Literal[\"readonly\"] = ...,\n) -&gt; Generator[DaskPipeType]\n</code></pre> <pre><code>iter(\n    lazy: bool = False,\n    data_mode: Literal[\"numpy\", \"dask\"] = \"dask\",\n    iterator_mode: Literal[\n        \"readwrite\", \"readonly\"\n    ] = \"readwrite\",\n) -&gt; Generator\n</code></pre> <p>Create an iterator over the pixels of the ROIs.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def iter(\n    self,\n    lazy: bool = False,\n    data_mode: Literal[\"numpy\", \"dask\"] = \"dask\",\n    iterator_mode: Literal[\"readwrite\", \"readonly\"] = \"readwrite\",\n) -&gt; Generator:\n    \"\"\"Create an iterator over the pixels of the ROIs.\"\"\"\n    if data_mode == \"numpy\":\n        getters = self._numpy_getters_generator()\n        setters = self._numpy_setters_generator()\n    elif data_mode == \"dask\":\n        getters = self._dask_getters_generator()\n        setters = self._dask_setters_generator()\n    else:\n        raise NgioValueError(f\"Invalid mode: {data_mode}\")\n\n    if iterator_mode == \"readonly\":\n        if lazy:\n            return getters\n        else:\n            return (getter() for getter in getters)\n    if lazy:\n        return self._read_and_write_generator(getters, setters)\n    else:\n        gen = self._read_and_write_generator(getters, setters)\n        return ((getter(), setter) for getter, setter in gen)\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator.iter_as_numpy","title":"iter_as_numpy","text":"<pre><code>iter_as_numpy()\n</code></pre> <p>Create an iterator over the pixels of the ROIs.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def iter_as_numpy(\n    self,\n):\n    \"\"\"Create an iterator over the pixels of the ROIs.\"\"\"\n    return self.iter(lazy=False, data_mode=\"numpy\", iterator_mode=\"readwrite\")\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator.iter_as_dask","title":"iter_as_dask","text":"<pre><code>iter_as_dask()\n</code></pre> <p>Create an iterator over the pixels of the ROIs.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def iter_as_dask(\n    self,\n):\n    \"\"\"Create an iterator over the pixels of the ROIs.\"\"\"\n    return self.iter(lazy=False, data_mode=\"dask\", iterator_mode=\"readwrite\")\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator.map_as_numpy","title":"map_as_numpy","text":"<pre><code>map_as_numpy(\n    func: Callable[[NumpyPipeType], NumpyPipeType],\n    mapper: MapperProtocol[NumpyPipeType] | None = None,\n) -&gt; None\n</code></pre> <p>Apply a transformation function to the ROI pixels.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def map_as_numpy(\n    self,\n    func: Callable[[NumpyPipeType], NumpyPipeType],\n    mapper: MapperProtocol[NumpyPipeType] | None = None,\n) -&gt; None:\n    \"\"\"Apply a transformation function to the ROI pixels.\"\"\"\n    if mapper is None:\n        _mapper = BasicMapper[NumpyPipeType]()\n    else:\n        _mapper = mapper\n\n    _mapper(\n        func=func,\n        getters=self._numpy_getters_generator(),\n        setters=self._numpy_setters_generator(),\n    )\n    self.post_consolidate()\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator.map_as_dask","title":"map_as_dask","text":"<pre><code>map_as_dask(\n    func: Callable[[DaskPipeType], DaskPipeType],\n    mapper: MapperProtocol[DaskPipeType] | None = None,\n) -&gt; None\n</code></pre> <p>Apply a transformation function to the ROI pixels.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def map_as_dask(\n    self,\n    func: Callable[[DaskPipeType], DaskPipeType],\n    mapper: MapperProtocol[DaskPipeType] | None = None,\n) -&gt; None:\n    \"\"\"Apply a transformation function to the ROI pixels.\"\"\"\n    if mapper is None:\n        _mapper = BasicMapper[DaskPipeType]()\n    else:\n        _mapper = mapper\n\n    _mapper(\n        func=func,\n        getters=self._dask_getters_generator(),\n        setters=self._dask_setters_generator(),\n    )\n    self.post_consolidate()\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator.check_if_regions_overlap","title":"check_if_regions_overlap","text":"<pre><code>check_if_regions_overlap() -&gt; bool\n</code></pre> <p>Check if any of the ROIs overlap logically.</p> <p>If two ROIs cover the same pixel, they are considered to overlap. This does not consider chunking or other storage details.</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if any ROIs overlap. False otherwise.</p> </li> </ul> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def check_if_regions_overlap(self) -&gt; bool:\n    \"\"\"Check if any of the ROIs overlap logically.\n\n    If two ROIs cover the same pixel, they are considered to overlap.\n    This does not consider chunking or other storage details.\n\n    Returns:\n        bool: True if any ROIs overlap. False otherwise.\n    \"\"\"\n    if len(self.rois) &lt; 2:\n        # Less than 2 ROIs cannot overlap\n        return False\n\n    slicing_tuples = (\n        g.slicing_ops.normalized_slicing_tuple\n        for g in self._numpy_getters_generator()\n    )\n    x = check_if_regions_overlap(slicing_tuples)\n    return x\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator.require_no_regions_overlap","title":"require_no_regions_overlap","text":"<pre><code>require_no_regions_overlap() -&gt; None\n</code></pre> <p>Ensure that the Iterator's ROIs do not overlap.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def require_no_regions_overlap(self) -&gt; None:\n    \"\"\"Ensure that the Iterator's ROIs do not overlap.\"\"\"\n    if self.check_if_regions_overlap():\n        raise NgioValueError(\"Some rois overlap.\")\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator.check_if_chunks_overlap","title":"check_if_chunks_overlap","text":"<pre><code>check_if_chunks_overlap() -&gt; bool\n</code></pre> <p>Check if any of the ROIs overlap in terms of chunks.</p> <p>If two ROIs cover the same chunk, they are considered to overlap in chunks. This does not consider pixel-level overlaps.</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if any ROIs overlap in chunks, False otherwise.</p> </li> </ul> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def check_if_chunks_overlap(self) -&gt; bool:\n    \"\"\"Check if any of the ROIs overlap in terms of chunks.\n\n    If two ROIs cover the same chunk, they are considered to overlap in chunks.\n    This does not consider pixel-level overlaps.\n\n    Returns:\n        bool: True if any ROIs overlap in chunks, False otherwise.\n    \"\"\"\n    from ngio.io_pipes._ops_slices_utils import check_if_chunks_overlap\n\n    if len(self.rois) &lt; 2:\n        # Less than 2 ROIs cannot overlap\n        return False\n\n    slicing_tuples = (\n        g.slicing_ops.normalized_slicing_tuple\n        for g in self._numpy_getters_generator()\n    )\n    shape = self.ref_image.shape\n    chunks = self.ref_image.chunks\n    return check_if_chunks_overlap(slicing_tuples, shape, chunks)\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator.require_no_chunks_overlap","title":"require_no_chunks_overlap","text":"<pre><code>require_no_chunks_overlap() -&gt; None\n</code></pre> <p>Ensure that the ROIs do not overlap in terms of chunks.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def require_no_chunks_overlap(self) -&gt; None:\n    \"\"\"Ensure that the ROIs do not overlap in terms of chunks.\"\"\"\n    if self.check_if_chunks_overlap():\n        raise NgioValueError(\"Some rois overlap in chunks.\")\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator.get_init_kwargs","title":"get_init_kwargs","text":"<pre><code>get_init_kwargs() -&gt; dict\n</code></pre> <p>Return the initialization arguments for the iterator.</p> Source code in <code>ngio/experimental/iterators/_segmentation.py</code> <pre><code>def get_init_kwargs(self) -&gt; dict:\n    \"\"\"Return the initialization arguments for the iterator.\"\"\"\n    return {\n        \"input_image\": self._input,\n        \"output_label\": self._output,\n        \"channel_selection\": self._channel_selection,\n        \"axes_order\": self._axes_order,\n        \"input_transforms\": self._input_transforms,\n        \"output_transforms\": self._output_transforms,\n    }\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator.build_numpy_getter","title":"build_numpy_getter","text":"<pre><code>build_numpy_getter(roi: Roi)\n</code></pre> Source code in <code>ngio/experimental/iterators/_segmentation.py</code> <pre><code>def build_numpy_getter(self, roi: Roi):\n    return NumpyGetterMasked(\n        zarr_array=self._input.zarr_array,\n        dimensions=self._input.dimensions,\n        roi=roi,\n        label_zarr_array=self._input._label.zarr_array,\n        label_dimensions=self._input._label.dimensions,\n        axes_order=self._axes_order,\n        transforms=self._input_transforms,\n        slicing_dict=self._input_slicing_kwargs,\n    )\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator.build_numpy_setter","title":"build_numpy_setter","text":"<pre><code>build_numpy_setter(roi: Roi)\n</code></pre> Source code in <code>ngio/experimental/iterators/_segmentation.py</code> <pre><code>def build_numpy_setter(self, roi: Roi):\n    return NumpySetterMasked(\n        roi=roi,\n        zarr_array=self._output.zarr_array,\n        dimensions=self._output.dimensions,\n        label_zarr_array=self._input._label.zarr_array,\n        label_dimensions=self._input._label.dimensions,\n        axes_order=self._axes_order,\n        transforms=self._output_transforms,\n        remove_channel_selection=True,\n    )\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator.build_dask_getter","title":"build_dask_getter","text":"<pre><code>build_dask_getter(roi: Roi)\n</code></pre> Source code in <code>ngio/experimental/iterators/_segmentation.py</code> <pre><code>def build_dask_getter(self, roi: Roi):\n    return DaskGetterMasked(\n        roi=roi,\n        zarr_array=self._input.zarr_array,\n        dimensions=self._input.dimensions,\n        label_zarr_array=self._input._label.zarr_array,\n        label_dimensions=self._input._label.dimensions,\n        axes_order=self._axes_order,\n        transforms=self._input_transforms,\n        slicing_dict=self._input_slicing_kwargs,\n    )\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator.build_dask_setter","title":"build_dask_setter","text":"<pre><code>build_dask_setter(roi: Roi)\n</code></pre> Source code in <code>ngio/experimental/iterators/_segmentation.py</code> <pre><code>def build_dask_setter(self, roi: Roi):\n    return DaskSetterMasked(\n        roi=roi,\n        zarr_array=self._output.zarr_array,\n        dimensions=self._output.dimensions,\n        label_zarr_array=self._input._label.zarr_array,\n        label_dimensions=self._input._label.dimensions,\n        axes_order=self._axes_order,\n        transforms=self._output_transforms,\n        remove_channel_selection=True,\n    )\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.MaskedSegmentationIterator.post_consolidate","title":"post_consolidate","text":"<pre><code>post_consolidate()\n</code></pre> Source code in <code>ngio/experimental/iterators/_segmentation.py</code> <pre><code>def post_consolidate(self):\n    self._output.consolidate()\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.SegmentationIterator","title":"SegmentationIterator","text":"<pre><code>SegmentationIterator(\n    input_image: Image,\n    output_label: Label,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    input_transforms: Sequence[TransformProtocol]\n    | None = None,\n    output_transforms: Sequence[TransformProtocol]\n    | None = None,\n)\n</code></pre> <p>               Bases: <code>AbstractIteratorBuilder[ndarray, Array]</code></p> <p>Base class for iterators over ROIs.</p> <p>Initialize the iterator with a ROI table and input/output images.</p> <p>Parameters:</p> <ul> <li> <code>input_image</code>               (<code>Image</code>)           \u2013            <p>The input image to be used as input for the segmentation.</p> </li> <li> <code>output_label</code>               (<code>Label</code>)           \u2013            <p>The label image where the ROIs will be written.</p> </li> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Optional selection of channels to use for the segmentation.</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional axes order for the segmentation.</p> </li> <li> <code>input_transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional transforms to apply to the input image.</p> </li> <li> <code>output_transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional transforms to apply to the output label.</p> </li> </ul> Source code in <code>ngio/experimental/iterators/_segmentation.py</code> <pre><code>def __init__(\n    self,\n    input_image: Image,\n    output_label: Label,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    input_transforms: Sequence[TransformProtocol] | None = None,\n    output_transforms: Sequence[TransformProtocol] | None = None,\n) -&gt; None:\n    \"\"\"Initialize the iterator with a ROI table and input/output images.\n\n    Args:\n        input_image (Image): The input image to be used as input for the\n            segmentation.\n        output_label (Label): The label image where the ROIs will be written.\n        channel_selection (ChannelSlicingInputType): Optional\n            selection of channels to use for the segmentation.\n        axes_order (Sequence[str] | None): Optional axes order for the\n            segmentation.\n        input_transforms (Sequence[TransformProtocol] | None): Optional\n            transforms to apply to the input image.\n        output_transforms (Sequence[TransformProtocol] | None): Optional\n            transforms to apply to the output label.\n    \"\"\"\n    self._input = input_image\n    self._output = output_label\n    self._ref_image = input_image\n    self._rois = input_image.build_image_roi_table(name=None).rois()\n\n    # Set iteration parameters\n    self._input_slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self._input, channel_selection=channel_selection, slicing_dict={}\n    )\n    self._channel_selection = channel_selection\n    self._axes_order = axes_order\n    self._input_transforms = input_transforms\n    self._output_transforms = output_transforms\n\n    self._input.require_dimensions_match(self._output, allow_singleton=False)\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.SegmentationIterator.rois","title":"rois  <code>property</code>","text":"<pre><code>rois: list[Roi]\n</code></pre> <p>Get the list of ROIs for the iterator.</p>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.SegmentationIterator.ref_image","title":"ref_image  <code>property</code>","text":"<pre><code>ref_image: AbstractImage\n</code></pre> <p>Get the reference image for the iterator.</p>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.SegmentationIterator.grid","title":"grid","text":"<pre><code>grid(\n    size_x: int | None = None,\n    size_y: int | None = None,\n    size_z: int | None = None,\n    size_t: int | None = None,\n    stride_x: int | None = None,\n    stride_y: int | None = None,\n    stride_z: int | None = None,\n    stride_t: int | None = None,\n    base_name: str = \"\",\n) -&gt; Self\n</code></pre> <p>Create a grid of ROIs based on the input image dimensions.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def grid(\n    self,\n    size_x: int | None = None,\n    size_y: int | None = None,\n    size_z: int | None = None,\n    size_t: int | None = None,\n    stride_x: int | None = None,\n    stride_y: int | None = None,\n    stride_z: int | None = None,\n    stride_t: int | None = None,\n    base_name: str = \"\",\n) -&gt; Self:\n    \"\"\"Create a grid of ROIs based on the input image dimensions.\"\"\"\n    rois = grid(\n        rois=self.rois,\n        ref_image=self.ref_image,\n        size_x=size_x,\n        size_y=size_y,\n        size_z=size_z,\n        size_t=size_t,\n        stride_x=stride_x,\n        stride_y=stride_y,\n        stride_z=stride_z,\n        stride_t=stride_t,\n        base_name=base_name,\n    )\n    return self._new_from_rois(rois)\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.SegmentationIterator.by_yx","title":"by_yx","text":"<pre><code>by_yx() -&gt; Self\n</code></pre> <p>Return a new iterator that iterates over ROIs by YX coordinates.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def by_yx(self) -&gt; Self:\n    \"\"\"Return a new iterator that iterates over ROIs by YX coordinates.\"\"\"\n    rois = by_yx(self.rois, self.ref_image)\n    return self._new_from_rois(rois)\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.SegmentationIterator.by_zyx","title":"by_zyx","text":"<pre><code>by_zyx(strict: bool = True) -&gt; Self\n</code></pre> <p>Return a new iterator that iterates over ROIs by ZYX coordinates.</p> <p>Parameters:</p> <ul> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, only iterate over ZYX if a Z axis is present and not of size 1.</p> </li> </ul> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def by_zyx(self, strict: bool = True) -&gt; Self:\n    \"\"\"Return a new iterator that iterates over ROIs by ZYX coordinates.\n\n    Args:\n        strict (bool): If True, only iterate over ZYX if a Z axis\n            is present and not of size 1.\n\n    \"\"\"\n    rois = by_zyx(self.rois, self.ref_image, strict=strict)\n    return self._new_from_rois(rois)\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.SegmentationIterator.by_chunks","title":"by_chunks","text":"<pre><code>by_chunks(overlap_xy: int = 0, overlap_z: int = 0) -&gt; Self\n</code></pre> <p>Return a new iterator that iterates over ROIs by chunks.</p> <p>Parameters:</p> <ul> <li> <code>overlap_xy</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Overlap in XY dimensions.</p> </li> <li> <code>overlap_z</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Overlap in Z dimension.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SegmentationIterator</code> (              <code>Self</code> )          \u2013            <p>A new iterator with chunked ROIs.</p> </li> </ul> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def by_chunks(self, overlap_xy: int = 0, overlap_z: int = 0) -&gt; Self:\n    \"\"\"Return a new iterator that iterates over ROIs by chunks.\n\n    Args:\n        overlap_xy (int): Overlap in XY dimensions.\n        overlap_z (int): Overlap in Z dimension.\n\n    Returns:\n        SegmentationIterator: A new iterator with chunked ROIs.\n    \"\"\"\n    rois = by_chunks(\n        self.rois, self.ref_image, overlap_xy=overlap_xy, overlap_z=overlap_z\n    )\n    return self._new_from_rois(rois)\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.SegmentationIterator.product","title":"product","text":"<pre><code>product(other: list[Roi] | GenericRoiTable) -&gt; Self\n</code></pre> <p>Cartesian product of the current ROIs with an arbitrary list of ROIs.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def product(self, other: list[Roi] | GenericRoiTable) -&gt; Self:\n    \"\"\"Cartesian product of the current ROIs with an arbitrary list of ROIs.\"\"\"\n    if isinstance(other, GenericRoiTable):\n        other = other.rois()\n    rois = rois_product(self.rois, other)\n    return self._new_from_rois(rois)\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.SegmentationIterator.iter","title":"iter","text":"<pre><code>iter(\n    lazy: Literal[True],\n    data_mode: Literal[\"numpy\"],\n    iterator_mode: Literal[\"readwrite\"],\n) -&gt; Generator[\n    tuple[\n        DataGetterProtocol[NumpyPipeType],\n        DataSetterProtocol[NumpyPipeType],\n    ]\n]\n</code></pre><pre><code>iter(\n    lazy: Literal[True],\n    data_mode: Literal[\"numpy\"],\n    iterator_mode: Literal[\"readonly\"] = ...,\n) -&gt; Generator[DataGetterProtocol[NumpyPipeType]]\n</code></pre><pre><code>iter(\n    lazy: Literal[True],\n    data_mode: Literal[\"dask\"],\n    iterator_mode: Literal[\"readwrite\"],\n) -&gt; Generator[\n    tuple[\n        DataGetterProtocol[DaskPipeType],\n        DataSetterProtocol[DaskPipeType],\n    ]\n]\n</code></pre><pre><code>iter(\n    lazy: Literal[True],\n    data_mode: Literal[\"dask\"],\n    iterator_mode: Literal[\"readonly\"] = ...,\n) -&gt; Generator[DataGetterProtocol[DaskPipeType]]\n</code></pre><pre><code>iter(\n    lazy: Literal[False],\n    data_mode: Literal[\"numpy\"],\n    iterator_mode: Literal[\"readwrite\"],\n) -&gt; Generator[\n    tuple[NumpyPipeType, DataSetterProtocol[NumpyPipeType]]\n]\n</code></pre><pre><code>iter(\n    lazy: Literal[False],\n    data_mode: Literal[\"numpy\"],\n    iterator_mode: Literal[\"readonly\"] = ...,\n) -&gt; Generator[NumpyPipeType]\n</code></pre><pre><code>iter(\n    lazy: Literal[False],\n    data_mode: Literal[\"dask\"],\n    iterator_mode: Literal[\"readwrite\"],\n) -&gt; Generator[\n    tuple[DaskPipeType, DataSetterProtocol[DaskPipeType]]\n]\n</code></pre><pre><code>iter(\n    lazy: Literal[False],\n    data_mode: Literal[\"dask\"],\n    iterator_mode: Literal[\"readonly\"] = ...,\n) -&gt; Generator[DaskPipeType]\n</code></pre> <pre><code>iter(\n    lazy: bool = False,\n    data_mode: Literal[\"numpy\", \"dask\"] = \"dask\",\n    iterator_mode: Literal[\n        \"readwrite\", \"readonly\"\n    ] = \"readwrite\",\n) -&gt; Generator\n</code></pre> <p>Create an iterator over the pixels of the ROIs.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def iter(\n    self,\n    lazy: bool = False,\n    data_mode: Literal[\"numpy\", \"dask\"] = \"dask\",\n    iterator_mode: Literal[\"readwrite\", \"readonly\"] = \"readwrite\",\n) -&gt; Generator:\n    \"\"\"Create an iterator over the pixels of the ROIs.\"\"\"\n    if data_mode == \"numpy\":\n        getters = self._numpy_getters_generator()\n        setters = self._numpy_setters_generator()\n    elif data_mode == \"dask\":\n        getters = self._dask_getters_generator()\n        setters = self._dask_setters_generator()\n    else:\n        raise NgioValueError(f\"Invalid mode: {data_mode}\")\n\n    if iterator_mode == \"readonly\":\n        if lazy:\n            return getters\n        else:\n            return (getter() for getter in getters)\n    if lazy:\n        return self._read_and_write_generator(getters, setters)\n    else:\n        gen = self._read_and_write_generator(getters, setters)\n        return ((getter(), setter) for getter, setter in gen)\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.SegmentationIterator.iter_as_numpy","title":"iter_as_numpy","text":"<pre><code>iter_as_numpy()\n</code></pre> <p>Create an iterator over the pixels of the ROIs.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def iter_as_numpy(\n    self,\n):\n    \"\"\"Create an iterator over the pixels of the ROIs.\"\"\"\n    return self.iter(lazy=False, data_mode=\"numpy\", iterator_mode=\"readwrite\")\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.SegmentationIterator.iter_as_dask","title":"iter_as_dask","text":"<pre><code>iter_as_dask()\n</code></pre> <p>Create an iterator over the pixels of the ROIs.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def iter_as_dask(\n    self,\n):\n    \"\"\"Create an iterator over the pixels of the ROIs.\"\"\"\n    return self.iter(lazy=False, data_mode=\"dask\", iterator_mode=\"readwrite\")\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.SegmentationIterator.map_as_numpy","title":"map_as_numpy","text":"<pre><code>map_as_numpy(\n    func: Callable[[NumpyPipeType], NumpyPipeType],\n    mapper: MapperProtocol[NumpyPipeType] | None = None,\n) -&gt; None\n</code></pre> <p>Apply a transformation function to the ROI pixels.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def map_as_numpy(\n    self,\n    func: Callable[[NumpyPipeType], NumpyPipeType],\n    mapper: MapperProtocol[NumpyPipeType] | None = None,\n) -&gt; None:\n    \"\"\"Apply a transformation function to the ROI pixels.\"\"\"\n    if mapper is None:\n        _mapper = BasicMapper[NumpyPipeType]()\n    else:\n        _mapper = mapper\n\n    _mapper(\n        func=func,\n        getters=self._numpy_getters_generator(),\n        setters=self._numpy_setters_generator(),\n    )\n    self.post_consolidate()\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.SegmentationIterator.map_as_dask","title":"map_as_dask","text":"<pre><code>map_as_dask(\n    func: Callable[[DaskPipeType], DaskPipeType],\n    mapper: MapperProtocol[DaskPipeType] | None = None,\n) -&gt; None\n</code></pre> <p>Apply a transformation function to the ROI pixels.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def map_as_dask(\n    self,\n    func: Callable[[DaskPipeType], DaskPipeType],\n    mapper: MapperProtocol[DaskPipeType] | None = None,\n) -&gt; None:\n    \"\"\"Apply a transformation function to the ROI pixels.\"\"\"\n    if mapper is None:\n        _mapper = BasicMapper[DaskPipeType]()\n    else:\n        _mapper = mapper\n\n    _mapper(\n        func=func,\n        getters=self._dask_getters_generator(),\n        setters=self._dask_setters_generator(),\n    )\n    self.post_consolidate()\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.SegmentationIterator.check_if_regions_overlap","title":"check_if_regions_overlap","text":"<pre><code>check_if_regions_overlap() -&gt; bool\n</code></pre> <p>Check if any of the ROIs overlap logically.</p> <p>If two ROIs cover the same pixel, they are considered to overlap. This does not consider chunking or other storage details.</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if any ROIs overlap. False otherwise.</p> </li> </ul> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def check_if_regions_overlap(self) -&gt; bool:\n    \"\"\"Check if any of the ROIs overlap logically.\n\n    If two ROIs cover the same pixel, they are considered to overlap.\n    This does not consider chunking or other storage details.\n\n    Returns:\n        bool: True if any ROIs overlap. False otherwise.\n    \"\"\"\n    if len(self.rois) &lt; 2:\n        # Less than 2 ROIs cannot overlap\n        return False\n\n    slicing_tuples = (\n        g.slicing_ops.normalized_slicing_tuple\n        for g in self._numpy_getters_generator()\n    )\n    x = check_if_regions_overlap(slicing_tuples)\n    return x\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.SegmentationIterator.require_no_regions_overlap","title":"require_no_regions_overlap","text":"<pre><code>require_no_regions_overlap() -&gt; None\n</code></pre> <p>Ensure that the Iterator's ROIs do not overlap.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def require_no_regions_overlap(self) -&gt; None:\n    \"\"\"Ensure that the Iterator's ROIs do not overlap.\"\"\"\n    if self.check_if_regions_overlap():\n        raise NgioValueError(\"Some rois overlap.\")\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.SegmentationIterator.check_if_chunks_overlap","title":"check_if_chunks_overlap","text":"<pre><code>check_if_chunks_overlap() -&gt; bool\n</code></pre> <p>Check if any of the ROIs overlap in terms of chunks.</p> <p>If two ROIs cover the same chunk, they are considered to overlap in chunks. This does not consider pixel-level overlaps.</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if any ROIs overlap in chunks, False otherwise.</p> </li> </ul> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def check_if_chunks_overlap(self) -&gt; bool:\n    \"\"\"Check if any of the ROIs overlap in terms of chunks.\n\n    If two ROIs cover the same chunk, they are considered to overlap in chunks.\n    This does not consider pixel-level overlaps.\n\n    Returns:\n        bool: True if any ROIs overlap in chunks, False otherwise.\n    \"\"\"\n    from ngio.io_pipes._ops_slices_utils import check_if_chunks_overlap\n\n    if len(self.rois) &lt; 2:\n        # Less than 2 ROIs cannot overlap\n        return False\n\n    slicing_tuples = (\n        g.slicing_ops.normalized_slicing_tuple\n        for g in self._numpy_getters_generator()\n    )\n    shape = self.ref_image.shape\n    chunks = self.ref_image.chunks\n    return check_if_chunks_overlap(slicing_tuples, shape, chunks)\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.SegmentationIterator.require_no_chunks_overlap","title":"require_no_chunks_overlap","text":"<pre><code>require_no_chunks_overlap() -&gt; None\n</code></pre> <p>Ensure that the ROIs do not overlap in terms of chunks.</p> Source code in <code>ngio/experimental/iterators/_abstract_iterator.py</code> <pre><code>def require_no_chunks_overlap(self) -&gt; None:\n    \"\"\"Ensure that the ROIs do not overlap in terms of chunks.\"\"\"\n    if self.check_if_chunks_overlap():\n        raise NgioValueError(\"Some rois overlap in chunks.\")\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.SegmentationIterator.get_init_kwargs","title":"get_init_kwargs","text":"<pre><code>get_init_kwargs() -&gt; dict\n</code></pre> <p>Return the initialization arguments for the iterator.</p> Source code in <code>ngio/experimental/iterators/_segmentation.py</code> <pre><code>def get_init_kwargs(self) -&gt; dict:\n    \"\"\"Return the initialization arguments for the iterator.\"\"\"\n    return {\n        \"input_image\": self._input,\n        \"output_label\": self._output,\n        \"channel_selection\": self._channel_selection,\n        \"axes_order\": self._axes_order,\n        \"input_transforms\": self._input_transforms,\n        \"output_transforms\": self._output_transforms,\n    }\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.SegmentationIterator.build_numpy_getter","title":"build_numpy_getter","text":"<pre><code>build_numpy_getter(roi: Roi) -&gt; DataGetterProtocol[ndarray]\n</code></pre> Source code in <code>ngio/experimental/iterators/_segmentation.py</code> <pre><code>def build_numpy_getter(self, roi: Roi) -&gt; DataGetterProtocol[np.ndarray]:\n    return NumpyRoiGetter(\n        zarr_array=self._input.zarr_array,\n        dimensions=self._input.dimensions,\n        roi=roi,\n        axes_order=self._axes_order,\n        transforms=self._input_transforms,\n        slicing_dict=self._input_slicing_kwargs,\n    )\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.SegmentationIterator.build_numpy_setter","title":"build_numpy_setter","text":"<pre><code>build_numpy_setter(roi: Roi) -&gt; DataSetterProtocol[ndarray]\n</code></pre> Source code in <code>ngio/experimental/iterators/_segmentation.py</code> <pre><code>def build_numpy_setter(self, roi: Roi) -&gt; DataSetterProtocol[np.ndarray]:\n    return NumpyRoiSetter(\n        zarr_array=self._output.zarr_array,\n        dimensions=self._output.dimensions,\n        roi=roi,\n        axes_order=self._axes_order,\n        transforms=self._output_transforms,\n        remove_channel_selection=True,\n    )\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.SegmentationIterator.build_dask_getter","title":"build_dask_getter","text":"<pre><code>build_dask_getter(roi: Roi) -&gt; DataGetterProtocol[Array]\n</code></pre> Source code in <code>ngio/experimental/iterators/_segmentation.py</code> <pre><code>def build_dask_getter(self, roi: Roi) -&gt; DataGetterProtocol[da.Array]:\n    return DaskRoiGetter(\n        zarr_array=self._input.zarr_array,\n        dimensions=self._input.dimensions,\n        roi=roi,\n        axes_order=self._axes_order,\n        transforms=self._input_transforms,\n        slicing_dict=self._input_slicing_kwargs,\n    )\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.SegmentationIterator.build_dask_setter","title":"build_dask_setter","text":"<pre><code>build_dask_setter(roi: Roi) -&gt; DataSetterProtocol[Array]\n</code></pre> Source code in <code>ngio/experimental/iterators/_segmentation.py</code> <pre><code>def build_dask_setter(self, roi: Roi) -&gt; DataSetterProtocol[da.Array]:\n    return DaskRoiSetter(\n        zarr_array=self._output.zarr_array,\n        dimensions=self._output.dimensions,\n        roi=roi,\n        axes_order=self._axes_order,\n        transforms=self._output_transforms,\n        remove_channel_selection=True,\n    )\n</code></pre>"},{"location":"api/ngio/iterators/#ngio.experimental.iterators.SegmentationIterator.post_consolidate","title":"post_consolidate","text":"<pre><code>post_consolidate()\n</code></pre> Source code in <code>ngio/experimental/iterators/_segmentation.py</code> <pre><code>def post_consolidate(self):\n    self._output.consolidate()\n</code></pre>"},{"location":"api/ngio/ngio/","title":"ngio API documentation","text":""},{"location":"api/ngio/ngio/#ngio","title":"ngio","text":"<p>Next Generation file format IO.</p>"},{"location":"api/ngio/ngio/#ngio.DefaultNgffVersion","title":"DefaultNgffVersion  <code>module-attribute</code>","text":"<pre><code>DefaultNgffVersion: Literal['0.4'] = '0.4'\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.NgffVersions","title":"NgffVersions  <code>module-attribute</code>","text":"<pre><code>NgffVersions = Literal['0.4', '0.5']\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.NgioSupportedStore","title":"NgioSupportedStore  <code>module-attribute</code>","text":"<pre><code>NgioSupportedStore: TypeAlias = (\n    str\n    | Path\n    | FSMap\n    | FsspecStore\n    | MemoryStore\n    | dict\n    | LocalStore\n)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.StoreOrGroup","title":"StoreOrGroup  <code>module-attribute</code>","text":"<pre><code>StoreOrGroup: TypeAlias = NgioSupportedStore | Group\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.AxesSetup","title":"AxesSetup","text":"<p>               Bases: <code>BaseModel</code></p> <p>Axes setup model.</p> <p>This model is used to map the on disk axes to the canonical OME-Zarr axes.</p>"},{"location":"api/ngio/ngio/#ngio.AxesSetup.x","title":"x  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>x: str = 'x'\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.AxesSetup.y","title":"y  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>y: str = 'y'\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.AxesSetup.z","title":"z  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>z: str = 'z'\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.AxesSetup.c","title":"c  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>c: str = 'c'\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.AxesSetup.t","title":"t  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>t: str = 't'\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.AxesSetup.others","title":"others  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>others: list[str] = Field(default_factory=list)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.AxesSetup.allow_non_canonical_axes","title":"allow_non_canonical_axes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>allow_non_canonical_axes: bool = False\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.AxesSetup.strict_canonical_order","title":"strict_canonical_order  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>strict_canonical_order: bool = False\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.AxesSetup.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(extra='forbid', frozen=True)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.AxesSetup.from_ordered_list","title":"from_ordered_list  <code>classmethod</code>","text":"<pre><code>from_ordered_list(\n    axes_names: Sequence[str],\n    canonical_order: Sequence[str],\n)\n</code></pre> <p>Create an AxesSetup from an ordered list of axes names.</p> Source code in <code>ngio/ome_zarr_meta/ngio_specs/_axes.py</code> <pre><code>@classmethod\ndef from_ordered_list(\n    cls, axes_names: Sequence[str], canonical_order: Sequence[str]\n):\n    \"\"\"Create an AxesSetup from an ordered list of axes names.\"\"\"\n    # Make sure to only keep as many default axes as provided in axes_names\n    if len(axes_names) &gt; len(canonical_order):\n        raise NgioValueError(\n            f\"Cannot create AxesSetup from axes names {axes_names} \"\n            f\"and canonical order {canonical_order}. \"\n            \"The number of axes names cannot be greater than the \"\n            \"number of canonical axes.\"\n        )\n    canonical_order = list(canonical_order)\n    chanonical_axes = canonical_axes_order()\n    axes_mapping = {}\n    for ax in reversed(axes_names):\n        c_ax = canonical_order.pop()\n        if ax in chanonical_axes:\n            axes_mapping[ax] = ax\n        else:\n            axes_mapping[c_ax] = ax\n    return cls(**axes_mapping)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.AxesSetup.canonical_map","title":"canonical_map","text":"<pre><code>canonical_map() -&gt; dict[str, str]\n</code></pre> <p>Get the canonical map of axes.</p> Source code in <code>ngio/ome_zarr_meta/ngio_specs/_axes.py</code> <pre><code>def canonical_map(self) -&gt; dict[str, str]:\n    \"\"\"Get the canonical map of axes.\"\"\"\n    return {\n        \"t\": self.t,\n        \"c\": self.c,\n        \"z\": self.z,\n        \"y\": self.y,\n        \"x\": self.x,\n    }\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.AxesSetup.get_on_disk_name","title":"get_on_disk_name","text":"<pre><code>get_on_disk_name(canonical_name: str) -&gt; str | None\n</code></pre> <p>Get the on disk name of the axis by its canonical name.</p> Source code in <code>ngio/ome_zarr_meta/ngio_specs/_axes.py</code> <pre><code>def get_on_disk_name(self, canonical_name: str) -&gt; str | None:\n    \"\"\"Get the on disk name of the axis by its canonical name.\"\"\"\n    canonical_map = self.canonical_map()\n    return canonical_map.get(canonical_name, None)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.AxesSetup.inverse_canonical_map","title":"inverse_canonical_map","text":"<pre><code>inverse_canonical_map() -&gt; dict[str, str]\n</code></pre> <p>Get the on disk map of axes.</p> Source code in <code>ngio/ome_zarr_meta/ngio_specs/_axes.py</code> <pre><code>def inverse_canonical_map(self) -&gt; dict[str, str]:\n    \"\"\"Get the on disk map of axes.\"\"\"\n    return {\n        self.t: \"t\",\n        self.c: \"c\",\n        self.z: \"z\",\n        self.y: \"y\",\n        self.x: \"x\",\n    }\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.AxesSetup.get_canonical_name","title":"get_canonical_name","text":"<pre><code>get_canonical_name(on_disk_name: str) -&gt; str | None\n</code></pre> <p>Get the canonical name of the axis by its on disk name.</p> Source code in <code>ngio/ome_zarr_meta/ngio_specs/_axes.py</code> <pre><code>def get_canonical_name(self, on_disk_name: str) -&gt; str | None:\n    \"\"\"Get the canonical name of the axis by its on disk name.\"\"\"\n    inv_map = self.inverse_canonical_map()\n    return inv_map.get(on_disk_name, None)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.ChannelSelectionModel","title":"ChannelSelectionModel","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for channel selection.</p> <p>This model is used to select a channel by label, wavelength ID, or index.</p> Properties <p>identifier (str): Unique identifier for the channel.     This can be a channel label, wavelength ID, or index. mode (Literal[\"label\", \"wavelength_id\", \"index\"]): Specifies how to     interpret the identifier. Can be \"label\", \"wavelength_id\", or     \"index\" (must be an integer).</p>"},{"location":"api/ngio/ngio/#ngio.ChannelSelectionModel.mode","title":"mode  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mode: Literal['label', 'wavelength_id', 'index'] = 'label'\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.ChannelSelectionModel.identifier","title":"identifier  <code>instance-attribute</code>","text":"<pre><code>identifier: str\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.ChannelSelectionModel.check_channel_selection","title":"check_channel_selection","text":"<pre><code>check_channel_selection()\n</code></pre> Source code in <code>ngio/images/_image.py</code> <pre><code>@model_validator(mode=\"after\")\ndef check_channel_selection(self):\n    if self.mode == \"index\":\n        try:\n            int(self.identifier)\n        except ValueError as e:\n            raise ValueError(\n                \"Identifier must be an integer when mode is 'index'\"\n            ) from e\n    return self\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Dimensions","title":"Dimensions","text":"<pre><code>Dimensions(\n    shape: tuple[int, ...],\n    chunks: tuple[int, ...],\n    dataset: Dataset,\n)\n</code></pre> <p>Dimension metadata Handling Class.</p> <p>This class is used to handle and manipulate dimension metadata. It provides methods to access and validate dimension information, such as shape, axes, and properties like is_2d, is_3d, is_time_series, etc.</p> <p>Create a Dimension object from a Zarr array.</p> <p>Parameters:</p> <ul> <li> <code>shape</code>               (<code>tuple[int, ...]</code>)           \u2013            <p>The shape of the Zarr array.</p> </li> <li> <code>chunks</code>               (<code>tuple[int, ...]</code>)           \u2013            <p>The chunks of the Zarr array.</p> </li> <li> <code>dataset</code>               (<code>Dataset</code>)           \u2013            <p>The dataset object.</p> </li> </ul> Source code in <code>ngio/common/_dimensions.py</code> <pre><code>def __init__(\n    self,\n    shape: tuple[int, ...],\n    chunks: tuple[int, ...],\n    dataset: Dataset,\n) -&gt; None:\n    \"\"\"Create a Dimension object from a Zarr array.\n\n    Args:\n        shape: The shape of the Zarr array.\n        chunks: The chunks of the Zarr array.\n        dataset: The dataset object.\n    \"\"\"\n    self._shape = shape\n    self._chunks = chunks\n    self._axes_handler = dataset.axes_handler\n    self._pixel_size = dataset.pixel_size\n\n    if len(self._shape) != len(self._axes_handler.axes):\n        raise NgioValueError(\n            \"The number of dimensions must match the number of axes. \"\n            f\"Expected Axis {self._axes_handler.axes_names} but got shape \"\n            f\"{self._shape}.\"\n        )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Dimensions.require_axes_match","title":"require_axes_match  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>require_axes_match = require_axes_match\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Dimensions.check_if_axes_match","title":"check_if_axes_match  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>check_if_axes_match = check_if_axes_match\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Dimensions.require_dimensions_match","title":"require_dimensions_match  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>require_dimensions_match = require_dimensions_match\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Dimensions.check_if_dimensions_match","title":"check_if_dimensions_match  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>check_if_dimensions_match = check_if_dimensions_match\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Dimensions.require_rescalable","title":"require_rescalable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>require_rescalable = require_rescalable\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Dimensions.check_if_rescalable","title":"check_if_rescalable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>check_if_rescalable = check_if_rescalable\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Dimensions.axes_handler","title":"axes_handler  <code>property</code>","text":"<pre><code>axes_handler: AxesHandler\n</code></pre> <p>Return the axes handler object.</p>"},{"location":"api/ngio/ngio/#ngio.Dimensions.pixel_size","title":"pixel_size  <code>property</code>","text":"<pre><code>pixel_size: PixelSize\n</code></pre> <p>Return the pixel size object.</p>"},{"location":"api/ngio/ngio/#ngio.Dimensions.shape","title":"shape  <code>property</code>","text":"<pre><code>shape: tuple[int, ...]\n</code></pre> <p>Return the shape as a tuple.</p>"},{"location":"api/ngio/ngio/#ngio.Dimensions.chunks","title":"chunks  <code>property</code>","text":"<pre><code>chunks: tuple[int, ...]\n</code></pre> <p>Return the chunks as a tuple.</p>"},{"location":"api/ngio/ngio/#ngio.Dimensions.axes","title":"axes  <code>property</code>","text":"<pre><code>axes: tuple[str, ...]\n</code></pre> <p>Return the axes as a tuple of strings.</p>"},{"location":"api/ngio/ngio/#ngio.Dimensions.is_time_series","title":"is_time_series  <code>property</code>","text":"<pre><code>is_time_series: bool\n</code></pre> <p>Return whether the image is a time series.</p>"},{"location":"api/ngio/ngio/#ngio.Dimensions.is_2d","title":"is_2d  <code>property</code>","text":"<pre><code>is_2d: bool\n</code></pre> <p>Return whether the image is 2D.</p>"},{"location":"api/ngio/ngio/#ngio.Dimensions.is_2d_time_series","title":"is_2d_time_series  <code>property</code>","text":"<pre><code>is_2d_time_series: bool\n</code></pre> <p>Return whether the image is a 2D time series.</p>"},{"location":"api/ngio/ngio/#ngio.Dimensions.is_3d","title":"is_3d  <code>property</code>","text":"<pre><code>is_3d: bool\n</code></pre> <p>Return whether the image is 3D.</p>"},{"location":"api/ngio/ngio/#ngio.Dimensions.is_3d_time_series","title":"is_3d_time_series  <code>property</code>","text":"<pre><code>is_3d_time_series: bool\n</code></pre> <p>Return whether the image is a 3D time series.</p>"},{"location":"api/ngio/ngio/#ngio.Dimensions.is_multi_channels","title":"is_multi_channels  <code>property</code>","text":"<pre><code>is_multi_channels: bool\n</code></pre> <p>Return whether the image has multiple channels.</p>"},{"location":"api/ngio/ngio/#ngio.Dimensions.get","title":"get","text":"<pre><code>get(axis_name: str, default: None = None) -&gt; int | None\n</code></pre><pre><code>get(axis_name: str, default: int) -&gt; int\n</code></pre> <pre><code>get(\n    axis_name: str, default: int | None = None\n) -&gt; int | None\n</code></pre> <p>Return the dimension/shape of the given axis name.</p> <p>Parameters:</p> <ul> <li> <code>axis_name</code>               (<code>str</code>)           \u2013            <p>The name of the axis (either canonical or non-canonical).</p> </li> <li> <code>default</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The default value to return if the axis does not exist.</p> </li> </ul> Source code in <code>ngio/common/_dimensions.py</code> <pre><code>def get(self, axis_name: str, default: int | None = None) -&gt; int | None:\n    \"\"\"Return the dimension/shape of the given axis name.\n\n    Args:\n        axis_name: The name of the axis (either canonical or non-canonical).\n        default: The default value to return if the axis does not exist.\n    \"\"\"\n    index = self.axes_handler.get_index(axis_name)\n    if index is None:\n        return default\n    return self._shape[index]\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.ImageInWellPath","title":"ImageInWellPath","text":"<p>               Bases: <code>BaseModel</code></p> <p>Image in a well.</p>"},{"location":"api/ngio/ngio/#ngio.ImageInWellPath.row","title":"row  <code>instance-attribute</code>","text":"<pre><code>row: str\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.ImageInWellPath.column","title":"column  <code>instance-attribute</code>","text":"<pre><code>column: str | int\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.ImageInWellPath.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path: str\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.ImageInWellPath.acquisition_id","title":"acquisition_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>acquisition_id: int | None = None\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.ImageInWellPath.acquisition_name","title":"acquisition_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>acquisition_name: str | None = None\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.PixelSize","title":"PixelSize","text":"<p>               Bases: <code>BaseModel</code></p> <p>PixelSize class to store the pixel size in 3D space.</p>"},{"location":"api/ngio/ngio/#ngio.PixelSize.x","title":"x  <code>instance-attribute</code>","text":"<pre><code>x: float\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.PixelSize.y","title":"y  <code>instance-attribute</code>","text":"<pre><code>y: float\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.PixelSize.z","title":"z  <code>instance-attribute</code>","text":"<pre><code>z: float\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.PixelSize.t","title":"t  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>t: float = 1\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.PixelSize.space_unit","title":"space_unit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>space_unit: SpaceUnits | str | None = DefaultSpaceUnit\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.PixelSize.time_unit","title":"time_unit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>time_unit: TimeUnits | str | None = DefaultTimeUnit\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.PixelSize.tzyx","title":"tzyx  <code>property</code>","text":"<pre><code>tzyx: tuple[float, float, float, float]\n</code></pre> <p>Return the voxel size in t, z, y, x order.</p>"},{"location":"api/ngio/ngio/#ngio.PixelSize.zyx","title":"zyx  <code>property</code>","text":"<pre><code>zyx: tuple[float, float, float]\n</code></pre> <p>Return the voxel size in z, y, x order.</p>"},{"location":"api/ngio/ngio/#ngio.PixelSize.yx","title":"yx  <code>property</code>","text":"<pre><code>yx: tuple[float, float]\n</code></pre> <p>Return the xy plane pixel size in y, x order.</p>"},{"location":"api/ngio/ngio/#ngio.PixelSize.voxel_volume","title":"voxel_volume  <code>property</code>","text":"<pre><code>voxel_volume: float\n</code></pre> <p>Return the volume of a voxel.</p>"},{"location":"api/ngio/ngio/#ngio.PixelSize.xy_plane_area","title":"xy_plane_area  <code>property</code>","text":"<pre><code>xy_plane_area: float\n</code></pre> <p>Return the area of the xy plane.</p>"},{"location":"api/ngio/ngio/#ngio.PixelSize.time_spacing","title":"time_spacing  <code>property</code>","text":"<pre><code>time_spacing: float | None\n</code></pre> <p>Return the time spacing.</p>"},{"location":"api/ngio/ngio/#ngio.PixelSize.as_dict","title":"as_dict","text":"<pre><code>as_dict() -&gt; dict[str, float]\n</code></pre> <p>Return the pixel size as a dictionary.</p> Source code in <code>ngio/ome_zarr_meta/ngio_specs/_pixel_size.py</code> <pre><code>def as_dict(self) -&gt; dict[str, float]:\n    \"\"\"Return the pixel size as a dictionary.\"\"\"\n    return {\"t\": self.t, \"z\": self.z, \"y\": self.y, \"x\": self.x}\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.PixelSize.get","title":"get","text":"<pre><code>get(axis: str, default: float) -&gt; float\n</code></pre><pre><code>get(axis: str, default: None = None) -&gt; float | None\n</code></pre> <pre><code>get(\n    axis: str, default: float | None = None\n) -&gt; float | None\n</code></pre> <p>Get the pixel size for a given axis (in canonical name).</p> Source code in <code>ngio/ome_zarr_meta/ngio_specs/_pixel_size.py</code> <pre><code>def get(self, axis: str, default: float | None = None) -&gt; float | None:\n    \"\"\"Get the pixel size for a given axis (in canonical name).\"\"\"\n    px_size = self.as_dict().get(axis, default)\n    if px_size is None:\n        raise ValueError(\n            f\"Invalid axis name: {axis}, must be one of 'x', 'y', 'z', 't'.\"\n        )\n    return px_size\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.PixelSize.distance","title":"distance","text":"<pre><code>distance(other: PixelSize) -&gt; float\n</code></pre> <p>Return the distance between two pixel sizes.</p> Source code in <code>ngio/ome_zarr_meta/ngio_specs/_pixel_size.py</code> <pre><code>def distance(self, other: \"PixelSize\") -&gt; float:\n    \"\"\"Return the distance between two pixel sizes.\"\"\"\n    return float(np.linalg.norm(np.array(self.tzyx) - np.array(other.tzyx)))\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Roi","title":"Roi","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/ngio/ngio/#ngio.Roi.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str | None\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Roi.slices","title":"slices  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>slices: list[RoiSlice] = Field(min_length=2)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Roi.label","title":"label  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>label: int | None = Field(default=None, ge=0)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Roi.space","title":"space  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>space: Literal['world', 'pixel'] = 'world'\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Roi.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(extra='allow')\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Roi.validate_no_duplicate_axes","title":"validate_no_duplicate_axes  <code>classmethod</code>","text":"<pre><code>validate_no_duplicate_axes(\n    v: list[RoiSlice],\n) -&gt; list[RoiSlice]\n</code></pre> Source code in <code>ngio/common/_roi.py</code> <pre><code>@field_validator(\"slices\")\n@classmethod\ndef validate_no_duplicate_axes(cls, v: list[RoiSlice]) -&gt; list[RoiSlice]:\n    axis_names = [s.axis_name for s in v]\n    if len(axis_names) != len(set(axis_names)):\n        raise NgioValueError(\"Roi slices must have unique axis names\")\n    return v\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Roi.from_values","title":"from_values  <code>classmethod</code>","text":"<pre><code>from_values(\n    slices: Mapping[\n        str,\n        float | tuple[float | None, float | None] | slice,\n    ],\n    name: str | None,\n    label: int | None = None,\n    space: Literal[\"world\", \"pixel\"] = \"world\",\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>ngio/common/_roi.py</code> <pre><code>@classmethod\ndef from_values(\n    cls,\n    slices: Mapping[str, float | tuple[float | None, float | None] | slice],\n    name: str | None,\n    label: int | None = None,\n    space: Literal[\"world\", \"pixel\"] = \"world\",\n    **kwargs,\n) -&gt; Self:\n    _slices = []\n    for axis, _slice in slices.items():\n        _slices.append(RoiSlice.from_value(axis_name=axis, value=_slice))\n    return cls.model_construct(\n        name=name, slices=_slices, label=label, space=space, **kwargs\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Roi.get","title":"get","text":"<pre><code>get(axis_name: str) -&gt; RoiSlice | None\n</code></pre> Source code in <code>ngio/common/_roi.py</code> <pre><code>def get(self, axis_name: str) -&gt; RoiSlice | None:\n    for roi_slice in self.slices:\n        if roi_slice.axis_name == axis_name:\n            return roi_slice\n    return None\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Roi.get_name","title":"get_name","text":"<pre><code>get_name() -&gt; str\n</code></pre> Source code in <code>ngio/common/_roi.py</code> <pre><code>def get_name(self) -&gt; str:\n    if self.name is not None:\n        return self.name\n    if self.label is not None:\n        return str(self.label)\n    return self._nice_repr__()\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Roi.intersection","title":"intersection","text":"<pre><code>intersection(other: Self) -&gt; Self | None\n</code></pre> Source code in <code>ngio/common/_roi.py</code> <pre><code>def intersection(self, other: Self) -&gt; Self | None:\n    if self.space != other.space:\n        raise NgioValueError(\n            \"Roi intersection failed: One ROI is in pixel space and the \"\n            \"other in world space\"\n        )\n\n    out_slices = self._apply_sym_ops(\n        self.slices, other.slices, op=lambda a, b: a.intersection(b)\n    )\n    if out_slices is None:\n        return None\n\n    name = _join_roi_names(self.name, other.name)\n    label = _join_roi_labels(self.label, other.label)\n    return self.model_copy(\n        update={\"name\": name, \"slices\": out_slices, \"label\": label}\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Roi.union","title":"union","text":"<pre><code>union(other: Self) -&gt; Self\n</code></pre> Source code in <code>ngio/common/_roi.py</code> <pre><code>def union(self, other: Self) -&gt; Self:\n    if self.space != other.space:\n        raise NgioValueError(\n            \"Roi union failed: One ROI is in pixel space and the \"\n            \"other in world space\"\n        )\n\n    out_slices = self._apply_sym_ops(\n        self.slices, other.slices, op=lambda a, b: a.union(b)\n    )\n    if out_slices is None:\n        raise NgioValueError(\"Roi union failed: could not compute union\")\n\n    name = _join_roi_names(self.name, other.name)\n    label = _join_roi_labels(self.label, other.label)\n    return self.model_copy(\n        update={\"name\": name, \"slices\": out_slices, \"label\": label}\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Roi.zoom","title":"zoom","text":"<pre><code>zoom(\n    zoom_factor: float = 1.0,\n    axes: tuple[str, ...] = (\"x\", \"y\"),\n) -&gt; Self\n</code></pre> Source code in <code>ngio/common/_roi.py</code> <pre><code>def zoom(\n    self, zoom_factor: float = 1.0, axes: tuple[str, ...] = (\"x\", \"y\")\n) -&gt; Self:\n    new_slices = []\n    for roi_slice in self.slices:\n        if roi_slice.axis_name in axes:\n            new_slices.append(roi_slice.zoom(zoom_factor=zoom_factor))\n        else:\n            new_slices.append(roi_slice)\n    return self.model_copy(update={\"slices\": new_slices})\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Roi.to_world","title":"to_world","text":"<pre><code>to_world(pixel_size: PixelSize | None = None) -&gt; Self\n</code></pre> Source code in <code>ngio/common/_roi.py</code> <pre><code>def to_world(self, pixel_size: PixelSize | None = None) -&gt; Self:\n    if self.space == \"world\":\n        return self.model_copy()\n    if pixel_size is None:\n        raise NgioValueError(\n            \"Pixel sizes must be provided to convert ROI from pixel to world\"\n        )\n    new_slices = []\n    for roi_slice in self.slices:\n        pixel_size_ = pixel_size.get(roi_slice.axis_name, default=1.0)\n        new_slices.append(roi_slice.to_world(pixel_size=pixel_size_))\n    return self.model_copy(update={\"slices\": new_slices, \"space\": \"world\"})\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Roi.to_pixel","title":"to_pixel","text":"<pre><code>to_pixel(pixel_size: PixelSize | None = None) -&gt; Self\n</code></pre> Source code in <code>ngio/common/_roi.py</code> <pre><code>def to_pixel(self, pixel_size: PixelSize | None = None) -&gt; Self:\n    if self.space == \"pixel\":\n        return self.model_copy()\n\n    if pixel_size is None:\n        raise NgioValueError(\n            \"Pixel sizes must be provided to convert ROI from world to pixel\"\n        )\n\n    new_slices = []\n    for roi_slice in self.slices:\n        pixel_size_ = pixel_size.get(roi_slice.axis_name, default=1.0)\n        new_slices.append(roi_slice.to_pixel(pixel_size=pixel_size_))\n    return self.model_copy(update={\"slices\": new_slices, \"space\": \"pixel\"})\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Roi.to_slicing_dict","title":"to_slicing_dict","text":"<pre><code>to_slicing_dict(\n    pixel_size: PixelSize | None = None,\n) -&gt; dict[str, slice]\n</code></pre> Source code in <code>ngio/common/_roi.py</code> <pre><code>def to_slicing_dict(self, pixel_size: PixelSize | None = None) -&gt; dict[str, slice]:\n    roi = self.to_pixel(pixel_size=pixel_size)\n    return {roi_slice.axis_name: roi_slice.to_slice() for roi_slice in roi.slices}\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.RoiSlice","title":"RoiSlice","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/ngio/ngio/#ngio.RoiSlice.axis_name","title":"axis_name  <code>instance-attribute</code>","text":"<pre><code>axis_name: str\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.RoiSlice.start","title":"start  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>start: float | None = Field(default=None)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.RoiSlice.length","title":"length  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>length: float | None = Field(default=None, ge=0)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.RoiSlice.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(extra='forbid')\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.RoiSlice.end","title":"end  <code>property</code>","text":"<pre><code>end: float | None\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.RoiSlice.from_value","title":"from_value  <code>classmethod</code>","text":"<pre><code>from_value(\n    axis_name: str,\n    value: float\n    | tuple[float | None, float | None]\n    | slice,\n) -&gt; RoiSlice\n</code></pre> Source code in <code>ngio/common/_roi.py</code> <pre><code>@classmethod\ndef from_value(\n    cls,\n    axis_name: str,\n    value: float | tuple[float | None, float | None] | slice,\n) -&gt; \"RoiSlice\":\n    if isinstance(value, slice):\n        return cls._from_slice(axis_name=axis_name, selection=value)\n    elif isinstance(value, tuple):\n        return cls(axis_name=axis_name, start=value[0], length=value[1])\n    elif isinstance(value, int | float):\n        return cls(axis_name=axis_name, start=value, length=1)\n    else:\n        raise TypeError(f\"Unsupported type for slice value: {type(value)}\")\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.RoiSlice.to_slice","title":"to_slice","text":"<pre><code>to_slice() -&gt; slice\n</code></pre> Source code in <code>ngio/common/_roi.py</code> <pre><code>def to_slice(self) -&gt; slice:\n    return slice(self.start, self.end)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.RoiSlice.union","title":"union","text":"<pre><code>union(other: RoiSlice) -&gt; RoiSlice\n</code></pre> Source code in <code>ngio/common/_roi.py</code> <pre><code>def union(self, other: \"RoiSlice\") -&gt; \"RoiSlice\":\n    self._is_compatible(other, \"RoiSlice union failed\")\n    start = min(self.start or 0, other.start or 0)\n    end = max(self.end or float(\"inf\"), other.end or float(\"inf\"))\n    length = end - start if end &gt; start else 0\n    if length == float(\"inf\"):\n        length = None\n    return RoiSlice(axis_name=self.axis_name, start=start, length=length)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.RoiSlice.intersection","title":"intersection","text":"<pre><code>intersection(other: RoiSlice) -&gt; RoiSlice | None\n</code></pre> Source code in <code>ngio/common/_roi.py</code> <pre><code>def intersection(self, other: \"RoiSlice\") -&gt; \"RoiSlice | None\":\n    self._is_compatible(other, \"RoiSlice intersection failed\")\n    start = max(self.start or 0, other.start or 0)\n    end = min(self.end or float(\"inf\"), other.end or float(\"inf\"))\n    if end &lt;= start:\n        # No intersection\n        return None\n    length = end - start\n    if length == float(\"inf\"):\n        length = None\n    return RoiSlice(axis_name=self.axis_name, start=start, length=length)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.RoiSlice.to_world","title":"to_world","text":"<pre><code>to_world(pixel_size: float) -&gt; RoiSlice\n</code></pre> Source code in <code>ngio/common/_roi.py</code> <pre><code>def to_world(self, pixel_size: float) -&gt; \"RoiSlice\":\n    start = (\n        pixel_to_world(self.start, pixel_size) if self.start is not None else None\n    )\n    length = (\n        pixel_to_world(self.length, pixel_size) if self.length is not None else None\n    )\n    return RoiSlice(axis_name=self.axis_name, start=start, length=length)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.RoiSlice.to_pixel","title":"to_pixel","text":"<pre><code>to_pixel(pixel_size: float) -&gt; RoiSlice\n</code></pre> Source code in <code>ngio/common/_roi.py</code> <pre><code>def to_pixel(self, pixel_size: float) -&gt; \"RoiSlice\":\n    start = (\n        world_to_pixel(self.start, pixel_size) if self.start is not None else None\n    )\n    length = (\n        world_to_pixel(self.length, pixel_size) if self.length is not None else None\n    )\n    return RoiSlice(axis_name=self.axis_name, start=start, length=length)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.RoiSlice.zoom","title":"zoom","text":"<pre><code>zoom(zoom_factor: float = 1.0) -&gt; RoiSlice\n</code></pre> Source code in <code>ngio/common/_roi.py</code> <pre><code>def zoom(self, zoom_factor: float = 1.0) -&gt; \"RoiSlice\":\n    if zoom_factor &lt;= 0:\n        raise NgioValueError(\"Zoom factor must be greater than 0\")\n    zoom_factor -= 1.0\n    if self.length is None:\n        return self\n\n    diff_length = self.length * zoom_factor\n    length = self.length + diff_length\n    start = max((self.start or 0) - (diff_length / 2), 0)\n    return RoiSlice(axis_name=self.axis_name, start=start, length=length)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.create_synthetic_ome_zarr","title":"create_synthetic_ome_zarr","text":"<pre><code>create_synthetic_ome_zarr(\n    store: StoreOrGroup,\n    shape: Sequence[int],\n    reference_sample: AVAILABLE_SAMPLES\n    | SampleInfo = \"Cardiomyocyte\",\n    levels: int | list[str] = 5,\n    translation: Sequence[float] | None = None,\n    table_backend: TableBackend = DefaultTableBackend,\n    scaling_factors: Sequence[float]\n    | Literal[\"auto\"] = \"auto\",\n    axes_names: Sequence[str] | None = None,\n    channels_meta: Sequence[str | Channel] | None = None,\n    ngff_version: NgffVersions = DefaultNgffVersion,\n    chunks: ChunksLike = \"auto\",\n    shards: ShardsLike | None = None,\n    dimension_separator: Literal[\".\", \"/\"] = \"/\",\n    compressors: CompressorLike = \"auto\",\n    extra_array_kwargs: Mapping[str, Any] | None = None,\n    overwrite: bool = False,\n) -&gt; OmeZarrContainer\n</code></pre> <p>Create a synthetic OME-Zarr image with the given shape and metadata.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group to create the image in.</p> </li> <li> <code>shape</code>               (<code>Sequence[int]</code>)           \u2013            <p>The shape of the image.</p> </li> <li> <code>reference_sample</code>               (<code>AVAILABLE_SAMPLES | SampleInfo</code>, default:                   <code>'Cardiomyocyte'</code> )           \u2013            <p>The reference sample to use. Defaults to \"Cardiomyocyte\".</p> </li> <li> <code>levels</code>               (<code>int | list[str]</code>, default:                   <code>5</code> )           \u2013            <p>The number of levels in the pyramid or a list of level names. Defaults to 5.</p> </li> <li> <code>translation</code>               (<code>Sequence[float] | None</code>, default:                   <code>None</code> )           \u2013            <p>The translation for each axis at the highest resolution level. Defaults to None.</p> </li> <li> <code>table_backend</code>               (<code>TableBackend</code>, default:                   <code>DefaultTableBackend</code> )           \u2013            <p>Table backend to be used to store tables. Defaults to DefaultTableBackend.</p> </li> <li> <code>scaling_factors</code>               (<code>Sequence[float] | Literal['auto']</code>, default:                   <code>'auto'</code> )           \u2013            <p>The down-scaling factors for the pyramid levels. Defaults to \"auto\".</p> </li> <li> <code>axes_names</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The names of the axes. If None the canonical names are used. Defaults to None.</p> </li> <li> <code>channels_meta</code>               (<code>Sequence[str | Channel] | None</code>, default:                   <code>None</code> )           \u2013            <p>The channels metadata. Defaults to None.</p> </li> <li> <code>ngff_version</code>               (<code>NgffVersions</code>, default:                   <code>DefaultNgffVersion</code> )           \u2013            <p>The version of the OME-Zarr specification. Defaults to DefaultNgffVersion.</p> </li> <li> <code>chunks</code>               (<code>ChunksLike</code>, default:                   <code>'auto'</code> )           \u2013            <p>The chunk shape. Defaults to \"auto\".</p> </li> <li> <code>shards</code>               (<code>ShardsLike | None</code>, default:                   <code>None</code> )           \u2013            <p>The shard shape. Defaults to None.</p> </li> <li> <code>dimension_separator</code>               (<code>Literal['.', '/']</code>, default:                   <code>'/'</code> )           \u2013            <p>The separator to use for dimensions. Defaults to \"/\".</p> </li> <li> <code>compressors</code>               (<code>CompressorLike</code>, default:                   <code>'auto'</code> )           \u2013            <p>The compressors to use. Defaults to \"auto\".</p> </li> <li> <code>extra_array_kwargs</code>               (<code>Mapping[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Extra arguments to pass to the zarr array creation. Defaults to None.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to overwrite an existing image. Defaults to False.</p> </li> </ul> Source code in <code>ngio/images/_create_synt_container.py</code> <pre><code>def create_synthetic_ome_zarr(\n    store: StoreOrGroup,\n    shape: Sequence[int],\n    reference_sample: AVAILABLE_SAMPLES | SampleInfo = \"Cardiomyocyte\",\n    levels: int | list[str] = 5,\n    translation: Sequence[float] | None = None,\n    table_backend: TableBackend = DefaultTableBackend,\n    scaling_factors: Sequence[float] | Literal[\"auto\"] = \"auto\",\n    axes_names: Sequence[str] | None = None,\n    channels_meta: Sequence[str | Channel] | None = None,\n    ngff_version: NgffVersions = DefaultNgffVersion,\n    chunks: ChunksLike = \"auto\",\n    shards: ShardsLike | None = None,\n    dimension_separator: Literal[\".\", \"/\"] = \"/\",\n    compressors: CompressorLike = \"auto\",\n    extra_array_kwargs: Mapping[str, Any] | None = None,\n    overwrite: bool = False,\n) -&gt; OmeZarrContainer:\n    \"\"\"Create a synthetic OME-Zarr image with the given shape and metadata.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group to create the image in.\n        shape (Sequence[int]): The shape of the image.\n        reference_sample (AVAILABLE_SAMPLES | SampleInfo): The reference sample to use.\n            Defaults to \"Cardiomyocyte\".\n        levels (int | list[str]): The number of levels in the pyramid or a list of\n            level names. Defaults to 5.\n        translation (Sequence[float] | None): The translation for each axis\n            at the highest resolution level. Defaults to None.\n        table_backend (TableBackend): Table backend to be used to store tables.\n            Defaults to DefaultTableBackend.\n        scaling_factors (Sequence[float] | Literal[\"auto\"]): The down-scaling factors\n            for the pyramid levels. Defaults to \"auto\".\n        axes_names (Sequence[str] | None): The names of the axes. If None the\n            canonical names are used. Defaults to None.\n        channels_meta (Sequence[str | Channel] | None): The channels metadata.\n            Defaults to None.\n        ngff_version (NgffVersions): The version of the OME-Zarr specification.\n            Defaults to DefaultNgffVersion.\n        chunks (ChunksLike): The chunk shape. Defaults to \"auto\".\n        shards (ShardsLike | None): The shard shape. Defaults to None.\n        dimension_separator (Literal[\".\", \"/\"]): The separator to use for\n            dimensions. Defaults to \"/\".\n        compressors (CompressorLike): The compressors to use. Defaults to \"auto\".\n        extra_array_kwargs (Mapping[str, Any] | None): Extra arguments to pass to\n            the zarr array creation. Defaults to None.\n        overwrite (bool): Whether to overwrite an existing image. Defaults to False.\n    \"\"\"\n    if isinstance(reference_sample, str):\n        sample_info = get_sample_info(reference_sample)\n    else:\n        sample_info = reference_sample\n\n    raw = np.asarray(PIL.Image.open(sample_info.img_path))\n    raw = fit_to_shape(arr=raw, out_shape=tuple(shape))\n    raw = raw / np.max(raw) * (2**16 - 1)\n    raw = raw.astype(np.uint16)\n    ome_zarr = create_ome_zarr_from_array(\n        store=store,\n        array=raw,\n        pixelsize=sample_info.pixelsize,\n        z_spacing=sample_info.z_spacing,\n        time_spacing=sample_info.time_spacing,\n        levels=levels,\n        translation=translation,\n        space_unit=sample_info.space_unit,\n        time_unit=sample_info.time_unit,\n        axes_names=axes_names,\n        channels_meta=channels_meta,\n        scaling_factors=scaling_factors,\n        extra_array_kwargs=extra_array_kwargs,\n        name=sample_info.name,\n        chunks=chunks,\n        shards=shards,\n        overwrite=overwrite,\n        dimension_separator=dimension_separator,\n        compressors=compressors,\n        ngff_version=ngff_version,\n    )\n\n    image = ome_zarr.get_image()\n    well_table = image.build_image_roi_table()\n    ome_zarr.add_table(\"well_ROI_table\", table=well_table, backend=table_backend)\n\n    for label_info in sample_info.labels:\n        ome_zarr.derive_label(name=label_info.name)\n        label = ome_zarr.get_label(name=label_info.name)\n\n        ref_label = np.asarray(PIL.Image.open(label_info.label_path))\n        ref_label = ref_label.astype(label_info.dtype)\n\n        ref_label = fit_to_shape(\n            arr=ref_label,\n            out_shape=label.shape,\n            ensure_unique_info=label_info.ensure_unique_labels,\n        )\n        ref_label = ref_label.astype(np.uint32)\n        label.set_array(ref_label)\n        label.consolidate()\n\n        if label_info.create_masking_table:\n            masking_table = label.build_masking_roi_table()\n            ome_zarr.add_table(\n                name=f\"{label_info.name}_masking_table\",\n                table=masking_table,\n                backend=table_backend,\n            )\n\n    return ome_zarr\n</code></pre>"},{"location":"api/ngio/tables/","title":"ngio.tables API documentation","text":""},{"location":"api/ngio/tables/#ngio.tables","title":"ngio.tables","text":"<p>Ngio Tables implementations.</p>"},{"location":"api/ngio/tables/#ngio.tables.ConditionTable","title":"ConditionTable  <code>module-attribute</code>","text":"<pre><code>ConditionTable = ConditionTableV1\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.FeatureTable","title":"FeatureTable  <code>module-attribute</code>","text":"<pre><code>FeatureTable = FeatureTableV1\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.GenericRoiTable","title":"GenericRoiTable  <code>module-attribute</code>","text":"<pre><code>GenericRoiTable = GenericRoiTableV1\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.MaskingRoiTable","title":"MaskingRoiTable  <code>module-attribute</code>","text":"<pre><code>MaskingRoiTable = MaskingRoiTableV1\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.RoiTable","title":"RoiTable  <code>module-attribute</code>","text":"<pre><code>RoiTable = RoiTableV1\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.TableType","title":"TableType  <code>module-attribute</code>","text":"<pre><code>TableType = TypeVar('TableType', bound=Table)\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.TypedTable","title":"TypedTable  <code>module-attribute</code>","text":"<pre><code>TypedTable = Literal[\n    \"generic_table\",\n    \"roi_table\",\n    \"masking_roi_table\",\n    \"feature_table\",\n    \"condition_table\",\n]\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.DefaultTableBackend","title":"DefaultTableBackend  <code>module-attribute</code>","text":"<pre><code>DefaultTableBackend = 'anndata_v1'\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.TableBackend","title":"TableBackend  <code>module-attribute</code>","text":"<pre><code>TableBackend = (\n    Literal[\"anndata\", \"json\", \"csv\", \"parquet\"]\n    | str\n    | TableBackendProtocol\n)\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.Table","title":"Table","text":"<p>               Bases: <code>Protocol</code></p> <p>Placeholder class for a table.</p>"},{"location":"api/ngio/tables/#ngio.tables.Table.backend_name","title":"backend_name  <code>property</code>","text":"<pre><code>backend_name: str | None\n</code></pre> <p>The name of the backend.</p>"},{"location":"api/ngio/tables/#ngio.tables.Table.meta","title":"meta  <code>property</code>","text":"<pre><code>meta: BackendMeta\n</code></pre> <p>Return the metadata for the table.</p>"},{"location":"api/ngio/tables/#ngio.tables.Table.dataframe","title":"dataframe  <code>property</code>","text":"<pre><code>dataframe: DataFrame\n</code></pre> <p>Return the table as a DataFrame.</p>"},{"location":"api/ngio/tables/#ngio.tables.Table.lazy_frame","title":"lazy_frame  <code>property</code>","text":"<pre><code>lazy_frame: LazyFrame\n</code></pre> <p>Return the table as a LazyFrame.</p>"},{"location":"api/ngio/tables/#ngio.tables.Table.anndata","title":"anndata  <code>property</code>","text":"<pre><code>anndata: AnnData\n</code></pre> <p>Return the table as an AnnData object.</p>"},{"location":"api/ngio/tables/#ngio.tables.Table.table_data","title":"table_data  <code>property</code>","text":"<pre><code>table_data: TabularData\n</code></pre> <p>Return the table.</p>"},{"location":"api/ngio/tables/#ngio.tables.Table.table_type","title":"table_type  <code>staticmethod</code>","text":"<pre><code>table_type() -&gt; str\n</code></pre> <p>Return the type of the table.</p> Source code in <code>ngio/tables/_tables_container.py</code> <pre><code>@staticmethod\ndef table_type() -&gt; str:\n    \"\"\"Return the type of the table.\"\"\"\n    ...\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.Table.version","title":"version  <code>staticmethod</code>","text":"<pre><code>version() -&gt; str\n</code></pre> <p>Return the version of the table.</p> Source code in <code>ngio/tables/_tables_container.py</code> <pre><code>@staticmethod\ndef version() -&gt; str:\n    \"\"\"Return the version of the table.\"\"\"\n    ...\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.Table.set_table_data","title":"set_table_data","text":"<pre><code>set_table_data(\n    table_data: TabularData | None = None,\n    refresh: bool = False,\n) -&gt; None\n</code></pre> <p>Make sure that the table data is set (exist in memory).</p> <p>If an object is passed, it will be used as the table. If None is passed, the table will be loaded from the backend.</p> <p>If refresh is True, the table will be reloaded from the backend.     If table is not None, this will be ignored.</p> Source code in <code>ngio/tables/_tables_container.py</code> <pre><code>def set_table_data(\n    self,\n    table_data: TabularData | None = None,\n    refresh: bool = False,\n) -&gt; None:\n    \"\"\"Make sure that the table data is set (exist in memory).\n\n    If an object is passed, it will be used as the table.\n    If None is passed, the table will be loaded from the backend.\n\n    If refresh is True, the table will be reloaded from the backend.\n        If table is not None, this will be ignored.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.Table.set_backend","title":"set_backend","text":"<pre><code>set_backend(\n    handler: ZarrGroupHandler | None = None,\n    backend: TableBackend = DefaultTableBackend,\n) -&gt; None\n</code></pre> <p>Set the backend store and path for the table.</p> <p>Either a handler or a backend must be provided.</p> <p>If the handler in none it will be inferred from the backend. If the backend is none, it will be inferred from the group attrs</p> Source code in <code>ngio/tables/_tables_container.py</code> <pre><code>def set_backend(\n    self,\n    handler: ZarrGroupHandler | None = None,\n    backend: TableBackend = DefaultTableBackend,\n) -&gt; None:\n    \"\"\"Set the backend store and path for the table.\n\n    Either a handler or a backend must be provided.\n\n    If the handler in none it will be inferred from the backend.\n    If the backend is none, it will be inferred from the group attrs\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.Table.from_handler","title":"from_handler  <code>classmethod</code>","text":"<pre><code>from_handler(\n    handler: ZarrGroupHandler,\n    backend: TableBackend | None = None,\n) -&gt; Table\n</code></pre> <p>Create a new table from a Zarr group handler.</p> Source code in <code>ngio/tables/_tables_container.py</code> <pre><code>@classmethod\ndef from_handler(\n    cls,\n    handler: ZarrGroupHandler,\n    backend: TableBackend | None = None,\n) -&gt; \"Table\":\n    \"\"\"Create a new table from a Zarr group handler.\"\"\"\n    ...\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.Table.from_table_data","title":"from_table_data  <code>classmethod</code>","text":"<pre><code>from_table_data(\n    table_data: TabularData, meta: BackendMeta\n) -&gt; Table\n</code></pre> <p>Create a new table from a DataFrame.</p> Source code in <code>ngio/tables/_tables_container.py</code> <pre><code>@classmethod\ndef from_table_data(cls, table_data: TabularData, meta: BackendMeta) -&gt; \"Table\":\n    \"\"\"Create a new table from a DataFrame.\"\"\"\n    ...\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.Table.consolidate","title":"consolidate","text":"<pre><code>consolidate() -&gt; None\n</code></pre> <p>Consolidate the table on disk.</p> Source code in <code>ngio/tables/_tables_container.py</code> <pre><code>def consolidate(self) -&gt; None:\n    \"\"\"Consolidate the table on disk.\"\"\"\n    ...\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.TablesContainer","title":"TablesContainer","text":"<pre><code>TablesContainer(group_handler: ZarrGroupHandler)\n</code></pre> <p>A class to handle the /tables group in an OME-NGFF file.</p> <p>Initialize the TablesContainer.</p> Source code in <code>ngio/tables/_tables_container.py</code> <pre><code>def __init__(self, group_handler: ZarrGroupHandler) -&gt; None:\n    \"\"\"Initialize the TablesContainer.\"\"\"\n    self._group_handler = group_handler\n\n    # Validate the group\n    # Either contains a tables attribute or is empty\n    attrs = self._group_handler.load_attrs()\n    if len(attrs) == 0:\n        # It's an empty group\n        pass\n    elif \"tables\" in attrs and isinstance(attrs[\"tables\"], list):\n        # It's a valid group\n        pass\n    else:\n        raise NgioValidationError(\n            f\"Invalid /tables group. \"\n            f\"Expected a single tables attribute with a list of table names. \"\n            f\"Found: {attrs}\"\n        )\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.TablesContainer.list","title":"list","text":"<pre><code>list(\n    filter_types: TypedTable | str | None = None,\n) -&gt; list[str]\n</code></pre> <p>List all tables in the group.</p> <p>Parameters:</p> <ul> <li> <code>filter_types</code>               (<code>TypedTable | str | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, only return tables of this type.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>A list of table names.</p> </li> </ul> Source code in <code>ngio/tables/_tables_container.py</code> <pre><code>def list(self, filter_types: TypedTable | str | None = None) -&gt; list[str]:\n    \"\"\"List all tables in the group.\n\n    Args:\n        filter_types: If provided, only return tables of this type.\n\n    Returns:\n        A list of table names.\n    \"\"\"\n    tables = self._get_tables_list()\n    if filter_types is None:\n        return tables\n\n    filtered_tables = []\n    for table_name in tables:\n        tb_handler = self._get_table_group_handler(table_name)\n        table_type = _get_meta(tb_handler).type\n        if table_type == filter_types:\n            filtered_tables.append(table_name)\n    return filtered_tables\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.TablesContainer.get","title":"get","text":"<pre><code>get(\n    name: str,\n    backend: TableBackend | None = None,\n    strict: bool = True,\n) -&gt; Table\n</code></pre> <p>Get a table from the group.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> <li> <code>backend</code>               (<code>TableBackend | None</code>, default:                   <code>None</code> )           \u2013            <p>The backend to use for reading the table.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, raise an error if the table type is not implemented.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Table</code>           \u2013            <p>The table object.</p> </li> </ul> Source code in <code>ngio/tables/_tables_container.py</code> <pre><code>def get(\n    self,\n    name: str,\n    backend: TableBackend | None = None,\n    strict: bool = True,\n) -&gt; Table:\n    \"\"\"Get a table from the group.\n\n    Args:\n        name: The name of the table.\n        backend: The backend to use for reading the table.\n        strict: If True, raise an error if the table type is not implemented.\n\n    Returns:\n        The table object.\n    \"\"\"\n    if name not in self.list():\n        raise NgioValueError(f\"Table '{name}' not found in the group.\")\n\n    table_handler = self._get_table_group_handler(name)\n\n    meta = _get_meta(table_handler)\n    return ImplementedTables().get_table(\n        meta=meta,\n        handler=table_handler,\n        backend=backend,\n        strict=strict,\n    )\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.TablesContainer.get_as","title":"get_as","text":"<pre><code>get_as(\n    name: str,\n    table_cls: type[TableType],\n    backend: TableBackend | None = None,\n) -&gt; TableType\n</code></pre> <p>Get a table from the group as a specific type.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> <li> <code>table_cls</code>               (<code>type[TableType]</code>)           \u2013            <p>The table class to use for loading the table.</p> </li> <li> <code>backend</code>               (<code>TableBackend | None</code>, default:                   <code>None</code> )           \u2013            <p>The backend to use for reading the table.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>TableType</code>           \u2013            <p>The table object of the specified type.</p> </li> </ul> Source code in <code>ngio/tables/_tables_container.py</code> <pre><code>def get_as(\n    self,\n    name: str,\n    table_cls: type[TableType],\n    backend: TableBackend | None = None,\n) -&gt; TableType:\n    \"\"\"Get a table from the group as a specific type.\n\n    Args:\n        name: The name of the table.\n        table_cls: The table class to use for loading the table.\n        backend: The backend to use for reading the table.\n\n    Returns:\n        The table object of the specified type.\n    \"\"\"\n    if name not in self.list():\n        raise NgioValueError(f\"Table '{name}' not found in the group.\")\n\n    table_handler = self._get_table_group_handler(name)\n    return table_cls.from_handler(\n        handler=table_handler,\n        backend=backend,\n    )  # type: ignore[return-value]\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.TablesContainer.delete","title":"delete","text":"<pre><code>delete(name: str, missing_ok: bool = False) -&gt; None\n</code></pre> <p>Delete a table from the group.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table to delete.</p> </li> <li> <code>missing_ok</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, do not raise an error if the table does not exist.</p> </li> </ul> Source code in <code>ngio/tables/_tables_container.py</code> <pre><code>def delete(self, name: str, missing_ok: bool = False) -&gt; None:\n    \"\"\"Delete a table from the group.\n\n    Args:\n        name (str): The name of the table to delete.\n        missing_ok (bool): If True, do not raise an error if\n            the table does not exist.\n    \"\"\"\n    existing_tables = self._get_tables_list()\n    if name not in existing_tables:\n        if missing_ok:\n            return\n        raise NgioValueError(\n            f\"Table '{name}' not found in the Tables group. \"\n            f\"Available tables: {existing_tables}\"\n        )\n\n    self._group_handler.delete_group(name)\n    existing_tables.remove(name)\n    self._group_handler.write_attrs({\"tables\": existing_tables})\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.TablesContainer.add","title":"add","text":"<pre><code>add(\n    name: str,\n    table: Table,\n    backend: TableBackend = DefaultTableBackend,\n    overwrite: bool = False,\n) -&gt; None\n</code></pre> <p>Add a table to the group.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> <li> <code>table</code>               (<code>Table</code>)           \u2013            <p>The table object to add.</p> </li> <li> <code>backend</code>               (<code>TableBackend</code>, default:                   <code>DefaultTableBackend</code> )           \u2013            <p>The backend to use for writing the table.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to overwrite an existing table with the same name.</p> </li> </ul> Source code in <code>ngio/tables/_tables_container.py</code> <pre><code>def add(\n    self,\n    name: str,\n    table: Table,\n    backend: TableBackend = DefaultTableBackend,\n    overwrite: bool = False,\n) -&gt; None:\n    \"\"\"Add a table to the group.\n\n    Args:\n        name: The name of the table.\n        table: The table object to add.\n        backend: The backend to use for writing the table.\n        overwrite: Whether to overwrite an existing table with the same name.\n    \"\"\"\n    existing_tables = self._get_tables_list()\n    if name in existing_tables and not overwrite:\n        raise NgioValueError(\n            f\"Table '{name}' already exists in the group. \"\n            \"Use overwrite=True to replace it.\"\n        )\n\n    table_handler = self._group_handler.get_handler(path=name, overwrite=overwrite)\n\n    if backend is None:\n        backend = table.backend_name\n\n    table.set_table_data()\n    table.set_backend(\n        handler=table_handler,\n        backend=backend,\n    )\n    table.consolidate()\n    if name not in existing_tables:\n        existing_tables.append(name)\n        self._group_handler.write_attrs({\"tables\": existing_tables})\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.ImplementedTableBackends","title":"ImplementedTableBackends","text":"<p>A class to manage the available table backends.</p>"},{"location":"api/ngio/tables/#ngio.tables.ImplementedTableBackends.available_backends","title":"available_backends  <code>property</code>","text":"<pre><code>available_backends: list[str]\n</code></pre> <p>Return the available table backends.</p>"},{"location":"api/ngio/tables/#ngio.tables.ImplementedTableBackends.get_backend","title":"get_backend","text":"<pre><code>get_backend(\n    *,\n    group_handler: ZarrGroupHandler,\n    backend_name: str = \"anndata\",\n    index_key: str | None = None,\n    index_type: Literal[\"int\", \"str\"] | None = None,\n) -&gt; TableBackendProtocol\n</code></pre> <p>Try to get a handler for the given store based on the metadata version.</p> Source code in <code>ngio/tables/backends/_table_backends.py</code> <pre><code>def get_backend(\n    self,\n    *,\n    group_handler: ZarrGroupHandler,\n    backend_name: str = \"anndata\",\n    index_key: str | None = None,\n    index_type: Literal[\"int\", \"str\"] | None = None,\n) -&gt; TableBackendProtocol:\n    \"\"\"Try to get a handler for the given store based on the metadata version.\"\"\"\n    if backend_name not in self._implemented_backends:\n        raise NgioValueError(f\"Table backend {backend_name} not implemented.\")\n    backend = self._implemented_backends[backend_name]()\n    backend.set_group_handler(\n        group_handler=group_handler, index_key=index_key, index_type=index_type\n    )\n    return backend\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.ImplementedTableBackends.add_backend","title":"add_backend","text":"<pre><code>add_backend(\n    table_backend: type[TableBackendProtocol],\n    overwrite: bool = False,\n    aliases: list[str] | None = None,\n) -&gt; None\n</code></pre> <p>Register a new handler.</p> Source code in <code>ngio/tables/backends/_table_backends.py</code> <pre><code>def add_backend(\n    self,\n    table_backend: type[TableBackendProtocol],\n    overwrite: bool = False,\n    aliases: list[str] | None = None,\n) -&gt; None:\n    \"\"\"Register a new handler.\"\"\"\n    self._add_backend(\n        table_backend=table_backend,\n        name=table_backend.backend_name(),\n        overwrite=overwrite,\n    )\n    if aliases is not None:\n        for alias in aliases:\n            self._add_backend(\n                table_backend=table_backend, name=alias, overwrite=overwrite\n            )\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.TableBackendProtocol","title":"TableBackendProtocol","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/ngio/tables/#ngio.tables.TableBackendProtocol.group_handler","title":"group_handler  <code>property</code>","text":"<pre><code>group_handler: ZarrGroupHandler\n</code></pre> <p>Return the group handler.</p>"},{"location":"api/ngio/tables/#ngio.tables.TableBackendProtocol.set_group_handler","title":"set_group_handler","text":"<pre><code>set_group_handler(\n    group_handler: ZarrGroupHandler,\n    index_key: str | None = None,\n    index_type: Literal[\"int\", \"str\"] | None = None,\n) -&gt; None\n</code></pre> <p>Attach a group handler to the backend.</p> <p>Index keys and index types are used to ensure that the serialization and deserialization of the table is consistent across different backends.</p> <p>Making sure that this is consistent is a duty of the backend implementations.</p> Source code in <code>ngio/tables/backends/_table_backends.py</code> <pre><code>def set_group_handler(\n    self,\n    group_handler: ZarrGroupHandler,\n    index_key: str | None = None,\n    index_type: Literal[\"int\", \"str\"] | None = None,\n) -&gt; None:\n    \"\"\"Attach a group handler to the backend.\n\n    Index keys and index types are used to ensure that the\n    serialization and deserialization of the table\n    is consistent across different backends.\n\n    Making sure that this is consistent is\n    a duty of the backend implementations.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.TableBackendProtocol.backend_name","title":"backend_name  <code>staticmethod</code>","text":"<pre><code>backend_name() -&gt; str\n</code></pre> <p>Return the name of the backend.</p> As a convention we set name as <p>{backend_name}_v{version}</p> <p>Where the version is a integer.</p> Source code in <code>ngio/tables/backends/_table_backends.py</code> <pre><code>@staticmethod\ndef backend_name() -&gt; str:\n    \"\"\"Return the name of the backend.\n\n    As a convention we set name as:\n        {backend_name}_v{version}\n\n    Where the version is a integer.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.TableBackendProtocol.implements_anndata","title":"implements_anndata  <code>staticmethod</code>","text":"<pre><code>implements_anndata() -&gt; bool\n</code></pre> <p>Check if the backend implements the anndata protocol.</p> <p>If this is True, the backend should implement the <code>write_from_anndata</code> method.</p> <p>AnnData objects are more complex than DataFrames, so if this is true the backend should implement the full serialization of the AnnData object.</p> <p>If this is False, these methods should raise a <code>NotImplementedError</code>.</p> Source code in <code>ngio/tables/backends/_table_backends.py</code> <pre><code>@staticmethod\ndef implements_anndata() -&gt; bool:\n    \"\"\"Check if the backend implements the anndata protocol.\n\n    If this is True, the backend should implement the\n    `write_from_anndata` method.\n\n    AnnData objects are more complex than DataFrames,\n    so if this is true the backend should implement the\n    full serialization of the AnnData object.\n\n    If this is False, these methods should raise a\n    `NotImplementedError`.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.TableBackendProtocol.implements_pandas","title":"implements_pandas  <code>staticmethod</code>","text":"<pre><code>implements_pandas() -&gt; bool\n</code></pre> <p>Check if the backend implements the pandas protocol.</p> <p>If this is True, the backend should implement the <code>write_from_dataframe</code> methods.</p> <p>If this is False, these methods should raise a <code>NotImplementedError</code>.</p> Source code in <code>ngio/tables/backends/_table_backends.py</code> <pre><code>@staticmethod\ndef implements_pandas() -&gt; bool:\n    \"\"\"Check if the backend implements the pandas protocol.\n\n    If this is True, the backend should implement the\n    `write_from_dataframe` methods.\n\n    If this is False, these methods should raise a\n    `NotImplementedError`.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.TableBackendProtocol.implements_polars","title":"implements_polars  <code>staticmethod</code>","text":"<pre><code>implements_polars() -&gt; bool\n</code></pre> <p>Check if the backend implements the polars protocol.</p> <p>If this is True, the backend should implement the <code>write_from_polars</code> methods.</p> <p>If this is False, these methods should raise a <code>NotImplementedError</code>.</p> Source code in <code>ngio/tables/backends/_table_backends.py</code> <pre><code>@staticmethod\ndef implements_polars() -&gt; bool:\n    \"\"\"Check if the backend implements the polars protocol.\n\n    If this is True, the backend should implement the\n    `write_from_polars` methods.\n\n    If this is False, these methods should raise a\n    `NotImplementedError`.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.TableBackendProtocol.load_as_anndata","title":"load_as_anndata","text":"<pre><code>load_as_anndata() -&gt; AnnData\n</code></pre> <p>Load the table as an AnnData object.</p> Source code in <code>ngio/tables/backends/_table_backends.py</code> <pre><code>def load_as_anndata(self) -&gt; AnnData:\n    \"\"\"Load the table as an AnnData object.\"\"\"\n    ...\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.TableBackendProtocol.load_as_pandas_df","title":"load_as_pandas_df","text":"<pre><code>load_as_pandas_df() -&gt; DataFrame\n</code></pre> <p>Load the table as a pandas DataFrame.</p> Source code in <code>ngio/tables/backends/_table_backends.py</code> <pre><code>def load_as_pandas_df(self) -&gt; DataFrame:\n    \"\"\"Load the table as a pandas DataFrame.\"\"\"\n    ...\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.TableBackendProtocol.load_as_polars_lf","title":"load_as_polars_lf","text":"<pre><code>load_as_polars_lf() -&gt; LazyFrame\n</code></pre> <p>Load the table as a polars LazyFrame.</p> Source code in <code>ngio/tables/backends/_table_backends.py</code> <pre><code>def load_as_polars_lf(self) -&gt; LazyFrame:\n    \"\"\"Load the table as a polars LazyFrame.\"\"\"\n    ...\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.TableBackendProtocol.load","title":"load","text":"<pre><code>load() -&gt; TabularData\n</code></pre> <p>The default load method.</p> <p>This method will be default way to load the table from the backend. This method should wrap one of the <code>load_as_anndata</code>, <code>load_as_dataframe</code> or <code>load_as_polars</code> methods depending on the backend implementation.</p> Source code in <code>ngio/tables/backends/_table_backends.py</code> <pre><code>def load(self) -&gt; TabularData:\n    \"\"\"The default load method.\n\n    This method will be default way to load the table\n    from the backend. This method should wrap one of the\n    `load_as_anndata`, `load_as_dataframe` or `load_as_polars`\n    methods depending on the backend implementation.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.TableBackendProtocol.write_from_pandas","title":"write_from_pandas","text":"<pre><code>write_from_pandas(table: DataFrame) -&gt; None\n</code></pre> <p>Serialize the table from a pandas DataFrame.</p> Source code in <code>ngio/tables/backends/_table_backends.py</code> <pre><code>def write_from_pandas(self, table: DataFrame) -&gt; None:\n    \"\"\"Serialize the table from a pandas DataFrame.\"\"\"\n    ...\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.TableBackendProtocol.write_from_anndata","title":"write_from_anndata","text":"<pre><code>write_from_anndata(table: AnnData) -&gt; None\n</code></pre> <p>Serialize the table from an AnnData object.</p> Source code in <code>ngio/tables/backends/_table_backends.py</code> <pre><code>def write_from_anndata(self, table: AnnData) -&gt; None:\n    \"\"\"Serialize the table from an AnnData object.\"\"\"\n    ...\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.TableBackendProtocol.write_from_polars","title":"write_from_polars","text":"<pre><code>write_from_polars(table: LazyFrame | DataFrame) -&gt; None\n</code></pre> <p>Serialize the table from a polars DataFrame or LazyFrame.</p> Source code in <code>ngio/tables/backends/_table_backends.py</code> <pre><code>def write_from_polars(self, table: LazyFrame | PolarsDataFrame) -&gt; None:\n    \"\"\"Serialize the table from a polars DataFrame or LazyFrame.\"\"\"\n    ...\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.TableBackendProtocol.write","title":"write","text":"<pre><code>write(\n    table_data: DataFrame | AnnData | DataFrame | LazyFrame,\n    metadata: dict[str, str] | None = None,\n) -&gt; None\n</code></pre> <p>This is a generic write method.</p> <p>Will call the appropriate write method depending on the type of the table.</p> <p>Moreover it will also write the metadata if provided, and the backend methadata</p> <p>the backend should write in the zarr group attributes     - backend: the backend name (self.backend_name())     - index_key: the index key     - index_type: the index type</p> Source code in <code>ngio/tables/backends/_table_backends.py</code> <pre><code>def write(\n    self,\n    table_data: DataFrame | AnnData | PolarsDataFrame | LazyFrame,\n    metadata: dict[str, str] | None = None,\n) -&gt; None:\n    \"\"\"This is a generic write method.\n\n    Will call the appropriate write method\n    depending on the type of the table.\n\n    Moreover it will also write the metadata\n    if provided, and the backend methadata\n\n    the backend should write in the zarr group attributes\n        - backend: the backend name (self.backend_name())\n        - index_key: the index key\n        - index_type: the index type\n\n    \"\"\"\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.GenericTable","title":"GenericTable","text":"<pre><code>GenericTable(\n    table_data: TabularData | None = None,\n    *,\n    meta: BackendMeta | None = None,\n)\n</code></pre> <p>               Bases: <code>AbstractBaseTable</code></p> <p>Class to a non-specific table.</p> <p>This can be used to load any table that does not have a specific definition.</p> <p>Initialize the table.</p> Source code in <code>ngio/tables/_abstract_table.py</code> <pre><code>def __init__(\n    self,\n    table_data: TabularData | None = None,\n    *,\n    meta: BackendMeta | None = None,\n) -&gt; None:\n    \"\"\"Initialize the table.\"\"\"\n    if meta is None:\n        meta = BackendMeta()\n\n    self._meta = meta\n    if table_data is not None:\n        table_data = normalize_table(\n            table_data,\n            index_key=meta.index_key,\n            index_type=meta.index_type,\n        )\n    self._table_data = table_data\n    self._table_backend = None\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.GenericTable.backend_name","title":"backend_name  <code>property</code>","text":"<pre><code>backend_name: str | None\n</code></pre> <p>Return the name of the backend.</p>"},{"location":"api/ngio/tables/#ngio.tables.GenericTable.meta","title":"meta  <code>property</code>","text":"<pre><code>meta: BackendMeta\n</code></pre> <p>Return the metadata of the table.</p>"},{"location":"api/ngio/tables/#ngio.tables.GenericTable.index_key","title":"index_key  <code>property</code>","text":"<pre><code>index_key: str | None\n</code></pre> <p>Get the index key.</p>"},{"location":"api/ngio/tables/#ngio.tables.GenericTable.index_type","title":"index_type  <code>property</code>","text":"<pre><code>index_type: Literal['int', 'str'] | None\n</code></pre> <p>Get the index type.</p>"},{"location":"api/ngio/tables/#ngio.tables.GenericTable.table_data","title":"table_data  <code>property</code>","text":"<pre><code>table_data: TabularData\n</code></pre> <p>Return the table.</p>"},{"location":"api/ngio/tables/#ngio.tables.GenericTable.dataframe","title":"dataframe  <code>property</code>","text":"<pre><code>dataframe: DataFrame\n</code></pre> <p>Return the table as a DataFrame.</p>"},{"location":"api/ngio/tables/#ngio.tables.GenericTable.lazy_frame","title":"lazy_frame  <code>property</code>","text":"<pre><code>lazy_frame: LazyFrame\n</code></pre> <p>Return the table as a LazyFrame.</p>"},{"location":"api/ngio/tables/#ngio.tables.GenericTable.anndata","title":"anndata  <code>property</code>","text":"<pre><code>anndata: AnnData\n</code></pre> <p>Return the table as an AnnData object.</p>"},{"location":"api/ngio/tables/#ngio.tables.GenericTable.load_as_anndata","title":"load_as_anndata","text":"<pre><code>load_as_anndata() -&gt; AnnData\n</code></pre> <p>Load the table as an AnnData object.</p> Source code in <code>ngio/tables/_abstract_table.py</code> <pre><code>def load_as_anndata(self) -&gt; AnnData:\n    \"\"\"Load the table as an AnnData object.\"\"\"\n    if self._table_backend is None:\n        raise NgioValueError(\"No backend set for the table.\")\n    return self._table_backend.load_as_anndata()\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.GenericTable.load_as_pandas_df","title":"load_as_pandas_df","text":"<pre><code>load_as_pandas_df() -&gt; DataFrame\n</code></pre> <p>Load the table as a pandas DataFrame.</p> Source code in <code>ngio/tables/_abstract_table.py</code> <pre><code>def load_as_pandas_df(self) -&gt; pd.DataFrame:\n    \"\"\"Load the table as a pandas DataFrame.\"\"\"\n    if self._table_backend is None:\n        raise NgioValueError(\"No backend set for the table.\")\n    return self._table_backend.load_as_pandas_df()\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.GenericTable.load_as_polars_lf","title":"load_as_polars_lf","text":"<pre><code>load_as_polars_lf() -&gt; LazyFrame\n</code></pre> <p>Load the table as a polars LazyFrame.</p> Source code in <code>ngio/tables/_abstract_table.py</code> <pre><code>def load_as_polars_lf(self) -&gt; pl.LazyFrame:\n    \"\"\"Load the table as a polars LazyFrame.\"\"\"\n    if self._table_backend is None:\n        raise NgioValueError(\"No backend set for the table.\")\n    return self._table_backend.load_as_polars_lf()\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.GenericTable.set_table_data","title":"set_table_data","text":"<pre><code>set_table_data(\n    table_data: TabularData | None = None,\n    refresh: bool = False,\n) -&gt; None\n</code></pre> <p>Set the table.</p> <p>If an object is passed, it will be used as the table. If None is passed, the table will be loaded from the backend.</p> <p>If refresh is True, the table will be reloaded from the backend.     If table is not None, this will be ignored.</p> Source code in <code>ngio/tables/_abstract_table.py</code> <pre><code>def set_table_data(\n    self,\n    table_data: TabularData | None = None,\n    refresh: bool = False,\n) -&gt; None:\n    \"\"\"Set the table.\n\n    If an object is passed, it will be used as the table.\n    If None is passed, the table will be loaded from the backend.\n\n    If refresh is True, the table will be reloaded from the backend.\n        If table is not None, this will be ignored.\n    \"\"\"\n    if table_data is not None:\n        if not isinstance(table_data, TabularData):\n            raise NgioValueError(\n                \"The table must be a pandas DataFrame, polars LazyFrame, \"\n                \" or AnnData object.\"\n            )\n\n        self._table_data = normalize_table(\n            table_data,\n            index_key=self.index_key,\n            index_type=self.index_type,\n        )\n        return None\n\n    if self._table_data is not None and not refresh:\n        return None\n\n    if self._table_backend is None:\n        raise NgioValueError(\n            \"The table does not have a DataFrame in memory nor a backend.\"\n        )\n    self._table_data = self._table_backend.load()\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.GenericTable.set_backend","title":"set_backend","text":"<pre><code>set_backend(\n    handler: ZarrGroupHandler | None = None,\n    backend: TableBackend = DefaultTableBackend,\n) -&gt; None\n</code></pre> <p>Set the backend of the table.</p> Source code in <code>ngio/tables/_abstract_table.py</code> <pre><code>def set_backend(\n    self,\n    handler: ZarrGroupHandler | None = None,\n    backend: TableBackend = DefaultTableBackend,\n) -&gt; None:\n    \"\"\"Set the backend of the table.\"\"\"\n    if handler is None:\n        if self._table_backend is None:\n            raise NgioValueError(\n                \"No backend set for the table yet. \"\n                \"A ZarrGroupHandler must be provided.\"\n            )\n        handler = self._table_backend.group_handler\n\n    meta = self._meta\n    _backend = self._load_backend(\n        meta=meta,\n        handler=handler,\n        backend=backend,\n    )\n    self._table_backend = _backend\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.GenericTable.from_table_data","title":"from_table_data  <code>classmethod</code>","text":"<pre><code>from_table_data(\n    table_data: TabularData, meta: BackendMeta\n) -&gt; Self\n</code></pre> <p>Create a new ROI table from a Zarr group handler.</p> Source code in <code>ngio/tables/_abstract_table.py</code> <pre><code>@classmethod\ndef from_table_data(cls, table_data: TabularData, meta: BackendMeta) -&gt; Self:\n    \"\"\"Create a new ROI table from a Zarr group handler.\"\"\"\n    return cls(\n        table_data=table_data,\n        meta=meta,\n    )\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.GenericTable.consolidate","title":"consolidate","text":"<pre><code>consolidate() -&gt; None\n</code></pre> <p>Write the current state of the table to the Zarr file.</p> Source code in <code>ngio/tables/_abstract_table.py</code> <pre><code>def consolidate(self) -&gt; None:\n    \"\"\"Write the current state of the table to the Zarr file.\"\"\"\n    if self._table_backend is None:\n        raise NgioValueError(\n            \"No backend set for the table. \"\n            \"Please add the table to a OME-Zarr Image before calling consolidate.\"\n        )\n\n    self._table_backend.write(\n        self.table_data,\n        metadata=self._meta.model_dump(exclude_none=True),\n    )\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.GenericTable.table_type","title":"table_type  <code>staticmethod</code>","text":"<pre><code>table_type() -&gt; str\n</code></pre> <p>Return the type of the table.</p> Source code in <code>ngio/tables/v1/_generic_table.py</code> <pre><code>@staticmethod\ndef table_type() -&gt; str:\n    \"\"\"Return the type of the table.\"\"\"\n    return \"generic_table\"\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.GenericTable.version","title":"version  <code>staticmethod</code>","text":"<pre><code>version() -&gt; str\n</code></pre> <p>The generic table does not have a version.</p> <p>Since does not follow a specific schema.</p> Source code in <code>ngio/tables/v1/_generic_table.py</code> <pre><code>@staticmethod\ndef version() -&gt; str:\n    \"\"\"The generic table does not have a version.\n\n    Since does not follow a specific schema.\n    \"\"\"\n    return \"1\"\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.GenericTable.from_handler","title":"from_handler  <code>classmethod</code>","text":"<pre><code>from_handler(\n    handler: ZarrGroupHandler,\n    backend: TableBackend | None = None,\n) -&gt; GenericTable\n</code></pre> Source code in <code>ngio/tables/v1/_generic_table.py</code> <pre><code>@classmethod\ndef from_handler(\n    cls,\n    handler: ZarrGroupHandler,\n    backend: TableBackend | None = None,\n) -&gt; \"GenericTable\":\n    return cls._from_handler(\n        handler=handler,\n        backend=backend,\n        meta_model=BackendMeta,\n    )\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.open_table","title":"open_table","text":"<pre><code>open_table(\n    store: StoreOrGroup,\n    backend: TableBackend | None = None,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n) -&gt; Table\n</code></pre> <p>Open a table from a Zarr store.</p> Source code in <code>ngio/tables/_tables_container.py</code> <pre><code>def open_table(\n    store: StoreOrGroup,\n    backend: TableBackend | None = None,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n) -&gt; Table:\n    \"\"\"Open a table from a Zarr store.\"\"\"\n    handler = ZarrGroupHandler(\n        store=store,\n        cache=cache,\n        mode=mode,\n    )\n    meta = _get_meta(handler)\n    return ImplementedTables().get_table(\n        meta=meta, handler=handler, backend=backend, strict=False\n    )\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.open_table_as","title":"open_table_as","text":"<pre><code>open_table_as(\n    store: StoreOrGroup,\n    table_cls: type[TableType],\n    backend: TableBackend | None = None,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n) -&gt; TableType\n</code></pre> <p>Open a table from a Zarr store as a specific type.</p> Source code in <code>ngio/tables/_tables_container.py</code> <pre><code>def open_table_as(\n    store: StoreOrGroup,\n    table_cls: type[TableType],\n    backend: TableBackend | None = None,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n) -&gt; TableType:\n    \"\"\"Open a table from a Zarr store as a specific type.\"\"\"\n    handler = ZarrGroupHandler(\n        store=store,\n        cache=cache,\n        mode=mode,\n    )\n    return table_cls.from_handler(\n        handler=handler,\n        backend=backend,\n    )  # type: ignore[return-value]\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.open_tables_container","title":"open_tables_container","text":"<pre><code>open_tables_container(\n    store: StoreOrGroup,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n) -&gt; TablesContainer\n</code></pre> <p>Open a table handler from a Zarr store.</p> Source code in <code>ngio/tables/_tables_container.py</code> <pre><code>def open_tables_container(\n    store: StoreOrGroup,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n) -&gt; TablesContainer:\n    \"\"\"Open a table handler from a Zarr store.\"\"\"\n    handler = ZarrGroupHandler(store=store, cache=cache, mode=mode)\n    return TablesContainer(handler)\n</code></pre>"},{"location":"api/ngio/transforms/","title":"ngio.transforms API documentation","text":""},{"location":"api/ngio/transforms/#ngio.transforms","title":"ngio.transforms","text":"<p>Concrete IO transformations.</p>"},{"location":"api/ngio/transforms/#ngio.transforms.ZoomTransform","title":"ZoomTransform","text":"<pre><code>ZoomTransform(\n    input_image: AbstractImage,\n    target_image: AbstractImage,\n    order: InterpolationOrder = \"nearest\",\n)\n</code></pre> <p>               Bases: <code>BaseZoomTransform</code></p> Source code in <code>ngio/transforms/_zoom.py</code> <pre><code>def __init__(\n    self,\n    input_image: AbstractImage,\n    target_image: AbstractImage,\n    order: InterpolationOrder = \"nearest\",\n) -&gt; None:\n    super().__init__(\n        input_dimensions=input_image.dimensions,\n        target_dimensions=target_image.dimensions,\n        order=order,\n    )\n</code></pre>"},{"location":"api/ngio/transforms/#ngio.transforms.ZoomTransform.get_as_numpy_transform","title":"get_as_numpy_transform","text":"<pre><code>get_as_numpy_transform(\n    array: ndarray,\n    slicing_ops: SlicingOps,\n    axes_ops: AxesOps,\n) -&gt; ndarray\n</code></pre> <p>Apply the scaling transformation to a numpy array.</p> Source code in <code>ngio/io_pipes/_zoom_transform.py</code> <pre><code>def get_as_numpy_transform(\n    self, array: np.ndarray, slicing_ops: SlicingOps, axes_ops: AxesOps\n) -&gt; np.ndarray:\n    \"\"\"Apply the scaling transformation to a numpy array.\"\"\"\n    target_shape = self._compute_zoom_shape(\n        array_shape=array.shape, axes_ops=axes_ops, slicing_ops=slicing_ops\n    )\n    return self._numpy_zoom(array=array, target_shape=target_shape)\n</code></pre>"},{"location":"api/ngio/transforms/#ngio.transforms.ZoomTransform.get_as_dask_transform","title":"get_as_dask_transform","text":"<pre><code>get_as_dask_transform(\n    array: Array, slicing_ops: SlicingOps, axes_ops: AxesOps\n) -&gt; Array\n</code></pre> <p>Apply the scaling transformation to a dask array.</p> Source code in <code>ngio/io_pipes/_zoom_transform.py</code> <pre><code>def get_as_dask_transform(\n    self, array: da.Array, slicing_ops: SlicingOps, axes_ops: AxesOps\n) -&gt; da.Array:\n    \"\"\"Apply the scaling transformation to a dask array.\"\"\"\n    array_shape = tuple(int(s) for s in array.shape)\n    target_shape = self._compute_zoom_shape(\n        array_shape=array_shape, axes_ops=axes_ops, slicing_ops=slicing_ops\n    )\n    return self._dask_zoom(\n        array=array, array_shape=array_shape, target_shape=target_shape\n    )\n</code></pre>"},{"location":"api/ngio/transforms/#ngio.transforms.ZoomTransform.set_as_numpy_transform","title":"set_as_numpy_transform","text":"<pre><code>set_as_numpy_transform(\n    array: ndarray,\n    slicing_ops: SlicingOps,\n    axes_ops: AxesOps,\n) -&gt; ndarray\n</code></pre> <p>Apply the inverse scaling transformation to a numpy array.</p> Source code in <code>ngio/io_pipes/_zoom_transform.py</code> <pre><code>def set_as_numpy_transform(\n    self, array: np.ndarray, slicing_ops: SlicingOps, axes_ops: AxesOps\n) -&gt; np.ndarray:\n    \"\"\"Apply the inverse scaling transformation to a numpy array.\"\"\"\n    target_shape = self._compute_inverse_zoom_shape(\n        array_shape=array.shape, axes_ops=axes_ops, slicing_ops=slicing_ops\n    )\n    return self._numpy_zoom(array=array, target_shape=target_shape)\n</code></pre>"},{"location":"api/ngio/transforms/#ngio.transforms.ZoomTransform.set_as_dask_transform","title":"set_as_dask_transform","text":"<pre><code>set_as_dask_transform(\n    array: Array, slicing_ops: SlicingOps, axes_ops: AxesOps\n) -&gt; Array\n</code></pre> <p>Apply the inverse scaling transformation to a dask array.</p> Source code in <code>ngio/io_pipes/_zoom_transform.py</code> <pre><code>def set_as_dask_transform(\n    self, array: da.Array, slicing_ops: SlicingOps, axes_ops: AxesOps\n) -&gt; da.Array:\n    \"\"\"Apply the inverse scaling transformation to a dask array.\"\"\"\n    array_shape = tuple(int(s) for s in array.shape)\n    target_shape = self._compute_inverse_zoom_shape(\n        array_shape=array_shape, axes_ops=axes_ops, slicing_ops=slicing_ops\n    )\n    return self._dask_zoom(\n        array=array, array_shape=array_shape, target_shape=target_shape\n    )\n</code></pre>"},{"location":"api/ngio/utils/","title":"ngio.utils","text":""},{"location":"api/ngio/utils/#ngio.utils","title":"ngio.utils","text":"<p>Various utilities for the ngio package.</p>"},{"location":"api/ngio/utils/#ngio.utils.AccessModeLiteral","title":"AccessModeLiteral  <code>module-attribute</code>","text":"<pre><code>AccessModeLiteral = Literal['r', 'r+', 'w', 'w-', 'a']\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.NgioSupportedStore","title":"NgioSupportedStore  <code>module-attribute</code>","text":"<pre><code>NgioSupportedStore: TypeAlias = (\n    str\n    | Path\n    | FSMap\n    | FsspecStore\n    | MemoryStore\n    | dict\n    | LocalStore\n)\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.StoreOrGroup","title":"StoreOrGroup  <code>module-attribute</code>","text":"<pre><code>StoreOrGroup: TypeAlias = NgioSupportedStore | Group\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.NgioError","title":"NgioError","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for all errors in the NGFF project.</p>"},{"location":"api/ngio/utils/#ngio.utils.NgioFileExistsError","title":"NgioFileExistsError","text":"<p>               Bases: <code>NgioError</code>, <code>FileExistsError</code></p> <p>Error raised when a file already exists.</p>"},{"location":"api/ngio/utils/#ngio.utils.NgioFileNotFoundError","title":"NgioFileNotFoundError","text":"<p>               Bases: <code>NgioError</code>, <code>FileNotFoundError</code></p> <p>Error raised when a file is not found.</p>"},{"location":"api/ngio/utils/#ngio.utils.NgioTableValidationError","title":"NgioTableValidationError","text":"<p>               Bases: <code>NgioError</code></p> <p>Error raised when a table does not pass validation.</p>"},{"location":"api/ngio/utils/#ngio.utils.NgioValidationError","title":"NgioValidationError","text":"<p>               Bases: <code>NgioError</code>, <code>ValueError</code></p> <p>Generic error raised when a file does not pass validation.</p>"},{"location":"api/ngio/utils/#ngio.utils.NgioValueError","title":"NgioValueError","text":"<p>               Bases: <code>NgioError</code>, <code>ValueError</code></p> <p>Error raised when a value does not pass a run time test.</p>"},{"location":"api/ngio/utils/#ngio.utils.NgioCache","title":"NgioCache","text":"<pre><code>NgioCache(use_cache: bool = True)\n</code></pre> <p>               Bases: <code>Generic[T]</code></p> <p>A simple cache for NGIO objects.</p> Source code in <code>ngio/utils/_cache.py</code> <pre><code>def __init__(self, use_cache: bool = True):\n    self._cache: dict[str, T] = {}\n    self._use_cache = use_cache\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.NgioCache.use_cache","title":"use_cache  <code>property</code>","text":"<pre><code>use_cache: bool\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.NgioCache.cache","title":"cache  <code>property</code>","text":"<pre><code>cache: dict[str, T]\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.NgioCache.is_empty","title":"is_empty  <code>property</code>","text":"<pre><code>is_empty: bool\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.NgioCache.get","title":"get","text":"<pre><code>get(key: str, default: T | None = None) -&gt; T | None\n</code></pre> Source code in <code>ngio/utils/_cache.py</code> <pre><code>def get(self, key: str, default: T | None = None) -&gt; T | None:\n    if not self._use_cache:\n        self._cache_sanity_check()\n        return default\n    return self._cache.get(key, default)\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.NgioCache.set","title":"set","text":"<pre><code>set(key: str, value: T, overwrite: bool = True) -&gt; None\n</code></pre> Source code in <code>ngio/utils/_cache.py</code> <pre><code>def set(self, key: str, value: T, overwrite: bool = True) -&gt; None:\n    if not self._use_cache:\n        self._cache_sanity_check()\n        return\n    self._cache[key] = value\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.NgioCache.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> Source code in <code>ngio/utils/_cache.py</code> <pre><code>def clear(self) -&gt; None:\n    if not self._use_cache:\n        self._cache_sanity_check()\n        return\n    self._cache.clear()\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler","title":"ZarrGroupHandler","text":"<pre><code>ZarrGroupHandler(\n    store: StoreOrGroup,\n    zarr_format: Literal[2, 3] | None = None,\n    cache: bool = False,\n    mode: AccessModeLiteral | None = None,\n)\n</code></pre> <p>A simple wrapper around a Zarr group to handle metadata.</p> <p>Initialize the handler.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group containing the image data.</p> </li> <li> <code>zarr_format</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The Zarr format version to use.</p> </li> <li> <code>cache</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to cache the metadata.</p> </li> <li> <code>mode</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The mode of the store.</p> </li> </ul> Source code in <code>ngio/utils/_zarr_utils.py</code> <pre><code>def __init__(\n    self,\n    store: StoreOrGroup,\n    zarr_format: Literal[2, 3] | None = None,\n    cache: bool = False,\n    mode: AccessModeLiteral | None = None,\n):\n    \"\"\"Initialize the handler.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group containing the image data.\n        zarr_format (int | None): The Zarr format version to use.\n        cache (bool): Whether to cache the metadata.\n        mode (str | None): The mode of the store.\n    \"\"\"\n    if mode not in [\"r\", \"r+\", \"w\", \"w-\", \"a\", None]:\n        raise NgioValueError(f\"Mode {mode} is not supported.\")\n\n    group = open_group_wrapper(store=store, mode=mode, zarr_format=zarr_format)\n    self._group = group\n    self.use_cache = cache\n\n    self._group_cache: NgioCache[zarr.Group] = NgioCache(use_cache=cache)\n    self._array_cache: NgioCache[zarr.Array] = NgioCache(use_cache=cache)\n    self._handlers_cache: NgioCache[ZarrGroupHandler] = NgioCache(use_cache=cache)\n    self._lock: tuple[Path, BaseFileLock] | None = None\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler.use_cache","title":"use_cache  <code>instance-attribute</code>","text":"<pre><code>use_cache = cache\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler.store","title":"store  <code>property</code>","text":"<pre><code>store: Store\n</code></pre> <p>Return the store of the group.</p>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler.full_url","title":"full_url  <code>property</code>","text":"<pre><code>full_url: str | None\n</code></pre> <p>Return the store path.</p>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler.zarr_format","title":"zarr_format  <code>property</code>","text":"<pre><code>zarr_format: Literal[2, 3]\n</code></pre> <p>Return the Zarr format version.</p>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler.read_only","title":"read_only  <code>property</code>","text":"<pre><code>read_only: bool\n</code></pre> <p>Return whether the group is read only.</p>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler.lock","title":"lock  <code>property</code>","text":"<pre><code>lock: BaseFileLock\n</code></pre> <p>Return the lock.</p>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler.lock_path","title":"lock_path  <code>property</code>","text":"<pre><code>lock_path: Path\n</code></pre> <p>Return the lock path.</p>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler.group","title":"group  <code>property</code>","text":"<pre><code>group: Group\n</code></pre> <p>Return the group.</p>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler.is_listable","title":"is_listable  <code>property</code>","text":"<pre><code>is_listable: bool\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler.remove_lock","title":"remove_lock","text":"<pre><code>remove_lock() -&gt; None\n</code></pre> <p>Return the lock.</p> Source code in <code>ngio/utils/_zarr_utils.py</code> <pre><code>def remove_lock(self) -&gt; None:\n    \"\"\"Return the lock.\"\"\"\n    if self._lock is None:\n        return None\n\n    lock_path, lock = self._lock\n    if lock_path.exists() and lock.lock_counter == 0:\n        lock_path.unlink()\n        self._lock = None\n        return None\n\n    raise NgioValueError(\"The lock is still in use. Cannot remove it.\")\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler.reopen_group","title":"reopen_group","text":"<pre><code>reopen_group() -&gt; Group\n</code></pre> <p>Reopen the group.</p> <p>This is useful when the group has been modified outside of the handler.</p> Source code in <code>ngio/utils/_zarr_utils.py</code> <pre><code>def reopen_group(self) -&gt; zarr.Group:\n    \"\"\"Reopen the group.\n\n    This is useful when the group has been modified\n    outside of the handler.\n    \"\"\"\n    mode = \"r\" if self.read_only else \"r+\"\n    return zarr.open_group(\n        store=self._group.store,\n        path=self._group.path,\n        mode=mode,\n        zarr_format=self._group.metadata.zarr_format,\n    )\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler.reopen_handler","title":"reopen_handler","text":"<pre><code>reopen_handler() -&gt; ZarrGroupHandler\n</code></pre> <p>Reopen the handler.</p> <p>This is useful when the group has been modified outside of the handler.</p> Source code in <code>ngio/utils/_zarr_utils.py</code> <pre><code>def reopen_handler(self) -&gt; \"ZarrGroupHandler\":\n    \"\"\"Reopen the handler.\n\n    This is useful when the group has been modified\n    outside of the handler.\n    \"\"\"\n    mode = \"r\" if self.read_only else \"r+\"\n    group = self.reopen_group()\n    return ZarrGroupHandler(\n        store=group,\n        zarr_format=group.metadata.zarr_format,\n        cache=self.use_cache,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler.clean_cache","title":"clean_cache","text":"<pre><code>clean_cache() -&gt; None\n</code></pre> <p>Clear the cached metadata.</p> Source code in <code>ngio/utils/_zarr_utils.py</code> <pre><code>def clean_cache(self) -&gt; None:\n    \"\"\"Clear the cached metadata.\"\"\"\n    group = self.reopen_group()\n    self.__init__(\n        store=group,\n        zarr_format=group.metadata.zarr_format,\n        cache=self.use_cache,\n        mode=\"r\" if self.read_only else \"r+\",\n    )\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler.load_attrs","title":"load_attrs","text":"<pre><code>load_attrs() -&gt; dict\n</code></pre> <p>Load the attributes of the group.</p> Source code in <code>ngio/utils/_zarr_utils.py</code> <pre><code>def load_attrs(self) -&gt; dict:\n    \"\"\"Load the attributes of the group.\"\"\"\n    return self.reopen_group().attrs.asdict()\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler.write_attrs","title":"write_attrs","text":"<pre><code>write_attrs(attrs: dict, overwrite: bool = False) -&gt; None\n</code></pre> <p>Write the metadata to the store.</p> Source code in <code>ngio/utils/_zarr_utils.py</code> <pre><code>def write_attrs(self, attrs: dict, overwrite: bool = False) -&gt; None:\n    \"\"\"Write the metadata to the store.\"\"\"\n    # Maybe we should use the lock here\n    if self.read_only:\n        raise NgioValueError(\"The group is read only. Cannot write metadata.\")\n    group = self.reopen_group()\n    if overwrite:\n        group.attrs.clear()\n    group.attrs.update(attrs)\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler.create_group","title":"create_group","text":"<pre><code>create_group(path: str, overwrite: bool = False) -&gt; Group\n</code></pre> <p>Create a group in the group.</p> Source code in <code>ngio/utils/_zarr_utils.py</code> <pre><code>def create_group(self, path: str, overwrite: bool = False) -&gt; zarr.Group:\n    \"\"\"Create a group in the group.\"\"\"\n    if self.group.read_only:\n        raise NgioValueError(\"Cannot create a group in read only mode.\")\n\n    try:\n        group = self.group.create_group(path, overwrite=overwrite)\n    except ContainsGroupError as e:\n        raise NgioFileExistsError(\n            f\"A Zarr group already exists at {path}, \"\n            \"consider setting overwrite=True.\"\n        ) from e\n    self._group_cache.set(path, group, overwrite=overwrite)\n    return group\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler.get_group","title":"get_group","text":"<pre><code>get_group(\n    path: str,\n    create_mode: bool = False,\n    overwrite: bool = False,\n) -&gt; Group\n</code></pre> <p>Get a group from the group.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path to the group.</p> </li> <li> <code>create_mode</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, create the group if it does not exist.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, overwrite the group if it exists.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Group</code>           \u2013            <p>zarr.Group: The Zarr group.</p> </li> </ul> Source code in <code>ngio/utils/_zarr_utils.py</code> <pre><code>def get_group(\n    self,\n    path: str,\n    create_mode: bool = False,\n    overwrite: bool = False,\n) -&gt; zarr.Group:\n    \"\"\"Get a group from the group.\n\n    Args:\n        path (str): The path to the group.\n        create_mode (bool): If True, create the group if it does not exist.\n        overwrite (bool): If True, overwrite the group if it exists.\n\n    Returns:\n        zarr.Group: The Zarr group.\n\n    \"\"\"\n    if overwrite and not create_mode:\n        raise NgioValueError(\"Cannot overwrite a group without create_mode=True.\")\n\n    if overwrite:\n        return self.create_group(path, overwrite=overwrite)\n\n    group = self._group_cache.get(path)\n    if isinstance(group, zarr.Group):\n        return group\n\n    group = self.group.get(path, default=None)\n    if isinstance(group, zarr.Group):\n        self._group_cache.set(path, group, overwrite=overwrite)\n        return group\n\n    if isinstance(group, zarr.Array):\n        raise NgioValueError(f\"The object at {path} is not a group, but an array.\")\n\n    if not create_mode:\n        raise NgioFileNotFoundError(f\"No group found at {path}\")\n    group = self.create_group(path)\n    self._group_cache.set(path, group, overwrite=overwrite)\n    return group\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler.get_array","title":"get_array","text":"<pre><code>get_array(path: str) -&gt; Array\n</code></pre> <p>Get an array from the group.</p> Source code in <code>ngio/utils/_zarr_utils.py</code> <pre><code>def get_array(self, path: str) -&gt; zarr.Array:\n    \"\"\"Get an array from the group.\"\"\"\n    array = self._array_cache.get(path)\n    if isinstance(array, zarr.Array):\n        return array\n    array = self.group.get(path, default=None)\n    if isinstance(array, zarr.Array):\n        self._array_cache.set(path, array)\n        return array\n\n    if isinstance(array, zarr.Group):\n        raise NgioValueError(f\"The object at {path} is not an array, but a group.\")\n    raise NgioFileNotFoundError(f\"No array found at {path}\")\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler.get_handler","title":"get_handler","text":"<pre><code>get_handler(\n    path: str,\n    create_mode: bool = True,\n    overwrite: bool = False,\n) -&gt; ZarrGroupHandler\n</code></pre> <p>Get a new handler for a group in the current handler group.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path to the group.</p> </li> <li> <code>create_mode</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, create the group if it does not exist.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, overwrite the group if it exists.</p> </li> </ul> Source code in <code>ngio/utils/_zarr_utils.py</code> <pre><code>def get_handler(\n    self,\n    path: str,\n    create_mode: bool = True,\n    overwrite: bool = False,\n) -&gt; \"ZarrGroupHandler\":\n    \"\"\"Get a new handler for a group in the current handler group.\n\n    Args:\n        path (str): The path to the group.\n        create_mode (bool): If True, create the group if it does not exist.\n        overwrite (bool): If True, overwrite the group if it exists.\n    \"\"\"\n    handler = self._handlers_cache.get(path)\n    if handler is not None:\n        return handler\n    group = self.get_group(path, create_mode=create_mode, overwrite=overwrite)\n    mode = \"r\" if group.read_only else \"r+\"\n    handler = ZarrGroupHandler(\n        store=group, zarr_format=self.zarr_format, cache=self.use_cache, mode=mode\n    )\n    self._handlers_cache.set(path, handler)\n    return handler\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler.delete_group","title":"delete_group","text":"<pre><code>delete_group(path: str) -&gt; None\n</code></pre> <p>Delete a group from the current group.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path to the group to delete.</p> </li> </ul> Source code in <code>ngio/utils/_zarr_utils.py</code> <pre><code>def delete_group(self, path: str) -&gt; None:\n    \"\"\"Delete a group from the current group.\n\n    Args:\n        path (str): The path to the group to delete.\n    \"\"\"\n    if self.group.read_only:\n        raise NgioValueError(\"Cannot delete a group in read only mode.\")\n    self.group.__delitem__(path)\n    self._group_cache._cache.pop(path, None)\n    self._handlers_cache._cache.pop(path, None)\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler.delete_self","title":"delete_self","text":"<pre><code>delete_self() -&gt; None\n</code></pre> <p>Delete the current group.</p> Source code in <code>ngio/utils/_zarr_utils.py</code> <pre><code>def delete_self(self) -&gt; None:\n    \"\"\"Delete the current group.\"\"\"\n    if self.group.read_only:\n        raise NgioValueError(\"Cannot delete a group in read only mode.\")\n    self.group.__delitem__(\"/\")\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler.copy_group","title":"copy_group","text":"<pre><code>copy_group(dest_group: Group)\n</code></pre> <p>Copy the group to a new store.</p> Source code in <code>ngio/utils/_zarr_utils.py</code> <pre><code>def copy_group(self, dest_group: zarr.Group):\n    \"\"\"Copy the group to a new store.\"\"\"\n    copy_group(self.group, dest_group)\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.download_ome_zarr_dataset","title":"download_ome_zarr_dataset","text":"<pre><code>download_ome_zarr_dataset(\n    dataset_name: AVAILABLE_DATASETS | str,\n    download_dir: str | Path = \"data\",\n    re_unzip: bool = True,\n    progressbar: bool = False,\n) -&gt; Path\n</code></pre> <p>Download an OME-Zarr dataset.</p> <p>To list available datasets, use <code>list_ome_zarr_datasets</code>.</p> <p>Parameters:</p> <ul> <li> <code>dataset_name</code>               (<code>str</code>)           \u2013            <p>The dataset name.</p> </li> <li> <code>download_dir</code>               (<code>str</code>, default:                   <code>'data'</code> )           \u2013            <p>The download directory. Defaults to \"data\".</p> </li> <li> <code>re_unzip</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, it will unzip the dataset even if it already exists.</p> </li> <li> <code>progressbar</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, show a progress bar during download.</p> </li> </ul> Source code in <code>ngio/utils/_datasets.py</code> <pre><code>def download_ome_zarr_dataset(\n    dataset_name: AVAILABLE_DATASETS | str,\n    download_dir: str | Path = \"data\",\n    re_unzip: bool = True,\n    progressbar: bool = False,\n) -&gt; Path:\n    \"\"\"Download an OME-Zarr dataset.\n\n    To list available datasets, use `list_ome_zarr_datasets`.\n\n    Args:\n        dataset_name (str): The dataset name.\n        download_dir (str): The download directory. Defaults to \"data\".\n        re_unzip (bool): If True, it will unzip the dataset even if it already exists.\n        progressbar (bool): If True, show a progress bar during download.\n    \"\"\"\n    if dataset_name not in _ome_zarr_zoo:\n        raise NgioValueError(f\"Dataset {dataset_name} not found in the OME-Zarr zoo.\")\n    zenodo_infos = _ome_zarr_zoo[dataset_name]\n\n    fname = zenodo_infos[\"fname\"]\n    zarrname = fname.replace(\".zip\", \"\")\n\n    processor = UnzipAndRename(\n        extract_dir=\"\",\n        out_name=zarrname,\n        re_unzip=re_unzip,\n    )\n\n    pooch.retrieve(\n        url=zenodo_infos[\"url\"],\n        known_hash=zenodo_infos[\"known_hash\"],\n        fname=fname,\n        path=download_dir,\n        processor=processor,\n        progressbar=progressbar,\n        # Add User-Agent to avoid 403 errors from Zenodo\n        downloader=pooch.HTTPDownloader(\n            headers={\n                \"User-Agent\": f\"pooch/{pooch.__version__} (https://github.com/BioVisionCenter/ngio)\"\n            }\n        ),\n    )\n    return processor.output_file()\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.list_ome_zarr_datasets","title":"list_ome_zarr_datasets","text":"<pre><code>list_ome_zarr_datasets() -&gt; list[str]\n</code></pre> <p>List available OME-Zarr datasets.</p> Source code in <code>ngio/utils/_datasets.py</code> <pre><code>def list_ome_zarr_datasets() -&gt; list[str]:\n    \"\"\"List available OME-Zarr datasets.\"\"\"\n    return list(_ome_zarr_zoo.keys())\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.print_datasets_infos","title":"print_datasets_infos","text":"<pre><code>print_datasets_infos() -&gt; None\n</code></pre> Source code in <code>ngio/utils/_datasets.py</code> <pre><code>def print_datasets_infos() -&gt; None:\n    for dataset_name, dataset_info in _ome_zarr_zoo.items():\n        print(f\"{dataset_name} - Description: {dataset_info['description']}\")\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.fractal_fsspec_store","title":"fractal_fsspec_store","text":"<pre><code>fractal_fsspec_store(\n    url: str,\n    fractal_token: str | None = None,\n    client_kwargs: dict | None = None,\n) -&gt; FSMap\n</code></pre> <p>Simple function to get an http fsspec store from a url.</p> Source code in <code>ngio/utils/_fractal_fsspec_store.py</code> <pre><code>def fractal_fsspec_store(\n    url: str, fractal_token: str | None = None, client_kwargs: dict | None = None\n) -&gt; fsspec.mapping.FSMap:\n    \"\"\"Simple function to get an http fsspec store from a url.\"\"\"\n    client_kwargs = {} if client_kwargs is None else client_kwargs\n    if fractal_token is not None:\n        client_kwargs[\"headers\"] = {\"Authorization\": f\"Bearer {fractal_token}\"}\n    fs = fsspec.implementations.http.HTTPFileSystem(client_kwargs=client_kwargs)\n\n    store = fs.get_mapper(url)\n\n    possible_keys = [\".zgroup\", \".zarray\"]\n    for key in possible_keys:\n        try:\n            value = store.get(key)\n            if value is not None:\n                break\n        except ClientResponseError as e:\n            if e.status == 401 and fractal_token is None:\n                raise NgioValueError(\n                    \"No auto token is provided. You need a valid \"\n                    f\"'fractal_token' to access: {url}.\"\n                ) from e\n            elif e.status == 401 and fractal_token is not None:\n                raise NgioValueError(\n                    f\"The 'fractal_token' provided is invalid for: {url}.\"\n                ) from e\n            else:\n                raise e\n    else:\n        raise NgioValueError(\n            f\"Store {url} can not be read. Possible problems are: \\n\"\n            \"- The url does not exist. \\n\"\n            \"- The url is not a valid .zarr. \\n\"\n        )\n    return store\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.copy_group","title":"copy_group","text":"<pre><code>copy_group(\n    src_group: Group,\n    dest_group: Group,\n    suppress_warnings: bool = False,\n)\n</code></pre> Source code in <code>ngio/utils/_zarr_utils.py</code> <pre><code>def copy_group(\n    src_group: zarr.Group, dest_group: zarr.Group, suppress_warnings: bool = False\n):\n    if src_group.metadata.zarr_format != dest_group.metadata.zarr_format:\n        raise NgioValueError(\n            \"Different Zarr format versions between source and destination, \"\n            \"cannot copy.\"\n        )\n\n    if not is_group_listable(src_group):\n        raise NgioValueError(\"Source group is not listable, cannot copy.\")\n\n    if dest_group.read_only:\n        raise NgioValueError(\"Destination group is read only, cannot copy.\")\n    if isinstance(src_group.store, LocalStore | FsspecStore) and isinstance(\n        dest_group.store, LocalStore | FsspecStore\n    ):\n        _fsspec_copy(src_group.store, src_group.path, dest_group.store, dest_group.path)\n        return\n    if not suppress_warnings:\n        logger.warning(\n            \"Fsspec copy not possible, falling back to Zarr Python API for the copy. \"\n            \"This will preserve some tabular data non-zarr native (parquet, and csv), \"\n            \"and it will be slower for large datasets.\"\n        )\n    _zarr_python_copy(src_group, dest_group)\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.open_group_wrapper","title":"open_group_wrapper","text":"<pre><code>open_group_wrapper(\n    store: StoreOrGroup,\n    mode: AccessModeLiteral | None = None,\n    zarr_format: Literal[2, 3] | None = None,\n) -&gt; Group\n</code></pre> <p>Wrapper around zarr.open_group with some additional checks.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The store or group to open.</p> </li> <li> <code>mode</code>               (<code>AccessModeLiteral</code>, default:                   <code>None</code> )           \u2013            <p>The mode to open the group in.</p> </li> <li> <code>zarr_format</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The Zarr format version to use.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Group</code>           \u2013            <p>zarr.Group: The opened Zarr group.</p> </li> </ul> Source code in <code>ngio/utils/_zarr_utils.py</code> <pre><code>def open_group_wrapper(\n    store: StoreOrGroup,\n    mode: AccessModeLiteral | None = None,\n    zarr_format: Literal[2, 3] | None = None,\n) -&gt; zarr.Group:\n    \"\"\"Wrapper around zarr.open_group with some additional checks.\n\n    Args:\n        store (StoreOrGroup): The store or group to open.\n        mode (AccessModeLiteral): The mode to open the group in.\n        zarr_format (int): The Zarr format version to use.\n\n    Returns:\n        zarr.Group: The opened Zarr group.\n    \"\"\"\n    if isinstance(store, zarr.Group):\n        group = _check_group(store, mode)\n        _check_store(group.store)\n        return group\n\n    try:\n        _check_store(store)\n        mode = mode if mode is not None else \"a\"\n        group = zarr.open_group(store=store, mode=mode, zarr_format=zarr_format)\n\n    except FileExistsError as e:\n        raise NgioFileExistsError(\n            f\"A Zarr group already exists at {store}, consider setting overwrite=True.\"\n        ) from e\n\n    except FileNotFoundError as e:\n        raise NgioFileNotFoundError(f\"No Zarr group found at {store}\") from e\n\n    except ContainsGroupError as e:\n        raise NgioFileExistsError(\n            f\"A Zarr group already exists at {store}, consider setting overwrite=True.\"\n        ) from e\n\n    return group\n</code></pre>"},{"location":"getting_started/0_quickstart/","title":"Quickstart","text":"<p>Ngio is a Python package that provides a simple and intuitive API for reading and writing data to and from OME-Zarr. This guide will walk you through the basics of using <code>ngio</code> to read and write data.</p>"},{"location":"getting_started/0_quickstart/#installation","title":"Installation","text":"<p><code>ngio</code> can be installed from PyPI, conda-forge, or from source.</p> <ul> <li><code>ngio</code> requires Python <code>&gt;=3.11</code></li> </ul> pipmamba/condaSource <p>The recommended way to install <code>ngio</code> is from PyPI using pip:</p> <pre><code>pip install ngio\n</code></pre> <p>Alternatively, you can install <code>ngio</code> using mamba:</p> <pre><code>mamba install -c conda-forge ngio\n</code></pre> <p>or conda:</p> <pre><code>conda install -c conda-forge ngio\n</code></pre> <ol> <li> <p>Clone the repository: <pre><code>git clone https://github.com/fractal-analytics-platform/ngio.git\ncd ngio\n</code></pre></p> </li> <li> <p>Install the package: <pre><code>pip install .\n</code></pre></p> </li> </ol>"},{"location":"getting_started/0_quickstart/#troubleshooting","title":"Troubleshooting","text":"<p>Please report installation problems by opening an issue on our GitHub repository.</p>"},{"location":"getting_started/0_quickstart/#setup-some-test-data","title":"Setup some test data","text":"<p>Let's start by downloading a sample OME-Zarr dataset to work with.</p> <pre><code>from pathlib import Path\nfrom ngio.utils import download_ome_zarr_dataset\n\n# Download a sample dataset\ndownload_dir = Path(\"./data\")\nhcs_path = download_ome_zarr_dataset(\"CardiomyocyteSmallMip\", download_dir=download_dir)\nimage_path = hcs_path / \"B\" / \"03\" / \"0\"\n</code></pre>"},{"location":"getting_started/0_quickstart/#open-an-ome-zarr-image","title":"Open an OME-Zarr image","text":"<p>Let's start by opening an OME-Zarr file and inspecting its contents.</p> <pre><code>&gt;&gt;&gt; from ngio import open_ome_zarr_container\n&gt;&gt;&gt; ome_zarr_container = open_ome_zarr_container(image_path)\n&gt;&gt;&gt; ome_zarr_container\nOmeZarrContainer(levels=5, #labels=4, #tables=7)\n</code></pre>"},{"location":"getting_started/0_quickstart/#what-is-the-ome-zarr-container","title":"What is the OME-Zarr container?","text":"<p>The <code>OME-Zarr Container</code> is the core of ngio and the entry point to working with OME-Zarr images. It provides high-level access to the image metadata, images, labels, and tables.</p>"},{"location":"getting_started/0_quickstart/#what-is-the-ome-zarr-container-not","title":"What is the OME-Zarr container not?","text":"<p>The <code>OME-Zarr Container</code> object does not allow the user to interact with the image data directly. For that, we need to use the <code>Image</code>, <code>Label</code>, and <code>Table</code> objects.</p>"},{"location":"getting_started/0_quickstart/#next-steps","title":"Next steps","text":"<p>To learn how to work with the <code>OME-Zarr Container</code> object, but also with the image, label, and table data, check out the following guides:</p> <ul> <li>OME-Zarr Container: An overview on how to use the OME-Zarr Container object and how to create new images and labels.</li> <li>Images/Labels: To know more on how to work with image data.</li> <li>Tables: To know more on how to work with table data, and how you can combine tables with image data.</li> <li>Masked Images/Labels: To know more on how to work with masked image data.</li> <li>HCS Plates: To know more on how to work with HCS plate data.</li> </ul> <p>Also, checkout our jupyer notebook tutorials for more examples:</p> <ul> <li>Image Processing: Learn how to perform simple image processing operations.</li> <li>Image Segmentation: Learn how to create new labels from images.</li> <li>Feature Extraction: Learn how to extract features from images.</li> <li>HCS Exploration: Learn how to explore high-content screening data using ngio.</li> </ul>"},{"location":"getting_started/1_ome_zarr_containers/","title":"1. OME-Zarr Container","text":"<p>Let's see how to open and explore an OME-Zarr image using <code>ngio</code>:</p> <pre><code>from pathlib import Path\nfrom ngio import open_ome_zarr_container\nfrom ngio.utils import download_ome_zarr_dataset\n\n# Download a sample dataset\ndownload_dir = Path(\"./data\")\nhcs_path = download_ome_zarr_dataset(\"CardiomyocyteSmallMip\", download_dir=download_dir)\nimage_path = hcs_path / \"B\" / \"03\" / \"0\"\n\n# Open the OME-Zarr container\nome_zarr_container = open_ome_zarr_container(image_path)\n</code></pre> <p>The <code>OME-Zarr Container</code> in is your entry point to working with OME-Zarr images. It provides high-level access to the image metadata, images, labels, and tables.</p> <pre><code>&gt;&gt;&gt; ome_zarr_container\nOmeZarrContainer(levels=5, #labels=4, #tables=7)\n</code></pre> <p>The <code>OME-Zarr Container</code> will be the starting point for all your image processing tasks.</p>"},{"location":"getting_started/1_ome_zarr_containers/#main-concepts","title":"Main concepts","text":""},{"location":"getting_started/1_ome_zarr_containers/#what-is-the-ome-zarr-container","title":"What is the OME-Zarr container?","text":"<p>The <code>OME-Zarr Container</code> in ngio is your entry point to working with OME-Zarr images.</p> <p>It provides:</p> <ul> <li>OME-Zarr overview: get an overview of the OME-Zarr file, including the number of image levels, list of labels, and tables available.</li> <li>Image access: get access to the images at different resolution levels and pixel sizes.</li> <li>Label management: check which labels are available, access them, and create new labels.</li> <li>Table management: check which tables are available, access them, and create new tables.</li> <li>Derive new OME-Zarr images: create new images based on the original one, with the same or similar metadata.</li> </ul>"},{"location":"getting_started/1_ome_zarr_containers/#what-is-the-ome-zarr-container-not","title":"What is the OME-Zarr container not?","text":"<p>The <code>OME-Zarr Container</code> object does not allow the user to interact with the image data directly. For that, we need to use the <code>Image</code>, <code>Label</code>, and <code>Table</code> objects.</p>"},{"location":"getting_started/1_ome_zarr_containers/#ome-zarr-overview","title":"OME-Zarr overview","text":"<p>Examples of the OME-Zarr metadata access:</p> Number of Resolution LevelsAvailable PathsDimensionalityFull Metadata Object <p>Show the number of resolution levels: <pre><code>&gt;&gt;&gt; ome_zarr_container.levels # Show the number of resolution levels\n5\n</code></pre></p> <p>Show the paths to all available resolution levels: <pre><code>&gt;&gt;&gt; ome_zarr_container.level_paths # Show the paths to all available images\n['0', '1', '2', '3', '4']\n</code></pre></p> <p>Show if the image is 2D or 3D: <pre><code>&gt;&gt;&gt; ome_zarr_container.is_3d # Get if the image is 3D\nFalse\n</code></pre> or if the image is a time series: <pre><code>&gt;&gt;&gt; ome_zarr_container.is_time_series # Get if the image is a time series\nFalse\n</code></pre></p> <p><pre><code>&gt;&gt;&gt; metadata = ome_zarr_container.meta\nNgioImageMeta(name=None, datasets=['0', '1', '2', '3', '4'], axes=('c', 'z', 'y', 'x'))\n</code></pre> The metadata object contains all the information about the image, for example, the channel labels: <pre><code>&gt;&gt;&gt; metadata.channels_meta.channel_labels\n['DAPI', 'nanog', 'Lamin B1']\n</code></pre></p>"},{"location":"getting_started/1_ome_zarr_containers/#modifying-metadata","title":"Modifying metadata","text":"<p>ngio provides methods to modify the image metadata, such as channel labels, colors, display windows, axes names, and units.</p>"},{"location":"getting_started/1_ome_zarr_containers/#channel-metadata","title":"Channel metadata","text":"<p>You can update channel labels, colors, and display windows:</p> Channel LabelsChannel ColorsChannel WindowsChannel Windows from Percentiles <p>Update the labels (names) of the channels: <pre><code>&gt;&gt;&gt; ome_zarr_container.set_channel_labels([\"DAPI\", \"GFP\", \"RFP\"])\n</code></pre></p> <p>Update the display colors of the channels (hex format): <pre><code>&gt;&gt;&gt; ome_zarr_container.set_channel_colors([\"0000FF\", \"00FF00\", \"FF0000\"])\n</code></pre></p> <p>Update the display windows (start/end values) for each channel: <pre><code>&gt;&gt;&gt; ome_zarr_container.set_channel_windows([(0, 255), (0, 1000), (0, 500)])\n</code></pre></p> <p>Automatically compute display windows based on data percentiles: <pre><code>&gt;&gt;&gt; ome_zarr_container.set_channel_windows_with_percentiles(percentiles=(0.1, 99.9))\n</code></pre></p>"},{"location":"getting_started/1_ome_zarr_containers/#axes-metadata","title":"Axes metadata","text":"<p>You can update the axes names and units:</p> Axes NamesAxes Units <p>Rename the axes in the metadata: <pre><code>&gt;&gt;&gt; ome_zarr_container.set_axes_names([\"t\", \"c\", \"z\", \"y\", \"x\"])\n</code></pre></p> <p>Set the space and time units: <pre><code>&gt;&gt;&gt; ome_zarr_container.set_axes_units(space_unit=\"micrometer\", time_unit=\"second\")\n</code></pre></p>"},{"location":"getting_started/1_ome_zarr_containers/#image-name","title":"Image name","text":"<p>You can set the name of the image in the metadata:</p> <pre><code>&gt;&gt;&gt; ome_zarr_container.set_name(\"My Processed Image\")\n</code></pre> <p>Note</p> <p>The <code>set_name</code> method only updates the metadata. It does not change the group name or file paths.</p>"},{"location":"getting_started/1_ome_zarr_containers/#accessing-images-labels-tables","title":"Accessing images / labels / tables","text":"<p>To access images, labels, and tables, you can use the <code>get_image</code>, <code>get_label</code>, and <code>get_table</code> methods of the <code>OME-Zarr Container</code> object.</p> <p>A variety of examples and additional information can be found in the Images and Labels, and Tables sections.</p>"},{"location":"getting_started/1_ome_zarr_containers/#creating-derived-images","title":"Creating derived images","text":"<p>When processing an image, you might want to create a new image with the same metadata:</p> <pre><code># Create a new image based on the original\nnew_image = ome_zarr_container.derive_image(\"data/new_ome.zarr\", overwrite=True)\n</code></pre> <p>This will create a new OME-Zarr image with the same metadata as the original image. But you can also create a new image with slightly different metadata, for example, with a different shape:</p> <pre><code># Create a new image with a different shape\nnew_image = ome_zarr_container.derive_image(\n    \"data/new_ome.zarr\", \n    overwrite=True, \n    shape=(16, 128, 128), \n    pixelsize=0.65, \n    z_spacing=1.0\n)\n</code></pre>"},{"location":"getting_started/1_ome_zarr_containers/#creating-new-images","title":"Creating new images","text":"<p>You can create OME-Zarr images from an existing numpy array using the <code>create_ome_zarr_from_array</code> function.</p> <pre><code>import numpy as np\nfrom ngio import create_ome_zarr_from_array\n\n# Create a random 3D array\nx = np.random.randint(0, 255, (16, 128, 128), dtype=np.uint8)\n\n# Save as OME-Zarr\nnew_ome_zarr_image = create_ome_zarr_from_array(\n    store=\"random_ome.zarr\", \n    array=x, \n    pixelsize=0.65, \n    z_spacing=1.0\n)\n</code></pre> <p>Alternatively, if you wanto to create an a empty OME-Zarr image, you can use the <code>create_empty_ome_zarr</code> function:</p> <pre><code>from ngio import create_empty_ome_zarr\n# Create an empty OME-Zarr image\nnew_ome_zarr_image = create_empty_ome_zarr(\n    store=\"empty_ome.zarr\", \n    shape=(16, 128, 128), \n    pixelsize=0.65, \n    z_spacing=1.0\n)\n</code></pre> <p>This will create an empty OME-Zarr image with the specified shape and pixel sizes.</p>"},{"location":"getting_started/1_ome_zarr_containers/#opening-remote-ome-zarr-containers","title":"Opening remote OME-Zarr containers","text":"<p>You can use <code>ngio</code> to open remote OME-Zarr containers. For publicly available OME-Zarr containers, you can just use the <code>open_ome_zarr_container</code> function with a URL.</p> <p>For example, to open a remote OME-Zarr container hosted on a github repository:</p> <pre><code>from ngio.utils import fractal_fsspec_store\n\nurl = (\n    \"https://raw.githubusercontent.com/\"\n    \"fractal-analytics-platform/fractal-ome-zarr-examples/\"\n    \"refs/heads/main/v04/\"\n    \"20200812-CardiomyocyteDifferentiation14-Cycle1_B_03_mip.zarr/\"\n)\n\nstore = fractal_fsspec_store(url=url)\nome_zarr_container = open_ome_zarr_container(store)\n</code></pre> <p>For fractal users, the <code>fractal_fsspec_store</code> function can be used to open private OME-Zarr containers. In this case we need to provide a <code>fractal_token</code> to authenticate the user.</p> <pre><code>from ngio.utils import fractal_fsspec_store\n\nstore = fractal_fsspec_store(url=\"https://fractal_url...\", fractal_token=\"**your_secret_token**\")\nome_zarr_container = open_ome_zarr_container(store)\n</code></pre>"},{"location":"getting_started/2_images/","title":"2. Images and Labels","text":""},{"location":"getting_started/2_images/#images","title":"Images","text":"<p>In order to start working with the image data, we need to instantiate an <code>Image</code> object. ngio provides a high-level API to access the image data at different resolution levels and pixel sizes.</p>"},{"location":"getting_started/2_images/#getting-an-image","title":"Getting an image","text":"Highest Resolution ImageSpecific Pyramid LevelSpecific ResolutionNearest Resolution <p>By default, the <code>get_image</code> method returns the highest resolution image: <pre><code>&gt;&gt;&gt; ome_zarr_container.get_image() # Get the highest resolution image\nImage(path=0, Dimensions(c: 3, z: 1, y: 4320, x: 5120))\n</code></pre></p> <p>To get a specific pyramid level, you can use the <code>path</code> parameter: <pre><code>&gt;&gt;&gt; ome_zarr_container.get_image(path=\"1\") # Get a specific pyramid level\nImage(path=1, Dimensions(c: 3, z: 1, y: 2160, x: 2560))\n</code></pre> This will return the image at the specified pyramid level.</p> <p>If you want to get an image with a specific pixel size, you can use the <code>pixel_size</code> parameter: <pre><code>&gt;&gt;&gt; from ngio import PixelSize\n&gt;&gt;&gt; pixel_size = PixelSize(x=0.65, y=0.65, z=1.0)\n&gt;&gt;&gt; ome_zarr_container.get_image(pixel_size=pixel_size)\nImage(path=2, Dimensions(c: 3, z: 1, y: 1080, x: 1280))\n</code></pre></p> <p>By default the pixels must match exactly the requested pixel size. If you want to get the nearest resolution, you can use the <code>strict</code> parameter: <pre><code>&gt;&gt;&gt; from ngio import PixelSize\n&gt;&gt;&gt; pixel_size = PixelSize(x=0.60, y=0.60, z=1.0)\n&gt;&gt;&gt; ome_zarr_container.get_image(pixel_size=pixel_size, strict=False)\nImage(path=2, Dimensions(c: 3, z: 1, y: 1080, x: 1280))\n</code></pre> This will return the image with the nearest resolution to the requested pixel size.</p> <p>Similarly to the <code>OME-Zarr Container</code>, the <code>Image</code> object provides a high-level API to access the image metadata.</p> DimensionsPixel SizeOn disk array infos <p><pre><code>&gt;&gt;&gt; image.dimensions\nDimensions(c: 3, z: 1, y: 1080, x: 1280)\n</code></pre> The <code>dimensions</code> attribute returns a object with the image dimensions for each axis.</p> <p><pre><code>&gt;&gt;&gt; image.pixel_size\nx=0.65 y=0.65 z=1.0 t=1.0 space_unit='micrometer' time_unit=None\n</code></pre> The <code>pixel_size</code> attribute returns the pixel size for each axis.</p> <p><pre><code>&gt;&gt;&gt; image.shape, image.dtype, image.chunks\n(3, 1, 1080, 1280) uint16 (1, 1, 1080, 1280)\n</code></pre> The <code>axes</code> attribute returns the order of the axes in the image.</p>"},{"location":"getting_started/2_images/#working-with-image-data","title":"Working with image data","text":"<p>Once you have the <code>Image</code> object, you can access the image data as a:</p> Numpy ArrayDask ArrayLegacy <pre><code>&gt;&gt;&gt; data = image.get_as_numpy() # Get the image as a numpy array\n&gt;&gt;&gt; data.shape, data.dtype\n(3, 1, 1080, 1280) uint16\n</code></pre> <pre><code>&gt;&gt;&gt; dask_array = image.get_as_dask() # Get the image as a dask array\n&gt;&gt;&gt; dask_array\ndask.array&lt;from-zarr, shape=(3, 1, 1080, 1280), dtype=uint16, chunksize=(1, 1, 1080, 1280), chunktype=numpy.ndarray&gt;\n</code></pre> <p>A generic <code>get_array</code> method is still available for backwards compatibility.</p> <pre><code>&gt;&gt;&gt; data = image.get_array(mode=\"numpy\") # Get the image as a numpy or dask or delayed object\n&gt;&gt;&gt; data.shape, data.dtype\n(3, 1, 1080, 1280) uint16\n</code></pre> <p>The <code>get_as_*</code> can also be used to slice the image data, and query specific axes in specific orders:</p> <pre><code>&gt;&gt;&gt; image_slice = image.get_as_numpy(channel_selection=\"DAPI\", x=slice(0, 128), axes_order=[\"t\", \"z\", \"y\", \"x\", \"c\"]) # Get a specific channel and axes order\n&gt;&gt;&gt; image_slice.shape\n(1, 1, 1080, 128, 1)\n</code></pre> <p>If you want to edit the image data, you can use the <code>set_array</code> method:</p> <pre><code>&gt;&gt;&gt; image.set_array(data) # Set the image data\n</code></pre> <p>The <code>set_array</code> method can be used to set the image data from a numpy array, dask array, or dask delayed object.</p> <p>A minimal example of how to use the <code>get_array</code> and <code>set_array</code> methods:</p> <pre><code># Get the image data as a numpy array\ndata = image.get_as_numpy(channel_selection=\"DAPI\", x=slice(0, 128), y=slice(0, 128), axes_order=[\"z\", \"y\", \"x\", \"c\"])\n\n# Modify the image data\ndata = some_function(data)\n\n# Set the modified image data\nimage.set_array(data, channel_selection=\"DAPI\", x=slice(0, 128), y=slice(0, 128), axes_order=[\"z\", \"y\", \"x\", \"c\"])\nimage.consolidate() # Consolidate the changes to all resolution levels, see below for more details\n</code></pre> <p>Important</p> <p>The <code>set_array</code> method will overwrite the image data at single resolution level. After you have finished editing the image data, you need to <code>consolidate</code> the changes to the OME-Zarr file at all resolution levels: <pre><code>&gt;&gt;&gt; image.consolidate() # Consolidate the changes\n</code></pre> This will write the changes to the OME-Zarr file at all resolution levels.</p>"},{"location":"getting_started/2_images/#world-coordinates-slicing","title":"World coordinates slicing","text":"<p>To read or write a specific region of the image defined in world coordinates, you can use the <code>Roi</code> object.</p> <pre><code>&gt;&gt;&gt; from ngio import Roi\n&gt;&gt;&gt; roi = Roi.from_values(slices={\"x\": (34.1, 321.6), \"y\": (10, 330)}, name=None) # Define a ROI in world coordinates\n&gt;&gt;&gt; image.get_roi_as_numpy(roi) # Get the image data in the ROI as a numpy array\n(3, 1, 509, 496)\n</code></pre>"},{"location":"getting_started/2_images/#labels","title":"Labels","text":"<p><code>Labels</code> represent segmentation masks that identify objects in the image. In ngio <code>Labels</code> are similar to <code>Images</code> and can be accessed and manipulated in the same way.</p>"},{"location":"getting_started/2_images/#getting-a-label","title":"Getting a label","text":"<p>Now let's see what labels are available in our image:</p> <pre><code>&gt;&gt;&gt; ome_zarr_container.list_labels() # Available labels\n['nuclei', 'wf_2_labels', 'wf_3_labels', 'wf_4_labels']\n</code></pre> <p>We have <code>4</code> labels available in our image. Let's see how to access them:</p> Highest Resolution LabelSpecific Pyramid LevelSpecific ResolutionNearest Resolution <p>By default, the <code>get_label</code> method returns the highest resolution label: <pre><code>&gt;&gt;&gt; ome_zarr_container.get_label(\"nuclei\") # Get the highest resolution label\nLabel(path=0, Dimensions(z: 1, y: 4320, x: 5120))\n</code></pre></p> <p>To get a specific pyramid level, you can use the <code>path</code> parameter: <pre><code>&gt;&gt;&gt; ome_zarr_container.get_label(\"nuclei\", path=\"1\") # Get a specific pyramid level\nLabel(path=1, Dimensions(z: 1, y: 2160, x: 2560))\n</code></pre> This will return the label at the specified pyramid level.</p> <p>If you want to get a label with a specific pixel size, you can use the <code>pixel_size</code> parameter: <pre><code>&gt;&gt;&gt; from ngio import PixelSize\n&gt;&gt;&gt; pixel_size = PixelSize(x=0.65, y=0.65, z=1.0)\n&gt;&gt;&gt; ome_zarr_container.get_label(\"nuclei\", pixel_size=pixel_size)\nLabel(path=2, Dimensions(z: 1, y: 1080, x: 1280))\n</code></pre></p> <p>By default the pixels must match exactly the requested pixel size. If you want to get the nearest resolution, you can use the <code>strict</code> parameter: <pre><code>&gt;&gt;&gt; from ngio import PixelSize\n&gt;&gt;&gt; pixel_size = PixelSize(x=0.60, y=0.60, z=1.0)\n&gt;&gt;&gt; ome_zarr_container.get_label(\"nuclei\", pixel_size=pixel_size, strict=False)\nLabel(path=2, Dimensions(z: 1, y: 1080, x: 1280))\n</code></pre> This will return the label with the nearest resolution to the requested pixel size.</p>"},{"location":"getting_started/2_images/#working-with-label-data","title":"Working with label data","text":"<p>Data access and manipulation for <code>Labels</code> is similar to <code>Images</code>. You can use the <code>get_array</code> and <code>set_array</code> methods to access and modify the label data.</p>"},{"location":"getting_started/2_images/#deriving-a-label","title":"Deriving a label","text":"<p>Often, you might want to create a new label based on an existing image. You can do this using the <code>derive_label</code> method:</p> <pre><code>&gt;&gt;&gt; new_label = ome_zarr_container.derive_label(\"new_label\", overwrite=True) # Derive a new label\nLabel(path=0, Dimensions(z: 1, y: 4320, x: 5120))\n</code></pre> <p>This will create a new label with the same dimensions as the original image (without channels) and compatible metadata. If you want to create a new label with slightly different metadata see API Reference.</p>"},{"location":"getting_started/3_tables/","title":"3. Tables","text":"<p>Tables are not part of the core OME-Zarr specification but can be used in ngio to store measurements, features, regions of interest (ROIs), and other tabular data. Ngio follows the Fractal's Table Spec.</p>"},{"location":"getting_started/3_tables/#getting-a-table","title":"Getting a table","text":"<p>We can list all available tables and load a specific table:</p> <pre><code>&gt;&gt;&gt; ome_zarr_container.list_tables()\n['FOV_ROI_table', 'nuclei_ROI_table', 'well_ROI_table', 'regionprops_DAPI', 'nuclei_measurements_wf3', 'nuclei_measurements_wf4', 'nuclei_lamin_measurements_wf4']\n</code></pre> <p>Ngio supports three types of tables: <code>roi_table</code>, <code>feature_table</code>, and <code>masking_roi_table</code>, as well as untyped <code>generic_table</code>.</p> ROI TableMasking ROI TableFeatures Table <p>ROI tables can be used to store arbitrary regions of interest (ROIs) in the image. Here for example we will load the <code>FOV_ROI_table</code> that contains the microscope field of view (FOV) ROIs: <pre><code>&gt;&gt;&gt; roi_table = ome_zarr_container.get_table(\"FOV_ROI_table\") # Get a ROI table\n&gt;&gt;&gt; roi_table.get(\"FOV_1\")\nname='FOV_1' slices=[x: 0.0-&gt;416.0, y: 0.0-&gt;351.0, z: 0.0-&gt;1.0] label=None space='world' x_micrometer_original=-1448.300048828125 y_micrometer_original=-1517.699951171875\n</code></pre> 2026-02-06T14:41:09.909174 image/svg+xml Matplotlib v3.10.8, https://matplotlib.org/    This will return all the ROIs in the table. ROIs can be used to slice the image data: <pre><code>&gt;&gt;&gt; roi = roi_table.get(\"FOV_1\")\n&gt;&gt;&gt; roi_data = image.get_roi_as_numpy(roi)\n&gt;&gt;&gt; roi_data.shape\n(3, 1, 540, 640)\n</code></pre> This will return the image data for the specified ROI.  2026-02-06T14:41:10.077026 image/svg+xml Matplotlib v3.10.8, https://matplotlib.org/ </p> <p>Masking ROIs are a special type of ROIs that can be used to store ROIs for masked objects in the image. The <code>nuclei_ROI_table</code> contains the masks for the <code>nuclei</code> label in the image, and is indexed by the label id. <pre><code>&gt;&gt;&gt; masking_table = ome_zarr_container.get_table(\"nuclei_ROI_table\") # Get a mask table\n&gt;&gt;&gt; masking_table.get_label(1)\nname='100' slices=[x: 33.63750076293945-&gt;45.01250076293945, y: 18.850000381469727-&gt;33.47500038146973, z: 0.0-&gt;1.0] label=100 space='world'\n</code></pre> ROIs can be used to slice the image data: <pre><code>&gt;&gt;&gt; roi = masking_table.get_label(100)\n&gt;&gt;&gt; roi_data = image.get_roi_as_numpy(roi)\n&gt;&gt;&gt; roi_data.shape\n(3, 1, 23, 19)\n</code></pre> This will return the image data for the specified ROI.  2026-02-06T14:41:10.317858 image/svg+xml Matplotlib v3.10.8, https://matplotlib.org/    See 4. Masked Images and Labels for more details on how to use the masking ROIs to load masked data.</p> <p>Features tables are used to store measurements and are indexed by the label id <pre><code>&gt;&gt;&gt; feature_table = ome_zarr_container.get_table(\"regionprops_DAPI\") # Get a feature table\n&gt;&gt;&gt; feature_table.dataframe.head(5) # only show the first 5 rows\n</code></pre> label area bbox_area equivalent_diameter max_intensity mean_intensity min_intensity standard_deviation_intensity 1 2120 2655 15.9384 476 278.636 86 54.3438 2 327 456 8.54771 604 324.162 118 90.8471 3 1381 1749 13.8165 386 212.682 60 50.1696 4 2566 3588 16.9858 497 251.731 61 53.3072 5 4201 5472 20.0194 466 223.863 51 56.719 </p>"},{"location":"getting_started/3_tables/#creating-a-table","title":"Creating a table","text":"<p>Tables (differently from Images and Labels) can be purely in memory objects, and don't need to be saved on disk.</p> Creating a ROI TableCreating a Masking ROI TableCreating a Feature TableCreating a Generic Table <p><pre><code>&gt;&gt;&gt; from ngio.tables import RoiTable\n&gt;&gt;&gt; from ngio import Roi\n&gt;&gt;&gt; roi = Roi.from_values(slices={\"x\": (0, 128), \"y\": (0, 128)}, name=\"FOV_1\")\n&gt;&gt;&gt; roi_table = RoiTable(rois=[roi])\nRoiTableV1(num_rois=1)\n</code></pre> If you would like to create on-the-fly a ROI table for the whole image: <pre><code>&gt;&gt;&gt; roi_table = ome_zarr_container.build_image_roi_table(\"whole_image\")\n&gt;&gt;&gt; roi_table\nRoiTableV1(num_rois=1)\n</code></pre> The <code>build_image_roi_table</code> method will create a ROI table with a single ROI that covers the whole image. This table is not associated with the image and is purely in memory. If we want to save it to disk, we can use the <code>add_table</code> method: <pre><code>&gt;&gt;&gt; ome_zarr_container.add_table(\"new_roi_table\", roi_table, overwrite=True)\n&gt;&gt;&gt; roi_table = ome_zarr_container.get_table(\"new_roi_table\")\nRoiTableV1(num_rois=1)\n</code></pre></p> <p>Similarly to the ROI table, we can create a masking ROI table on-the-fly: Let's for example create a masking ROI table for the <code>nuclei</code> label: <pre><code>&gt;&gt;&gt; masking_table = ome_zarr_container.build_masking_roi_table(\"nuclei\")\n&gt;&gt;&gt; masking_table\nMaskingRoiTableV1(num_rois=3006, reference_label=nuclei)\n</code></pre></p> <p>Feature tables can be created from a pandas <code>Dataframe</code>: <pre><code>&gt;&gt;&gt; from ngio.tables import FeatureTable\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; example_data = pd.DataFrame({\"label\": [1, 2, 3], \"area\": [100, 200, 300]})\n&gt;&gt;&gt; feature_table = FeatureTable(table_data=example_data)\n&gt;&gt;&gt; feature_table\nFeatureTableV1(num_rows=3, num_columns=1)\n</code></pre></p> <p>Sometimes you might want to create a table that doesn't fit into the <code>ROI</code>, <code>Masking ROI</code>, or <code>Feature</code> categories. In this case, you can use the <code>GenericTable</code> class, which allows you to store any tabular data. It can be created from a pandas <code>Dataframe</code>: <pre><code>&gt;&gt;&gt; from ngio.tables import GenericTable\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; example_data = pd.DataFrame({\"area\": [100, 200, 300], \"perimeter\": [50, 60, 70]})\n&gt;&gt;&gt; generic_table = GenericTable(table_data=example_data)\n&gt;&gt;&gt; generic_table\nGenericTable\n</code></pre> Or from an \"AnnData\" object: <pre><code>&gt;&gt;&gt; from ngio.tables import GenericTable\n&gt;&gt;&gt; import anndata as ad\n&gt;&gt;&gt; adata = ad.AnnData(X=np.random.rand(10, 5), obs=pd.DataFrame({\"cell_type\": [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\"]}))\n&gt;&gt;&gt; generic_table = GenericTable(table_data=adata)\n&gt;&gt;&gt; generic_table\nGenericTable\n</code></pre> The <code>GenericTable</code> class allows you to store any tabular data, and is a flexible way to work with tables in ngio.</p>"},{"location":"getting_started/4_masked_images/","title":"4. Masked Images and Labels","text":"<p>Masked images (or labels) are images that are masked by an instance segmentation mask.</p> <p>In this section we will show how to create a <code>MaskedImage</code> object and how to use it to get the data of the image.</p> <p></p> <p>Similar to the <code>Image</code> and <code>Label</code> objects, the <code>MaskedImage</code> can be initialized from an <code>OME-Zarr Container</code> object using the <code>get_masked_image</code> method.</p> <p>Let's create a masked image from the <code>nuclei</code> label:</p> <pre><code>&gt;&gt;&gt; masked_image = ome_zarr_container.get_masked_image(\"nuclei\")\n&gt;&gt;&gt; masked_image\nMaskedImage(path=0, Dimensions(c: 3, z: 1, y: 4320, x: 5120), nuclei)\n</code></pre> <p>Since the <code>MaskedImage</code> is a subclass of <code>Image</code>, we can use all the methods available for <code>Image</code> objects.</p> <p>The two most notable exceptions are the <code>get_roi_as_numpy</code> (or <code>get_roi_as_dask</code>) and <code>set_roi</code> which now instead of requiring a <code>roi</code> object, require an integer <code>label</code>.</p> <pre><code>&gt;&gt;&gt; roi_data = masked_image.get_roi_as_numpy(label=1009, c=0)\n&gt;&gt;&gt; roi_data.shape\n(1, 77, 84)\n</code></pre> 2026-02-06T14:41:12.537607 image/svg+xml Matplotlib v3.10.8, https://matplotlib.org/ <p>Additionally we can used the <code>zoom_factor</code> argument to get more context around the ROI. For example we can zoom out the ROI by a factor of <code>2</code>:</p> <pre><code>&gt;&gt;&gt; roi_data = masked_image.get_roi_as_numpy(label=1009, c=0, zoom_factor=2)\n&gt;&gt;&gt; roi_data.shape\n(1, 154, 167)\n</code></pre> 2026-02-06T14:41:12.620096 image/svg+xml Matplotlib v3.10.8, https://matplotlib.org/"},{"location":"getting_started/4_masked_images/#masked-operations","title":"Masked operations","text":"<p>In addition to the <code>get_roi_as_numpy</code> method, the <code>MaskedImage</code> class also provides a masked operation method that allows you to perform reading and writing only on the masked pixels.</p> <p>For these operations we can use the <code>get_roi_masked</code> and <code>set_roi_masked</code> methods. For example, we can use the <code>get_roi_masked</code> method to get the masked data for a specific label:</p> <pre><code>&gt;&gt;&gt; masked_roi_data = masked_image.get_roi_masked(label=1009, c=0, zoom_factor=2)\n&gt;&gt;&gt; masked_roi_data.shape\n(1, 154, 167)\n</code></pre> 2026-02-06T14:41:12.754068 image/svg+xml Matplotlib v3.10.8, https://matplotlib.org/ <p>We can also use the <code>set_roi_masked</code> method to set the masked data for a specific label:</p> <pre><code>&gt;&gt;&gt; masked_data = masked_image.get_roi_masked(label=1009, c=0)\n&gt;&gt;&gt; masked_data = np.random.randint(0, 255, masked_data.shape, dtype=np.uint8)\n&gt;&gt;&gt; masked_image.set_roi_masked(label=1009, c=0, patch=masked_data)\n</code></pre> 2026-02-06T14:41:12.917657 image/svg+xml Matplotlib v3.10.8, https://matplotlib.org/"},{"location":"getting_started/4_masked_images/#masked-labels","title":"Masked Labels","text":"<p>The <code>MaskedLabel</code> class is a subclass of <code>Label</code> and provides the same functionality as the <code>MaskedImage</code> class.</p> <p>The <code>MaskedLabel</code> class can be used to create a masked label from an <code>OME-Zarr Container</code> object using the <code>get_masked_label</code> method.</p> <pre><code>&gt;&gt;&gt; masked_label = ome_zarr_container.get_masked_label(label_name = \"wf_2_labels\", masking_label_name = \"nuclei\")\n&gt;&gt;&gt; masked_label\nMaskedLabel(path=0, Dimensions(z: 1, y: 4320, x: 5120), nuclei)\n</code></pre>"},{"location":"getting_started/5_hcs/","title":"5. HCS Plates","text":"<p>Ngio provides a simple interface for high-content screening (HCS) plates. An HCS plate is a collection of OME-Zarr images organized in a grid-like structure. Each plates contains columns and rows, and each well in the plate is identified by its row and column indices. Each well can contain multiple images, and each image can belong to a different acquisition.</p> <p>The HCS plate is represented by the <code>OmeZarrPlate</code> class.</p> <p>Let's open an <code>OmeZarrPlate</code> object.</p> <pre><code>&gt;&gt;&gt; from ngio.utils import download_ome_zarr_dataset\n&gt;&gt;&gt; from ngio import open_ome_zarr_plate\n&gt;&gt;&gt; hcs_path = download_ome_zarr_dataset(\"CardiomyocyteSmallMip\", download_dir=download_dir)\n&gt;&gt;&gt; ome_zarr_plate = open_ome_zarr_plate(hcs_path)\n&gt;&gt;&gt; ome_zarr_plate\nPlate([rows x columns] (1 x 1))\n</code></pre> <p>This example plate is very small and contains only a single well.</p>"},{"location":"getting_started/5_hcs/#plate-overview","title":"Plate overview","text":"<p>The <code>OmeZarrPlate</code> object provides a high-level overview of the plate, including rows, columns, and acquisitions. The following methods are available:</p> ColumnsRowsAcquisitions <p>Show the columns in the plate: <pre><code>&gt;&gt;&gt; ome_zarr_plate.columns\n['03']\n</code></pre></p> <p>Show the rows in the plate: <pre><code>&gt;&gt;&gt; ome_zarr_plate.rows\n['B']\n</code></pre></p> <p>Show the acquisitions ids: <pre><code>&gt;&gt;&gt; ome_zarr_plate.acquisition_ids\n[0]\n</code></pre></p>"},{"location":"getting_started/5_hcs/#retrieving-the-path-to-the-images","title":"Retrieving the path to the images","text":"<p>The <code>OmeZarrPlate</code> object provides multiple methods to retrieve the path to the images in the plate.</p> All Images PathsAll Wells PathsAll Images Paths in a Well <p>This will return the paths to all images in the plate: <pre><code>&gt;&gt;&gt; ome_zarr_plate.images_paths()\n['B/03/0']\n</code></pre></p> <p>This will return the paths to all wells in the plate: <pre><code>&gt;&gt;&gt; ome_zarr_plate.wells_paths()\n['B/03']\n</code></pre></p> <p>This will return the paths to all images in a well: <pre><code>&gt;&gt;&gt; ome_zarr_plate.well_images_paths(row=\"B\", column=3)\n['B/03/0']\n</code></pre></p>"},{"location":"getting_started/5_hcs/#getting-the-images","title":"Getting the images","text":"<p>The <code>OmeZarrPlate</code> object provides a method to get the image objects in a well. The method <code>get_well_images</code> takes the row and column indices of the well and returns a list of <code>OmeZarrContainer</code> objects.</p> All ImagesAll Images in a WellSpecific ImageFilter by Acquisition <p>Get all images in the plate: <pre><code>&gt;&gt;&gt; ome_zarr_plate.get_images()\n&gt;&gt;&gt; ome_zarr_plate\n{'B/03/0': OmeZarrContainer(levels=5, #labels=4, #tables=7)}\n</code></pre> This dictionary contains the path to the images and the corresponding <code>OmeZarrContainer</code> object.</p> <p>Get all images in a well: <pre><code>&gt;&gt;&gt; well_images = ome_zarr_plate.get_well_images(row=\"B\", column=3)\n&gt;&gt;&gt; well_images\n{'B/03/0': OmeZarrContainer(levels=5, #labels=4, #tables=7)}\n</code></pre> This dictionary contains the path to the images and the corresponding <code>OmeZarrContainer</code> object.</p> <p>Get a specific image in a well: <pre><code>&gt;&gt;&gt; ome_zarr_plate.get_image(row=\"B\", column=3, image_path=\"0\")\nOmeZarrContainer(levels=5, #labels=4, #tables=7)\n</code></pre> This will return the <code>OmeZarrContainer</code> object for the image in the well.</p> <p>In these methods, you can also filter the images by acquisition. When available, the <code>acquisition</code> parameter can be used to filter the images by acquisition id. <pre><code>&gt;&gt;&gt; well_images = ome_zarr_plate.get_well_images(row=\"B\", column=3, acquisition=0)\n&gt;&gt;&gt; well_images\n{}\n</code></pre> The <code>acquisition</code> is not required, and if not provided, an empty dictionary will be returned.</p>"},{"location":"getting_started/5_hcs/#creating-a-plate","title":"Creating a plate","text":"<p>Ngio provides a utility function to create a plate.</p> <p>The first step is to create a list of <code>ImageInWellPath</code> objects. Each <code>ImageInWellPath</code> object contains the path to the image and the corresponding well.</p> <pre><code>from ngio import ImageInWellPath\nlist_of_images = [ImageInWellPath(path=\"0\", row=\"A\", column=0),\n                    ImageInWellPath(path=\"0\", row=\"B\", column=1),\n                    ImageInWellPath(path=\"0\", row=\"C\", column=1),\n                    ImageInWellPath(path=\"1\", row=\"A\", column=0, acquisition_id=1, acquisition_name=\"acquisition_1\"),\n]\n</code></pre> <p>Note</p> <p>The order in which the images are added is not important. The <code>rows</code> and <code>columns</code> attributes of the plate will be sorted in alphabetical/numerical order.</p> <p>Then, you can create the plate using the <code>create_empty_plate</code> function.</p> <pre><code>&gt;&gt;&gt; from ngio import create_empty_plate\n&gt;&gt;&gt; plate = create_empty_plate(store=\"new_plate.zarr\", name=\"test_plate\", images=list_of_images, overwrite=True)\n&gt;&gt;&gt; plate\nPlate([rows x columns] (3 x 2))\n</code></pre> <p>This has created a new empty plate with the metadata correctly set. But no images have been added yet.</p>"},{"location":"getting_started/5_hcs/#modifying-the-plate","title":"Modifying the plate","text":"<p>You can add images or remove images</p> Add ImagesRemove Images <p>To add images to the plate, you can use the <code>add_image</code> method. This method takes the row and column indices of the well and the path to the image. <pre><code>&gt;&gt;&gt; print(f\"Before adding images: {plate.rows} rows, {plate.columns} columns\")\n&gt;&gt;&gt; plate.add_image(row=\"D\", column=0, image_path=\"0\")\n&gt;&gt;&gt; print(f\"After adding images: {plate.rows} rows, {plate.columns} columns\")\nBefore adding images: ['A', 'B', 'C'] rows, ['00', '01'] columns\nAfter adding images: ['A', 'B', 'C', 'D'] rows, ['00', '01'] columns\n</code></pre> This will add a new image to the plate and well metadata.</p> <p>Note</p> <p>The order in which the images are added is not important. The <code>rows</code> and <code>columns</code> attributes of the plate will be sorted in alphabetical/numerical order.</p> <p>Warning</p> <p>This function is not multiprocessing safe. If you are using multiprocessing, you should use the <code>atomic_add_image</code> method instead.</p> <p>To remove images from the plate, you can use the <code>remove_image</code> method. This method takes the row and column indices of the well and the path to the image. <pre><code>&gt;&gt;&gt; print(f\"Before removing images: {plate.wells_paths()} wells\")\n&gt;&gt;&gt; plate.remove_image(row=\"D\", column=0, image_path=\"0\")\n&gt;&gt;&gt; print(f\"After removing images: {plate.wells_paths()} wells\")\nBefore removing images: ['A/00', 'B/01', 'C/01', 'D/00'] wells\nAfter removing images: ['A/00', 'B/01', 'C/01'] wells\n</code></pre> This will remove the image metadata from the plate and well metadata.</p> <p>Warning</p> <p>No data will be removed from the store. If an image is saved in the store it will remain there. Also the metadata will only be removed from the plate.well metadata. The number of columns and rows will not be updated. This function is not multiprocessing safe. If you are using multiprocessing, you should use the <code>atomic_remove_image</code> method instead.</p>"},{"location":"getting_started/6_iterators/","title":"6. Iterators","text":"<p>When building image processing pipelines it is often useful to iterate over specific regions of the image, for example to process the image in smaller tiles or to process only specific regions of interest (ROIs).</p> <p>Moreover, when working with OME-Zarr Images it is often useful to set specific broadcasting rules for the iteration, for example to iterate over all z-planes or iterate over all timepoints.</p> <p>Ngio provides a set of <code>Iterator</code> classes that can be used for this purpose. We provide iterators four basic iterators: </p> <ul> <li>The <code>SegmentationIterator</code> is designed to build segmentation pipelines, where an input image is processed to produce a segmentation mask. An example use case on how to use the <code>SegmentationIterator</code> can be found in the Image Segmentation Tutorial.</li> <li>The <code>MaskedSegmentationIterator</code> is similar to the <code>SegmentationIterator</code>, but it uses a masking roi table to restrict the segmentation to masks. This is useful when you want to segment only specific regions of the image, for example, segmenting cells only within a specific tissue region. An example use case on how to use the <code>MaskedSegmentationIterator</code> can be found in the Image Segmentation Tutorial.</li> <li>The <code>ImageProcessingIterator</code> is designed to build image processing pipelines, where an input image is processed to produce a new image. An example use case on how to use the <code>ImageProcessingIterator</code> can be found in the Image Processing Tutorial.</li> <li>The <code>FeatureExtractionIterator</code> is read-only iterator designed to iterate over pairs of images and labels to extract features from the image based on the labels. An example use case on how to use the <code>FeatureExtractionIterator</code> can be found in the Feature Extraction Tutorial.</li> </ul> <p>A set of more complete example can be found in the Fractal Tasks Template.</p>"},{"location":"table_specs/backend/","title":"Table Backends","text":"<p>In ngio we implemented four different table backends. Each table backend is a python class that can serialize tabular data into OME-Zarr containers.</p> <p>These backends are wrappers around existing tooling implemented in <code>anndata</code>, <code>pandas</code>, and <code>polars</code>. Currently, we provide a thin layer of metadata and table normalization to ensure that tables are serialized/deserialized in a consistent way across the different backends and across different table objects.</p> <p>In particular, we provide the metadata that describes the intended index key and type of the table for each backend.</p>"},{"location":"table_specs/backend/#anndata-backend","title":"AnnData Backend","text":"<p>AnnData is a widely used format in single-cell genomics, and can natively store complex tabular data in a Zarr group. The AnnData backend in ngio is a wrapper around the <code>anndata</code> library, which performs some table normalization for consistency and compatibility with the ngio table specifications.</p> <p>The following normalization steps are applied to each table before saving it to the AnnData backend:</p> <ul> <li>We separate the table in two parts: The floating point columns are casted to <code>float32</code> and stored as <code>X</code> in the AnnData object, while the categorical, boolean, and integer columns are stored as <code>obs</code>.</li> <li>The index column is cast to a string, and is stored in the <code>obs</code> index.</li> <li>The index column name must match the <code>index_key</code> specified in the metadata.</li> </ul> <p>AnnData backend metadata:</p> <pre><code>{\n    // Backend metadata\n    \"backend\": \"annadata\", // the backend used to store the table, e.g. \"annadata\", \"parquet\", etc..\n    \"index_key\": \"index\", // The default index key for the table, which is used to identify each row.\n    \"index_type\": \"str\", // Either \"int\" or \"str\"\n}\n</code></pre> <p>Additionally, the AnnData package will write some additional metadata to the group attributes</p> <pre><code>{\n    \"encoding-type\": \"anndata\",\n    \"encoding-version\": \"0.1.0\",\n}\n</code></pre>"},{"location":"table_specs/backend/#parquet-backend","title":"Parquet Backend","text":"<p>The Parquet backend is a high-performance columnar storage format that is widely used in big data processing. It is designed to efficiently store large datasets and can be used with various data processing frameworks. Another advantage of the Parquet backend is that it can be used lazily, meaning that the data is not loaded into memory until it is needed. This can be useful for working with large datasets that do not fit into memory.</p> <p>Parquet backend metadata:</p> <pre><code>{\n    // Backend metadata\n    \"backend\": \"parquet\", // the backend used to store the table, e.g. \"annadata\", \"parquet\", etc..\n    \"index_key\": \"index\", // The default index key for the table, which is used to identify each row.\n    \"index_type\": \"int\", // Either \"int\" or \"str\"\n}\n</code></pre> <p>The Zarr group directory will contain the Parquet file, and the metadata will be stored in the group attributes.</p> <pre><code>table.zarr          # Zarr group for the table\n\u251c\u2500\u2500 table.parquet   # Parquet file containing the table data\n\u251c\u2500\u2500 .zattrs         # Zarr group attributes containing the metadata\n\u2514\u2500\u2500 .zgroup         # Zarr group metadata\n</code></pre>"},{"location":"table_specs/backend/#csv-backend","title":"CSV Backend","text":"<p>The CSV backend is a plain text format that is widely used for tabular data. It is easy to read and write, and can be used across many different tools.</p> <p>The CSV backend in ngio follows closely the same specifications as the Parquet backend, with the following metadata:</p> <pre><code>{\n    // Backend metadata\n    \"backend\": \"csv\", // the backend used to store the table, e.g. \"annadata\", \"parquet\", etc..\n    \"index_key\": \"index\", // The default index key for the table, which is used to identify each row.\n    \"index_type\": \"int\", // Either \"int\" or \"str\"\n}\n</code></pre> <p>The Zarr group directory will contain the CSV file, and the metadata will be stored in the group attributes.</p> <pre><code>table.zarr         # Zarr group for the table\n\u251c\u2500\u2500 table.csv      # CSV file containing the table data\n\u251c\u2500\u2500 .zattrs        # Zarr group attributes containing the metadata\n\u2514\u2500\u2500 .zgroup        # Zarr group metadata\n</code></pre>"},{"location":"table_specs/backend/#json-backend","title":"JSON Backend","text":"<p>The JSON backend serializes the table data into the Zarr group attributes as a JSON object. This backend is useful for tiny tables.</p> <p>JSON backend metadata:</p> <pre><code>{\n    // Backend metadata\n    \"backend\": \"json\", // the backend used to store the table, e.g. \"annadata\", \"parquet\", etc..\n    \"index_key\": \"index\", // The default index key for the table, which is used to identify each row.\n    \"index_type\": \"int\" // Either \"int\" or \"str\"\n}\n</code></pre> <p>The table will be stored in a subgroup of the Zarr group, and the metadata will be stored in the group attributes. Storing the table in a subgroup instead of a standalone json file allows for easier access via the Zarr API.</p> <pre><code>table.zarr          # Zarr group for the table\n\u2514\u2500\u2500 table           # Zarr subgroup containing the table data\n    \u251c\u2500\u2500 .zattrs     # the json table data serialized as a JSON object\n    \u2514\u2500\u2500 .zgroup     # Zarr group metadata\n\u251c\u2500\u2500 .zattrs         # Zarr group attributes containing the metadata\n\u2514\u2500\u2500 .zgroup         # Zarr group metadata\n</code></pre>"},{"location":"table_specs/overview/","title":"Tables Overview","text":"<p>Ngio's architecture is designed to tightly integrate image and tabular data. For this purpose we developed custom specifications for serializing and deserializing tabular data into OME-Zarr containers, and semantically typed tables derived from the fractal table specification.</p>"},{"location":"table_specs/overview/#architecture","title":"Architecture","text":"<p>The ngio tables architectures is composed of three main components:</p>"},{"location":"table_specs/overview/#1-table-backends","title":"1. Table Backends","text":"<p>A backend module is a class that can serialize tabular data into OME-Zarr containers. We currently support four on-disk file formats:</p> <ul> <li>AnnData: Commonly used in single-cell genomics and was the standard table for the initial Fractal table spec.</li> <li>Parquet: A columnar storage file format optimized for large datasets.</li> <li>CSV: A simple text format for tabular data, easily human readable and writable.</li> <li>JSON: A lightweight data interchange format that both readable and efficient for small tables.</li> </ul> <p>A more detailed description of the backend module can be found in the Table Backends documentation.</p>"},{"location":"table_specs/overview/#2-in-memory-table-objects","title":"2. In-Memory Table Objects","text":"<p>These are Python objects that represent the tabular data in memory. They provide a convenient interface for manipulating and analyzing the data without needing to interact directly with the underlying file format. We support the following in-memory table objects:</p> <ul> <li>Pandas DataFrame: The most commonly used data structure for tabular data in Python.</li> <li>Polars LazyFrame: A fast DataFrame implementation that allows for lazy evaluation and efficient computation on large datasets.</li> <li>AnnData: A specialized data structure for single-cell genomics data, which goes beyond simple tabular data.</li> </ul> <p>We also provide utilities to convert between these in-memory representations in a standardized way based on the table type specifications/metadata.</p>"},{"location":"table_specs/overview/#3-table-type-specifications","title":"3. Table Type Specifications","text":"<p>These specifications define structured tables that standardize common table types used in image analysis. We have defined five table types so far:</p> <ul> <li>Generic Tables: A flexible table type that can represent any tabular data. See more in the Generic Tables documentation.</li> <li>ROI Tables: A table type specifically designed for representing Regions of Interest (ROIs) in images. See more in the ROI Tables documentation.</li> <li>Masking ROI Tables: A specialized table type for representing ROIs that are associated with specific labels in a OME-Zarr label image. See more in the Masking ROI Tables documentation.</li> <li>Feature Tables: A table type for representing features extracted from images. This table is also associated with a specific label image. See more in the Feature Tables documentation.</li> <li>Condition Tables: A table to represent experimental conditions or metadata associated with images or experiments. See more in the Condition Tables documentation.</li> </ul>"},{"location":"table_specs/overview/#tables-groups","title":"Tables Groups","text":"<p>Tables in OME-Zarr images are organized into groups of tables. Each group is saved in a Zarr group, and can be associated with a specific image or plate. The tables groups are:</p> <ul> <li>Image Tables: These tables are a sub group of the OME-Zarr image group and contain metadata or features related only to that specific image. The <code>.zarr</code> hierarchy is based on image specification in NGFF 0.4. The subgroup structure is based on the approach of the OME-Zarr <code>labels</code> group.</li> </ul> <pre><code>image.zarr        # Zarr group for a OME-Zarr image\n|\n\u251c\u2500\u2500 0             # Zarr array for multiscale level 0\n\u251c\u2500\u2500 ...\n\u251c\u2500\u2500 N             # Zarr array for multiscale level N\n|\n\u251c\u2500\u2500 labels        # Zarr subgroup with a list of labels associated to this image\n|   \u251c\u2500\u2500 label_A   # Zarr subgroup for a given label\n|   \u251c\u2500\u2500 label_B   # Zarr subgroup for a given label\n|   \u2514\u2500\u2500 ...\n|\n\u2514\u2500\u2500 tables        # Zarr subgroup with a list of tables associated to this image\n    \u251c\u2500\u2500 table_1   # Zarr subgroup for a given table\n    \u251c\u2500\u2500 table_2   # Zarr subgroup for a given table\n    \u2514\u2500\u2500 ...\n</code></pre> <ul> <li>Plate Tables: These tables are a sub group of the OME-Zarr plate group and contain metadata or features related only to that specific plate.</li> </ul> <pre><code>plate.zarr       # Zarr group for a OME-Zarr HCS plate\n|\n\u251c\u2500\u2500 A             # Row A of the plate\n|   \u251c\u2500\u2500 1         # Column 0 of row A\n|   |   \u251c\u2500\u2500 0     # Acquisition 0 of column A1\n|   |   \u251c\u2500\u2500 1     # Acquisition 1 of column A1\n|   |   \u2514\u2500\u2500 ...   # Other acquisitions of column A1\n...\n\u251c\u2500\u2500 tables        # Zarr subgroup with a list of tables associated to this plate\n|   \u251c\u2500\u2500 table_1   # Zarr subgroup for a given table\n|   \u251c\u2500\u2500 table_2   # Zarr subgroup for a given table\n|   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 ...\n</code></pre> <p>If a plate table contains per image information, the table should contain a <code>row</code>, <code>column</code>, and <code>path_in_well</code> columns.</p>"},{"location":"table_specs/overview/#tables-group-attributes","title":"Tables Group Attributes","text":"<p>The Zarr attributes of the tables group must include the key tables, pointing to the list of all tables (this simplifies discovery of tables associated to the current OME-Zarr image or plate), as in</p> <pre><code>{\n    \"tables\": [\"table_1\", \"table_2\"]\n}\n</code></pre>"},{"location":"table_specs/table_types/condition_table/","title":"Condition Table","text":"<p>A condition table is a simple table that can be used to represent experimental conditions or metadata associated with images or experiments. It is a flexible table type that can be used to store any kind of metadata related to the images or experiments.</p> <p>Example condition table:</p> Cell Type Drug Dose A Drug A 10 A Drug B 20"},{"location":"table_specs/table_types/condition_table/#specifications","title":"Specifications","text":""},{"location":"table_specs/table_types/condition_table/#v1","title":"V1","text":"<p>A condition table must include the following metadata fields in the group attributes:</p> <pre><code>{\n    // Condition table metadata\n    \"type\": \"condition_table\",\n    \"table_version\": \"1\",\n    // Backend metadata\n    \"backend\": \"csv\", // the backend used to store the table, e.g. \"annadata\", \"parquet\", etc..\n    \"index_key\": \"index\", // The default index key for the condition table, which is used to identify each row.\n    \"index_type\": \"int\" // Either \"int\" or \"str\"\n}\n</code></pre>"},{"location":"table_specs/table_types/custom_table/","title":"Add a Custom Table","text":"<p>Ngio allows users to define custom tables that can be used to store any kind of tabular data. Custom tables are flexible and can be used to represent any kind of data that does not fit into the predefined table types.</p> <p>Warning</p> <p>The library is still in the early stages and full documentation for custom tables is not yet available.</p>"},{"location":"table_specs/table_types/feature_table/","title":"Feature Tables","text":"<p>A feature table is a table type for representing per object features in an image. Each row in a feature table corresponds to a specific label in the label image.</p> <p>Feature tables can optionally include metadata to specify the type of features stored in each column:</p> <ul> <li><code>measurement</code>: A quantitative measurement of the object, such as area, perimeter, or intensity.</li> <li><code>categorical</code>: A categorical feature of the object, such as a classification label or a type.</li> <li><code>metadata</code>: Additional free-from columns that can be used to store any other information about the object, but that should not be used for analysis/classification purposes.</li> </ul> <p>These feature types inform casting of the values when serialising a table and can be used in downstream analysis to select specific subsets of features. The feature type can be explicitly specified in the feature table metadata. Alternatively, if a column is not specified, we apply the following casting rules:</p> <ul> <li>If the column contains only numeric values, it is considered a <code>measurement</code>.</li> <li>If the column contains string or boolean values, it is considered a <code>categorical</code>.</li> <li>The index column is considered a <code>categorical</code> feature.</li> </ul>"},{"location":"table_specs/table_types/feature_table/#specifications","title":"Specifications","text":""},{"location":"table_specs/table_types/feature_table/#v1","title":"V1","text":"<p>A feature table must include the following metadata fields in the group attributes:</p> <pre><code>{\n    // Feature table metadata\n    \"type\": \"feature_table\",\n    \"table_version\": \"1\",\n    \"region\": {\"path\": \"../labels/label_DAPI\"}, // Path to the label image associated with this feature table\n    // Backend metadata\n    \"backend\": \"annadata\", // the backend used to store the table, e.g. \"annadata\", \"parquet\", etc..\n    \"index_key\": \"label\", \n    \"index_type\": \"int\", // Either \"int\" or \"str\"\n}\n</code></pre> <p>Additionally, it can include feature type information such as:</p> <pre><code>{\n    \"categorical_columns\": [\n        \"label\",\n        \"cell_type\",\n    ],\n    \"measurement_columns\": [\n        \"area\",\n        \"perimeter\",\n        \"intensity_mean\",\n        \"intensity_std\"\n    ],\n    \"metadata_columns\": [\n        \"description\",\n    ],\n}\n</code></pre>"},{"location":"table_specs/table_types/generic_table/","title":"Generic Tables","text":"<p>A generic table is a flexible table type that can represent any tabular data. It is not tied to any specific domain or use case, making it suitable for a wide range of custom applications.</p> <p>Generic tables can used as a safe fallback when trying to read a table that does not match any other specific table type.</p>"},{"location":"table_specs/table_types/generic_table/#specifications","title":"Specifications","text":""},{"location":"table_specs/table_types/generic_table/#v1","title":"V1","text":"<p>A generic table should include the following metadata fields in the group attributes:</p> <pre><code>{\n    // Generic table metadata\n    \"type\": \"generic_table\",\n    \"table_version\": \"1\",\n    // Backend metadata\n    \"backend\": \"annadata\", // the backend used to store the table, e.g. \"annadata\", \"parquet\", etc..\n    \"index_key\": \"index\", // The default index key for the generic table, which is used to identify each row.\n    \"index_type\": \"int\" // Either \"int\" or \"str\"\n}\n</code></pre>"},{"location":"table_specs/table_types/masking_roi_table/","title":"Masking ROI Tables","text":"<p>A masking ROI table is a specialized table type for representing Regions of Interest (ROIs) that are associated with specific labels in a label image. Each row in a masking ROI table corresponds to a specific label in the label image.</p> <p>Masking ROI tables can be used for several purposes, such as:</p> <ul> <li>Feature extraction from specific regions in the image.</li> <li>Masking specific regions in the image for further processing. For example a masking ROI table could store the ROIs for specific tissues, and for each of these ROIs we would like to perform cell segmentation.</li> </ul>"},{"location":"table_specs/table_types/masking_roi_table/#specifications","title":"Specifications","text":""},{"location":"table_specs/table_types/masking_roi_table/#v1","title":"V1","text":"<p>A ROI table must include the following metadata fields in the group attributes:</p> <pre><code>{\n    // ROI table metadata\n    \"type\": \"masking_roi_table\",\n    \"table_version\": \"1\",\n    \"region\": {\"path\": \"../labels/label_DAPI\"}, // Path to the label image associated with this masking ROI table\n    // Backend metadata\n    \"backend\": \"annadata\", // the backend used to store the table, e.g. \"annadata\", \"parquet\", etc..\n    \"index_key\": \"label\", // The default index key for the ROI table, which is used to identify each ROI. \n    \"index_type\": \"int\", // Either \"int\" or \"str\"\n}\n</code></pre> <p>Moreover the ROI table must include the following columns:</p> <ul> <li><code>x_micrometer</code>, <code>y_micrometer</code>, <code>z_micrometer</code>: the top-left corner coordinates of the ROI in micrometers.</li> <li><code>len_x_micrometer</code>, <code>len_y_micrometer</code>, <code>len_z_micrometer</code>: the size of the ROI in micrometers along each axis.</li> <li><code>label</code>: An integer column label associated with the ROI, which corresponds to a specific label in the label image. This can also be the table index key.</li> <li>(Optional) <code>t_second</code> and <code>len_t_second</code>: the time coordinate of the ROI in seconds, and the length of the time coordinate in seconds. This is useful for multiplexing acquisitions.</li> </ul> <p>Additionally, each ROI can include the following optional columns: see ROI Table.</p>"},{"location":"table_specs/table_types/roi_table/","title":"ROI Table","text":"<p>A ROI table defines regions of space which are axes-aligned bounding boxes in the image space.</p> <p>ROI tables can be used for several purposes, such as:</p> <ul> <li>Storing information about the Microscope Field of View (FOV).</li> <li>Storing arbitrary regions of interest (ROIs).</li> <li>Use them as masks for other processes, such as segmentation or feature extraction.</li> </ul>"},{"location":"table_specs/table_types/roi_table/#specifications","title":"Specifications","text":""},{"location":"table_specs/table_types/roi_table/#v1","title":"V1","text":"<p>A ROI table must include the following metadata fields in the group attributes:</p> <pre><code>{\n    // ROI table metadata\n    \"type\": \"roi_table\",\n    \"table_version\": \"1\",\n    // Backend metadata\n    \"backend\": \"annadata\", // the backend used to store the table, e.g. \"annadata\", \"parquet\", etc..\n    \"index_key\": \"FieldIndex\", // The default index key for the ROI table, which is used to identify each ROI. \n    \"index_type\": \"str\", // Either \"int\" or \"str\"\n}\n</code></pre> <p>Moreover the ROI table must include the following columns:</p> <ul> <li><code>x_micrometer</code>, <code>y_micrometer</code>, <code>z_micrometer</code>: the top-left corner coordinates of the ROI in micrometers.</li> <li><code>len_x_micrometer</code>, <code>len_y_micrometer</code>, <code>len_z_micrometer</code>: the size of the ROI in micrometers along each axis.</li> </ul> <p>Additionally, each ROI can include the following optional columns:</p> <ul> <li><code>t_second</code> and <code>len_t_second</code>: the time coordinate of the ROI in seconds, and the length of the time coordinate in seconds. This is useful for multiplexing acquisitions.</li> <li><code>x_micrometer_original</code>, <code>y_micrometer_original</code> and <code>z_micrometer_original</code> which are the original coordinates of the ROI in micrometers. These are typically used when the data is saved in different coordinates during conversion, e.g. to avoid overwriting data from overlapping ROIs.</li> <li><code>translation_x</code>, <code>translation_y</code> and <code>translation_z</code>, which are used during registration of multiplexing acquisitions.</li> </ul> <p>The user can also add additional columns to the ROI table, but these columns will not be exposed in the ROI table API.</p>"},{"location":"tutorials/create_ome_zarr/","title":"OME-Zarr Creation","text":"In\u00a0[1]: Copied! <pre>import skimage\nfrom matplotlib import pyplot as plt\n\nplt.imshow(skimage.data.human_mitosis(), cmap=\"gray\")\nplt.axis(\"off\")\nplt.show()\n</pre> import skimage from matplotlib import pyplot as plt  plt.imshow(skimage.data.human_mitosis(), cmap=\"gray\") plt.axis(\"off\") plt.show() <pre>/opt/hostedtoolcache/Python/3.13.11/x64/lib/python3.13/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n  from .autonotebook import tqdm as notebook_tqdm\nDownloading file 'data/mitosis.tif' from 'https://gitlab.com/scikit-image/data/-/raw/2cdc5ce89b334d28f06a58c9f0ca21aa6992a5ba/AS_09125_050116030001_D03f00d0.tif' to '/home/runner/.cache/scikit-image/0.26.0'.\n</pre> In\u00a0[2]: Copied! <pre>from ngio import create_ome_zarr_from_array\n\nome_zarr = create_ome_zarr_from_array(\n    store=\"./data/human_mitosis.zarr\",\n    array=skimage.data.human_mitosis(),\n    pixelsize=0.1,  # Just a guess\n)\nome_zarr\n</pre> from ngio import create_ome_zarr_from_array  ome_zarr = create_ome_zarr_from_array(     store=\"./data/human_mitosis.zarr\",     array=skimage.data.human_mitosis(),     pixelsize=0.1,  # Just a guess ) ome_zarr Out[2]: <pre>OmeZarrContainer(levels=5)</pre> In\u00a0[3]: Copied! <pre># create a roi for the whole image\nroi_table = ome_zarr.build_image_roi_table(name=\"image_roi\")\nome_zarr.add_table(\"image_roi_table\", roi_table)\n</pre> # create a roi for the whole image roi_table = ome_zarr.build_image_roi_table(name=\"image_roi\") ome_zarr.add_table(\"image_roi_table\", roi_table) <pre>/opt/hostedtoolcache/Python/3.13.11/x64/lib/python3.13/site-packages/anndata/_io/zarr.py:44: UserWarning: Writing zarr v2 data will no longer be the default in the next minor release. v3 data will be written by default. If you are explicitly setting this configuration, consider migrating to the zarr v3 file format.\n  f = open_write_group(store)\n</pre>"},{"location":"tutorials/create_ome_zarr/#ome-zarr-creation","title":"OME-Zarr Creation\u00b6","text":"<p>This is a minimal example of how to create an OME-Zarr image using <code>ngio</code>.</p> <p>This example is just a simple demonstration but for more complex conversion tasks please refer to the converter tooling library ome-zarr-converters-tools.</p> <p>Let's start by converting a sample image from <code>skimage</code> to OME-Zarr format.</p>"},{"location":"tutorials/create_ome_zarr/#adding-a-roi-table-to-an-ome-zarr-image","title":"Adding a ROI table to an OME-Zarr image\u00b6","text":"<p>Often, is useful to add ROIs to OME-Zarr images to be able to retrieve them later. This can be done using the <code>ngio</code> library as follows.</p>"},{"location":"tutorials/feature_extraction/","title":"Feature Extraction","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport pandas as pd\nfrom skimage import measure\n\n\ndef extract_features(image: np.ndarray, label: np.ndarray) -&gt; pd.DataFrame:\n    \"\"\"Basic feature extraction using skimage.measure.regionprops_table.\"\"\"\n    label = label.squeeze(-1)  # Remove the channel axis if present\n    roi_feat_table = measure.regionprops_table(\n        label_image=label,\n        intensity_image=image,\n        properties=[\n            \"label\",\n            \"area\",\n            \"mean_intensity\",\n            \"max_intensity\",\n            \"min_intensity\",\n        ],\n    )\n    return pd.DataFrame(roi_feat_table)\n</pre> import numpy as np import pandas as pd from skimage import measure   def extract_features(image: np.ndarray, label: np.ndarray) -&gt; pd.DataFrame:     \"\"\"Basic feature extraction using skimage.measure.regionprops_table.\"\"\"     label = label.squeeze(-1)  # Remove the channel axis if present     roi_feat_table = measure.regionprops_table(         label_image=label,         intensity_image=image,         properties=[             \"label\",             \"area\",             \"mean_intensity\",             \"max_intensity\",             \"min_intensity\",         ],     )     return pd.DataFrame(roi_feat_table) In\u00a0[2]: Copied! <pre>from pathlib import Path\n\nfrom ngio import open_ome_zarr_container\nfrom ngio.utils import download_ome_zarr_dataset\n\n# Download the dataset\ndownload_dir = Path(\".\").absolute().parent.parent / \"data\"\nhcs_path = download_ome_zarr_dataset(\"CardiomyocyteTinyMip\", download_dir=download_dir)\nimage_path = hcs_path / \"B\" / \"03\" / \"0\"\n\n# Open the ome-zarr container\nome_zarr = open_ome_zarr_container(image_path)\n</pre> from pathlib import Path  from ngio import open_ome_zarr_container from ngio.utils import download_ome_zarr_dataset  # Download the dataset download_dir = Path(\".\").absolute().parent.parent / \"data\" hcs_path = download_ome_zarr_dataset(\"CardiomyocyteTinyMip\", download_dir=download_dir) image_path = hcs_path / \"B\" / \"03\" / \"0\"  # Open the ome-zarr container ome_zarr = open_ome_zarr_container(image_path) <pre>/opt/hostedtoolcache/Python/3.13.11/x64/lib/python3.13/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n  from .autonotebook import tqdm as notebook_tqdm\n</pre> <pre>Downloading data from 'https://zenodo.org/records/13305156/files/20200812-CardiomyocyteDifferentiation14-Cycle1_mip.zarr.zip' to file '/home/runner/work/ngio/ngio/data/20200812-CardiomyocyteDifferentiation14-Cycle1-tiny-mip.zarr.zip'.\n</pre> <pre>Unzipping contents of '/home/runner/work/ngio/ngio/data/20200812-CardiomyocyteDifferentiation14-Cycle1-tiny-mip.zarr.zip' to '/home/runner/work/ngio/ngio/data/tmp'\n</pre> In\u00a0[3]: Copied! <pre>from ngio.transforms import ZoomTransform\n\n# First we will need the image object and the FOVs table\nimage = ome_zarr.get_image()\n\n# Get the nuclei label\nnuclei = ome_zarr.get_label(\"nuclei\")\n\n# In this example we the image is available at an higher resolution than the nuclei\nprint(f\"Image dimensions: {image.dimensions}, pixel size: {image.pixel_size}\")\nprint(f\"Nuclei dimensions: {nuclei.dimensions}, pixel size: {nuclei.pixel_size}\")\n\n# We need to setup a transform to resample the nuclei to the image resolution\nzoom_transform = ZoomTransform(\n    input_image=nuclei,\n    target_image=image,\n    order=\"nearest\",  # Nearest neighbor interpolation for labels\n)\n</pre> from ngio.transforms import ZoomTransform  # First we will need the image object and the FOVs table image = ome_zarr.get_image()  # Get the nuclei label nuclei = ome_zarr.get_label(\"nuclei\")  # In this example we the image is available at an higher resolution than the nuclei print(f\"Image dimensions: {image.dimensions}, pixel size: {image.pixel_size}\") print(f\"Nuclei dimensions: {nuclei.dimensions}, pixel size: {nuclei.pixel_size}\")  # We need to setup a transform to resample the nuclei to the image resolution zoom_transform = ZoomTransform(     input_image=nuclei,     target_image=image,     order=\"nearest\",  # Nearest neighbor interpolation for labels ) <pre>Image dimensions: Dimensions(c: 1, z: 1, y: 2160, x: 5120), pixel size: x=0.1625 y=0.1625 z=1.0 t=1.0 space_unit='micrometer' time_unit=None\nNuclei dimensions: Dimensions(z: 1, y: 540, x: 1280), pixel size: x=0.65 y=0.65 z=1.0 t=1.0 space_unit='micrometer' time_unit=None\n</pre> In\u00a0[4]: Copied! <pre>from ngio.experimental.iterators import FeatureExtractorIterator\nfrom ngio.tables import FeatureTable\n\niterator = FeatureExtractorIterator(\n    input_image=image,\n    input_label=nuclei,\n    label_transforms=[zoom_transform],\n    axes_order=[\"y\", \"x\", \"c\"],\n)\n\nfeat_table = []\nfor image_data, label_data, roi in iterator.iter_as_numpy():\n    print(f\"Processing ROI: {roi}\")\n    roi_feat_table = extract_features(image=image_data, label=label_data)\n    feat_table.append(roi_feat_table)\n\n# Concatenate all the dataframes into a single one\nfeat_table = pd.concat(feat_table)\nfeat_table = FeatureTable(table_data=feat_table, reference_label=\"nuclei\")\nome_zarr.add_table(\"nuclei_regionprops\", feat_table)\n</pre> from ngio.experimental.iterators import FeatureExtractorIterator from ngio.tables import FeatureTable  iterator = FeatureExtractorIterator(     input_image=image,     input_label=nuclei,     label_transforms=[zoom_transform],     axes_order=[\"y\", \"x\", \"c\"], )  feat_table = [] for image_data, label_data, roi in iterator.iter_as_numpy():     print(f\"Processing ROI: {roi}\")     roi_feat_table = extract_features(image=image_data, label=label_data)     feat_table.append(roi_feat_table)  # Concatenate all the dataframes into a single one feat_table = pd.concat(feat_table) feat_table = FeatureTable(table_data=feat_table, reference_label=\"nuclei\") ome_zarr.add_table(\"nuclei_regionprops\", feat_table) <pre>Processing ROI: name=None slices=[z: 0.0-&gt;1.0, y: 0.0-&gt;351.0, x: 0.0-&gt;832.0] label=None space='world'\n</pre> <pre>/opt/hostedtoolcache/Python/3.13.11/x64/lib/python3.13/site-packages/anndata/_io/zarr.py:44: UserWarning: Writing zarr v2 data will no longer be the default in the next minor release. v3 data will be written by default. If you are explicitly setting this configuration, consider migrating to the zarr v3 file format.\n  f = open_write_group(store)\n</pre> In\u00a0[5]: Copied! <pre>ome_zarr.get_table(\"nuclei_regionprops\").lazy_frame.collect()\n</pre> ome_zarr.get_table(\"nuclei_regionprops\").lazy_frame.collect() Out[5]: shape: (1_497, 5)labelareamean_intensity-0max_intensity-0min_intensity-0i64f64f64f64f6411360.0184.579412268.0125.022464.0273.246753461.0132.031968.0277.291667429.0143.045120.0279.035156413.0118.05288.0243.315972341.0147.0\u2026\u2026\u2026\u2026\u202614931248.0269.291667385.0108.01494528.0315.710227475.0128.01495608.0281.544408377.0122.01496288.0261.003472356.0122.01497432.0336.101852454.0172.0 In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/feature_extraction/#feature-extraction","title":"Feature Extraction\u00b6","text":"<p>This sections will cover how to extract regionprops features from an image using <code>ngio</code>, <code>skimage</code>. Moreover we will also write the features to a table in the ome-zarr container.</p>"},{"location":"tutorials/feature_extraction/#step-1-open-the-ome-zarr-container","title":"Step 1: Open the OME-Zarr Container\u00b6","text":""},{"location":"tutorials/feature_extraction/#step-2-setup-the-inputs","title":"Step 2: Setup the inputs\u00b6","text":""},{"location":"tutorials/feature_extraction/#step-3-use-the-featureextractoriterator-to-create-a-feature-table","title":"Step 3: Use the FeatureExtractorIterator to create a feature table\u00b6","text":""},{"location":"tutorials/feature_extraction/#sanity-check-read-the-table-back","title":"Sanity Check: Read the Table back\u00b6","text":""},{"location":"tutorials/hcs_exploration/","title":"HCS Plates","text":"In\u00a0[1]: Copied! <pre>from pathlib import Path\n\nfrom ngio import open_ome_zarr_plate\nfrom ngio.utils import download_ome_zarr_dataset\n\n# Download the dataset\ndownload_dir = Path(\".\").absolute().parent.parent / \"data\"\n\nhcs_path = download_ome_zarr_dataset(\"CardiomyocyteTinyMip\", download_dir=download_dir)\nhcs_zarr = open_ome_zarr_plate(hcs_path)\nprint(hcs_zarr)\nprint(f\"Rows: {hcs_zarr.rows}, Columns: {hcs_zarr.columns}\")\n\n# Get all the images in the plate\nhcs_zarr.get_images()\n</pre> from pathlib import Path  from ngio import open_ome_zarr_plate from ngio.utils import download_ome_zarr_dataset  # Download the dataset download_dir = Path(\".\").absolute().parent.parent / \"data\"  hcs_path = download_ome_zarr_dataset(\"CardiomyocyteTinyMip\", download_dir=download_dir) hcs_zarr = open_ome_zarr_plate(hcs_path) print(hcs_zarr) print(f\"Rows: {hcs_zarr.rows}, Columns: {hcs_zarr.columns}\")  # Get all the images in the plate hcs_zarr.get_images() <pre>/opt/hostedtoolcache/Python/3.13.11/x64/lib/python3.13/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n  from .autonotebook import tqdm as notebook_tqdm\n</pre> <pre>Unzipping contents of '/home/runner/work/ngio/ngio/data/20200812-CardiomyocyteDifferentiation14-Cycle1-tiny-mip.zarr.zip' to '/home/runner/work/ngio/ngio/data/tmp'\n</pre> <pre>Plate([rows x columns] (1 x 1))\nRows: ['B'], Columns: ['03']\n</pre> Out[1]: <pre>{'B/03/0': OmeZarrContainer(levels=5, labels=['nuclei'], #tables=4)}</pre> In\u00a0[2]: Copied! <pre># Aggregate all table across all images\n\ntable = hcs_zarr.concatenate_image_tables(name=\"nuclei\")\ntable.dataframe\n</pre> # Aggregate all table across all images  table = hcs_zarr.concatenate_image_tables(name=\"nuclei\") table.dataframe <pre>/opt/hostedtoolcache/Python/3.13.11/x64/lib/python3.13/functools.py:934: ImplicitModificationWarning: Transforming to str index.\n  return dispatch(args[0].__class__)(*args, **kw)\n</pre> Out[2]: area bbox_area equivalent_diameter max_intensity mean_intensity min_intensity standard_deviation_intensity row column path_in_well label 1 1360.0 1664.0 13.746119 268.0 184.579407 125.0 24.502481 B 03 0 2 2464.0 2992.0 16.757685 461.0 273.246765 132.0 51.794971 B 03 0 3 1968.0 2688.0 15.548035 429.0 277.291656 143.0 41.822422 B 03 0 4 5120.0 6400.0 21.384073 413.0 279.035156 118.0 44.379074 B 03 0 5 288.0 352.0 8.193409 341.0 243.315979 147.0 41.861721 B 03 0 ... ... ... ... ... ... ... ... ... ... ... 1493 1248.0 1440.0 13.357914 385.0 269.291656 108.0 45.967396 B 03 0 1494 528.0 704.0 10.027941 475.0 315.710236 128.0 70.174896 B 03 0 1495 608.0 768.0 10.510781 377.0 281.544403 122.0 34.698723 B 03 0 1496 288.0 480.0 8.193409 356.0 261.003479 122.0 44.835232 B 03 0 1497 432.0 528.0 9.379111 454.0 336.101837 172.0 53.799728 B 03 0 <p>1497 rows \u00d7 10 columns</p> In\u00a0[3]: Copied! <pre># Save the tabvle in the HCS plate\nhcs_zarr.add_table(name=\"nuclei\", table=table)\n\n# Read the table back for sanity check\nhcs_zarr.get_table(\"nuclei\").dataframe\n</pre> # Save the tabvle in the HCS plate hcs_zarr.add_table(name=\"nuclei\", table=table)  # Read the table back for sanity check hcs_zarr.get_table(\"nuclei\").dataframe <pre>/opt/hostedtoolcache/Python/3.13.11/x64/lib/python3.13/site-packages/anndata/_io/zarr.py:44: UserWarning: Writing zarr v2 data will no longer be the default in the next minor release. v3 data will be written by default. If you are explicitly setting this configuration, consider migrating to the zarr v3 file format.\n  f = open_write_group(store)\n</pre> Out[3]: area bbox_area equivalent_diameter max_intensity mean_intensity min_intensity standard_deviation_intensity row column path_in_well label 1 1360.0 1664.0 13.746119 268.0 184.579407 125.0 24.502481 B 03 0 2 2464.0 2992.0 16.757685 461.0 273.246765 132.0 51.794971 B 03 0 3 1968.0 2688.0 15.548035 429.0 277.291656 143.0 41.822422 B 03 0 4 5120.0 6400.0 21.384073 413.0 279.035156 118.0 44.379074 B 03 0 5 288.0 352.0 8.193409 341.0 243.315979 147.0 41.861721 B 03 0 ... ... ... ... ... ... ... ... ... ... ... 1493 1248.0 1440.0 13.357914 385.0 269.291656 108.0 45.967396 B 03 0 1494 528.0 704.0 10.027941 475.0 315.710236 128.0 70.174896 B 03 0 1495 608.0 768.0 10.510781 377.0 281.544403 122.0 34.698723 B 03 0 1496 288.0 480.0 8.193409 356.0 261.003479 122.0 44.835232 B 03 0 1497 432.0 528.0 9.379111 454.0 336.101837 172.0 53.799728 B 03 0 <p>1497 rows \u00d7 10 columns</p> In\u00a0[4]: Copied! <pre>from ngio import ImageInWellPath, create_empty_plate\n\ntest_plate = create_empty_plate(\n    store=\"./data/empty_plate.zarr\",\n    name=\"Test Plate\",\n    images=[\n        ImageInWellPath(row=\"A\", column=\"01\", path=\"0\"),\n        ImageInWellPath(row=\"A\", column=\"02\", path=\"0\"),\n        ImageInWellPath(row=\"A\", column=\"02\", path=\"1\", acquisition_id=1),\n    ],\n    overwrite=True,\n)\n\nprint(test_plate)\nprint(f\"Rows: {test_plate.rows}, Columns: {test_plate.columns}\")\n</pre> from ngio import ImageInWellPath, create_empty_plate  test_plate = create_empty_plate(     store=\"./data/empty_plate.zarr\",     name=\"Test Plate\",     images=[         ImageInWellPath(row=\"A\", column=\"01\", path=\"0\"),         ImageInWellPath(row=\"A\", column=\"02\", path=\"0\"),         ImageInWellPath(row=\"A\", column=\"02\", path=\"1\", acquisition_id=1),     ],     overwrite=True, )  print(test_plate) print(f\"Rows: {test_plate.rows}, Columns: {test_plate.columns}\") <pre>Plate([rows x columns] (1 x 2))\nRows: ['A'], Columns: ['01', '02']\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/hcs_exploration/#hcs-plates","title":"HCS Plates\u00b6","text":"<p>This is a minimal example of how to work with OME-Zarr Plates using <code>ngio</code>.</p>"},{"location":"tutorials/hcs_exploration/#show-whats-in-the-plate","title":"Show what's in the plate\u00b6","text":""},{"location":"tutorials/hcs_exploration/#aggregate-tables-across-all-images","title":"Aggregate tables across all images\u00b6","text":""},{"location":"tutorials/hcs_exploration/#save-the-table-in-the-hcs-plate","title":"Save the table in the HCS plate\u00b6","text":""},{"location":"tutorials/hcs_exploration/#create-a-new-empty-plate","title":"Create a new empty Plate\u00b6","text":""},{"location":"tutorials/image_processing/","title":"Image Processing","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport skimage\n\n\ndef gaussian_blur(image: np.ndarray, sigma: float) -&gt; np.ndarray:\n    \"\"\"Apply gaussian blur to an image.\"\"\"\n    original_type = image.dtype\n    image = skimage.filters.gaussian(\n        image, sigma=sigma, channel_axis=0, preserve_range=True\n    )\n    # Convert the image back to the original type\n    image = image.astype(original_type)\n    return image\n</pre> import numpy as np import skimage   def gaussian_blur(image: np.ndarray, sigma: float) -&gt; np.ndarray:     \"\"\"Apply gaussian blur to an image.\"\"\"     original_type = image.dtype     image = skimage.filters.gaussian(         image, sigma=sigma, channel_axis=0, preserve_range=True     )     # Convert the image back to the original type     image = image.astype(original_type)     return image In\u00a0[2]: Copied! <pre>from pathlib import Path\n\nfrom ngio import open_ome_zarr_container\nfrom ngio.utils import download_ome_zarr_dataset\n\n# Download the dataset\ndownload_dir = Path(\".\").absolute().parent.parent / \"data\"\n\nhcs_path = download_ome_zarr_dataset(\"CardiomyocyteTiny\", download_dir=download_dir)\nimage_path = hcs_path / \"B\" / \"03\" / \"0\"\n\n# Open the ome-zarr container\nome_zarr = open_ome_zarr_container(image_path)\n</pre> from pathlib import Path  from ngio import open_ome_zarr_container from ngio.utils import download_ome_zarr_dataset  # Download the dataset download_dir = Path(\".\").absolute().parent.parent / \"data\"  hcs_path = download_ome_zarr_dataset(\"CardiomyocyteTiny\", download_dir=download_dir) image_path = hcs_path / \"B\" / \"03\" / \"0\"  # Open the ome-zarr container ome_zarr = open_ome_zarr_container(image_path) <pre>/opt/hostedtoolcache/Python/3.13.11/x64/lib/python3.13/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n  from .autonotebook import tqdm as notebook_tqdm\n</pre> <pre>Unzipping contents of '/home/runner/work/ngio/ngio/data/20200812-CardiomyocyteDifferentiation14-Cycle1-tiny.zarr.zip' to '/home/runner/work/ngio/ngio/data/tmp'\n</pre> In\u00a0[3]: Copied! <pre># First we will need the image object\nimage = ome_zarr.get_image()\n\n# Second we need to derive a new ome-zarr image where we will store\n# the processed image\n\nblurred_omezarr_path = image_path.parent / \"0_blurred\"\nblurred_omezarr = ome_zarr.derive_image(\n    store=blurred_omezarr_path, name=\"Blurred Image\", overwrite=True\n)\nblurred_image = blurred_omezarr.get_image()\n</pre> # First we will need the image object image = ome_zarr.get_image()  # Second we need to derive a new ome-zarr image where we will store # the processed image  blurred_omezarr_path = image_path.parent / \"0_blurred\" blurred_omezarr = ome_zarr.derive_image(     store=blurred_omezarr_path, name=\"Blurred Image\", overwrite=True ) blurred_image = blurred_omezarr.get_image() In\u00a0[4]: Copied! <pre># We can use the axes order to specify how we query the image data.\n# Here we will reorder the axes to be [\"c\", \"z\", \"y\", \"x\"].\n# So that it will be compatible with the gaussian blur function\n# which expects the channel axis to be the first one.\nimage_data = image.get_as_numpy(axes_order=[\"c\", \"z\", \"y\", \"x\"])\n# Apply gaussian blur to the image\nsigma = 5.0\nblurred_image_data = gaussian_blur(image_data, sigma=sigma)\n\n# Set the processed image data back to the ome-zarr image\nblurred_image.set_array(patch=blurred_image_data, axes_order=[\"c\", \"z\", \"y\", \"x\"])\n\n# The `set_array` method only saved the blurred image to the container at a specific\n# resolution level. So all other resolution levels are still empty.\n# To propagate the changes to all resolution levels,\n# we can use the `consolidate` method.\nblurred_image.consolidate()\n</pre> # We can use the axes order to specify how we query the image data. # Here we will reorder the axes to be [\"c\", \"z\", \"y\", \"x\"]. # So that it will be compatible with the gaussian blur function # which expects the channel axis to be the first one. image_data = image.get_as_numpy(axes_order=[\"c\", \"z\", \"y\", \"x\"]) # Apply gaussian blur to the image sigma = 5.0 blurred_image_data = gaussian_blur(image_data, sigma=sigma)  # Set the processed image data back to the ome-zarr image blurred_image.set_array(patch=blurred_image_data, axes_order=[\"c\", \"z\", \"y\", \"x\"])  # The `set_array` method only saved the blurred image to the container at a specific # resolution level. So all other resolution levels are still empty. # To propagate the changes to all resolution levels, # we can use the `consolidate` method. blurred_image.consolidate() In\u00a0[5]: Copied! <pre>import matplotlib.pyplot as plt\nimport numpy as np\nfrom matplotlib.colors import ListedColormap\n\nrand_cmap = np.random.rand(1000, 3)\nrand_cmap[0] = 0\nrand_cmap = ListedColormap(rand_cmap)\n\nfig, axs = plt.subplots(2, 1, figsize=(8, 4))\naxs[0].set_title(\"Original image\")\naxs[0].imshow(image.get_as_numpy(c=0, z=1, axes_order=[\"y\", \"x\"]), cmap=\"gray\")\naxs[1].set_title(\"Blurred image\")\naxs[1].imshow(blurred_image.get_as_numpy(c=0, z=1, axes_order=[\"y\", \"x\"]), cmap=\"gray\")\nfor ax in axs:\n    ax.axis(\"off\")\nplt.tight_layout()\nplt.show()\n</pre> import matplotlib.pyplot as plt import numpy as np from matplotlib.colors import ListedColormap  rand_cmap = np.random.rand(1000, 3) rand_cmap[0] = 0 rand_cmap = ListedColormap(rand_cmap)  fig, axs = plt.subplots(2, 1, figsize=(8, 4)) axs[0].set_title(\"Original image\") axs[0].imshow(image.get_as_numpy(c=0, z=1, axes_order=[\"y\", \"x\"]), cmap=\"gray\") axs[1].set_title(\"Blurred image\") axs[1].imshow(blurred_image.get_as_numpy(c=0, z=1, axes_order=[\"y\", \"x\"]), cmap=\"gray\") for ax in axs:     ax.axis(\"off\") plt.tight_layout() plt.show() In\u00a0[6]: Copied! <pre>from dask import array as da\n\n\ndef dask_gaussian_blur(image: da.Array, sigma: float) -&gt; da.Array:\n    \"\"\"Apply gaussian blur to a dask array.\"\"\"\n    # This will itroduce some edge artifacts at chunk boundaries\n    # In a real application, consider using map_overlap to mitigate this\n    # With appropriate depth based on sigma\n    return da.map_blocks(gaussian_blur, image, dtype=image.dtype, sigma=sigma)\n\n\nimage_dask = image.get_as_dask(axes_order=[\"c\", \"z\", \"y\", \"x\"])\nblurred_image_dask = dask_gaussian_blur(image_dask, sigma=sigma)\nblurred_image_dask\n</pre> from dask import array as da   def dask_gaussian_blur(image: da.Array, sigma: float) -&gt; da.Array:     \"\"\"Apply gaussian blur to a dask array.\"\"\"     # This will itroduce some edge artifacts at chunk boundaries     # In a real application, consider using map_overlap to mitigate this     # With appropriate depth based on sigma     return da.map_blocks(gaussian_blur, image, dtype=image.dtype, sigma=sigma)   image_dask = image.get_as_dask(axes_order=[\"c\", \"z\", \"y\", \"x\"]) blurred_image_dask = dask_gaussian_blur(image_dask, sigma=sigma) blurred_image_dask Out[6]:  Array   Chunk   Bytes   42.19 MiB   10.55 MiB   Shape   (1, 2, 2160, 5120)   (1, 1, 2160, 2560)   Dask graph   4 chunks in 3 graph layers   Data type   uint16 numpy.ndarray  1 1 5120 2160 2 In\u00a0[7]: Copied! <pre>from ngio.experimental.iterators import ImageProcessingIterator\n\niterator = ImageProcessingIterator(\n    input_image=image,\n    output_image=blurred_image,\n    axes_order=[\"c\", \"z\", \"y\", \"x\"],\n)\n\n# After initializing the iterator, the iterator will have created\n# will iterate over the entire image.\nprint(f\"Iterator after initialization: {iterator}\")\n\n# Iterate over an arbitrary region of interest table\n# We can use the product method that performs a cartesian product\n# between the iterator and the table.\ntable = ome_zarr.get_roi_table(\"FOV_ROI_table\")\niterator = iterator.product(table)\nprint(f\"Iterator after product with table: {iterator}\")\n\n# We can explicitly set a broadcasting behavior\n# For example we can iterate over all zyx planes, and broadcast all the other\n# spatial dimensions\niterator = iterator.by_zyx()\n\n# Finally (if needed) we can check if the regions are not-overlapping\niterator.require_no_regions_overlap()\n# We can also check if the regions lay on non-overlapping chunks\niterator.require_no_chunks_overlap()\n\n# Now we can map the gaussian blur function to the iterator\niterator.map_as_numpy(lambda x: gaussian_blur(x, sigma=sigma))\n\n# No need to consolidate, the iterator takes care of that\n# after all the regions have been processed\n</pre> from ngio.experimental.iterators import ImageProcessingIterator  iterator = ImageProcessingIterator(     input_image=image,     output_image=blurred_image,     axes_order=[\"c\", \"z\", \"y\", \"x\"], )  # After initializing the iterator, the iterator will have created # will iterate over the entire image. print(f\"Iterator after initialization: {iterator}\")  # Iterate over an arbitrary region of interest table # We can use the product method that performs a cartesian product # between the iterator and the table. table = ome_zarr.get_roi_table(\"FOV_ROI_table\") iterator = iterator.product(table) print(f\"Iterator after product with table: {iterator}\")  # We can explicitly set a broadcasting behavior # For example we can iterate over all zyx planes, and broadcast all the other # spatial dimensions iterator = iterator.by_zyx()  # Finally (if needed) we can check if the regions are not-overlapping iterator.require_no_regions_overlap() # We can also check if the regions lay on non-overlapping chunks iterator.require_no_chunks_overlap()  # Now we can map the gaussian blur function to the iterator iterator.map_as_numpy(lambda x: gaussian_blur(x, sigma=sigma))  # No need to consolidate, the iterator takes care of that # after all the regions have been processed <pre>Iterator after initialization: ImageProcessingIterator(regions=1)\nIterator after product with table: ImageProcessingIterator(regions=2)\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/image_processing/#image-processing","title":"Image Processing\u00b6","text":"<p>This is a minimal example of how to use the <code>ngio</code> library for applying some basic image processing techniques.</p> <p>For this example we will apply gaussian blur to an image.</p>"},{"location":"tutorials/image_processing/#step-1-setup","title":"Step 1: Setup\u00b6","text":"<p>We will first create a simple function to apply gaussian blur to an image. This function will take an image and a sigma value as input and return the blurred image.</p>"},{"location":"tutorials/image_processing/#step-2-open-the-omezarr-container","title":"Step 2: Open the OmeZarr container\u00b6","text":""},{"location":"tutorials/image_processing/#step-3-create-a-new-empty-omezarr-container","title":"Step 3: Create a new empty omeZarr container\u00b6","text":"<p>ngio provide a simple way to \"derive\" a new container from an existing one. This is useful when you want to apply some processing to an image and save the results in a new container that preserves the original metadata and dimensions (unless explicitly changed when deriving).</p>"},{"location":"tutorials/image_processing/#step-4-apply-the-gaussian-blur-and-consolidate-the-processed-image","title":"Step 4: Apply the gaussian blur and consolidate the processed image\u00b6","text":""},{"location":"tutorials/image_processing/#plot-the-results","title":"Plot the results\u00b6","text":"<p>Finally, we can visualize the original and blurred images using <code>matplotlib</code>.</p>"},{"location":"tutorials/image_processing/#step-5-out-of-memory-processing","title":"Step 5: Out of memory processing\u00b6","text":"<p>Sometimes we want to apply some simple processing to larger than memory images. In this case, we can use the <code>dask</code> library to process the image in chunks. In <code>ngio</code> we can simply query the data as a <code>dask</code> array and apply the desired processing function to it.</p>"},{"location":"tutorials/image_processing/#step-6-image-processing-iterators","title":"Step 6. Image Processing Iterators\u00b6","text":"<p><code>ngio</code> provides an alternative way to process large images using iterators. This API is not meant to replace <code>dask</code> but to provide a simple way to iterate over arbitrary regions, moreover it provides a simple way to implement default broadcasting behaviors.</p>"},{"location":"tutorials/image_segmentation/","title":"Image Segmentation","text":"In\u00a0[1]: Copied! <pre># Setup a simple segmentation function\nimport numpy as np\nimport skimage\n\n\ndef otsu_threshold_segmentation(image: np.ndarray, max_label: int) -&gt; np.ndarray:\n    \"\"\"Simple segmentation using Otsu thresholding.\"\"\"\n    threshold = skimage.filters.threshold_otsu(image)\n    binary = image &gt; threshold\n    label_image = skimage.measure.label(binary)\n    label_image += max_label\n    label_image = np.where(binary, label_image, 0)\n    return label_image.astype(np.uint32)\n</pre> # Setup a simple segmentation function import numpy as np import skimage   def otsu_threshold_segmentation(image: np.ndarray, max_label: int) -&gt; np.ndarray:     \"\"\"Simple segmentation using Otsu thresholding.\"\"\"     threshold = skimage.filters.threshold_otsu(image)     binary = image &gt; threshold     label_image = skimage.measure.label(binary)     label_image += max_label     label_image = np.where(binary, label_image, 0)     return label_image.astype(np.uint32) In\u00a0[2]: Copied! <pre>from pathlib import Path\n\nfrom ngio import open_ome_zarr_container\nfrom ngio.utils import download_ome_zarr_dataset\n\n# Download the dataset\ndownload_dir = Path(\".\").absolute().parent.parent / \"data\"\nhcs_path = download_ome_zarr_dataset(\"CardiomyocyteTiny\", download_dir=download_dir)\nimage_path = hcs_path / \"B\" / \"03\" / \"0\"\n\n# Open the ome-zarr container\nome_zarr = open_ome_zarr_container(image_path)\n</pre> from pathlib import Path  from ngio import open_ome_zarr_container from ngio.utils import download_ome_zarr_dataset  # Download the dataset download_dir = Path(\".\").absolute().parent.parent / \"data\" hcs_path = download_ome_zarr_dataset(\"CardiomyocyteTiny\", download_dir=download_dir) image_path = hcs_path / \"B\" / \"03\" / \"0\"  # Open the ome-zarr container ome_zarr = open_ome_zarr_container(image_path) <pre>/opt/hostedtoolcache/Python/3.13.11/x64/lib/python3.13/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n  from .autonotebook import tqdm as notebook_tqdm\n</pre> <pre>Unzipping contents of '/home/runner/work/ngio/ngio/data/20200812-CardiomyocyteDifferentiation14-Cycle1-tiny.zarr.zip' to '/home/runner/work/ngio/ngio/data/tmp'\n</pre> In\u00a0[3]: Copied! <pre>from ngio.experimental.iterators import SegmentationIterator\n\n# First we will need the image object and the FOVs table\nimage = ome_zarr.get_image()\nroi_table = ome_zarr.get_roi_table(\"FOV_ROI_table\")\n\n# Second we need to derive a new label image to use as target for the segmentation\n\nlabel = ome_zarr.derive_label(\"new_label\", overwrite=True)\n\n# Setup the segmentation iterator\nseg_iterator = SegmentationIterator(\n    input_image=image,\n    output_label=label,\n    channel_selection=\"DAPI\",\n    axes_order=[\"z\", \"y\", \"x\"],\n)\nseg_iterator = seg_iterator.product(roi_table)\n\n# Make sure that if other axes are present they are iterated over\nseg_iterator = seg_iterator.by_zyx()\n\nmax_label = 0  # We will use this to avoid label collisions\nfor image_data, label_writer in seg_iterator.iter_as_numpy():\n    roi_segmentation = otsu_threshold_segmentation(\n        image_data, max_label\n    )  # Segment the image\n\n    max_label = roi_segmentation.max()  # Get the max label for the next iteration\n\n    label_writer(patch=roi_segmentation)  # Write the segmentation back to the label\n\n# No need to consolidate, the iterator does it automatically after the last write\n</pre> from ngio.experimental.iterators import SegmentationIterator  # First we will need the image object and the FOVs table image = ome_zarr.get_image() roi_table = ome_zarr.get_roi_table(\"FOV_ROI_table\")  # Second we need to derive a new label image to use as target for the segmentation  label = ome_zarr.derive_label(\"new_label\", overwrite=True)  # Setup the segmentation iterator seg_iterator = SegmentationIterator(     input_image=image,     output_label=label,     channel_selection=\"DAPI\",     axes_order=[\"z\", \"y\", \"x\"], ) seg_iterator = seg_iterator.product(roi_table)  # Make sure that if other axes are present they are iterated over seg_iterator = seg_iterator.by_zyx()  max_label = 0  # We will use this to avoid label collisions for image_data, label_writer in seg_iterator.iter_as_numpy():     roi_segmentation = otsu_threshold_segmentation(         image_data, max_label     )  # Segment the image      max_label = roi_segmentation.max()  # Get the max label for the next iteration      label_writer(patch=roi_segmentation)  # Write the segmentation back to the label  # No need to consolidate, the iterator does it automatically after the last write In\u00a0[4]: Copied! <pre>import matplotlib.pyplot as plt\nimport numpy as np\nfrom matplotlib.colors import ListedColormap\n\nrand_cmap = np.random.rand(1000, 3)\nrand_cmap[0] = 0\nrand_cmap = ListedColormap(rand_cmap)\n\nfig, axs = plt.subplots(2, 1, figsize=(8, 4))\naxs[0].set_title(\"Original image\")\naxs[0].imshow(image.get_as_numpy(c=0, z=1, axes_order=[\"y\", \"x\"]), cmap=\"gray\")\naxs[1].set_title(\"Final segmentation\")\naxs[1].imshow(label.get_as_numpy(z=1, axes_order=[\"y\", \"x\"]), cmap=rand_cmap)\nfor ax in axs:\n    ax.axis(\"off\")\nplt.tight_layout()\nplt.show()\n</pre> import matplotlib.pyplot as plt import numpy as np from matplotlib.colors import ListedColormap  rand_cmap = np.random.rand(1000, 3) rand_cmap[0] = 0 rand_cmap = ListedColormap(rand_cmap)  fig, axs = plt.subplots(2, 1, figsize=(8, 4)) axs[0].set_title(\"Original image\") axs[0].imshow(image.get_as_numpy(c=0, z=1, axes_order=[\"y\", \"x\"]), cmap=\"gray\") axs[1].set_title(\"Final segmentation\") axs[1].imshow(label.get_as_numpy(z=1, axes_order=[\"y\", \"x\"]), cmap=rand_cmap) for ax in axs:     ax.axis(\"off\") plt.tight_layout() plt.show() In\u00a0[5]: Copied! <pre># Create a basic mask for illustration purposes\nmask = ome_zarr.derive_label(\"mask\", overwrite=True)\nmask_data = mask.get_as_numpy(axes_order=[\"z\", \"y\", \"x\"])\nmask_data[:, 200:-200, 500:2000] = 1\nmask_data[:, 200:-200, 3000:-500] = 2\nmask_data[:, 600:-600, 1200:-1000] = 0\nmask_data[:, 700:-700, 1600:-1500] = 3\nmask.set_array(mask_data, axes_order=[\"z\", \"y\", \"x\"])\nmask.consolidate()\n\nfig, axs = plt.subplots(2, 1, figsize=(8, 4))\naxs[0].set_title(\"Original image\")\naxs[0].imshow(image.get_as_numpy(c=0, z=1, axes_order=[\"y\", \"x\"]), cmap=\"gray\")\naxs[1].set_title(\"Mask\")\naxs[1].imshow(mask.get_as_numpy(z=1, axes_order=[\"y\", \"x\"]), cmap=rand_cmap)\nfor ax in axs:\n    ax.axis(\"off\")\nplt.tight_layout()\nplt.show()\n</pre> # Create a basic mask for illustration purposes mask = ome_zarr.derive_label(\"mask\", overwrite=True) mask_data = mask.get_as_numpy(axes_order=[\"z\", \"y\", \"x\"]) mask_data[:, 200:-200, 500:2000] = 1 mask_data[:, 200:-200, 3000:-500] = 2 mask_data[:, 600:-600, 1200:-1000] = 0 mask_data[:, 700:-700, 1600:-1500] = 3 mask.set_array(mask_data, axes_order=[\"z\", \"y\", \"x\"]) mask.consolidate()  fig, axs = plt.subplots(2, 1, figsize=(8, 4)) axs[0].set_title(\"Original image\") axs[0].imshow(image.get_as_numpy(c=0, z=1, axes_order=[\"y\", \"x\"]), cmap=\"gray\") axs[1].set_title(\"Mask\") axs[1].imshow(mask.get_as_numpy(z=1, axes_order=[\"y\", \"x\"]), cmap=rand_cmap) for ax in axs:     ax.axis(\"off\") plt.tight_layout() plt.show() In\u00a0[6]: Copied! <pre>from ngio.experimental.iterators import MaskedSegmentationIterator\n\n# First we will need the masked image object\n# (that contains the masking table information inside)\nimage = ome_zarr.get_masked_image(masking_label_name=\"mask\")\n\n# Second we need to derive a new label image to use as target for the segmentation\nlabel = ome_zarr.derive_label(\"masked_new_label\", overwrite=True)\n\n# Setup the masked segmentation iterator\nseg_iterator = MaskedSegmentationIterator(\n    input_image=image,\n    output_label=label,\n    channel_selection=\"DAPI\",\n    axes_order=[\"z\", \"y\", \"x\"],\n)\n\n# Make sure that if other axes are present they are iterated over\nseg_iterator = seg_iterator.by_zyx()\n\nmax_label = 0  # We will use this to avoid label collisions\nfor image_data, label_writer in seg_iterator.iter_as_numpy():\n    roi_segmentation = otsu_threshold_segmentation(\n        image_data, max_label\n    )  # Segment the image\n\n    max_label = roi_segmentation.max()  # Get the max label for the next iteration\n\n    label_writer(patch=roi_segmentation)  # Write the segmentation back to the label\n\n# No need to consolidate, the iterator does it automatically after the last write\n</pre> from ngio.experimental.iterators import MaskedSegmentationIterator  # First we will need the masked image object # (that contains the masking table information inside) image = ome_zarr.get_masked_image(masking_label_name=\"mask\")  # Second we need to derive a new label image to use as target for the segmentation label = ome_zarr.derive_label(\"masked_new_label\", overwrite=True)  # Setup the masked segmentation iterator seg_iterator = MaskedSegmentationIterator(     input_image=image,     output_label=label,     channel_selection=\"DAPI\",     axes_order=[\"z\", \"y\", \"x\"], )  # Make sure that if other axes are present they are iterated over seg_iterator = seg_iterator.by_zyx()  max_label = 0  # We will use this to avoid label collisions for image_data, label_writer in seg_iterator.iter_as_numpy():     roi_segmentation = otsu_threshold_segmentation(         image_data, max_label     )  # Segment the image      max_label = roi_segmentation.max()  # Get the max label for the next iteration      label_writer(patch=roi_segmentation)  # Write the segmentation back to the label  # No need to consolidate, the iterator does it automatically after the last write In\u00a0[7]: Copied! <pre>import matplotlib.pyplot as plt\nimport numpy as np\nfrom matplotlib.colors import ListedColormap\n\nfig, axs = plt.subplots(2, 1, figsize=(8, 4))\naxs[0].set_title(\"Original image\")\naxs[0].imshow(image.get_as_numpy(c=0, z=1, axes_order=[\"y\", \"x\"]), cmap=\"gray\")\naxs[1].set_title(\"Final segmentation\")\naxs[1].imshow(label.get_as_numpy(z=1, axes_order=[\"y\", \"x\"]), cmap=rand_cmap)\nfor ax in axs:\n    ax.axis(\"off\")\nplt.tight_layout()\nplt.show()\n</pre> import matplotlib.pyplot as plt import numpy as np from matplotlib.colors import ListedColormap  fig, axs = plt.subplots(2, 1, figsize=(8, 4)) axs[0].set_title(\"Original image\") axs[0].imshow(image.get_as_numpy(c=0, z=1, axes_order=[\"y\", \"x\"]), cmap=\"gray\") axs[1].set_title(\"Final segmentation\") axs[1].imshow(label.get_as_numpy(z=1, axes_order=[\"y\", \"x\"]), cmap=rand_cmap) for ax in axs:     ax.axis(\"off\") plt.tight_layout() plt.show()"},{"location":"tutorials/image_segmentation/#image-segmentation","title":"Image Segmentation\u00b6","text":"<p>This is a minimal tutorial on how to use ngio for image segmentation.</p>"},{"location":"tutorials/image_segmentation/#step-1-setup","title":"Step 1: Setup\u00b6","text":"<p>We will first implement a very simple function to segment an image. We will use skimage to do this.</p>"},{"location":"tutorials/image_segmentation/#step-2-open-the-omezarr-container","title":"Step 2: Open the OmeZarr container\u00b6","text":""},{"location":"tutorials/image_segmentation/#step-3-segment-the-image","title":"Step 3: Segment the image\u00b6","text":"<p>For this example, we will not segment the image all at once. Instead we will iterate over the image FOVs and segment them one by one.</p>"},{"location":"tutorials/image_segmentation/#plot-the-segmentation","title":"Plot the segmentation\u00b6","text":""},{"location":"tutorials/image_segmentation/#step-4-masked-image-segmentation","title":"Step 4: Masked image segmentation\u00b6","text":"<p>In this example we will use a mask to restrict the segmentation to certain areas of the image. In this case we will create a simple mask for illustration purposes, but in a real case scenario the mask could come from another segmentation mask.</p>"}]}