{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"NGIO: Streamlined OME-Zarr Image Analysis","text":"<p>ngio is a Python library designed to simplify bioimage analysis workflows, offering an intuitive interface for working with OME-Zarr files.</p>"},{"location":"#what-is-ngio","title":"What is Ngio?","text":"<p>Ngio is built for the OME-Zarr file format, a modern, cloud-optimized format for biological imaging data. OME-Zarr stores large, multi-dimensional microscopy images and metadata in an efficient and scalable way.</p> <p>Ngio's mission is to streamline working with OME-Zarr files by providing a simple, object-based API for opening, exploring, and manipulating OME-Zarr images and high-content screening (HCS) plates. It also offers comprehensive support for labels, tables and regions of interest (ROIs), making it easy to extract and analyze specific regions in your data.</p>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#simple-object-based-api","title":"\ud83d\udcca Simple Object-Based API","text":"<ul> <li>Easily open, explore, and manipulate OME-Zarr images and HCS plates</li> <li>Create and derive new images and labels with minimal boilerplate code</li> </ul>"},{"location":"#rich-tables-and-regions-of-interest-roi-support","title":"\ud83d\udd0d Rich Tables and Regions of Interest (ROI) Support","text":"<ul> <li>Extract and analyze specific regions of interest</li> <li>Tight integration with Fractal's table framework</li> </ul>"},{"location":"#scalable-data-processing-coming-soon","title":"\ud83d\udd04 Scalable Data Processing (Coming Soon)","text":"<ul> <li>Powerful iterators for processing data at scale</li> <li>Efficient memory management for large datasets</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Refer to the Getting Started guide to integrate ngio into your workflows. We also provide a collection of Tutorials to help you get up and running quickly. For more advanced usage and API documentation, see our API Reference.</p>"},{"location":"#supported-ome-zarr-versions","title":"Supported OME-Zarr versions","text":"<p>Currently, ngio only supports OME-Zarr v0.4. Support for version 0.5 and higher is planned for future releases.</p>"},{"location":"#development-status","title":"Development Status","text":"<p>Warning</p> <p>Ngio is under active development and is not yet stable. The API is subject to change, and bugs and breaking changes are expected. We follow Semantic Versioning. Which means for 0.x releases potentially breaking changes can be introduced in minor releases.</p>"},{"location":"#available-features","title":"Available Features","text":"<ul> <li>\u2705 OME-Zarr metadata handling and validation</li> <li>\u2705 Image and label access across pyramid levels</li> <li>\u2705 ROI and table support</li> <li>\u2705 Streaming from remote sources</li> <li>\u2705 Documentation and examples</li> </ul>"},{"location":"#upcoming-features","title":"Upcoming Features","text":"<ul> <li>Advanced image processing iterators</li> <li>Parallel processing capabilities</li> <li>Support for OME-Zarr v0.5 and Zarr v3</li> </ul>"},{"location":"#contributors","title":"Contributors","text":"<p>Ngio is developed at the BioVisionCenter, University of Zurich, by @lorenzocerrone and @jluethi.</p>"},{"location":"#license","title":"License","text":"<p>Ngio is released under the BSD-3-Clause License. See LICENSE for details.</p>"},{"location":"#repository","title":"Repository","text":"<p>Visit our GitHub repository for the latest code, issues, and contributions.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v040a1","title":"[v0.4.0a1]","text":""},{"location":"changelog/#features","title":"Features","text":"<ul> <li>add support for time in rois and roi-tables</li> <li>Building masking roi tables expanded to time series data</li> <li>add experimental support for Iterators</li> <li>add support for rescaling on-the-fly masks for masked images</li> </ul>"},{"location":"changelog/#api-changes","title":"API Changes","text":"<ul> <li>The image-like <code>get_*</code> api have been slightly changed. Now if a single int is passed as slice_kwargs, it is interpreted as a single index. So the dimension is automatically squeezed.</li> <li>Remove the <code>get_*_delayed</code> methods, now data cam only be loaded as numpy or dask array.Use the <code>get_as_dask</code> method instead, which returns a dask array that can be used with dask delayed.</li> <li>A new model for channel selection is available. Now channels can be selected by name, index or with <code>ChannelSelectionModel</code> object.</li> <li>Change <code>table_name</code> keyword argument to <code>name</code> for consistency in all table concatenation functions, e.g. <code>concatenate_image_tables</code>,  <code>concatenate_image_tables_as</code>, etc.</li> <li>Change to <code>Dimension</code> class. <code>get_shape</code> and <code>get_canonical_shape</code> have been removed, <code>get</code> uses new keyword arguments <code>default</code> instead of <code>strict</code>.</li> <li>Image like objects now have a more clean API to load data. Instead of <code>get_array</code> and <code>set_array</code>, they now use <code>get_as_numpy</code>, and <code>get_as_dask</code> for delayed arrays.</li> <li>Also for <code>get_roi</code> now specific methods are available. For ROI objects, the <code>get_roi_as_numpy</code>, and <code>get_roi_as_dask</code> methods.</li> <li>Table ops moved to <code>ngio.images</code></li> <li>Make <code>label</code> an explicit attribute in <code>Roi</code> objects.</li> </ul>"},{"location":"changelog/#table-specs","title":"Table specs","text":"<ul> <li>add <code>t_second</code> and <code>len_t_second</code> to ROI tables and masking ROI tables</li> </ul>"},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>improve type consistency and remove non-necessary \"type: ignore\"</li> </ul>"},{"location":"changelog/#v035","title":"[v0.3.5]","text":"<ul> <li>Remove path normalization for images in wells. While the spec requires paths to be alphanumeric, this patch removes the normalization to allow for arbitrary image paths.</li> </ul>"},{"location":"changelog/#v034","title":"[v0.3.4]","text":"<ul> <li>allow to write as <code>anndata_v1</code> for backward compatibility with older ngio versions.</li> </ul>"},{"location":"changelog/#v033","title":"[v0.3.3]","text":""},{"location":"changelog/#chores","title":"Chores","text":"<ul> <li>improve dataset download process and streamline the CI workflows</li> </ul>"},{"location":"changelog/#v032","title":"[v0.3.2]","text":""},{"location":"changelog/#api-changes_1","title":"API Changes","text":"<ul> <li>change table backend default to <code>anndata_v1</code> for backward compatibility. This will be chaanged again when ngio <code>v0.2.x</code> is no longer supported.</li> </ul>"},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>fix #13 (converters tools)</li> <li>fix #88</li> </ul>"},{"location":"code_of_conduct/","title":"Code of Conduct","text":"<p>Warning</p> <p>The library is still in the early stages of development, the code of conduct is not yet established.</p>"},{"location":"contributing/","title":"Contributing Guide","text":"<p>Warning</p> <p>The library is still in the early stages of development, no contribution guidelines are established yet. But contributions are welcome! Please open an issue or a pull request to discuss your ideas. We are looking for contributors to help us improve the library and documentation.</p>"},{"location":"api/hcs/","title":"HCS API Documentation","text":""},{"location":"api/hcs/#open-a-plate","title":"Open a Plate","text":""},{"location":"api/hcs/#ngio.open_ome_zarr_plate","title":"ngio.open_ome_zarr_plate","text":"<pre><code>open_ome_zarr_plate(\n    store: StoreOrGroup,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n    parallel_safe: bool = True,\n) -&gt; OmeZarrPlate\n</code></pre> <p>Open an OME-Zarr plate.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group that stores the plate.</p> </li> <li> <code>cache</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use a cache for the zarr group metadata.</p> </li> <li> <code>mode</code>               (<code>AccessModeLiteral</code>, default:                   <code>'r+'</code> )           \u2013            <p>The access mode for the image. Defaults to \"r+\".</p> </li> <li> <code>parallel_safe</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the group handler is parallel safe.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def open_ome_zarr_plate(\n    store: StoreOrGroup,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n    parallel_safe: bool = True,\n) -&gt; OmeZarrPlate:\n    \"\"\"Open an OME-Zarr plate.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group that stores the plate.\n        cache (bool): Whether to use a cache for the zarr group metadata.\n        mode (AccessModeLiteral): The\n            access mode for the image. Defaults to \"r+\".\n        parallel_safe (bool): Whether the group handler is parallel safe.\n    \"\"\"\n    group_handler = ZarrGroupHandler(\n        store=store, cache=cache, mode=mode, parallel_safe=parallel_safe\n    )\n    return OmeZarrPlate(group_handler)\n</code></pre>"},{"location":"api/hcs/#ngioomezarrplate-class-reference","title":"ngio.OmeZarrPlate Class Reference","text":""},{"location":"api/hcs/#ngio.OmeZarrPlate","title":"ngio.OmeZarrPlate","text":"<pre><code>OmeZarrPlate(\n    group_handler: ZarrGroupHandler,\n    table_container: TablesContainer | None = None,\n)\n</code></pre> <p>A class to handle the Plate Sequence in an OME-Zarr file.</p> <p>Initialize the LabelGroupHandler.</p> <p>Parameters:</p> <ul> <li> <code>group_handler</code>               (<code>ZarrGroupHandler</code>)           \u2013            <p>The Zarr group handler that contains the Plate.</p> </li> <li> <code>table_container</code>               (<code>TablesContainer | None</code>, default:                   <code>None</code> )           \u2013            <p>The tables container that contains plate level tables.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def __init__(\n    self,\n    group_handler: ZarrGroupHandler,\n    table_container: TablesContainer | None = None,\n) -&gt; None:\n    \"\"\"Initialize the LabelGroupHandler.\n\n    Args:\n        group_handler: The Zarr group handler that contains the Plate.\n        table_container: The tables container that contains plate level tables.\n    \"\"\"\n    self._group_handler = group_handler\n    self._meta_handler = find_plate_meta_handler(group_handler)\n    self._tables_container = table_container\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.meta_handler","title":"meta_handler  <code>property</code>","text":"<pre><code>meta_handler\n</code></pre> <p>Return the metadata handler.</p>"},{"location":"api/hcs/#ngio.OmeZarrPlate.meta","title":"meta  <code>property</code>","text":"<pre><code>meta\n</code></pre> <p>Return the metadata.</p>"},{"location":"api/hcs/#ngio.OmeZarrPlate.columns","title":"columns  <code>property</code>","text":"<pre><code>columns: list[str]\n</code></pre> <p>Return the number of columns in the plate.</p>"},{"location":"api/hcs/#ngio.OmeZarrPlate.rows","title":"rows  <code>property</code>","text":"<pre><code>rows: list[str]\n</code></pre> <p>Return the number of rows in the plate.</p>"},{"location":"api/hcs/#ngio.OmeZarrPlate.acquisitions_names","title":"acquisitions_names  <code>property</code>","text":"<pre><code>acquisitions_names: list[str | None]\n</code></pre> <p>Return the acquisitions in the plate.</p>"},{"location":"api/hcs/#ngio.OmeZarrPlate.acquisition_ids","title":"acquisition_ids  <code>property</code>","text":"<pre><code>acquisition_ids: list[int]\n</code></pre> <p>Return the acquisitions ids in the plate.</p>"},{"location":"api/hcs/#ngio.OmeZarrPlate.tables_container","title":"tables_container  <code>property</code>","text":"<pre><code>tables_container: TablesContainer\n</code></pre> <p>Return the tables container.</p>"},{"location":"api/hcs/#ngio.OmeZarrPlate.wells_paths","title":"wells_paths","text":"<pre><code>wells_paths() -&gt; list[str]\n</code></pre> <p>Return the wells paths in the plate.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def wells_paths(self) -&gt; list[str]:\n    \"\"\"Return the wells paths in the plate.\"\"\"\n    return self.meta.wells_paths\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.images_paths_async","title":"images_paths_async  <code>async</code>","text":"<pre><code>images_paths_async(\n    acquisition: int | None = None,\n) -&gt; list[str]\n</code></pre> <p>Return the images paths in the plate asynchronously.</p> <p>If acquisition is None, return all images paths in the plate. Else, return the images paths in the plate for the given acquisition.</p> <p>Parameters:</p> <ul> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>async def images_paths_async(self, acquisition: int | None = None) -&gt; list[str]:\n    \"\"\"Return the images paths in the plate asynchronously.\n\n    If acquisition is None, return all images paths in the plate.\n    Else, return the images paths in the plate for the given acquisition.\n\n    Args:\n        acquisition (int | None): The acquisition id to filter the images.\n    \"\"\"\n    wells = await self.get_wells_async()\n    paths = []\n    for well_path, well in wells.items():\n        for img_path in well.paths(acquisition):\n            paths.append(f\"{well_path}/{img_path}\")\n    return paths\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.images_paths","title":"images_paths","text":"<pre><code>images_paths(acquisition: int | None = None) -&gt; list[str]\n</code></pre> <p>Return the images paths in the plate.</p> <p>If acquisition is None, return all images paths in the plate. Else, return the images paths in the plate for the given acquisition.</p> <p>Parameters:</p> <ul> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def images_paths(self, acquisition: int | None = None) -&gt; list[str]:\n    \"\"\"Return the images paths in the plate.\n\n    If acquisition is None, return all images paths in the plate.\n    Else, return the images paths in the plate for the given acquisition.\n\n    Args:\n        acquisition (int | None): The acquisition id to filter the images.\n    \"\"\"\n    wells = self.get_wells()\n    images = []\n    for well_path, well in wells.items():\n        for img_path in well.paths(acquisition):\n            images.append(f\"{well_path}/{img_path}\")\n    return images\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.well_images_paths","title":"well_images_paths","text":"<pre><code>well_images_paths(\n    row: str,\n    column: int | str,\n    acquisition: int | None = None,\n) -&gt; list[str]\n</code></pre> <p>Return the images paths in a well.</p> <p>If acquisition is None, return all images paths in the well. Else, return the images paths in the well for the given acquisition.</p> <p>Parameters:</p> <ul> <li> <code>row</code>               (<code>str</code>)           \u2013            <p>The row of the well.</p> </li> <li> <code>column</code>               (<code>int | str</code>)           \u2013            <p>The column of the well.</p> </li> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def well_images_paths(\n    self, row: str, column: int | str, acquisition: int | None = None\n) -&gt; list[str]:\n    \"\"\"Return the images paths in a well.\n\n    If acquisition is None, return all images paths in the well.\n    Else, return the images paths in the well for the given acquisition.\n\n    Args:\n        row (str): The row of the well.\n        column (int | str): The column of the well.\n        acquisition (int | None): The acquisition id to filter the images.\n    \"\"\"\n    images = []\n    well = self.get_well(row=row, column=column)\n    for path in well.paths(acquisition):\n        images.append(self._image_path(row=row, column=column, path=path))\n    return images\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.get_image_acquisition_id","title":"get_image_acquisition_id","text":"<pre><code>get_image_acquisition_id(\n    row: str, column: int | str, image_path: str\n) -&gt; int | None\n</code></pre> <p>Get the acquisition id of an image in a well.</p> <p>Parameters:</p> <ul> <li> <code>row</code>               (<code>str</code>)           \u2013            <p>The row of the well.</p> </li> <li> <code>column</code>               (<code>int | str</code>)           \u2013            <p>The column of the well.</p> </li> <li> <code>image_path</code>               (<code>str</code>)           \u2013            <p>The path of the image.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int | None</code>           \u2013            <p>int | None: The acquisition id of the image.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_image_acquisition_id(\n    self, row: str, column: int | str, image_path: str\n) -&gt; int | None:\n    \"\"\"Get the acquisition id of an image in a well.\n\n    Args:\n        row (str): The row of the well.\n        column (int | str): The column of the well.\n        image_path (str): The path of the image.\n\n    Returns:\n        int | None: The acquisition id of the image.\n    \"\"\"\n    well = self.get_well(row=row, column=column)\n    return well.get_image_acquisition_id(image_path=image_path)\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.get_well","title":"get_well","text":"<pre><code>get_well(row: str, column: int | str) -&gt; OmeZarrWell\n</code></pre> <p>Get a well from the plate.</p> <p>Parameters:</p> <ul> <li> <code>row</code>               (<code>str</code>)           \u2013            <p>The row of the well.</p> </li> <li> <code>column</code>               (<code>int | str</code>)           \u2013            <p>The column of the well.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OmeZarrWell</code> (              <code>OmeZarrWell</code> )          \u2013            <p>The well.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_well(self, row: str, column: int | str) -&gt; OmeZarrWell:\n    \"\"\"Get a well from the plate.\n\n    Args:\n        row (str): The row of the well.\n        column (int | str): The column of the well.\n\n    Returns:\n        OmeZarrWell: The well.\n    \"\"\"\n    well_path = self._well_path(row=row, column=column)\n    group_handler = self._group_handler.derive_handler(well_path)\n    return OmeZarrWell(group_handler)\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.get_wells_async","title":"get_wells_async  <code>async</code>","text":"<pre><code>get_wells_async() -&gt; dict[str, OmeZarrWell]\n</code></pre> <p>Get all wells in the plate asynchronously.</p> <p>This method processes wells in parallel for improved performance when working with a large number of wells.</p> <p>Returns:</p> <ul> <li> <code>dict[str, OmeZarrWell]</code>           \u2013            <p>dict[str, OmeZarrWell]: A dictionary of wells, where the key is the well path and the value is the well object.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>async def get_wells_async(self) -&gt; dict[str, OmeZarrWell]:\n    \"\"\"Get all wells in the plate asynchronously.\n\n    This method processes wells in parallel for improved performance\n    when working with a large number of wells.\n\n    Returns:\n        dict[str, OmeZarrWell]: A dictionary of wells, where the key is the well\n            path and the value is the well object.\n    \"\"\"\n    wells = self._group_handler.get_from_cache(\"wells\")\n    if wells is not None:\n        assert isinstance(wells, dict)\n        return wells\n\n    def process_well(well_path):\n        group_handler = self._group_handler.derive_handler(well_path)\n        well = OmeZarrWell(group_handler)\n        return well_path, well\n\n    wells, tasks = {}, []\n    for well_path in self.wells_paths():\n        task = asyncio.to_thread(process_well, well_path)\n        tasks.append(task)\n\n    results = await asyncio.gather(*tasks)\n    for well_path, well in results:\n        wells[well_path] = well\n\n    self._group_handler.add_to_cache(\"wells\", wells)\n    return wells\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.get_wells","title":"get_wells","text":"<pre><code>get_wells() -&gt; dict[str, OmeZarrWell]\n</code></pre> <p>Get all wells in the plate.</p> <p>Returns:</p> <ul> <li> <code>dict[str, OmeZarrWell]</code>           \u2013            <p>dict[str, OmeZarrWell]: A dictionary of wells, where the key is the well path and the value is the well object.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_wells(self) -&gt; dict[str, OmeZarrWell]:\n    \"\"\"Get all wells in the plate.\n\n    Returns:\n        dict[str, OmeZarrWell]: A dictionary of wells, where the key is the well\n            path and the value is the well object.\n    \"\"\"\n    wells = self._group_handler.get_from_cache(\"wells\")\n    if wells is not None:\n        assert isinstance(wells, dict)\n        return wells\n\n    def process_well(well_path):\n        group_handler = self._group_handler.derive_handler(well_path)\n        well = OmeZarrWell(group_handler)\n        return well_path, well\n\n    wells = {}\n    for well_path in self.wells_paths():\n        _, well = process_well(well_path)\n        wells[well_path] = well\n\n    self._group_handler.add_to_cache(\"wells\", wells)\n    return wells\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.get_images_async","title":"get_images_async  <code>async</code>","text":"<pre><code>get_images_async(\n    acquisition: int | None = None,\n) -&gt; dict[str, OmeZarrContainer]\n</code></pre> <p>Get all images in the plate asynchronously.</p> <p>This method processes images in parallel for improved performance when working with a large number of images.</p> <p>Parameters:</p> <ul> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, OmeZarrContainer]</code>           \u2013            <p>dict[str, OmeZarrContainer]: A dictionary of images, where the key is the image path and the value is the image object.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>async def get_images_async(\n    self, acquisition: int | None = None\n) -&gt; dict[str, OmeZarrContainer]:\n    \"\"\"Get all images in the plate asynchronously.\n\n    This method processes images in parallel for improved performance\n    when working with a large number of images.\n\n    Args:\n        acquisition: The acquisition id to filter the images.\n\n    Returns:\n        dict[str, OmeZarrContainer]: A dictionary of images, where the key is the\n            image path and the value is the image object.\n    \"\"\"\n    images = self._group_handler.get_from_cache(\"images\")\n    if images is not None:\n        assert isinstance(images, dict)\n        return images\n\n    paths = await self.images_paths_async(acquisition=acquisition)\n\n    def process_image(image_path):\n        \"\"\"Process a single image and return the image path and image object.\"\"\"\n        img_group_handler = self._group_handler.derive_handler(image_path)\n        image = OmeZarrContainer(img_group_handler)\n        return image_path, image\n\n    images, tasks = {}, []\n    for image_path in paths:\n        task = asyncio.to_thread(process_image, image_path)\n        tasks.append(task)\n\n    results = await asyncio.gather(*tasks)\n\n    for image_path, image in results:\n        images[image_path] = image\n\n    self._group_handler.add_to_cache(\"images\", images)\n    return images\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.get_images","title":"get_images","text":"<pre><code>get_images(\n    acquisition: int | None = None,\n) -&gt; dict[str, OmeZarrContainer]\n</code></pre> <p>Get all images in the plate.</p> <p>Parameters:</p> <ul> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_images(self, acquisition: int | None = None) -&gt; dict[str, OmeZarrContainer]:\n    \"\"\"Get all images in the plate.\n\n    Args:\n        acquisition: The acquisition id to filter the images.\n    \"\"\"\n    images = self._group_handler.get_from_cache(\"images\")\n    if images is not None:\n        assert isinstance(images, dict)\n        return images\n    paths = self.images_paths(acquisition=acquisition)\n\n    def process_image(image_path):\n        \"\"\"Process a single image and return the image path and image object.\"\"\"\n        img_group_handler = self._group_handler.derive_handler(image_path)\n        image = OmeZarrContainer(img_group_handler)\n        return image_path, image\n\n    images = {}\n    for image_path in paths:\n        _, image = process_image(image_path)\n        images[image_path] = image\n\n    self._group_handler.add_to_cache(\"images\", images)\n    return images\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.get_image","title":"get_image","text":"<pre><code>get_image(\n    row: str, column: int | str, image_path: str\n) -&gt; OmeZarrContainer\n</code></pre> <p>Get an image from the plate.</p> <p>Parameters:</p> <ul> <li> <code>row</code>               (<code>str</code>)           \u2013            <p>The row of the well.</p> </li> <li> <code>column</code>               (<code>int | str</code>)           \u2013            <p>The column of the well.</p> </li> <li> <code>image_path</code>               (<code>str</code>)           \u2013            <p>The path of the image.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OmeZarrContainer</code> (              <code>OmeZarrContainer</code> )          \u2013            <p>The image.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_image(\n    self, row: str, column: int | str, image_path: str\n) -&gt; OmeZarrContainer:\n    \"\"\"Get an image from the plate.\n\n    Args:\n        row (str): The row of the well.\n        column (int | str): The column of the well.\n        image_path (str): The path of the image.\n\n    Returns:\n        OmeZarrContainer: The image.\n    \"\"\"\n    image_path = self._image_path(row=row, column=column, path=image_path)\n    group_handler = self._group_handler.derive_handler(image_path)\n    return OmeZarrContainer(group_handler)\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.get_image_store","title":"get_image_store","text":"<pre><code>get_image_store(\n    row: str, column: int | str, image_path: str\n) -&gt; StoreOrGroup\n</code></pre> <p>Get the image store from the plate.</p> <p>Parameters:</p> <ul> <li> <code>row</code>               (<code>str</code>)           \u2013            <p>The row of the well.</p> </li> <li> <code>column</code>               (<code>int | str</code>)           \u2013            <p>The column of the well.</p> </li> <li> <code>image_path</code>               (<code>str</code>)           \u2013            <p>The path of the image.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_image_store(\n    self, row: str, column: int | str, image_path: str\n) -&gt; StoreOrGroup:\n    \"\"\"Get the image store from the plate.\n\n    Args:\n        row (str): The row of the well.\n        column (int | str): The column of the well.\n        image_path (str): The path of the image.\n    \"\"\"\n    well = self.get_well(row=row, column=column)\n    return well.get_image_store(image_path=image_path)\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.get_well_images","title":"get_well_images","text":"<pre><code>get_well_images(\n    row: str,\n    column: str | int,\n    acquisition: int | None = None,\n) -&gt; dict[str, OmeZarrContainer]\n</code></pre> <p>Get all images in a well.</p> <p>Parameters:</p> <ul> <li> <code>row</code>               (<code>str</code>)           \u2013            <p>The row of the well.</p> </li> <li> <code>column</code>               (<code>str | int</code>)           \u2013            <p>The column of the well.</p> </li> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_well_images(\n    self, row: str, column: str | int, acquisition: int | None = None\n) -&gt; dict[str, OmeZarrContainer]:\n    \"\"\"Get all images in a well.\n\n    Args:\n        row: The row of the well.\n        column: The column of the well.\n        acquisition: The acquisition id to filter the images.\n    \"\"\"\n    images = {}\n    for image_paths in self.well_images_paths(\n        row=row, column=column, acquisition=acquisition\n    ):\n        group_handler = self._group_handler.derive_handler(image_paths)\n        images[image_paths] = OmeZarrContainer(group_handler)\n    return images\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.atomic_add_image","title":"atomic_add_image","text":"<pre><code>atomic_add_image(\n    row: str,\n    column: int | str,\n    image_path: str,\n    acquisition_id: int | None = None,\n    acquisition_name: str | None = None,\n) -&gt; str\n</code></pre> <p>Parallel safe version of add_image.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def atomic_add_image(\n    self,\n    row: str,\n    column: int | str,\n    image_path: str,\n    acquisition_id: int | None = None,\n    acquisition_name: str | None = None,\n) -&gt; str:\n    \"\"\"Parallel safe version of add_image.\"\"\"\n    if image_path is None:\n        raise ValueError(\n            \"Image path cannot be None for atomic add_image. \"\n            \"If your intent is to add a well, use add_well instead.\"\n        )\n    path = self._add_image(\n        row=row,\n        column=column,\n        image_path=image_path,\n        acquisition_id=acquisition_id,\n        acquisition_name=acquisition_name,\n        atomic=True,\n    )\n    return path\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.add_image","title":"add_image","text":"<pre><code>add_image(\n    row: str,\n    column: int | str,\n    image_path: str,\n    acquisition_id: int | None = None,\n    acquisition_name: str | None = None,\n) -&gt; str\n</code></pre> <p>Add an image to an ome-zarr plate.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def add_image(\n    self,\n    row: str,\n    column: int | str,\n    image_path: str,\n    acquisition_id: int | None = None,\n    acquisition_name: str | None = None,\n) -&gt; str:\n    \"\"\"Add an image to an ome-zarr plate.\"\"\"\n    if image_path is None:\n        raise ValueError(\n            \"Image path cannot be None for atomic add_image. \"\n            \"If your intent is to add a well, use add_well instead.\"\n        )\n    path = self._add_image(\n        row=row,\n        column=column,\n        image_path=image_path,\n        acquisition_id=acquisition_id,\n        acquisition_name=acquisition_name,\n        atomic=False,\n    )\n    return path\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.add_well","title":"add_well","text":"<pre><code>add_well(row: str, column: int | str) -&gt; OmeZarrWell\n</code></pre> <p>Add a well to an ome-zarr plate.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def add_well(\n    self,\n    row: str,\n    column: int | str,\n) -&gt; OmeZarrWell:\n    \"\"\"Add a well to an ome-zarr plate.\"\"\"\n    _ = self._add_image(\n        row=row,\n        column=column,\n        image_path=None,\n        acquisition_id=None,\n        acquisition_name=None,\n        atomic=False,\n    )\n    return self.get_well(row=row, column=column)\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.add_column","title":"add_column","text":"<pre><code>add_column(column: int | str) -&gt; OmeZarrPlate\n</code></pre> <p>Add a column to an ome-zarr plate.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def add_column(\n    self,\n    column: int | str,\n) -&gt; \"OmeZarrPlate\":\n    \"\"\"Add a column to an ome-zarr plate.\"\"\"\n    meta, _ = self.meta.add_column(column)\n    self.meta_handler.write_meta(meta)\n    self.meta_handler._group_handler.clean_cache()\n    return self\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.add_row","title":"add_row","text":"<pre><code>add_row(row: str) -&gt; OmeZarrPlate\n</code></pre> <p>Add a row to an ome-zarr plate.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def add_row(\n    self,\n    row: str,\n) -&gt; \"OmeZarrPlate\":\n    \"\"\"Add a row to an ome-zarr plate.\"\"\"\n    meta, _ = self.meta.add_row(row)\n    self.meta_handler.write_meta(meta)\n    self.meta_handler._group_handler.clean_cache()\n    return self\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.add_acquisition","title":"add_acquisition","text":"<pre><code>add_acquisition(\n    acquisition_id: int, acquisition_name: str\n) -&gt; OmeZarrPlate\n</code></pre> <p>Add an acquisition to an ome-zarr plate.</p> <p>Be aware that this is not a parallel safe operation.</p> <p>Parameters:</p> <ul> <li> <code>acquisition_id</code>               (<code>int</code>)           \u2013            <p>The acquisition id.</p> </li> <li> <code>acquisition_name</code>               (<code>str</code>)           \u2013            <p>The acquisition name.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def add_acquisition(\n    self,\n    acquisition_id: int,\n    acquisition_name: str,\n) -&gt; \"OmeZarrPlate\":\n    \"\"\"Add an acquisition to an ome-zarr plate.\n\n    Be aware that this is not a parallel safe operation.\n\n    Args:\n        acquisition_id (int): The acquisition id.\n        acquisition_name (str): The acquisition name.\n    \"\"\"\n    meta = self.meta.add_acquisition(\n        acquisition_id=acquisition_id, acquisition_name=acquisition_name\n    )\n    self.meta_handler.write_meta(meta)\n    self.meta_handler._group_handler.clean_cache()\n    return self\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.atomic_remove_image","title":"atomic_remove_image","text":"<pre><code>atomic_remove_image(\n    row: str, column: int | str, image_path: str\n)\n</code></pre> <p>Parallel safe version of remove_image.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def atomic_remove_image(\n    self,\n    row: str,\n    column: int | str,\n    image_path: str,\n):\n    \"\"\"Parallel safe version of remove_image.\"\"\"\n    return self._remove_image(\n        row=row,\n        column=column,\n        image_path=image_path,\n        atomic=True,\n    )\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.remove_image","title":"remove_image","text":"<pre><code>remove_image(row: str, column: int | str, image_path: str)\n</code></pre> <p>Remove an image from an ome-zarr plate.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def remove_image(\n    self,\n    row: str,\n    column: int | str,\n    image_path: str,\n):\n    \"\"\"Remove an image from an ome-zarr plate.\"\"\"\n    return self._remove_image(\n        row=row,\n        column=column,\n        image_path=image_path,\n        atomic=False,\n    )\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.derive_plate","title":"derive_plate","text":"<pre><code>derive_plate(\n    store: StoreOrGroup,\n    plate_name: str | None = None,\n    version: NgffVersions = \"0.4\",\n    keep_acquisitions: bool = False,\n    cache: bool = False,\n    overwrite: bool = False,\n    parallel_safe: bool = True,\n) -&gt; OmeZarrPlate\n</code></pre> <p>Derive a new OME-Zarr plate from an existing one.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group that stores the plate.</p> </li> <li> <code>plate_name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the new plate.</p> </li> <li> <code>version</code>               (<code>NgffVersion</code>, default:                   <code>'0.4'</code> )           \u2013            <p>The version of the new plate.</p> </li> <li> <code>keep_acquisitions</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to keep the acquisitions in the new plate.</p> </li> <li> <code>cache</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use a cache for the zarr group metadata.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to overwrite the existing plate.</p> </li> <li> <code>parallel_safe</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the group handler is parallel safe.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def derive_plate(\n    self,\n    store: StoreOrGroup,\n    plate_name: str | None = None,\n    version: NgffVersions = \"0.4\",\n    keep_acquisitions: bool = False,\n    cache: bool = False,\n    overwrite: bool = False,\n    parallel_safe: bool = True,\n) -&gt; \"OmeZarrPlate\":\n    \"\"\"Derive a new OME-Zarr plate from an existing one.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group that stores the plate.\n        plate_name (str | None): The name of the new plate.\n        version (NgffVersion): The version of the new plate.\n        keep_acquisitions (bool): Whether to keep the acquisitions in the new plate.\n        cache (bool): Whether to use a cache for the zarr group metadata.\n        overwrite (bool): Whether to overwrite the existing plate.\n        parallel_safe (bool): Whether the group handler is parallel safe.\n    \"\"\"\n    return derive_ome_zarr_plate(\n        ome_zarr_plate=self,\n        store=store,\n        plate_name=plate_name,\n        version=version,\n        keep_acquisitions=keep_acquisitions,\n        cache=cache,\n        overwrite=overwrite,\n        parallel_safe=parallel_safe,\n    )\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.list_tables","title":"list_tables","text":"<pre><code>list_tables(\n    filter_types: TypedTable | str | None = None,\n) -&gt; list[str]\n</code></pre> <p>List all tables in the image.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def list_tables(self, filter_types: TypedTable | str | None = None) -&gt; list[str]:\n    \"\"\"List all tables in the image.\"\"\"\n    return self.tables_container.list(filter_types=filter_types)\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.list_roi_tables","title":"list_roi_tables","text":"<pre><code>list_roi_tables() -&gt; list[str]\n</code></pre> <p>List all ROI tables in the image.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def list_roi_tables(self) -&gt; list[str]:\n    \"\"\"List all ROI tables in the image.\"\"\"\n    masking_roi = self.tables_container.list(\n        filter_types=\"masking_roi_table\",\n    )\n    roi = self.tables_container.list(\n        filter_types=\"roi_table\",\n    )\n    return masking_roi + roi\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.get_roi_table","title":"get_roi_table","text":"<pre><code>get_roi_table(name: str) -&gt; RoiTable\n</code></pre> <p>Get a ROI table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_roi_table(self, name: str) -&gt; RoiTable:\n    \"\"\"Get a ROI table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, RoiTable):\n        raise NgioValueError(f\"Table {name} is not a ROI table. Got {type(table)}\")\n    return table\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.get_masking_roi_table","title":"get_masking_roi_table","text":"<pre><code>get_masking_roi_table(name: str) -&gt; MaskingRoiTable\n</code></pre> <p>Get a masking ROI table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_masking_roi_table(self, name: str) -&gt; MaskingRoiTable:\n    \"\"\"Get a masking ROI table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, MaskingRoiTable):\n        raise NgioValueError(\n            f\"Table {name} is not a masking ROI table. Got {type(table)}\"\n        )\n    return table\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.get_feature_table","title":"get_feature_table","text":"<pre><code>get_feature_table(name: str) -&gt; FeatureTable\n</code></pre> <p>Get a feature table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_feature_table(self, name: str) -&gt; FeatureTable:\n    \"\"\"Get a feature table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, FeatureTable):\n        raise NgioValueError(\n            f\"Table {name} is not a feature table. Got {type(table)}\"\n        )\n    return table\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.get_generic_roi_table","title":"get_generic_roi_table","text":"<pre><code>get_generic_roi_table(name: str) -&gt; GenericRoiTable\n</code></pre> <p>Get a generic ROI table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_generic_roi_table(self, name: str) -&gt; GenericRoiTable:\n    \"\"\"Get a generic ROI table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, GenericRoiTable):\n        raise NgioValueError(\n            f\"Table {name} is not a generic ROI table. Got {type(table)}\"\n        )\n    return table\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.get_condition_table","title":"get_condition_table","text":"<pre><code>get_condition_table(name: str) -&gt; ConditionTable\n</code></pre> <p>Get a condition table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_condition_table(self, name: str) -&gt; ConditionTable:\n    \"\"\"Get a condition table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, ConditionTable):\n        raise NgioValueError(\n            f\"Table {name} is not a condition table. Got {type(table)}\"\n        )\n    return table\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.get_table","title":"get_table","text":"<pre><code>get_table(\n    name: str, check_type: TypedTable | None = None\n) -&gt; Table\n</code></pre> <p>Get a table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> <li> <code>check_type</code>               (<code>TypedTable | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Please use 'get_table_as' instead, or one of the type specific get_*table() methods.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_table(self, name: str, check_type: TypedTable | None = None) -&gt; Table:\n    \"\"\"Get a table from the image.\n\n    Args:\n        name (str): The name of the table.\n        check_type (TypedTable | None): Deprecated. Please use\n            'get_table_as' instead, or one of the type specific\n            get_*table() methods.\n\n    \"\"\"\n    if check_type is not None:\n        warnings.warn(\n            \"The 'check_type' argument is deprecated, and will be removed in \"\n            \"ngio=0.3. Use 'get_table_as' instead or one of the \"\n            \"type specific get_*table() methods.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n    return self.tables_container.get(name=name, strict=False)\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.get_table_as","title":"get_table_as","text":"<pre><code>get_table_as(\n    name: str,\n    table_cls: type[TableType],\n    backend: TableBackend | None = None,\n) -&gt; TableType\n</code></pre> <p>Get a table from the image as a specific type.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> <li> <code>table_cls</code>               (<code>type[TableType]</code>)           \u2013            <p>The type of the table.</p> </li> <li> <code>backend</code>               (<code>TableBackend | None</code>, default:                   <code>None</code> )           \u2013            <p>The backend to use. If None, the default backend is used.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_table_as(\n    self,\n    name: str,\n    table_cls: type[TableType],\n    backend: TableBackend | None = None,\n) -&gt; TableType:\n    \"\"\"Get a table from the image as a specific type.\n\n    Args:\n        name (str): The name of the table.\n        table_cls (type[TableType]): The type of the table.\n        backend (TableBackend | None): The backend to use. If None,\n            the default backend is used.\n    \"\"\"\n    return self.tables_container.get_as(\n        name=name,\n        table_cls=table_cls,\n        backend=backend,\n    )\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.add_table","title":"add_table","text":"<pre><code>add_table(\n    name: str,\n    table: Table,\n    backend: TableBackend = DefaultTableBackend,\n    overwrite: bool = False,\n) -&gt; None\n</code></pre> <p>Add a table to the image.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def add_table(\n    self,\n    name: str,\n    table: Table,\n    backend: TableBackend = DefaultTableBackend,\n    overwrite: bool = False,\n) -&gt; None:\n    \"\"\"Add a table to the image.\"\"\"\n    self.tables_container.add(\n        name=name, table=table, backend=backend, overwrite=overwrite\n    )\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.list_image_tables","title":"list_image_tables","text":"<pre><code>list_image_tables(\n    acquisition: int | None = None,\n    filter_types: str | None = None,\n    mode: Literal[\"common\", \"all\"] = \"common\",\n) -&gt; list[str]\n</code></pre> <p>List all image tables in the image.</p> <p>Parameters:</p> <ul> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> <li> <code>filter_types</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The type of tables to filter. If None, return all tables. Defaults to None.</p> </li> <li> <code>mode</code>               (<code>Literal['common', 'all']</code>, default:                   <code>'common'</code> )           \u2013            <p>The mode to use for listing the tables. If 'common', return only common tables between all images. If 'all', return all tables. Defaults to 'common'.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def list_image_tables(\n    self,\n    acquisition: int | None = None,\n    filter_types: str | None = None,\n    mode: Literal[\"common\", \"all\"] = \"common\",\n) -&gt; list[str]:\n    \"\"\"List all image tables in the image.\n\n    Args:\n        acquisition (int | None): The acquisition id to filter the images.\n        filter_types (str | None): The type of tables to filter. If None,\n            return all tables. Defaults to None.\n        mode (Literal[\"common\", \"all\"]): The mode to use for listing the tables.\n            If 'common', return only common tables between all images.\n            If 'all', return all tables. Defaults to 'common'.\n    \"\"\"\n    images = tuple(self.get_images(acquisition=acquisition).values())\n    return list_image_tables(\n        images=images,\n        filter_types=filter_types,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.list_image_tables_async","title":"list_image_tables_async  <code>async</code>","text":"<pre><code>list_image_tables_async(\n    acquisition: int | None = None,\n    filter_types: str | None = None,\n    mode: Literal[\"common\", \"all\"] = \"common\",\n) -&gt; list[str]\n</code></pre> <p>List all image tables in the image asynchronously.</p> <p>Parameters:</p> <ul> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> <li> <code>filter_types</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The type of tables to filter. If None, return all tables. Defaults to None.</p> </li> <li> <code>mode</code>               (<code>Literal['common', 'all']</code>, default:                   <code>'common'</code> )           \u2013            <p>The mode to use for listing the tables. If 'common', return only common tables between all images. If 'all', return all tables. Defaults to 'common'.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>async def list_image_tables_async(\n    self,\n    acquisition: int | None = None,\n    filter_types: str | None = None,\n    mode: Literal[\"common\", \"all\"] = \"common\",\n) -&gt; list[str]:\n    \"\"\"List all image tables in the image asynchronously.\n\n    Args:\n        acquisition (int | None): The acquisition id to filter the images.\n        filter_types (str | None): The type of tables to filter. If None,\n            return all tables. Defaults to None.\n        mode (Literal[\"common\", \"all\"]): The mode to use for listing the tables.\n            If 'common', return only common tables between all images.\n            If 'all', return all tables. Defaults to 'common'.\n    \"\"\"\n    images = await self.get_images_async(acquisition=acquisition)\n    images = tuple(images.values())\n    return await list_image_tables_async(\n        images=images,\n        filter_types=filter_types,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.concatenate_image_tables","title":"concatenate_image_tables","text":"<pre><code>concatenate_image_tables(\n    name: str,\n    acquisition: int | None = None,\n    strict: bool = True,\n    index_key: str | None = None,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; Table\n</code></pre> <p>Concatenate tables from all images in the plate.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table to concatenate.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The key to use for the index of the concatenated table.</p> </li> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, raise an error if the table is not found in the image.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>If a string is provided, a new index column will be created new_index_pattern = {row}{column}{path_in_well}_{label}</p> </li> <li> <code>mode</code>               (<code>Literal['eager', 'lazy']</code>, default:                   <code>'eager'</code> )           \u2013            <p>The mode to use for concatenation. Can be 'eager' or 'lazy'. if 'eager', the table will be loaded into memory. if 'lazy', the table will be loaded as a lazy frame.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def concatenate_image_tables(\n    self,\n    name: str,\n    acquisition: int | None = None,\n    strict: bool = True,\n    index_key: str | None = None,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; Table:\n    \"\"\"Concatenate tables from all images in the plate.\n\n    Args:\n        name: The name of the table to concatenate.\n        index_key: The key to use for the index of the concatenated table.\n        acquisition: The acquisition id to filter the images.\n        strict: If True, raise an error if the table is not found in the image.\n        index_key: If a string is provided, a new index column will be created\n            new_index_pattern = {row}_{column}_{path_in_well}_{label}\n        mode: The mode to use for concatenation. Can be 'eager' or 'lazy'.\n            if 'eager', the table will be loaded into memory.\n            if 'lazy', the table will be loaded as a lazy frame.\n    \"\"\"\n    images = self.get_images(acquisition=acquisition)\n    extras = _build_extras(tuple(images.keys()))\n    return concatenate_image_tables(\n        images=tuple(images.values()),\n        extras=extras,\n        name=name,\n        index_key=index_key,\n        strict=strict,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.concatenate_image_tables_as","title":"concatenate_image_tables_as","text":"<pre><code>concatenate_image_tables_as(\n    name: str,\n    table_cls: type[TableType],\n    acquisition: int | None = None,\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; TableType\n</code></pre> <p>Concatenate tables from all images in the plate as a specific type.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table to concatenate.</p> </li> <li> <code>table_cls</code>               (<code>type[TableType]</code>)           \u2013            <p>The type of the table to concatenate.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The key to use for the index of the concatenated table.</p> </li> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>If a string is provided, a new index column will be created new_index_pattern = {row}{column}{path_in_well}_{label}</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, raise an error if the table is not found in the image.</p> </li> <li> <code>mode</code>               (<code>Literal['eager', 'lazy']</code>, default:                   <code>'eager'</code> )           \u2013            <p>The mode to use for concatenation. Can be 'eager' or 'lazy'. if 'eager', the table will be loaded into memory. if 'lazy', the table will be loaded as a lazy frame.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def concatenate_image_tables_as(\n    self,\n    name: str,\n    table_cls: type[TableType],\n    acquisition: int | None = None,\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; TableType:\n    \"\"\"Concatenate tables from all images in the plate as a specific type.\n\n    Args:\n        name: The name of the table to concatenate.\n        table_cls: The type of the table to concatenate.\n        index_key: The key to use for the index of the concatenated table.\n        acquisition: The acquisition id to filter the images.\n        index_key: If a string is provided, a new index column will be created\n            new_index_pattern = {row}_{column}_{path_in_well}_{label}\n        strict: If True, raise an error if the table is not found in the image.\n        mode: The mode to use for concatenation. Can be 'eager' or 'lazy'.\n            if 'eager', the table will be loaded into memory.\n            if 'lazy', the table will be loaded as a lazy frame.\n    \"\"\"\n    images = self.get_images(acquisition=acquisition)\n    extras = _build_extras(tuple(images.keys()))\n    return concatenate_image_tables_as(\n        images=tuple(images.values()),\n        extras=extras,\n        name=name,\n        table_cls=table_cls,\n        index_key=index_key,\n        strict=strict,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.concatenate_image_tables_async","title":"concatenate_image_tables_async  <code>async</code>","text":"<pre><code>concatenate_image_tables_async(\n    name: str,\n    acquisition: int | None = None,\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; Table\n</code></pre> <p>Concatenate tables from all images in the plate asynchronously.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table to concatenate.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The key to use for the index of the concatenated table.</p> </li> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>If a string is provided, a new index column will be created new_index_pattern = {row}{column}{path_in_well}_{label}</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, raise an error if the table is not found in the image.</p> </li> <li> <code>mode</code>               (<code>Literal['eager', 'lazy']</code>, default:                   <code>'eager'</code> )           \u2013            <p>The mode to use for concatenation. Can be 'eager' or 'lazy'. if 'eager', the table will be loaded into memory. if 'lazy', the table will be loaded as a lazy frame.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>async def concatenate_image_tables_async(\n    self,\n    name: str,\n    acquisition: int | None = None,\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; Table:\n    \"\"\"Concatenate tables from all images in the plate asynchronously.\n\n    Args:\n        name: The name of the table to concatenate.\n        index_key: The key to use for the index of the concatenated table.\n        acquisition: The acquisition id to filter the images.\n        index_key: If a string is provided, a new index column will be created\n            new_index_pattern = {row}_{column}_{path_in_well}_{label}\n        strict: If True, raise an error if the table is not found in the image.\n        mode: The mode to use for concatenation. Can be 'eager' or 'lazy'.\n            if 'eager', the table will be loaded into memory.\n            if 'lazy', the table will be loaded as a lazy frame.\n    \"\"\"\n    images = await self.get_images_async(acquisition=acquisition)\n    extras = _build_extras(tuple(images.keys()))\n    return await concatenate_image_tables_async(\n        images=tuple(images.values()),\n        extras=extras,\n        name=name,\n        index_key=index_key,\n        strict=strict,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrPlate.concatenate_image_tables_as_async","title":"concatenate_image_tables_as_async  <code>async</code>","text":"<pre><code>concatenate_image_tables_as_async(\n    name: str,\n    table_cls: type[TableType],\n    acquisition: int | None = None,\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; TableType\n</code></pre> <p>Concatenate tables from all images in the plate as a specific type.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table to concatenate.</p> </li> <li> <code>table_cls</code>               (<code>type[TableType]</code>)           \u2013            <p>The type of the table to concatenate.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The key to use for the index of the concatenated table.</p> </li> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>If a string is provided, a new index column will be created new_index_pattern = {row}{column}{path_in_well}_{label}</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, raise an error if the table is not found in the image.</p> </li> <li> <code>mode</code>               (<code>Literal['eager', 'lazy']</code>, default:                   <code>'eager'</code> )           \u2013            <p>The mode to use for concatenation. Can be 'eager' or 'lazy'. if 'eager', the table will be loaded into memory. if 'lazy', the table will be loaded as a lazy frame.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>async def concatenate_image_tables_as_async(\n    self,\n    name: str,\n    table_cls: type[TableType],\n    acquisition: int | None = None,\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; TableType:\n    \"\"\"Concatenate tables from all images in the plate as a specific type.\n\n    Args:\n        name: The name of the table to concatenate.\n        table_cls: The type of the table to concatenate.\n        index_key: The key to use for the index of the concatenated table.\n        acquisition: The acquisition id to filter the images.\n        index_key: If a string is provided, a new index column will be created\n            new_index_pattern = {row}_{column}_{path_in_well}_{label}\n        strict: If True, raise an error if the table is not found in the image.\n        mode: The mode to use for concatenation. Can be 'eager' or 'lazy'.\n            if 'eager', the table will be loaded into memory.\n            if 'lazy', the table will be loaded as a lazy frame.\n    \"\"\"\n    images = await self.get_images_async(acquisition=acquisition)\n    extras = _build_extras(tuple(images.keys()))\n    return await concatenate_image_tables_as_async(\n        images=tuple(images.values()),\n        extras=extras,\n        name=name,\n        table_cls=table_cls,\n        index_key=index_key,\n        strict=strict,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/hcs/#open-a-well","title":"Open a Well","text":""},{"location":"api/hcs/#ngio.open_ome_zarr_well","title":"ngio.open_ome_zarr_well","text":"<pre><code>open_ome_zarr_well(\n    store: StoreOrGroup,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n    parallel_safe: bool = True,\n) -&gt; OmeZarrWell\n</code></pre> <p>Open an OME-Zarr well.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group that stores the plate.</p> </li> <li> <code>cache</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use a cache for the zarr group metadata.</p> </li> <li> <code>mode</code>               (<code>AccessModeLiteral</code>, default:                   <code>'r+'</code> )           \u2013            <p>The access mode for the image. Defaults to \"r+\".</p> </li> <li> <code>parallel_safe</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the group handler is parallel safe.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def open_ome_zarr_well(\n    store: StoreOrGroup,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n    parallel_safe: bool = True,\n) -&gt; OmeZarrWell:\n    \"\"\"Open an OME-Zarr well.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group that stores the plate.\n        cache (bool): Whether to use a cache for the zarr group metadata.\n        mode (AccessModeLiteral): The access mode for the image. Defaults to \"r+\".\n        parallel_safe (bool): Whether the group handler is parallel safe.\n    \"\"\"\n    group_handler = ZarrGroupHandler(\n        store=store, cache=cache, mode=mode, parallel_safe=parallel_safe\n    )\n    return OmeZarrWell(group_handler)\n</code></pre>"},{"location":"api/hcs/#ngioomezarrwell-class-reference","title":"ngio.OmeZarrWell Class Reference","text":""},{"location":"api/hcs/#ngio.OmeZarrWell","title":"ngio.OmeZarrWell","text":"<pre><code>OmeZarrWell(group_handler: ZarrGroupHandler)\n</code></pre> <p>A class to handle the Well Sequence in an OME-Zarr file.</p> <p>Initialize the LabelGroupHandler.</p> <p>Parameters:</p> <ul> <li> <code>group_handler</code>               (<code>ZarrGroupHandler</code>)           \u2013            <p>The Zarr group handler that contains the Well.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def __init__(self, group_handler: ZarrGroupHandler) -&gt; None:\n    \"\"\"Initialize the LabelGroupHandler.\n\n    Args:\n        group_handler: The Zarr group handler that contains the Well.\n    \"\"\"\n    self._group_handler = group_handler\n    self._meta_handler = find_well_meta_handler(group_handler)\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrWell.meta_handler","title":"meta_handler  <code>property</code>","text":"<pre><code>meta_handler\n</code></pre> <p>Return the metadata handler.</p>"},{"location":"api/hcs/#ngio.OmeZarrWell.meta","title":"meta  <code>property</code>","text":"<pre><code>meta\n</code></pre> <p>Return the metadata.</p>"},{"location":"api/hcs/#ngio.OmeZarrWell.acquisition_ids","title":"acquisition_ids  <code>property</code>","text":"<pre><code>acquisition_ids: list[int]\n</code></pre> <p>Return the acquisitions ids in the well.</p>"},{"location":"api/hcs/#ngio.OmeZarrWell.paths","title":"paths","text":"<pre><code>paths(acquisition: int | None = None) -&gt; list[str]\n</code></pre> <p>Return the images paths in the well.</p> <p>If acquisition is None, return all images paths in the well. Else, return the images paths in the well for the given acquisition.</p> <p>Parameters:</p> <ul> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def paths(self, acquisition: int | None = None) -&gt; list[str]:\n    \"\"\"Return the images paths in the well.\n\n    If acquisition is None, return all images paths in the well.\n    Else, return the images paths in the well for the given acquisition.\n\n    Args:\n        acquisition (int | None): The acquisition id to filter the images.\n    \"\"\"\n    return self.meta.paths(acquisition)\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrWell.get_image_store","title":"get_image_store","text":"<pre><code>get_image_store(image_path: str) -&gt; StoreOrGroup\n</code></pre> <p>Get the image store from the well.</p> <p>Parameters:</p> <ul> <li> <code>image_path</code>               (<code>str</code>)           \u2013            <p>The path of the image.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_image_store(self, image_path: str) -&gt; StoreOrGroup:\n    \"\"\"Get the image store from the well.\n\n    Args:\n        image_path (str): The path of the image.\n    \"\"\"\n    return self._group_handler.get_group(image_path, create_mode=True)\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrWell.get_image_acquisition_id","title":"get_image_acquisition_id","text":"<pre><code>get_image_acquisition_id(image_path: str) -&gt; int | None\n</code></pre> <p>Get the acquisition id of an image in the well.</p> <p>Parameters:</p> <ul> <li> <code>image_path</code>               (<code>str</code>)           \u2013            <p>The path of the image.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int | None</code>           \u2013            <p>int | None: The acquisition id of the image.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_image_acquisition_id(self, image_path: str) -&gt; int | None:\n    \"\"\"Get the acquisition id of an image in the well.\n\n    Args:\n        image_path (str): The path of the image.\n\n    Returns:\n        int | None: The acquisition id of the image.\n    \"\"\"\n    return self.meta.get_image_acquisition_id(image_path=image_path)\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrWell.get_image","title":"get_image","text":"<pre><code>get_image(image_path: str) -&gt; OmeZarrContainer\n</code></pre> <p>Get an image from the well.</p> <p>Parameters:</p> <ul> <li> <code>image_path</code>               (<code>str</code>)           \u2013            <p>The path of the image.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OmeZarrContainer</code> (              <code>OmeZarrContainer</code> )          \u2013            <p>The image.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_image(self, image_path: str) -&gt; OmeZarrContainer:\n    \"\"\"Get an image from the well.\n\n    Args:\n        image_path (str): The path of the image.\n\n    Returns:\n        OmeZarrContainer: The image.\n    \"\"\"\n    handler = self._group_handler.derive_handler(image_path)\n    return OmeZarrContainer(handler)\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrWell.atomic_add_image","title":"atomic_add_image","text":"<pre><code>atomic_add_image(\n    image_path: str,\n    acquisition_id: int | None = None,\n    strict: bool = True,\n) -&gt; StoreOrGroup\n</code></pre> <p>Parallel safe version of add_image.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def atomic_add_image(\n    self,\n    image_path: str,\n    acquisition_id: int | None = None,\n    strict: bool = True,\n) -&gt; StoreOrGroup:\n    \"\"\"Parallel safe version of add_image.\"\"\"\n    return self._add_image(\n        image_path=image_path,\n        acquisition_id=acquisition_id,\n        atomic=True,\n        strict=strict,\n    )\n</code></pre>"},{"location":"api/hcs/#ngio.OmeZarrWell.add_image","title":"add_image","text":"<pre><code>add_image(\n    image_path: str,\n    acquisition_id: int | None = None,\n    strict: bool = True,\n) -&gt; StoreOrGroup\n</code></pre> <p>Add an image to an ome-zarr well.</p> <p>Parameters:</p> <ul> <li> <code>image_path</code>               (<code>str</code>)           \u2013            <p>The path of the image.</p> </li> <li> <code>acquisition_id</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to check if the acquisition id is already exists in the well. Defaults to True. If False this might lead to acquisition in a well that does not exist at the plate level.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def add_image(\n    self,\n    image_path: str,\n    acquisition_id: int | None = None,\n    strict: bool = True,\n) -&gt; StoreOrGroup:\n    \"\"\"Add an image to an ome-zarr well.\n\n    Args:\n        image_path (str): The path of the image.\n        acquisition_id (int | None): The acquisition id to filter the images.\n        strict (bool): Whether to check if the acquisition id is already exists\n            in the well. Defaults to True. If False this might lead to\n            acquisition in a well that does not exist at the plate level.\n    \"\"\"\n    return self._add_image(\n        image_path=image_path,\n        acquisition_id=acquisition_id,\n        atomic=False,\n        strict=strict,\n    )\n</code></pre>"},{"location":"api/images/","title":"Images Like: API Documentation","text":""},{"location":"api/images/#open-an-image","title":"Open an Image","text":""},{"location":"api/images/#ngio.open_image","title":"ngio.open_image","text":"<pre><code>open_image(\n    store: StoreOrGroup,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = True,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n) -&gt; Image\n</code></pre> <p>Open a single level image from an OME-Zarr image.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group to create the image in.</p> </li> <li> <code>path</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the image in the ome_zarr file.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the image.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Only used if the pixel size is provided. If True, the     pixel size must match the image pixel size exactly. If False, the     closest pixel size level will be returned.</p> </li> <li> <code>cache</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use a cache for the zarr group metadata.</p> </li> <li> <code>mode</code>               (<code>AccessModeLiteral</code>, default:                   <code>'r+'</code> )           \u2013            <p>The access mode for the image. Defaults to \"r+\".</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def open_image(\n    store: StoreOrGroup,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = True,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n) -&gt; Image:\n    \"\"\"Open a single level image from an OME-Zarr image.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group to create the image in.\n        path (str | None): The path to the image in the ome_zarr file.\n        pixel_size (PixelSize | None): The pixel size of the image.\n        strict (bool): Only used if the pixel size is provided. If True, the\n                pixel size must match the image pixel size exactly. If False, the\n                closest pixel size level will be returned.\n        cache (bool): Whether to use a cache for the zarr group metadata.\n        mode (AccessModeLiteral): The\n            access mode for the image. Defaults to \"r+\".\n    \"\"\"\n    group_handler = ZarrGroupHandler(store, cache, mode)\n    images_container = ImagesContainer(group_handler)\n    return images_container.get(\n        path=path,\n        pixel_size=pixel_size,\n        strict=strict,\n    )\n</code></pre>"},{"location":"api/images/#ngioimage-class-reference","title":"ngio.Image Class Reference","text":""},{"location":"api/images/#ngio.Image","title":"ngio.Image","text":"<pre><code>Image(\n    group_handler: ZarrGroupHandler,\n    path: str,\n    meta_handler: ImageMetaHandler | None,\n)\n</code></pre> <p>               Bases: <code>AbstractImage[ImageMetaHandler]</code></p> <p>A class to handle a single image (or level) in an OME-Zarr image.</p> <p>This class is meant to be subclassed by specific image types.</p> <p>Initialize the Image at a single level.</p> <p>Parameters:</p> <ul> <li> <code>group_handler</code>               (<code>ZarrGroupHandler</code>)           \u2013            <p>The Zarr group handler.</p> </li> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path to the image in the ome_zarr file.</p> </li> <li> <code>meta_handler</code>               (<code>ImageMetaHandler | None</code>)           \u2013            <p>The image metadata handler.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def __init__(\n    self,\n    group_handler: ZarrGroupHandler,\n    path: str,\n    meta_handler: ImageMetaHandler | None,\n) -&gt; None:\n    \"\"\"Initialize the Image at a single level.\n\n    Args:\n        group_handler: The Zarr group handler.\n        path: The path to the image in the ome_zarr file.\n        meta_handler: The image metadata handler.\n\n    \"\"\"\n    if meta_handler is None:\n        meta_handler = find_image_meta_handler(group_handler)\n    super().__init__(\n        group_handler=group_handler, path=path, meta_handler=meta_handler\n    )\n</code></pre>"},{"location":"api/images/#ngio.Image.meta_handler","title":"meta_handler  <code>property</code>","text":"<pre><code>meta_handler: _image_handler\n</code></pre> <p>Return the metadata.</p>"},{"location":"api/images/#ngio.Image.zarr_array","title":"zarr_array  <code>property</code>","text":"<pre><code>zarr_array: Array\n</code></pre> <p>Return the Zarr array.</p>"},{"location":"api/images/#ngio.Image.shape","title":"shape  <code>property</code>","text":"<pre><code>shape: tuple[int, ...]\n</code></pre> <p>Return the shape of the image.</p>"},{"location":"api/images/#ngio.Image.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype: str\n</code></pre> <p>Return the dtype of the image.</p>"},{"location":"api/images/#ngio.Image.chunks","title":"chunks  <code>property</code>","text":"<pre><code>chunks: tuple[int, ...]\n</code></pre> <p>Return the chunks of the image.</p>"},{"location":"api/images/#ngio.Image.dimensions","title":"dimensions  <code>property</code>","text":"<pre><code>dimensions: Dimensions\n</code></pre> <p>Return the dimensions of the image.</p>"},{"location":"api/images/#ngio.Image.axes_mapper","title":"axes_mapper  <code>property</code>","text":"<pre><code>axes_mapper: AxesHandler\n</code></pre> <p>Return the axes mapper of the image.</p>"},{"location":"api/images/#ngio.Image.is_3d","title":"is_3d  <code>property</code>","text":"<pre><code>is_3d: bool\n</code></pre> <p>Return True if the image is 3D.</p>"},{"location":"api/images/#ngio.Image.is_2d","title":"is_2d  <code>property</code>","text":"<pre><code>is_2d: bool\n</code></pre> <p>Return True if the image is 2D.</p>"},{"location":"api/images/#ngio.Image.is_time_series","title":"is_time_series  <code>property</code>","text":"<pre><code>is_time_series: bool\n</code></pre> <p>Return True if the image is a time series.</p>"},{"location":"api/images/#ngio.Image.is_2d_time_series","title":"is_2d_time_series  <code>property</code>","text":"<pre><code>is_2d_time_series: bool\n</code></pre> <p>Return True if the image is a 2D time series.</p>"},{"location":"api/images/#ngio.Image.is_3d_time_series","title":"is_3d_time_series  <code>property</code>","text":"<pre><code>is_3d_time_series: bool\n</code></pre> <p>Return True if the image is a 3D time series.</p>"},{"location":"api/images/#ngio.Image.is_multi_channels","title":"is_multi_channels  <code>property</code>","text":"<pre><code>is_multi_channels: bool\n</code></pre> <p>Return True if the image is multichannel.</p>"},{"location":"api/images/#ngio.Image.space_unit","title":"space_unit  <code>property</code>","text":"<pre><code>space_unit: str | None\n</code></pre> <p>Return the space unit of the image.</p>"},{"location":"api/images/#ngio.Image.time_unit","title":"time_unit  <code>property</code>","text":"<pre><code>time_unit: str | None\n</code></pre> <p>Return the time unit of the image.</p>"},{"location":"api/images/#ngio.Image.pixel_size","title":"pixel_size  <code>property</code>","text":"<pre><code>pixel_size: PixelSize\n</code></pre> <p>Return the pixel size of the image.</p>"},{"location":"api/images/#ngio.Image.dataset","title":"dataset  <code>property</code>","text":"<pre><code>dataset: Dataset\n</code></pre> <p>Return the dataset of the image.</p>"},{"location":"api/images/#ngio.Image.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Return the path of the image.</p>"},{"location":"api/images/#ngio.Image.meta","title":"meta  <code>property</code>","text":"<pre><code>meta: NgioImageMeta\n</code></pre> <p>Return the metadata.</p>"},{"location":"api/images/#ngio.Image.channels_meta","title":"channels_meta  <code>property</code>","text":"<pre><code>channels_meta: ChannelsMeta\n</code></pre> <p>Return the channels metadata.</p>"},{"location":"api/images/#ngio.Image.channel_labels","title":"channel_labels  <code>property</code>","text":"<pre><code>channel_labels: list[str]\n</code></pre> <p>Return the channels of the image.</p>"},{"location":"api/images/#ngio.Image.wavelength_ids","title":"wavelength_ids  <code>property</code>","text":"<pre><code>wavelength_ids: list[str | None]\n</code></pre> <p>Return the list of wavelength of the image.</p>"},{"location":"api/images/#ngio.Image.num_channels","title":"num_channels  <code>property</code>","text":"<pre><code>num_channels: int\n</code></pre> <p>Return the number of channels.</p>"},{"location":"api/images/#ngio.Image.has_axis","title":"has_axis","text":"<pre><code>has_axis(axis: str) -&gt; bool\n</code></pre> <p>Return True if the image has the given axis.</p> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def has_axis(self, axis: str) -&gt; bool:\n    \"\"\"Return True if the image has the given axis.\"\"\"\n    self.axes_mapper.get_index(\"x\")\n    return self.dimensions.has_axis(axis)\n</code></pre>"},{"location":"api/images/#ngio.Image.build_image_roi_table","title":"build_image_roi_table","text":"<pre><code>build_image_roi_table(\n    name: str | None = \"image\",\n) -&gt; RoiTable\n</code></pre> <p>Build the ROI table for an image.</p> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def build_image_roi_table(self, name: str | None = \"image\") -&gt; RoiTable:\n    \"\"\"Build the ROI table for an image.\"\"\"\n    return build_image_roi_table(image=self, name=name)\n</code></pre>"},{"location":"api/images/#ngio.Image.assert_dimensions_match","title":"assert_dimensions_match","text":"<pre><code>assert_dimensions_match(\n    other: AbstractImage, allow_singleton: bool = False\n) -&gt; None\n</code></pre> <p>Assert that two images have matching spatial dimensions.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>AbstractImage</code>)           \u2013            <p>The other image to compare to.</p> </li> <li> <code>allow_singleton</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, allow singleton dimensions to be compatible with non-singleton dimensions.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NgioValueError</code>             \u2013            <p>If the images do not have compatible dimensions.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def assert_dimensions_match(\n    self,\n    other: \"AbstractImage\",\n    allow_singleton: bool = False,\n) -&gt; None:\n    \"\"\"Assert that two images have matching spatial dimensions.\n\n    Args:\n        other: The other image to compare to.\n        allow_singleton: If True, allow singleton dimensions to be\n            compatible with non-singleton dimensions.\n\n    Raises:\n        NgioValueError: If the images do not have compatible dimensions.\n    \"\"\"\n    assert_dimensions_match(\n        image1=self, image2=other, allow_singleton=allow_singleton\n    )\n</code></pre>"},{"location":"api/images/#ngio.Image.assert_axes_match","title":"assert_axes_match","text":"<pre><code>assert_axes_match(other: AbstractImage) -&gt; None\n</code></pre> <p>Assert that two images have compatible axes.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>AbstractImage</code>)           \u2013            <p>The other image to compare to.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NgioValueError</code>             \u2013            <p>If the images do not have compatible axes.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def assert_axes_match(\n    self,\n    other: \"AbstractImage\",\n) -&gt; None:\n    \"\"\"Assert that two images have compatible axes.\n\n    Args:\n        other: The other image to compare to.\n\n    Raises:\n        NgioValueError: If the images do not have compatible axes.\n    \"\"\"\n    assert_axes_match(image1=self, image2=other)\n</code></pre>"},{"location":"api/images/#ngio.Image.assert_can_be_rescaled","title":"assert_can_be_rescaled","text":"<pre><code>assert_can_be_rescaled(other: AbstractImage) -&gt; None\n</code></pre> <p>Assert that two images can be rescaled to each other.</p> <p>For this to be true, the images must have the same axes, and the pixel sizes must be compatible (i.e. one can be scaled to the other).</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>AbstractImage</code>)           \u2013            <p>The other image to compare to.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NgioValueError</code>             \u2013            <p>If the images cannot be scaled to each other.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def assert_can_be_rescaled(\n    self,\n    other: \"AbstractImage\",\n) -&gt; None:\n    \"\"\"Assert that two images can be rescaled to each other.\n\n    For this to be true, the images must have the same axes, and\n    the pixel sizes must be compatible (i.e. one can be scaled to the other).\n\n    Args:\n        other: The other image to compare to.\n\n    Raises:\n        NgioValueError: If the images cannot be scaled to each other.\n    \"\"\"\n    assert_can_be_rescaled(image1=self, image2=other)\n</code></pre>"},{"location":"api/images/#ngio.Image.get_channel_idx","title":"get_channel_idx","text":"<pre><code>get_channel_idx(\n    channel_label: str | None = None,\n    wavelength_id: str | None = None,\n) -&gt; int\n</code></pre> <p>Get the index of a channel by its label or wavelength ID.</p> Source code in <code>ngio/images/_image.py</code> <pre><code>def get_channel_idx(\n    self, channel_label: str | None = None, wavelength_id: str | None = None\n) -&gt; int:\n    \"\"\"Get the index of a channel by its label or wavelength ID.\"\"\"\n    return self.channels_meta.get_channel_idx(\n        channel_label=channel_label, wavelength_id=wavelength_id\n    )\n</code></pre>"},{"location":"api/images/#ngio.Image.get_as_numpy","title":"get_as_numpy","text":"<pre><code>get_as_numpy(\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: slice | int | Sequence[int] | None,\n) -&gt; ndarray\n</code></pre> <p>Get the image as a numpy array.</p> <p>Parameters:</p> <ul> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Select a specific channel by label. If None, all channels are returned. Alternatively, you can slice arbitrary channels using the slice_kwargs (c=[0, 2]).</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The order of the axes to return the array.</p> </li> <li> <code>transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>The transforms to apply to the array.</p> </li> <li> <code>**slicing_kwargs</code>               (<code>slice | int | Sequence[int] | None</code>, default:                   <code>{}</code> )           \u2013            <p>The slices to get the array.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The array of the region of interest.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def get_as_numpy(\n    self,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: slice | int | Sequence[int] | None,\n) -&gt; np.ndarray:\n    \"\"\"Get the image as a numpy array.\n\n    Args:\n        channel_selection: Select a specific channel by label.\n            If None, all channels are returned.\n            Alternatively, you can slice arbitrary channels\n            using the slice_kwargs (c=[0, 2]).\n        axes_order: The order of the axes to return the array.\n        transforms: The transforms to apply to the array.\n        **slicing_kwargs: The slices to get the array.\n\n    Returns:\n        The array of the region of interest.\n    \"\"\"\n    _slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self, channel_selection=channel_selection, slicing_dict=slicing_kwargs\n    )\n    return self._get_as_numpy(\n        axes_order=axes_order, transforms=transforms, **_slicing_kwargs\n    )\n</code></pre>"},{"location":"api/images/#ngio.Image.get_roi_as_numpy","title":"get_roi_as_numpy","text":"<pre><code>get_roi_as_numpy(\n    roi: Roi | RoiPixels,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; ndarray\n</code></pre> <p>Get the image as a numpy array for a region of interest.</p> <p>Parameters:</p> <ul> <li> <code>roi</code>               (<code>Roi | RoiPixels</code>)           \u2013            <p>The region of interest to get the array.</p> </li> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Select a what subset of channels to return. If None, all channels are returned.</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The order of the axes to return the array.</p> </li> <li> <code>transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>The transforms to apply to the array.</p> </li> <li> <code>**slicing_kwargs</code>               (<code>SlicingInputType</code>, default:                   <code>{}</code> )           \u2013            <p>The slices to get the array.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The array of the region of interest.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def get_roi_as_numpy(\n    self,\n    roi: Roi | RoiPixels,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; np.ndarray:\n    \"\"\"Get the image as a numpy array for a region of interest.\n\n    Args:\n        roi: The region of interest to get the array.\n        channel_selection: Select a what subset of channels to return.\n            If None, all channels are returned.\n        axes_order: The order of the axes to return the array.\n        transforms: The transforms to apply to the array.\n        **slicing_kwargs: The slices to get the array.\n\n    Returns:\n        The array of the region of interest.\n    \"\"\"\n    _slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self, channel_selection=channel_selection, slicing_dict=slicing_kwargs\n    )\n    return self._get_roi_as_numpy(\n        roi=roi, axes_order=axes_order, transforms=transforms, **_slicing_kwargs\n    )\n</code></pre>"},{"location":"api/images/#ngio.Image.get_as_dask","title":"get_as_dask","text":"<pre><code>get_as_dask(\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; Array\n</code></pre> <p>Get the image as a dask array.</p> <p>Parameters:</p> <ul> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Select a what subset of channels to return. If None, all channels are returned.</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The order of the axes to return the array.</p> </li> <li> <code>transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>The transforms to apply to the array.</p> </li> <li> <code>**slicing_kwargs</code>               (<code>SlicingInputType</code>, default:                   <code>{}</code> )           \u2013            <p>The slices to get the array.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array</code>           \u2013            <p>The dask array of the region of interest.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def get_as_dask(\n    self,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; da.Array:\n    \"\"\"Get the image as a dask array.\n\n    Args:\n        channel_selection: Select a what subset of channels to return.\n            If None, all channels are returned.\n        axes_order: The order of the axes to return the array.\n        transforms: The transforms to apply to the array.\n        **slicing_kwargs: The slices to get the array.\n\n    Returns:\n        The dask array of the region of interest.\n    \"\"\"\n    _slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self, channel_selection=channel_selection, slicing_dict=slicing_kwargs\n    )\n    return self._get_as_dask(\n        axes_order=axes_order, transforms=transforms, **_slicing_kwargs\n    )\n</code></pre>"},{"location":"api/images/#ngio.Image.get_roi_as_dask","title":"get_roi_as_dask","text":"<pre><code>get_roi_as_dask(\n    roi: Roi | RoiPixels,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; Array\n</code></pre> <p>Get the image as a dask array for a region of interest.</p> <p>Parameters:</p> <ul> <li> <code>roi</code>               (<code>Roi | RoiPixels</code>)           \u2013            <p>The region of interest to get the array.</p> </li> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Select a what subset of channels to return. If None, all channels are returned.</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The order of the axes to return the array.</p> </li> <li> <code>transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>The transforms to apply to the array.</p> </li> <li> <code>**slicing_kwargs</code>               (<code>SlicingInputType</code>, default:                   <code>{}</code> )           \u2013            <p>The slices to get the array.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array</code>           \u2013            <p>The dask array of the region of interest.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def get_roi_as_dask(\n    self,\n    roi: Roi | RoiPixels,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; da.Array:\n    \"\"\"Get the image as a dask array for a region of interest.\n\n    Args:\n        roi: The region of interest to get the array.\n        channel_selection: Select a what subset of channels to return.\n            If None, all channels are returned.\n        axes_order: The order of the axes to return the array.\n        transforms: The transforms to apply to the array.\n        **slicing_kwargs: The slices to get the array.\n\n    Returns:\n        The dask array of the region of interest.\n    \"\"\"\n    _slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self, channel_selection=channel_selection, slicing_dict=slicing_kwargs\n    )\n    return self._get_roi_as_dask(\n        roi=roi, axes_order=axes_order, transforms=transforms, **_slicing_kwargs\n    )\n</code></pre>"},{"location":"api/images/#ngio.Image.get_array","title":"get_array","text":"<pre><code>get_array(\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    mode: Literal[\"numpy\", \"dask\"] = \"numpy\",\n    **slicing_kwargs: SlicingInputType,\n) -&gt; ndarray | Array\n</code></pre> <p>Get the image as a zarr array.</p> <p>Parameters:</p> <ul> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Select a what subset of channels to return. If None, all channels are returned.</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The order of the axes to return the array.</p> </li> <li> <code>transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>The transforms to apply to the array.</p> </li> <li> <code>mode</code>               (<code>Literal['numpy', 'dask']</code>, default:                   <code>'numpy'</code> )           \u2013            <p>The object type to return. Can be \"dask\", \"numpy\".</p> </li> <li> <code>**slicing_kwargs</code>               (<code>SlicingInputType</code>, default:                   <code>{}</code> )           \u2013            <p>The slices to get the array.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray | Array</code>           \u2013            <p>The zarr array of the region of interest.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def get_array(\n    self,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    mode: Literal[\"numpy\", \"dask\"] = \"numpy\",\n    **slicing_kwargs: SlicingInputType,\n) -&gt; np.ndarray | da.Array:\n    \"\"\"Get the image as a zarr array.\n\n    Args:\n        channel_selection: Select a what subset of channels to return.\n            If None, all channels are returned.\n        axes_order: The order of the axes to return the array.\n        transforms: The transforms to apply to the array.\n        mode: The object type to return.\n            Can be \"dask\", \"numpy\".\n        **slicing_kwargs: The slices to get the array.\n\n    Returns:\n        The zarr array of the region of interest.\n    \"\"\"\n    _slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self, channel_selection=channel_selection, slicing_dict=slicing_kwargs\n    )\n    return self._get_array(\n        axes_order=axes_order, mode=mode, transforms=transforms, **_slicing_kwargs\n    )\n</code></pre>"},{"location":"api/images/#ngio.Image.get_roi","title":"get_roi","text":"<pre><code>get_roi(\n    roi: Roi | RoiPixels,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    mode: Literal[\"numpy\", \"dask\"] = \"numpy\",\n    **slicing_kwargs: SlicingInputType,\n) -&gt; ndarray | Array\n</code></pre> <p>Get the image as a zarr array for a region of interest.</p> <p>Parameters:</p> <ul> <li> <code>roi</code>               (<code>Roi | RoiPixels</code>)           \u2013            <p>The region of interest to get the array.</p> </li> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Select a what subset of channels to return. If None, all channels are returned.</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The order of the axes to return the array.</p> </li> <li> <code>transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>The transforms to apply to the array.</p> </li> <li> <code>mode</code>               (<code>Literal['numpy', 'dask']</code>, default:                   <code>'numpy'</code> )           \u2013            <p>The object type to return. Can be \"dask\", \"numpy\".</p> </li> <li> <code>**slicing_kwargs</code>               (<code>SlicingInputType</code>, default:                   <code>{}</code> )           \u2013            <p>The slices to get the array.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray | Array</code>           \u2013            <p>The zarr array of the region of interest.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def get_roi(\n    self,\n    roi: Roi | RoiPixels,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    mode: Literal[\"numpy\", \"dask\"] = \"numpy\",\n    **slicing_kwargs: SlicingInputType,\n) -&gt; np.ndarray | da.Array:\n    \"\"\"Get the image as a zarr array for a region of interest.\n\n    Args:\n        roi: The region of interest to get the array.\n        channel_selection: Select a what subset of channels to return.\n            If None, all channels are returned.\n        axes_order: The order of the axes to return the array.\n        transforms: The transforms to apply to the array.\n        mode: The object type to return.\n            Can be \"dask\", \"numpy\".\n        **slicing_kwargs: The slices to get the array.\n\n    Returns:\n        The zarr array of the region of interest.\n    \"\"\"\n    _slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self, channel_selection=channel_selection, slicing_dict=slicing_kwargs\n    )\n    return self._get_roi(\n        roi=roi,\n        axes_order=axes_order,\n        mode=mode,\n        transforms=transforms,\n        **_slicing_kwargs,\n    )\n</code></pre>"},{"location":"api/images/#ngio.Image.set_array","title":"set_array","text":"<pre><code>set_array(\n    patch: ndarray | Array,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; None\n</code></pre> <p>Set the image array.</p> <p>Parameters:</p> <ul> <li> <code>patch</code>               (<code>ndarray | Array</code>)           \u2013            <p>The array to set.</p> </li> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Select a what subset of channels to return. If None, all channels are set.</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The order of the axes to set the array.</p> </li> <li> <code>transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>The transforms to apply to the array.</p> </li> <li> <code>**slicing_kwargs</code>               (<code>SlicingInputType</code>, default:                   <code>{}</code> )           \u2013            <p>The slices to set the array.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def set_array(\n    self,\n    patch: np.ndarray | da.Array,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; None:\n    \"\"\"Set the image array.\n\n    Args:\n        patch: The array to set.\n        channel_selection: Select a what subset of channels to return.\n            If None, all channels are set.\n        axes_order: The order of the axes to set the array.\n        transforms: The transforms to apply to the array.\n        **slicing_kwargs: The slices to set the array.\n    \"\"\"\n    _slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self, channel_selection=channel_selection, slicing_dict=slicing_kwargs\n    )\n    self._set_array(\n        patch=patch, axes_order=axes_order, transforms=transforms, **_slicing_kwargs\n    )\n</code></pre>"},{"location":"api/images/#ngio.Image.set_roi","title":"set_roi","text":"<pre><code>set_roi(\n    roi: Roi | RoiPixels,\n    patch: ndarray | Array,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; None\n</code></pre> <p>Set the image array for a region of interest.</p> <p>Parameters:</p> <ul> <li> <code>roi</code>               (<code>Roi | RoiPixels</code>)           \u2013            <p>The region of interest to set the array.</p> </li> <li> <code>patch</code>               (<code>ndarray | Array</code>)           \u2013            <p>The array to set.</p> </li> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Select a what subset of channels to return.</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The order of the axes to set the array.</p> </li> <li> <code>transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>The transforms to apply to the array.</p> </li> <li> <code>**slicing_kwargs</code>               (<code>SlicingInputType</code>, default:                   <code>{}</code> )           \u2013            <p>The slices to set the array.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def set_roi(\n    self,\n    roi: Roi | RoiPixels,\n    patch: np.ndarray | da.Array,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; None:\n    \"\"\"Set the image array for a region of interest.\n\n    Args:\n        roi: The region of interest to set the array.\n        patch: The array to set.\n        channel_selection: Select a what subset of channels to return.\n        axes_order: The order of the axes to set the array.\n        transforms: The transforms to apply to the array.\n        **slicing_kwargs: The slices to set the array.\n    \"\"\"\n    _slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self, channel_selection=channel_selection, slicing_dict=slicing_kwargs\n    )\n    self._set_roi(\n        roi=roi,\n        patch=patch,\n        axes_order=axes_order,\n        transforms=transforms,\n        **_slicing_kwargs,\n    )\n</code></pre>"},{"location":"api/images/#ngio.Image.consolidate","title":"consolidate","text":"<pre><code>consolidate(\n    order: InterpolationOrder = \"linear\",\n    mode: Literal[\"dask\", \"numpy\", \"coarsen\"] = \"dask\",\n) -&gt; None\n</code></pre> <p>Consolidate the label on disk.</p> Source code in <code>ngio/images/_image.py</code> <pre><code>def consolidate(\n    self,\n    order: InterpolationOrder = \"linear\",\n    mode: Literal[\"dask\", \"numpy\", \"coarsen\"] = \"dask\",\n) -&gt; None:\n    \"\"\"Consolidate the label on disk.\"\"\"\n    self._consolidate(order=order, mode=mode)\n</code></pre>"},{"location":"api/images/#open-a-label","title":"Open a Label","text":""},{"location":"api/images/#ngio.open_label","title":"ngio.open_label","text":"<pre><code>open_label(\n    store: StoreOrGroup,\n    name: str | None = None,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = True,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n) -&gt; Label\n</code></pre> <p>Open a single level label from an OME-Zarr Label group.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group to create the image in.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the label. If None, we will try to open the store as a multiscale label.</p> </li> <li> <code>path</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the image in the ome_zarr file.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the image.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Only used if the pixel size is provided. If True, the pixel size must match the image pixel size exactly. If False, the closest pixel size level will be returned.</p> </li> <li> <code>cache</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use a cache for the zarr group metadata.</p> </li> <li> <code>mode</code>               (<code>AccessModeLiteral</code>, default:                   <code>'r+'</code> )           \u2013            <p>The access mode for the image. Defaults to \"r+\".</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def open_label(\n    store: StoreOrGroup,\n    name: str | None = None,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = True,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n) -&gt; Label:\n    \"\"\"Open a single level label from an OME-Zarr Label group.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group to create the image in.\n        name (str | None): The name of the label. If None,\n            we will try to open the store as a multiscale label.\n        path (str | None): The path to the image in the ome_zarr file.\n        pixel_size (PixelSize | None): The pixel size of the image.\n        strict (bool): Only used if the pixel size is provided. If True, the\n            pixel size must match the image pixel size exactly. If False, the\n            closest pixel size level will be returned.\n        cache (bool): Whether to use a cache for the zarr group metadata.\n        mode (AccessModeLiteral): The access mode for the image. Defaults to \"r+\".\n\n    \"\"\"\n    group_handler = ZarrGroupHandler(store, cache, mode)\n    if name is None:\n        label_meta_handler = find_label_meta_handler(group_handler)\n        path = label_meta_handler.meta.get_dataset(\n            path=path, pixel_size=pixel_size, strict=strict\n        ).path\n        return Label(group_handler, path, label_meta_handler)\n\n    labels_container = LabelsContainer(group_handler)\n    return labels_container.get(\n        name=name,\n        path=path,\n        pixel_size=pixel_size,\n        strict=strict,\n    )\n</code></pre>"},{"location":"api/images/#ngiolabel-class-reference","title":"ngio.Label Class Reference","text":""},{"location":"api/images/#ngio.Label","title":"ngio.Label","text":"<pre><code>Label(\n    group_handler: ZarrGroupHandler,\n    path: str,\n    meta_handler: LabelMetaHandler | None,\n)\n</code></pre> <p>               Bases: <code>AbstractImage[LabelMetaHandler]</code></p> <p>Placeholder class for a label.</p> <p>Initialize the Image at a single level.</p> <p>Parameters:</p> <ul> <li> <code>group_handler</code>               (<code>ZarrGroupHandler</code>)           \u2013            <p>The Zarr group handler.</p> </li> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path to the image in the ome_zarr file.</p> </li> <li> <code>meta_handler</code>               (<code>LabelMetaHandler | None</code>)           \u2013            <p>The image metadata handler.</p> </li> </ul> Source code in <code>ngio/images/_label.py</code> <pre><code>def __init__(\n    self,\n    group_handler: ZarrGroupHandler,\n    path: str,\n    meta_handler: LabelMetaHandler | None,\n) -&gt; None:\n    \"\"\"Initialize the Image at a single level.\n\n    Args:\n        group_handler: The Zarr group handler.\n        path: The path to the image in the ome_zarr file.\n        meta_handler: The image metadata handler.\n\n    \"\"\"\n    if meta_handler is None:\n        meta_handler = find_label_meta_handler(group_handler)\n    super().__init__(\n        group_handler=group_handler, path=path, meta_handler=meta_handler\n    )\n</code></pre>"},{"location":"api/images/#ngio.Label.meta_handler","title":"meta_handler  <code>property</code>","text":"<pre><code>meta_handler: _image_handler\n</code></pre> <p>Return the metadata.</p>"},{"location":"api/images/#ngio.Label.zarr_array","title":"zarr_array  <code>property</code>","text":"<pre><code>zarr_array: Array\n</code></pre> <p>Return the Zarr array.</p>"},{"location":"api/images/#ngio.Label.shape","title":"shape  <code>property</code>","text":"<pre><code>shape: tuple[int, ...]\n</code></pre> <p>Return the shape of the image.</p>"},{"location":"api/images/#ngio.Label.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype: str\n</code></pre> <p>Return the dtype of the image.</p>"},{"location":"api/images/#ngio.Label.chunks","title":"chunks  <code>property</code>","text":"<pre><code>chunks: tuple[int, ...]\n</code></pre> <p>Return the chunks of the image.</p>"},{"location":"api/images/#ngio.Label.dimensions","title":"dimensions  <code>property</code>","text":"<pre><code>dimensions: Dimensions\n</code></pre> <p>Return the dimensions of the image.</p>"},{"location":"api/images/#ngio.Label.axes_mapper","title":"axes_mapper  <code>property</code>","text":"<pre><code>axes_mapper: AxesHandler\n</code></pre> <p>Return the axes mapper of the image.</p>"},{"location":"api/images/#ngio.Label.is_3d","title":"is_3d  <code>property</code>","text":"<pre><code>is_3d: bool\n</code></pre> <p>Return True if the image is 3D.</p>"},{"location":"api/images/#ngio.Label.is_2d","title":"is_2d  <code>property</code>","text":"<pre><code>is_2d: bool\n</code></pre> <p>Return True if the image is 2D.</p>"},{"location":"api/images/#ngio.Label.is_time_series","title":"is_time_series  <code>property</code>","text":"<pre><code>is_time_series: bool\n</code></pre> <p>Return True if the image is a time series.</p>"},{"location":"api/images/#ngio.Label.is_2d_time_series","title":"is_2d_time_series  <code>property</code>","text":"<pre><code>is_2d_time_series: bool\n</code></pre> <p>Return True if the image is a 2D time series.</p>"},{"location":"api/images/#ngio.Label.is_3d_time_series","title":"is_3d_time_series  <code>property</code>","text":"<pre><code>is_3d_time_series: bool\n</code></pre> <p>Return True if the image is a 3D time series.</p>"},{"location":"api/images/#ngio.Label.is_multi_channels","title":"is_multi_channels  <code>property</code>","text":"<pre><code>is_multi_channels: bool\n</code></pre> <p>Return True if the image is multichannel.</p>"},{"location":"api/images/#ngio.Label.space_unit","title":"space_unit  <code>property</code>","text":"<pre><code>space_unit: str | None\n</code></pre> <p>Return the space unit of the image.</p>"},{"location":"api/images/#ngio.Label.time_unit","title":"time_unit  <code>property</code>","text":"<pre><code>time_unit: str | None\n</code></pre> <p>Return the time unit of the image.</p>"},{"location":"api/images/#ngio.Label.pixel_size","title":"pixel_size  <code>property</code>","text":"<pre><code>pixel_size: PixelSize\n</code></pre> <p>Return the pixel size of the image.</p>"},{"location":"api/images/#ngio.Label.dataset","title":"dataset  <code>property</code>","text":"<pre><code>dataset: Dataset\n</code></pre> <p>Return the dataset of the image.</p>"},{"location":"api/images/#ngio.Label.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Return the path of the image.</p>"},{"location":"api/images/#ngio.Label.get_as_numpy","title":"get_as_numpy  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_as_numpy = _get_as_numpy\n</code></pre>"},{"location":"api/images/#ngio.Label.get_as_dask","title":"get_as_dask  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_as_dask = _get_as_dask\n</code></pre>"},{"location":"api/images/#ngio.Label.get_array","title":"get_array  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_array = _get_array\n</code></pre>"},{"location":"api/images/#ngio.Label.get_roi_as_numpy","title":"get_roi_as_numpy  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_roi_as_numpy = _get_roi_as_numpy\n</code></pre>"},{"location":"api/images/#ngio.Label.get_roi_as_dask","title":"get_roi_as_dask  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_roi_as_dask = _get_roi_as_dask\n</code></pre>"},{"location":"api/images/#ngio.Label.get_roi","title":"get_roi  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_roi = _get_roi\n</code></pre>"},{"location":"api/images/#ngio.Label.set_array","title":"set_array  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>set_array = _set_array\n</code></pre>"},{"location":"api/images/#ngio.Label.set_roi","title":"set_roi  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>set_roi = _set_roi\n</code></pre>"},{"location":"api/images/#ngio.Label.meta","title":"meta  <code>property</code>","text":"<pre><code>meta: NgioLabelMeta\n</code></pre> <p>Return the metadata.</p>"},{"location":"api/images/#ngio.Label.has_axis","title":"has_axis","text":"<pre><code>has_axis(axis: str) -&gt; bool\n</code></pre> <p>Return True if the image has the given axis.</p> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def has_axis(self, axis: str) -&gt; bool:\n    \"\"\"Return True if the image has the given axis.\"\"\"\n    self.axes_mapper.get_index(\"x\")\n    return self.dimensions.has_axis(axis)\n</code></pre>"},{"location":"api/images/#ngio.Label.build_image_roi_table","title":"build_image_roi_table","text":"<pre><code>build_image_roi_table(\n    name: str | None = \"image\",\n) -&gt; RoiTable\n</code></pre> <p>Build the ROI table for an image.</p> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def build_image_roi_table(self, name: str | None = \"image\") -&gt; RoiTable:\n    \"\"\"Build the ROI table for an image.\"\"\"\n    return build_image_roi_table(image=self, name=name)\n</code></pre>"},{"location":"api/images/#ngio.Label.assert_dimensions_match","title":"assert_dimensions_match","text":"<pre><code>assert_dimensions_match(\n    other: AbstractImage, allow_singleton: bool = False\n) -&gt; None\n</code></pre> <p>Assert that two images have matching spatial dimensions.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>AbstractImage</code>)           \u2013            <p>The other image to compare to.</p> </li> <li> <code>allow_singleton</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, allow singleton dimensions to be compatible with non-singleton dimensions.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NgioValueError</code>             \u2013            <p>If the images do not have compatible dimensions.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def assert_dimensions_match(\n    self,\n    other: \"AbstractImage\",\n    allow_singleton: bool = False,\n) -&gt; None:\n    \"\"\"Assert that two images have matching spatial dimensions.\n\n    Args:\n        other: The other image to compare to.\n        allow_singleton: If True, allow singleton dimensions to be\n            compatible with non-singleton dimensions.\n\n    Raises:\n        NgioValueError: If the images do not have compatible dimensions.\n    \"\"\"\n    assert_dimensions_match(\n        image1=self, image2=other, allow_singleton=allow_singleton\n    )\n</code></pre>"},{"location":"api/images/#ngio.Label.assert_axes_match","title":"assert_axes_match","text":"<pre><code>assert_axes_match(other: AbstractImage) -&gt; None\n</code></pre> <p>Assert that two images have compatible axes.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>AbstractImage</code>)           \u2013            <p>The other image to compare to.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NgioValueError</code>             \u2013            <p>If the images do not have compatible axes.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def assert_axes_match(\n    self,\n    other: \"AbstractImage\",\n) -&gt; None:\n    \"\"\"Assert that two images have compatible axes.\n\n    Args:\n        other: The other image to compare to.\n\n    Raises:\n        NgioValueError: If the images do not have compatible axes.\n    \"\"\"\n    assert_axes_match(image1=self, image2=other)\n</code></pre>"},{"location":"api/images/#ngio.Label.assert_can_be_rescaled","title":"assert_can_be_rescaled","text":"<pre><code>assert_can_be_rescaled(other: AbstractImage) -&gt; None\n</code></pre> <p>Assert that two images can be rescaled to each other.</p> <p>For this to be true, the images must have the same axes, and the pixel sizes must be compatible (i.e. one can be scaled to the other).</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>AbstractImage</code>)           \u2013            <p>The other image to compare to.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NgioValueError</code>             \u2013            <p>If the images cannot be scaled to each other.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def assert_can_be_rescaled(\n    self,\n    other: \"AbstractImage\",\n) -&gt; None:\n    \"\"\"Assert that two images can be rescaled to each other.\n\n    For this to be true, the images must have the same axes, and\n    the pixel sizes must be compatible (i.e. one can be scaled to the other).\n\n    Args:\n        other: The other image to compare to.\n\n    Raises:\n        NgioValueError: If the images cannot be scaled to each other.\n    \"\"\"\n    assert_can_be_rescaled(image1=self, image2=other)\n</code></pre>"},{"location":"api/images/#ngio.Label.set_axes_unit","title":"set_axes_unit","text":"<pre><code>set_axes_unit(\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n) -&gt; None\n</code></pre> <p>Set the axes unit of the image.</p> <p>Parameters:</p> <ul> <li> <code>space_unit</code>               (<code>SpaceUnits</code>, default:                   <code>DefaultSpaceUnit</code> )           \u2013            <p>The space unit of the image.</p> </li> <li> <code>time_unit</code>               (<code>TimeUnits</code>, default:                   <code>DefaultTimeUnit</code> )           \u2013            <p>The time unit of the image.</p> </li> </ul> Source code in <code>ngio/images/_label.py</code> <pre><code>def set_axes_unit(\n    self,\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n) -&gt; None:\n    \"\"\"Set the axes unit of the image.\n\n    Args:\n        space_unit (SpaceUnits): The space unit of the image.\n        time_unit (TimeUnits): The time unit of the image.\n    \"\"\"\n    meta = self.meta\n    meta = meta.to_units(space_unit=space_unit, time_unit=time_unit)\n    self._meta_handler.write_meta(meta)\n</code></pre>"},{"location":"api/images/#ngio.Label.build_masking_roi_table","title":"build_masking_roi_table","text":"<pre><code>build_masking_roi_table() -&gt; MaskingRoiTable\n</code></pre> <p>Compute the masking ROI table.</p> Source code in <code>ngio/images/_label.py</code> <pre><code>def build_masking_roi_table(self) -&gt; MaskingRoiTable:\n    \"\"\"Compute the masking ROI table.\"\"\"\n    return build_masking_roi_table(self)\n</code></pre>"},{"location":"api/images/#ngio.Label.consolidate","title":"consolidate","text":"<pre><code>consolidate(\n    mode: Literal[\"dask\", \"numpy\", \"coarsen\"] = \"dask\",\n) -&gt; None\n</code></pre> <p>Consolidate the label on disk.</p> Source code in <code>ngio/images/_label.py</code> <pre><code>def consolidate(\n    self,\n    mode: Literal[\"dask\", \"numpy\", \"coarsen\"] = \"dask\",\n) -&gt; None:\n    \"\"\"Consolidate the label on disk.\"\"\"\n    self._consolidate(\n        order=\"nearest\",\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/ome_zarr_container/","title":"OmeZarrContainer: API Documentation","text":""},{"location":"api/ome_zarr_container/#open-an-ome-zarr-container","title":"Open an OME-Zarr Container","text":""},{"location":"api/ome_zarr_container/#ngio.open_ome_zarr_container","title":"ngio.open_ome_zarr_container","text":"<pre><code>open_ome_zarr_container(\n    store: StoreOrGroup,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n    validate_arrays: bool = True,\n) -&gt; OmeZarrContainer\n</code></pre> <p>Open an OME-Zarr image.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def open_ome_zarr_container(\n    store: StoreOrGroup,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n    validate_arrays: bool = True,\n) -&gt; OmeZarrContainer:\n    \"\"\"Open an OME-Zarr image.\"\"\"\n    handler = ZarrGroupHandler(store=store, cache=cache, mode=mode)\n    return OmeZarrContainer(\n        group_handler=handler,\n        validate_paths=validate_arrays,\n    )\n</code></pre>"},{"location":"api/ome_zarr_container/#create-an-ome-zarr-container","title":"Create an OME-Zarr Container","text":""},{"location":"api/ome_zarr_container/#ngio.create_empty_ome_zarr","title":"ngio.create_empty_ome_zarr","text":"<pre><code>create_empty_ome_zarr(\n    store: StoreOrGroup,\n    shape: Sequence[int],\n    xy_pixelsize: float,\n    z_spacing: float = 1.0,\n    time_spacing: float = 1.0,\n    levels: int | list[str] = 5,\n    xy_scaling_factor: float = 2,\n    z_scaling_factor: float = 1.0,\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n    axes_names: Sequence[str] | None = None,\n    name: str | None = None,\n    chunks: Sequence[int] | None = None,\n    dtype: str = \"uint16\",\n    channel_labels: list[str] | None = None,\n    channel_wavelengths: list[str] | None = None,\n    channel_colors: Sequence[str] | None = None,\n    channel_active: Sequence[bool] | None = None,\n    overwrite: bool = False,\n    version: NgffVersions = DefaultNgffVersion,\n) -&gt; OmeZarrContainer\n</code></pre> <p>Create an empty OME-Zarr image with the given shape and metadata.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group to create the image in.</p> </li> <li> <code>shape</code>               (<code>Sequence[int]</code>)           \u2013            <p>The shape of the image.</p> </li> <li> <code>xy_pixelsize</code>               (<code>float</code>)           \u2013            <p>The pixel size in x and y dimensions.</p> </li> <li> <code>z_spacing</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The spacing between z slices. Defaults to 1.0.</p> </li> <li> <code>time_spacing</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The spacing between time points. Defaults to 1.0.</p> </li> <li> <code>levels</code>               (<code>int | list[str]</code>, default:                   <code>5</code> )           \u2013            <p>The number of levels in the pyramid or a list of level names. Defaults to 5.</p> </li> <li> <code>xy_scaling_factor</code>               (<code>float</code>, default:                   <code>2</code> )           \u2013            <p>The down-scaling factor in x and y dimensions. Defaults to 2.0.</p> </li> <li> <code>z_scaling_factor</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The down-scaling factor in z dimension. Defaults to 1.0.</p> </li> <li> <code>space_unit</code>               (<code>SpaceUnits</code>, default:                   <code>DefaultSpaceUnit</code> )           \u2013            <p>The unit of space. Defaults to DefaultSpaceUnit.</p> </li> <li> <code>time_unit</code>               (<code>TimeUnits</code>, default:                   <code>DefaultTimeUnit</code> )           \u2013            <p>The unit of time. Defaults to DefaultTimeUnit.</p> </li> <li> <code>axes_names</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The names of the axes. If None the canonical names are used. Defaults to None.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the image. Defaults to None.</p> </li> <li> <code>chunks</code>               (<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The chunk shape. If None the shape is used. Defaults to None.</p> </li> <li> <code>dtype</code>               (<code>str</code>, default:                   <code>'uint16'</code> )           \u2013            <p>The data type of the image. Defaults to \"uint16\".</p> </li> <li> <code>channel_labels</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The labels of the channels. Defaults to None.</p> </li> <li> <code>channel_wavelengths</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The wavelengths of the channels. Defaults to None.</p> </li> <li> <code>channel_colors</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The colors of the channels. Defaults to None.</p> </li> <li> <code>channel_active</code>               (<code>Sequence[bool] | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether the channels are active. Defaults to None.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to overwrite an existing image. Defaults to True.</p> </li> <li> <code>version</code>               (<code>NgffVersion</code>, default:                   <code>DefaultNgffVersion</code> )           \u2013            <p>The version of the OME-Zarr specification. Defaults to DefaultNgffVersion.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def create_empty_ome_zarr(\n    store: StoreOrGroup,\n    shape: Sequence[int],\n    xy_pixelsize: float,\n    z_spacing: float = 1.0,\n    time_spacing: float = 1.0,\n    levels: int | list[str] = 5,\n    xy_scaling_factor: float = 2,\n    z_scaling_factor: float = 1.0,\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n    axes_names: Sequence[str] | None = None,\n    name: str | None = None,\n    chunks: Sequence[int] | None = None,\n    dtype: str = \"uint16\",\n    channel_labels: list[str] | None = None,\n    channel_wavelengths: list[str] | None = None,\n    channel_colors: Sequence[str] | None = None,\n    channel_active: Sequence[bool] | None = None,\n    overwrite: bool = False,\n    version: NgffVersions = DefaultNgffVersion,\n) -&gt; OmeZarrContainer:\n    \"\"\"Create an empty OME-Zarr image with the given shape and metadata.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group to create the image in.\n        shape (Sequence[int]): The shape of the image.\n        xy_pixelsize (float): The pixel size in x and y dimensions.\n        z_spacing (float, optional): The spacing between z slices. Defaults to 1.0.\n        time_spacing (float, optional): The spacing between time points.\n            Defaults to 1.0.\n        levels (int | list[str], optional): The number of levels in the pyramid or a\n            list of level names. Defaults to 5.\n        xy_scaling_factor (float, optional): The down-scaling factor in x and y\n            dimensions. Defaults to 2.0.\n        z_scaling_factor (float, optional): The down-scaling factor in z dimension.\n            Defaults to 1.0.\n        space_unit (SpaceUnits, optional): The unit of space. Defaults to\n            DefaultSpaceUnit.\n        time_unit (TimeUnits, optional): The unit of time. Defaults to\n            DefaultTimeUnit.\n        axes_names (Sequence[str] | None, optional): The names of the axes.\n            If None the canonical names are used. Defaults to None.\n        name (str | None, optional): The name of the image. Defaults to None.\n        chunks (Sequence[int] | None, optional): The chunk shape. If None the shape\n            is used. Defaults to None.\n        dtype (str, optional): The data type of the image. Defaults to \"uint16\".\n        channel_labels (list[str] | None, optional): The labels of the channels.\n            Defaults to None.\n        channel_wavelengths (list[str] | None, optional): The wavelengths of the\n            channels. Defaults to None.\n        channel_colors (Sequence[str] | None, optional): The colors of the channels.\n            Defaults to None.\n        channel_active (Sequence[bool] | None, optional): Whether the channels are\n            active. Defaults to None.\n        overwrite (bool, optional): Whether to overwrite an existing image.\n            Defaults to True.\n        version (NgffVersion, optional): The version of the OME-Zarr specification.\n            Defaults to DefaultNgffVersion.\n    \"\"\"\n    handler = create_empty_image_container(\n        store=store,\n        shape=shape,\n        pixelsize=xy_pixelsize,\n        z_spacing=z_spacing,\n        time_spacing=time_spacing,\n        levels=levels,\n        yx_scaling_factor=xy_scaling_factor,\n        z_scaling_factor=z_scaling_factor,\n        space_unit=space_unit,\n        time_unit=time_unit,\n        axes_names=axes_names,\n        name=name,\n        chunks=chunks,\n        dtype=dtype,\n        overwrite=overwrite,\n        version=version,\n    )\n\n    ome_zarr = OmeZarrContainer(group_handler=handler)\n    ome_zarr.set_channel_meta(\n        labels=channel_labels,\n        wavelength_id=channel_wavelengths,\n        percentiles=None,\n        colors=channel_colors,\n        active=channel_active,\n    )\n    return ome_zarr\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.create_ome_zarr_from_array","title":"ngio.create_ome_zarr_from_array","text":"<pre><code>create_ome_zarr_from_array(\n    store: StoreOrGroup,\n    array: ndarray,\n    xy_pixelsize: float,\n    z_spacing: float = 1.0,\n    time_spacing: float = 1.0,\n    levels: int | list[str] = 5,\n    xy_scaling_factor: float = 2.0,\n    z_scaling_factor: float = 1.0,\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n    axes_names: Sequence[str] | None = None,\n    channel_labels: list[str] | None = None,\n    channel_wavelengths: list[str] | None = None,\n    percentiles: tuple[float, float] | None = (0.1, 99.9),\n    channel_colors: Sequence[str] | None = None,\n    channel_active: Sequence[bool] | None = None,\n    name: str | None = None,\n    chunks: Sequence[int] | None = None,\n    overwrite: bool = False,\n    version: NgffVersions = DefaultNgffVersion,\n) -&gt; OmeZarrContainer\n</code></pre> <p>Create an OME-Zarr image from a numpy array.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group to create the image in.</p> </li> <li> <code>array</code>               (<code>ndarray</code>)           \u2013            <p>The image data.</p> </li> <li> <code>xy_pixelsize</code>               (<code>float</code>)           \u2013            <p>The pixel size in x and y dimensions.</p> </li> <li> <code>z_spacing</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The spacing between z slices. Defaults to 1.0.</p> </li> <li> <code>time_spacing</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The spacing between time points. Defaults to 1.0.</p> </li> <li> <code>levels</code>               (<code>int | list[str]</code>, default:                   <code>5</code> )           \u2013            <p>The number of levels in the pyramid or a list of level names. Defaults to 5.</p> </li> <li> <code>xy_scaling_factor</code>               (<code>float</code>, default:                   <code>2.0</code> )           \u2013            <p>The down-scaling factor in x and y dimensions. Defaults to 2.0.</p> </li> <li> <code>z_scaling_factor</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The down-scaling factor in z dimension. Defaults to 1.0.</p> </li> <li> <code>space_unit</code>               (<code>SpaceUnits</code>, default:                   <code>DefaultSpaceUnit</code> )           \u2013            <p>The unit of space. Defaults to DefaultSpaceUnit.</p> </li> <li> <code>time_unit</code>               (<code>TimeUnits</code>, default:                   <code>DefaultTimeUnit</code> )           \u2013            <p>The unit of time. Defaults to DefaultTimeUnit.</p> </li> <li> <code>axes_names</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The names of the axes. If None the canonical names are used. Defaults to None.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the image. Defaults to None.</p> </li> <li> <code>chunks</code>               (<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The chunk shape. If None the shape is used. Defaults to None.</p> </li> <li> <code>channel_labels</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The labels of the channels. Defaults to None.</p> </li> <li> <code>channel_wavelengths</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The wavelengths of the channels. Defaults to None.</p> </li> <li> <code>percentiles</code>               (<code>tuple[float, float] | None</code>, default:                   <code>(0.1, 99.9)</code> )           \u2013            <p>The percentiles of the channels. Defaults to None.</p> </li> <li> <code>channel_colors</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The colors of the channels. Defaults to None.</p> </li> <li> <code>channel_active</code>               (<code>Sequence[bool] | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether the channels are active. Defaults to None.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to overwrite an existing image. Defaults to True.</p> </li> <li> <code>version</code>               (<code>str</code>, default:                   <code>DefaultNgffVersion</code> )           \u2013            <p>The version of the OME-Zarr specification. Defaults to DefaultNgffVersion.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def create_ome_zarr_from_array(\n    store: StoreOrGroup,\n    array: np.ndarray,\n    xy_pixelsize: float,\n    z_spacing: float = 1.0,\n    time_spacing: float = 1.0,\n    levels: int | list[str] = 5,\n    xy_scaling_factor: float = 2.0,\n    z_scaling_factor: float = 1.0,\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n    axes_names: Sequence[str] | None = None,\n    channel_labels: list[str] | None = None,\n    channel_wavelengths: list[str] | None = None,\n    percentiles: tuple[float, float] | None = (0.1, 99.9),\n    channel_colors: Sequence[str] | None = None,\n    channel_active: Sequence[bool] | None = None,\n    name: str | None = None,\n    chunks: Sequence[int] | None = None,\n    overwrite: bool = False,\n    version: NgffVersions = DefaultNgffVersion,\n) -&gt; OmeZarrContainer:\n    \"\"\"Create an OME-Zarr image from a numpy array.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group to create the image in.\n        array (np.ndarray): The image data.\n        xy_pixelsize (float): The pixel size in x and y dimensions.\n        z_spacing (float, optional): The spacing between z slices. Defaults to 1.0.\n        time_spacing (float, optional): The spacing between time points.\n            Defaults to 1.0.\n        levels (int | list[str], optional): The number of levels in the pyramid or a\n            list of level names. Defaults to 5.\n        xy_scaling_factor (float, optional): The down-scaling factor in x and y\n            dimensions. Defaults to 2.0.\n        z_scaling_factor (float, optional): The down-scaling factor in z dimension.\n            Defaults to 1.0.\n        space_unit (SpaceUnits, optional): The unit of space. Defaults to\n            DefaultSpaceUnit.\n        time_unit (TimeUnits, optional): The unit of time. Defaults to\n            DefaultTimeUnit.\n        axes_names (Sequence[str] | None, optional): The names of the axes.\n            If None the canonical names are used. Defaults to None.\n        name (str | None, optional): The name of the image. Defaults to None.\n        chunks (Sequence[int] | None, optional): The chunk shape. If None the shape\n            is used. Defaults to None.\n        channel_labels (list[str] | None, optional): The labels of the channels.\n            Defaults to None.\n        channel_wavelengths (list[str] | None, optional): The wavelengths of the\n            channels. Defaults to None.\n        percentiles (tuple[float, float] | None, optional): The percentiles of the\n            channels. Defaults to None.\n        channel_colors (Sequence[str] | None, optional): The colors of the channels.\n            Defaults to None.\n        channel_active (Sequence[bool] | None, optional): Whether the channels are\n            active. Defaults to None.\n        overwrite (bool, optional): Whether to overwrite an existing image.\n            Defaults to True.\n        version (str, optional): The version of the OME-Zarr specification.\n            Defaults to DefaultNgffVersion.\n    \"\"\"\n    handler = create_empty_image_container(\n        store=store,\n        shape=array.shape,\n        pixelsize=xy_pixelsize,\n        z_spacing=z_spacing,\n        time_spacing=time_spacing,\n        levels=levels,\n        yx_scaling_factor=xy_scaling_factor,\n        z_scaling_factor=z_scaling_factor,\n        space_unit=space_unit,\n        time_unit=time_unit,\n        axes_names=axes_names,\n        name=name,\n        chunks=chunks,\n        dtype=str(array.dtype),\n        overwrite=overwrite,\n        version=version,\n    )\n\n    ome_zarr = OmeZarrContainer(group_handler=handler)\n    image = ome_zarr.get_image()\n    image.set_array(array)\n    image.consolidate()\n    ome_zarr.set_channel_meta(\n        labels=channel_labels,\n        wavelength_id=channel_wavelengths,\n        percentiles=percentiles,\n        colors=channel_colors,\n        active=channel_active,\n    )\n    return ome_zarr\n</code></pre>"},{"location":"api/ome_zarr_container/#omezarrcontainer-class","title":"OmeZarrContainer Class","text":""},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer","title":"ngio.OmeZarrContainer","text":"<pre><code>OmeZarrContainer(\n    group_handler: ZarrGroupHandler,\n    table_container: TablesContainer | None = None,\n    label_container: LabelsContainer | None = None,\n    validate_paths: bool = False,\n)\n</code></pre> <p>This class is an object representation of an OME-Zarr image.</p> It provides methods to access <ul> <li>The multiscale image metadata</li> <li>To open images at different levels of resolution</li> <li>To access labels and tables associated with the image.</li> <li>To derive new images, labels, and add tables to the image.</li> <li>To modify the image metadata, such as axes units and channel metadata.</li> </ul> <p>Attributes:</p> <ul> <li> <code>images_container</code>               (<code>ImagesContainer</code>)           \u2013            <p>The container for the images.</p> </li> <li> <code>labels_container</code>               (<code>LabelsContainer</code>)           \u2013            <p>The container for the labels.</p> </li> <li> <code>tables_container</code>               (<code>TablesContainer</code>)           \u2013            <p>The container for the tables.</p> </li> </ul> <p>Initialize the OmeZarrContainer.</p> <p>Parameters:</p> <ul> <li> <code>group_handler</code>               (<code>ZarrGroupHandler</code>)           \u2013            <p>The Zarr group handler.</p> </li> <li> <code>table_container</code>               (<code>TablesContainer | None</code>, default:                   <code>None</code> )           \u2013            <p>The tables container.</p> </li> <li> <code>label_container</code>               (<code>LabelsContainer | None</code>, default:                   <code>None</code> )           \u2013            <p>The labels container.</p> </li> <li> <code>validate_paths</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to validate the paths of the image multiscale</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def __init__(\n    self,\n    group_handler: ZarrGroupHandler,\n    table_container: TablesContainer | None = None,\n    label_container: LabelsContainer | None = None,\n    validate_paths: bool = False,\n) -&gt; None:\n    \"\"\"Initialize the OmeZarrContainer.\n\n    Args:\n        group_handler (ZarrGroupHandler): The Zarr group handler.\n        table_container (TablesContainer | None): The tables container.\n        label_container (LabelsContainer | None): The labels container.\n        validate_paths (bool): Whether to validate the paths of the image multiscale\n    \"\"\"\n    self._group_handler = group_handler\n    self._images_container = ImagesContainer(self._group_handler)\n\n    self._labels_container = label_container\n    self._tables_container = table_container\n\n    if validate_paths:\n        for level_path in self._images_container.levels_paths:\n            self.get_image(path=level_path)\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.images_container","title":"images_container  <code>property</code>","text":"<pre><code>images_container: ImagesContainer\n</code></pre> <p>Return the images container.</p> <p>Returns:</p> <ul> <li> <code>ImagesContainer</code> (              <code>ImagesContainer</code> )          \u2013            <p>The images container.</p> </li> </ul>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.labels_container","title":"labels_container  <code>property</code>","text":"<pre><code>labels_container: LabelsContainer\n</code></pre> <p>Return the labels container.</p>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.tables_container","title":"tables_container  <code>property</code>","text":"<pre><code>tables_container: TablesContainer\n</code></pre> <p>Return the tables container.</p>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.image_meta","title":"image_meta  <code>property</code>","text":"<pre><code>image_meta: NgioImageMeta\n</code></pre> <p>Return the image metadata.</p>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.levels","title":"levels  <code>property</code>","text":"<pre><code>levels: int\n</code></pre> <p>Return the number of levels in the image.</p>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.levels_paths","title":"levels_paths  <code>property</code>","text":"<pre><code>levels_paths: list[str]\n</code></pre> <p>Return the paths of the levels in the image.</p>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.is_3d","title":"is_3d  <code>property</code>","text":"<pre><code>is_3d: bool\n</code></pre> <p>Return True if the image is 3D.</p>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.is_2d","title":"is_2d  <code>property</code>","text":"<pre><code>is_2d: bool\n</code></pre> <p>Return True if the image is 2D.</p>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.is_time_series","title":"is_time_series  <code>property</code>","text":"<pre><code>is_time_series: bool\n</code></pre> <p>Return True if the image is a time series.</p>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.is_2d_time_series","title":"is_2d_time_series  <code>property</code>","text":"<pre><code>is_2d_time_series: bool\n</code></pre> <p>Return True if the image is a 2D time series.</p>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.is_3d_time_series","title":"is_3d_time_series  <code>property</code>","text":"<pre><code>is_3d_time_series: bool\n</code></pre> <p>Return True if the image is a 3D time series.</p>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.is_multi_channels","title":"is_multi_channels  <code>property</code>","text":"<pre><code>is_multi_channels: bool\n</code></pre> <p>Return True if the image is multichannel.</p>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.space_unit","title":"space_unit  <code>property</code>","text":"<pre><code>space_unit: str | None\n</code></pre> <p>Return the space unit of the image.</p>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.time_unit","title":"time_unit  <code>property</code>","text":"<pre><code>time_unit: str | None\n</code></pre> <p>Return the time unit of the image.</p>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.channel_labels","title":"channel_labels  <code>property</code>","text":"<pre><code>channel_labels: list[str]\n</code></pre> <p>Return the channels of the image.</p>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.wavelength_ids","title":"wavelength_ids  <code>property</code>","text":"<pre><code>wavelength_ids: list[str | None]\n</code></pre> <p>Return the list of wavelength of the image.</p>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.num_channels","title":"num_channels  <code>property</code>","text":"<pre><code>num_channels: int\n</code></pre> <p>Return the number of channels.</p>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.get_channel_idx","title":"get_channel_idx","text":"<pre><code>get_channel_idx(\n    channel_label: str | None = None,\n    wavelength_id: str | None = None,\n) -&gt; int\n</code></pre> <p>Get the index of a channel by its label or wavelength ID.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_channel_idx(\n    self, channel_label: str | None = None, wavelength_id: str | None = None\n) -&gt; int:\n    \"\"\"Get the index of a channel by its label or wavelength ID.\"\"\"\n    image = self.get_image()\n    return image.channels_meta.get_channel_idx(\n        channel_label=channel_label, wavelength_id=wavelength_id\n    )\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.set_channel_meta","title":"set_channel_meta","text":"<pre><code>set_channel_meta(\n    labels: Sequence[str] | int | None = None,\n    wavelength_id: Sequence[str] | None = None,\n    percentiles: tuple[float, float] | None = None,\n    colors: Sequence[str] | None = None,\n    active: Sequence[bool] | None = None,\n    **omero_kwargs: dict,\n) -&gt; None\n</code></pre> <p>Create a ChannelsMeta object with the default unit.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def set_channel_meta(\n    self,\n    labels: Sequence[str] | int | None = None,\n    wavelength_id: Sequence[str] | None = None,\n    percentiles: tuple[float, float] | None = None,\n    colors: Sequence[str] | None = None,\n    active: Sequence[bool] | None = None,\n    **omero_kwargs: dict,\n) -&gt; None:\n    \"\"\"Create a ChannelsMeta object with the default unit.\"\"\"\n    self._images_container.set_channel_meta(\n        labels=labels,\n        wavelength_id=wavelength_id,\n        start=None,\n        end=None,\n        percentiles=percentiles,\n        colors=colors,\n        active=active,\n        **omero_kwargs,\n    )\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.set_channel_percentiles","title":"set_channel_percentiles","text":"<pre><code>set_channel_percentiles(\n    start_percentile: float = 0.1,\n    end_percentile: float = 99.9,\n) -&gt; None\n</code></pre> <p>Update the percentiles of the image.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def set_channel_percentiles(\n    self,\n    start_percentile: float = 0.1,\n    end_percentile: float = 99.9,\n) -&gt; None:\n    \"\"\"Update the percentiles of the image.\"\"\"\n    self._images_container.set_channel_percentiles(\n        start_percentile=start_percentile, end_percentile=end_percentile\n    )\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.set_axes_units","title":"set_axes_units","text":"<pre><code>set_axes_units(\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n    set_labels: bool = True,\n) -&gt; None\n</code></pre> <p>Set the units of the image.</p> <p>Parameters:</p> <ul> <li> <code>space_unit</code>               (<code>SpaceUnits</code>, default:                   <code>DefaultSpaceUnit</code> )           \u2013            <p>The unit of space.</p> </li> <li> <code>time_unit</code>               (<code>TimeUnits</code>, default:                   <code>DefaultTimeUnit</code> )           \u2013            <p>The unit of time.</p> </li> <li> <code>set_labels</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to set the units for the labels as well.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def set_axes_units(\n    self,\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n    set_labels: bool = True,\n) -&gt; None:\n    \"\"\"Set the units of the image.\n\n    Args:\n        space_unit (SpaceUnits): The unit of space.\n        time_unit (TimeUnits): The unit of time.\n        set_labels (bool): Whether to set the units for the labels as well.\n    \"\"\"\n    self._images_container.set_axes_unit(space_unit=space_unit, time_unit=time_unit)\n    if not set_labels:\n        return\n    for label_name in self.list_labels():\n        label = self.get_label(label_name)\n        label.set_axes_unit(space_unit=space_unit, time_unit=time_unit)\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.get_image","title":"get_image","text":"<pre><code>get_image(\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; Image\n</code></pre> <p>Get an image at a specific level.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the image in the ome_zarr file.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the image.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Only used if the pixel size is provided. If True, the pixel size must match the image pixel size exactly. If False, the closest pixel size level will be returned.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_image(\n    self,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; Image:\n    \"\"\"Get an image at a specific level.\n\n    Args:\n        path (str | None): The path to the image in the ome_zarr file.\n        pixel_size (PixelSize | None): The pixel size of the image.\n        strict (bool): Only used if the pixel size is provided. If True, the\n            pixel size must match the image pixel size exactly. If False, the\n            closest pixel size level will be returned.\n\n    \"\"\"\n    return self._images_container.get(\n        path=path, pixel_size=pixel_size, strict=strict\n    )\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.get_masked_image","title":"get_masked_image","text":"<pre><code>get_masked_image(\n    masking_label_name: str | None = None,\n    masking_table_name: str | None = None,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; MaskedImage\n</code></pre> <p>Get a masked image at a specific level.</p> <p>Parameters:</p> <ul> <li> <code>masking_label_name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the masking label to use. If None, the masking table must be provided.</p> </li> <li> <code>masking_table_name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the masking table to use. If None, the masking label must be provided.</p> </li> <li> <code>path</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the image in the ome_zarr file. If None, the first level will be used.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the image. This is only used if path is None.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Only used if the pixel size is provided. If True, the pixel size must match the image pixel size exactly. If False, the closest pixel size level will be returned.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_masked_image(\n    self,\n    masking_label_name: str | None = None,\n    masking_table_name: str | None = None,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; MaskedImage:\n    \"\"\"Get a masked image at a specific level.\n\n    Args:\n        masking_label_name (str | None): The name of the masking label to use.\n            If None, the masking table must be provided.\n        masking_table_name (str | None): The name of the masking table to use.\n            If None, the masking label must be provided.\n        path (str | None): The path to the image in the ome_zarr file.\n            If None, the first level will be used.\n        pixel_size (PixelSize | None): The pixel size of the image.\n            This is only used if path is None.\n        strict (bool): Only used if the pixel size is provided. If True, the\n            pixel size must match the image pixel size exactly. If False, the\n            closest pixel size level will be returned.\n    \"\"\"\n    image = self.get_image(path=path, pixel_size=pixel_size, strict=strict)\n    masking_label, masking_table = self._find_matching_masking_label(\n        masking_label_name=masking_label_name,\n        masking_table_name=masking_table_name,\n        pixel_size=pixel_size,\n    )\n    return MaskedImage(\n        group_handler=image._group_handler,\n        path=image.path,\n        meta_handler=image.meta_handler,\n        label=masking_label,\n        masking_roi_table=masking_table,\n    )\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.derive_image","title":"derive_image","text":"<pre><code>derive_image(\n    store: StoreOrGroup,\n    ref_path: str | None = None,\n    shape: Sequence[int] | None = None,\n    labels: Sequence[str] | None = None,\n    pixel_size: PixelSize | None = None,\n    axes_names: Sequence[str] | None = None,\n    name: str | None = None,\n    chunks: Sequence[int] | None = None,\n    dtype: str | None = None,\n    copy_labels: bool = False,\n    copy_tables: bool = False,\n    overwrite: bool = False,\n) -&gt; OmeZarrContainer\n</code></pre> <p>Create an empty OME-Zarr container from an existing image.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group to create the image in.</p> </li> <li> <code>ref_path</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the reference image in the image container.</p> </li> <li> <code>shape</code>               (<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The shape of the new image.</p> </li> <li> <code>labels</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The labels of the new image.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the new image.</p> </li> <li> <code>axes_names</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The axes names of the new image.</p> </li> <li> <code>chunks</code>               (<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The chunk shape of the new image.</p> </li> <li> <code>dtype</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The data type of the new image.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the new image.</p> </li> <li> <code>copy_labels</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to copy the labels from the reference image.</p> </li> <li> <code>copy_tables</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to copy the tables from the reference image.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to overwrite an existing image.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OmeZarrContainer</code> (              <code>OmeZarrContainer</code> )          \u2013            <p>The new image container.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def derive_image(\n    self,\n    store: StoreOrGroup,\n    ref_path: str | None = None,\n    shape: Sequence[int] | None = None,\n    labels: Sequence[str] | None = None,\n    pixel_size: PixelSize | None = None,\n    axes_names: Sequence[str] | None = None,\n    name: str | None = None,\n    chunks: Sequence[int] | None = None,\n    dtype: str | None = None,\n    copy_labels: bool = False,\n    copy_tables: bool = False,\n    overwrite: bool = False,\n) -&gt; \"OmeZarrContainer\":\n    \"\"\"Create an empty OME-Zarr container from an existing image.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group to create the image in.\n        ref_path (str | None): The path to the reference image in\n            the image container.\n        shape (Sequence[int] | None): The shape of the new image.\n        labels (Sequence[str] | None): The labels of the new image.\n        pixel_size (PixelSize | None): The pixel size of the new image.\n        axes_names (Sequence[str] | None): The axes names of the new image.\n        chunks (Sequence[int] | None): The chunk shape of the new image.\n        dtype (str | None): The data type of the new image.\n        name (str | None): The name of the new image.\n        copy_labels (bool): Whether to copy the labels from the reference image.\n        copy_tables (bool): Whether to copy the tables from the reference image.\n        overwrite (bool): Whether to overwrite an existing image.\n\n    Returns:\n        OmeZarrContainer: The new image container.\n\n    \"\"\"\n    _ = self._images_container.derive(\n        store=store,\n        ref_path=ref_path,\n        shape=shape,\n        labels=labels,\n        pixel_size=pixel_size,\n        axes_names=axes_names,\n        name=name,\n        chunks=chunks,\n        dtype=dtype,\n        overwrite=overwrite,\n    )\n\n    handler = ZarrGroupHandler(\n        store, cache=self._group_handler.use_cache, mode=self._group_handler.mode\n    )\n\n    new_ome_zarr = OmeZarrContainer(\n        group_handler=handler,\n        validate_paths=False,\n    )\n\n    if copy_labels:\n        self.labels_container._group_handler.copy_handler(\n            new_ome_zarr.labels_container._group_handler\n        )\n\n    if copy_tables:\n        self.tables_container._group_handler.copy_handler(\n            new_ome_zarr.tables_container._group_handler\n        )\n    return new_ome_zarr\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.list_tables","title":"list_tables","text":"<pre><code>list_tables(\n    filter_types: TypedTable | str | None = None,\n) -&gt; list[str]\n</code></pre> <p>List all tables in the image.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def list_tables(self, filter_types: TypedTable | str | None = None) -&gt; list[str]:\n    \"\"\"List all tables in the image.\"\"\"\n    table_container = self._get_tables_container()\n    if table_container is None:\n        return []\n\n    return table_container.list(\n        filter_types=filter_types,\n    )\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.list_roi_tables","title":"list_roi_tables","text":"<pre><code>list_roi_tables() -&gt; list[str]\n</code></pre> <p>List all ROI tables in the image.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def list_roi_tables(self) -&gt; list[str]:\n    \"\"\"List all ROI tables in the image.\"\"\"\n    masking_roi = self.tables_container.list(\n        filter_types=\"masking_roi_table\",\n    )\n    roi = self.tables_container.list(\n        filter_types=\"roi_table\",\n    )\n    return masking_roi + roi\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.get_roi_table","title":"get_roi_table","text":"<pre><code>get_roi_table(name: str) -&gt; RoiTable\n</code></pre> <p>Get a ROI table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_roi_table(self, name: str) -&gt; RoiTable:\n    \"\"\"Get a ROI table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, RoiTable):\n        raise NgioValueError(f\"Table {name} is not a ROI table. Got {type(table)}\")\n    return table\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.get_masking_roi_table","title":"get_masking_roi_table","text":"<pre><code>get_masking_roi_table(name: str) -&gt; MaskingRoiTable\n</code></pre> <p>Get a masking ROI table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_masking_roi_table(self, name: str) -&gt; MaskingRoiTable:\n    \"\"\"Get a masking ROI table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, MaskingRoiTable):\n        raise NgioValueError(\n            f\"Table {name} is not a masking ROI table. Got {type(table)}\"\n        )\n    return table\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.get_feature_table","title":"get_feature_table","text":"<pre><code>get_feature_table(name: str) -&gt; FeatureTable\n</code></pre> <p>Get a feature table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_feature_table(self, name: str) -&gt; FeatureTable:\n    \"\"\"Get a feature table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, FeatureTable):\n        raise NgioValueError(\n            f\"Table {name} is not a feature table. Got {type(table)}\"\n        )\n    return table\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.get_generic_roi_table","title":"get_generic_roi_table","text":"<pre><code>get_generic_roi_table(name: str) -&gt; GenericRoiTable\n</code></pre> <p>Get a generic ROI table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_generic_roi_table(self, name: str) -&gt; GenericRoiTable:\n    \"\"\"Get a generic ROI table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, GenericRoiTable):\n        raise NgioValueError(\n            f\"Table {name} is not a generic ROI table. Got {type(table)}\"\n        )\n    return table\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.get_condition_table","title":"get_condition_table","text":"<pre><code>get_condition_table(name: str) -&gt; ConditionTable\n</code></pre> <p>Get a condition table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_condition_table(self, name: str) -&gt; ConditionTable:\n    \"\"\"Get a condition table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, ConditionTable):\n        raise NgioValueError(\n            f\"Table {name} is not a condition table. Got {type(table)}\"\n        )\n    return table\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.get_table","title":"get_table","text":"<pre><code>get_table(\n    name: str, check_type: TypedTable | None = None\n) -&gt; Table\n</code></pre> <p>Get a table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> <li> <code>check_type</code>               (<code>TypedTable | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Please use 'get_table_as' instead, or one of the type specific get_*table() methods.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_table(self, name: str, check_type: TypedTable | None = None) -&gt; Table:\n    \"\"\"Get a table from the image.\n\n    Args:\n        name (str): The name of the table.\n        check_type (TypedTable | None): Deprecated. Please use\n            'get_table_as' instead, or one of the type specific\n            get_*table() methods.\n\n    \"\"\"\n    if check_type is not None:\n        warnings.warn(\n            \"The 'check_type' argument is deprecated, and will be removed in \"\n            \"ngio=0.3. Use 'get_table_as' instead or one of the \"\n            \"type specific get_*table() methods.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n    return self.tables_container.get(name=name, strict=False)\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.get_table_as","title":"get_table_as","text":"<pre><code>get_table_as(\n    name: str,\n    table_cls: type[TableType],\n    backend: TableBackend | None = None,\n) -&gt; TableType\n</code></pre> <p>Get a table from the image as a specific type.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> <li> <code>table_cls</code>               (<code>type[TableType]</code>)           \u2013            <p>The type of the table.</p> </li> <li> <code>backend</code>               (<code>TableBackend | None</code>, default:                   <code>None</code> )           \u2013            <p>The backend to use. If None, the default backend is used.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_table_as(\n    self,\n    name: str,\n    table_cls: type[TableType],\n    backend: TableBackend | None = None,\n) -&gt; TableType:\n    \"\"\"Get a table from the image as a specific type.\n\n    Args:\n        name (str): The name of the table.\n        table_cls (type[TableType]): The type of the table.\n        backend (TableBackend | None): The backend to use. If None,\n            the default backend is used.\n    \"\"\"\n    return self.tables_container.get_as(\n        name=name,\n        table_cls=table_cls,\n        backend=backend,\n    )\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.build_image_roi_table","title":"build_image_roi_table","text":"<pre><code>build_image_roi_table(\n    name: str | None = \"image\",\n) -&gt; RoiTable\n</code></pre> <p>Compute the ROI table for an image.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def build_image_roi_table(self, name: str | None = \"image\") -&gt; RoiTable:\n    \"\"\"Compute the ROI table for an image.\"\"\"\n    return self.get_image().build_image_roi_table(name=name)\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.build_masking_roi_table","title":"build_masking_roi_table","text":"<pre><code>build_masking_roi_table(label: str) -&gt; MaskingRoiTable\n</code></pre> <p>Compute the masking ROI table for a label.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def build_masking_roi_table(self, label: str) -&gt; MaskingRoiTable:\n    \"\"\"Compute the masking ROI table for a label.\"\"\"\n    return self.get_label(label).build_masking_roi_table()\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.add_table","title":"add_table","text":"<pre><code>add_table(\n    name: str,\n    table: Table,\n    backend: TableBackend = DefaultTableBackend,\n    overwrite: bool = False,\n) -&gt; None\n</code></pre> <p>Add a table to the image.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def add_table(\n    self,\n    name: str,\n    table: Table,\n    backend: TableBackend = DefaultTableBackend,\n    overwrite: bool = False,\n) -&gt; None:\n    \"\"\"Add a table to the image.\"\"\"\n    self.tables_container.add(\n        name=name, table=table, backend=backend, overwrite=overwrite\n    )\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.list_labels","title":"list_labels","text":"<pre><code>list_labels() -&gt; list[str]\n</code></pre> <p>List all labels in the image.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def list_labels(self) -&gt; list[str]:\n    \"\"\"List all labels in the image.\"\"\"\n    label_container = self._get_labels_container()\n    if label_container is None:\n        return []\n    return label_container.list()\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.get_label","title":"get_label","text":"<pre><code>get_label(\n    name: str,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; Label\n</code></pre> <p>Get a label from the group.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the label.</p> </li> <li> <code>path</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the image in the ome_zarr file.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the image.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Only used if the pixel size is provided. If True, the pixel size must match the image pixel size exactly. If False, the closest pixel size level will be returned.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_label(\n    self,\n    name: str,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; Label:\n    \"\"\"Get a label from the group.\n\n    Args:\n        name (str): The name of the label.\n        path (str | None): The path to the image in the ome_zarr file.\n        pixel_size (PixelSize | None): The pixel size of the image.\n        strict (bool): Only used if the pixel size is provided. If True, the\n            pixel size must match the image pixel size exactly. If False, the\n            closest pixel size level will be returned.\n    \"\"\"\n    return self.labels_container.get(\n        name=name, path=path, pixel_size=pixel_size, strict=strict\n    )\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.get_masked_label","title":"get_masked_label","text":"<pre><code>get_masked_label(\n    label_name: str,\n    masking_label_name: str | None = None,\n    masking_table_name: str | None = None,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; MaskedLabel\n</code></pre> <p>Get a masked image at a specific level.</p> <p>Parameters:</p> <ul> <li> <code>label_name</code>               (<code>str</code>)           \u2013            <p>The name of the label.</p> </li> <li> <code>masking_label_name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the masking label.</p> </li> <li> <code>masking_table_name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the masking table.</p> </li> <li> <code>path</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the image in the ome_zarr file.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the image.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Only used if the pixel size is provided. If True, the pixel size must match the image pixel size exactly. If False, the closest pixel size level will be returned.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_masked_label(\n    self,\n    label_name: str,\n    masking_label_name: str | None = None,\n    masking_table_name: str | None = None,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; MaskedLabel:\n    \"\"\"Get a masked image at a specific level.\n\n    Args:\n        label_name (str): The name of the label.\n        masking_label_name (str | None): The name of the masking label.\n        masking_table_name (str | None): The name of the masking table.\n        path (str | None): The path to the image in the ome_zarr file.\n        pixel_size (PixelSize | None): The pixel size of the image.\n        strict (bool): Only used if the pixel size is provided. If True, the\n            pixel size must match the image pixel size exactly. If False, the\n            closest pixel size level will be returned.\n    \"\"\"\n    label = self.get_label(\n        name=label_name, path=path, pixel_size=pixel_size, strict=strict\n    )\n    masking_label, masking_table = self._find_matching_masking_label(\n        masking_label_name=masking_label_name,\n        masking_table_name=masking_table_name,\n        pixel_size=pixel_size,\n    )\n    return MaskedLabel(\n        group_handler=label._group_handler,\n        path=label.path,\n        meta_handler=label.meta_handler,\n        label=masking_label,\n        masking_roi_table=masking_table,\n    )\n</code></pre>"},{"location":"api/ome_zarr_container/#ngio.OmeZarrContainer.derive_label","title":"derive_label","text":"<pre><code>derive_label(\n    name: str,\n    ref_image: Image | Label | None = None,\n    shape: Sequence[int] | None = None,\n    pixel_size: PixelSize | None = None,\n    axes_names: Sequence[str] | None = None,\n    chunks: Sequence[int] | None = None,\n    dtype: str = \"uint32\",\n    overwrite: bool = False,\n) -&gt; Label\n</code></pre> <p>Create an empty OME-Zarr label from a reference image.</p> <p>And add the label to the /labels group.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the new image.</p> </li> <li> <code>ref_image</code>               (<code>Image | Label | None</code>, default:                   <code>None</code> )           \u2013            <p>A reference image that will be used to create the new image.</p> </li> <li> <code>shape</code>               (<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The shape of the new image.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the new image.</p> </li> <li> <code>axes_names</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The axes names of the new image. For labels, the channel axis is not allowed.</p> </li> <li> <code>chunks</code>               (<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The chunk shape of the new image.</p> </li> <li> <code>dtype</code>               (<code>str</code>, default:                   <code>'uint32'</code> )           \u2013            <p>The data type of the new label.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to overwrite an existing image.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Label</code> (              <code>Label</code> )          \u2013            <p>The new label.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def derive_label(\n    self,\n    name: str,\n    ref_image: Image | Label | None = None,\n    shape: Sequence[int] | None = None,\n    pixel_size: PixelSize | None = None,\n    axes_names: Sequence[str] | None = None,\n    chunks: Sequence[int] | None = None,\n    dtype: str = \"uint32\",\n    overwrite: bool = False,\n) -&gt; \"Label\":\n    \"\"\"Create an empty OME-Zarr label from a reference image.\n\n    And add the label to the /labels group.\n\n    Args:\n        name (str): The name of the new image.\n        ref_image (Image | Label | None): A reference image that will be used\n            to create the new image.\n        shape (Sequence[int] | None): The shape of the new image.\n        pixel_size (PixelSize | None): The pixel size of the new image.\n        axes_names (Sequence[str] | None): The axes names of the new image.\n            For labels, the channel axis is not allowed.\n        chunks (Sequence[int] | None): The chunk shape of the new image.\n        dtype (str): The data type of the new label.\n        overwrite (bool): Whether to overwrite an existing image.\n\n    Returns:\n        Label: The new label.\n\n    \"\"\"\n    if ref_image is None:\n        ref_image = self.get_image()\n    return self.labels_container.derive(\n        name=name,\n        ref_image=ref_image,\n        shape=shape,\n        pixel_size=pixel_size,\n        axes_names=axes_names,\n        chunks=chunks,\n        dtype=dtype,\n        overwrite=overwrite,\n    )\n</code></pre>"},{"location":"api/tables/","title":"Ngio Tables API Documentation","text":""},{"location":"api/ngio/common/","title":"ngio.common API documentation","text":""},{"location":"api/ngio/common/#ngio.common","title":"ngio.common","text":"<p>Common classes and functions that are used across the package.</p>"},{"location":"api/ngio/common/#ngio.common.InterpolationOrder","title":"InterpolationOrder  <code>module-attribute</code>","text":"<pre><code>InterpolationOrder = Literal['nearest', 'linear', 'cubic']\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Dimensions","title":"Dimensions","text":"<pre><code>Dimensions(\n    shape: tuple[int, ...], axes_handler: AxesHandler\n)\n</code></pre> <p>Dimension metadata Handling Class.</p> <p>This class is used to handle and manipulate dimension metadata. It provides methods to access and validate dimension information, such as shape, axes, and properties like is_2d, is_3d, is_time_series, etc.</p> <p>Create a Dimension object from a Zarr array.</p> <p>Parameters:</p> <ul> <li> <code>shape</code>               (<code>tuple[int, ...]</code>)           \u2013            <p>The shape of the Zarr array.</p> </li> <li> <code>axes_handler</code>               (<code>AxesHandler</code>)           \u2013            <p>The axes handler object.</p> </li> </ul> Source code in <code>ngio/common/_dimensions.py</code> <pre><code>def __init__(\n    self,\n    shape: tuple[int, ...],\n    axes_handler: AxesHandler,\n) -&gt; None:\n    \"\"\"Create a Dimension object from a Zarr array.\n\n    Args:\n        shape: The shape of the Zarr array.\n        axes_handler: The axes handler object.\n    \"\"\"\n    self._shape = shape\n    self._axes_handler = axes_handler\n\n    if len(self._shape) != len(self._axes_handler.axes):\n        raise NgioValueError(\n            \"The number of dimensions must match the number of axes. \"\n            f\"Expected Axis {self._axes_handler.axes_names} but got shape \"\n            f\"{self._shape}.\"\n        )\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Dimensions.axes_handler","title":"axes_handler  <code>property</code>","text":"<pre><code>axes_handler: AxesHandler\n</code></pre> <p>Return the axes handler object.</p>"},{"location":"api/ngio/common/#ngio.common.Dimensions.shape","title":"shape  <code>property</code>","text":"<pre><code>shape: tuple[int, ...]\n</code></pre> <p>Return the shape as a tuple.</p>"},{"location":"api/ngio/common/#ngio.common.Dimensions.axes","title":"axes  <code>property</code>","text":"<pre><code>axes: tuple[str, ...]\n</code></pre> <p>Return the axes as a tuple of strings.</p>"},{"location":"api/ngio/common/#ngio.common.Dimensions.is_time_series","title":"is_time_series  <code>property</code>","text":"<pre><code>is_time_series: bool\n</code></pre> <p>Return whether the data is a time series.</p>"},{"location":"api/ngio/common/#ngio.common.Dimensions.is_2d","title":"is_2d  <code>property</code>","text":"<pre><code>is_2d: bool\n</code></pre> <p>Return whether the data is 2D.</p>"},{"location":"api/ngio/common/#ngio.common.Dimensions.is_2d_time_series","title":"is_2d_time_series  <code>property</code>","text":"<pre><code>is_2d_time_series: bool\n</code></pre> <p>Return whether the data is a 2D time series.</p>"},{"location":"api/ngio/common/#ngio.common.Dimensions.is_3d","title":"is_3d  <code>property</code>","text":"<pre><code>is_3d: bool\n</code></pre> <p>Return whether the data is 3D.</p>"},{"location":"api/ngio/common/#ngio.common.Dimensions.is_3d_time_series","title":"is_3d_time_series  <code>property</code>","text":"<pre><code>is_3d_time_series: bool\n</code></pre> <p>Return whether the data is a 3D time series.</p>"},{"location":"api/ngio/common/#ngio.common.Dimensions.is_multi_channels","title":"is_multi_channels  <code>property</code>","text":"<pre><code>is_multi_channels: bool\n</code></pre> <p>Return whether the data has multiple channels.</p>"},{"location":"api/ngio/common/#ngio.common.Dimensions.default_init","title":"default_init  <code>classmethod</code>","text":"<pre><code>default_init(\n    shape: tuple[int, ...],\n    axes_names: Sequence[str],\n    space_units: SpaceUnits | str | None = DefaultSpaceUnit,\n    time_units: TimeUnits | str | None = DefaultTimeUnit,\n    axes_setup: AxesSetup | None = None,\n    allow_non_canonical_axes: bool = False,\n    strict_canonical_order: bool = False,\n) -&gt; Dimensions\n</code></pre> <p>Create a Dimension object from a shape and axes names.</p> Source code in <code>ngio/common/_dimensions.py</code> <pre><code>@classmethod\ndef default_init(\n    cls,\n    shape: tuple[int, ...],\n    axes_names: Sequence[str],\n    space_units: SpaceUnits | str | None = DefaultSpaceUnit,\n    time_units: TimeUnits | str | None = DefaultTimeUnit,\n    # user defined args\n    axes_setup: AxesSetup | None = None,\n    allow_non_canonical_axes: bool = False,\n    strict_canonical_order: bool = False,\n) -&gt; \"Dimensions\":\n    \"\"\"Create a Dimension object from a shape and axes names.\"\"\"\n    axes_handler = build_canonical_axes_handler(\n        axes_names=axes_names,\n        space_units=space_units,\n        time_units=time_units,\n        axes_setup=axes_setup,\n        allow_non_canonical_axes=allow_non_canonical_axes,\n        strict_canonical_order=strict_canonical_order,\n    )\n    return cls(shape=shape, axes_handler=axes_handler)\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Dimensions.get","title":"get","text":"<pre><code>get(axis_name: str, default: None = None) -&gt; int | None\n</code></pre><pre><code>get(axis_name: str, default: int) -&gt; int\n</code></pre> <pre><code>get(\n    axis_name: str, default: int | None = None\n) -&gt; int | None\n</code></pre> <p>Return the dimension of the given axis name.</p> <p>Parameters:</p> <ul> <li> <code>axis_name</code>               (<code>str</code>)           \u2013            <p>The name of the axis (either canonical or non-canonical).</p> </li> <li> <code>default</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The default value to return if the axis does not exist.</p> </li> </ul> Source code in <code>ngio/common/_dimensions.py</code> <pre><code>def get(self, axis_name: str, default: int | None = None) -&gt; int | None:\n    \"\"\"Return the dimension of the given axis name.\n\n    Args:\n        axis_name: The name of the axis (either canonical or non-canonical).\n        default: The default value to return if the axis does not exist.\n    \"\"\"\n    index = self.axes_handler.get_index(axis_name)\n    if index is None:\n        return default\n    return self._shape[index]\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Dimensions.get_index","title":"get_index","text":"<pre><code>get_index(axis_name: str) -&gt; int | None\n</code></pre> <p>Return the index of the given axis name.</p> <p>Parameters:</p> <ul> <li> <code>axis_name</code>               (<code>str</code>)           \u2013            <p>The name of the axis (either canonical or non-canonical).</p> </li> </ul> Source code in <code>ngio/common/_dimensions.py</code> <pre><code>def get_index(self, axis_name: str) -&gt; int | None:\n    \"\"\"Return the index of the given axis name.\n\n    Args:\n        axis_name: The name of the axis (either canonical or non-canonical).\n    \"\"\"\n    return self.axes_handler.get_index(axis_name)\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Dimensions.get_pixel_size","title":"get_pixel_size","text":"<pre><code>get_pixel_size(axis_name: str) -&gt; float | None\n</code></pre> <p>Return the pixel size of the given axis name.</p> <p>Parameters:</p> <ul> <li> <code>axis_name</code>               (<code>str</code>)           \u2013            <p>The name of the axis (either canonical or non-canonical).</p> </li> </ul> Source code in <code>ngio/common/_dimensions.py</code> <pre><code>def get_pixel_size(self, axis_name: str) -&gt; float | None:\n    \"\"\"Return the pixel size of the given axis name.\n\n    Args:\n        axis_name: The name of the axis (either canonical or non-canonical).\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Dimensions.has_axis","title":"has_axis","text":"<pre><code>has_axis(axis_name: str) -&gt; bool\n</code></pre> <p>Return whether the axis exists.</p> Source code in <code>ngio/common/_dimensions.py</code> <pre><code>def has_axis(self, axis_name: str) -&gt; bool:\n    \"\"\"Return whether the axis exists.\"\"\"\n    index = self.axes_handler.get_index(axis_name)\n    if index is None:\n        return False\n    return True\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Dimensions.assert_axes_match","title":"assert_axes_match","text":"<pre><code>assert_axes_match(other: Dimensions) -&gt; None\n</code></pre> <p>Check if two Dimensions objects have the same axes.</p> <p>Besides the channel axis (which is a special case), all axes must be present in both Dimensions objects.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>Dimensions</code>)           \u2013            <p>The other dimensions object to compare against.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NgioValueError</code>             \u2013            <p>If the axes do not match.</p> </li> </ul> Source code in <code>ngio/common/_dimensions.py</code> <pre><code>def assert_axes_match(self, other: \"Dimensions\") -&gt; None:\n    \"\"\"Check if two Dimensions objects have the same axes.\n\n    Besides the channel axis (which is a special case), all axes must be\n    present in both Dimensions objects.\n\n    Args:\n        other (Dimensions): The other dimensions object to compare against.\n\n    Raises:\n        NgioValueError: If the axes do not match.\n    \"\"\"\n    for s_axis in self.axes_handler.axes:\n        if s_axis.axis_type == \"channel\":\n            continue\n        o_axis = other.axes_handler.get_axis(s_axis.name)\n        if o_axis is None:\n            raise NgioValueError(\n                f\"Axes do not match. The axis {s_axis.name} \"\n                f\"is not present in either dimensions.\"\n            )\n    # Check for axes present in the other dimensions but not in this one\n    for o_axis in other.axes_handler.axes:\n        if o_axis.axis_type == \"channel\":\n            continue\n        s_axis = self.axes_handler.get_axis(o_axis.name)\n        if s_axis is None:\n            raise NgioValueError(\n                f\"Axes do not match. The axis {o_axis.name} \"\n                f\"is not present in either dimensions.\"\n            )\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Dimensions.assert_dimensions_match","title":"assert_dimensions_match","text":"<pre><code>assert_dimensions_match(\n    other: Dimensions, allow_singleton: bool = False\n) -&gt; None\n</code></pre> <p>Check if two Dimensions objects have the same axes and dimensions.</p> <p>Besides the channel axis, all axes must have the same dimension in both images.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>Dimensions</code>)           \u2013            <p>The other dimensions object to compare against.</p> </li> <li> <code>allow_singleton</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to allow singleton dimensions to be different. For example, if the input image has shape (5, 100, 100) and the label has shape (1, 100, 100).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NgioValueError</code>             \u2013            <p>If the dimensions do not match.</p> </li> </ul> Source code in <code>ngio/common/_dimensions.py</code> <pre><code>def assert_dimensions_match(\n    self, other: \"Dimensions\", allow_singleton: bool = False\n) -&gt; None:\n    \"\"\"Check if two Dimensions objects have the same axes and dimensions.\n\n    Besides the channel axis, all axes must have the same dimension in\n    both images.\n\n    Args:\n        other (Dimensions): The other dimensions object to compare against.\n        allow_singleton (bool): Whether to allow singleton dimensions to be\n            different. For example, if the input image has shape\n            (5, 100, 100) and the label has shape (1, 100, 100).\n\n    Raises:\n        NgioValueError: If the dimensions do not match.\n    \"\"\"\n    self.assert_axes_match(other)\n    for s_axis in self.axes_handler.axes:\n        if s_axis.axis_type == \"channel\":\n            continue\n        o_axis = other.axes_handler.get_axis(s_axis.name)\n        assert o_axis is not None  # already checked in assert_axes_match\n\n        i_dim = self.get(s_axis.name, default=1)\n        o_dim = other.get(o_axis.name, default=1)\n\n        if i_dim != o_dim:\n            if allow_singleton and (i_dim == 1 or o_dim == 1):\n                continue\n            raise NgioValueError(\n                f\"Dimensions do not match for axis \"\n                f\"{s_axis.name}. Got {i_dim} and {o_dim}.\"\n            )\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Roi","title":"Roi","text":"<p>               Bases: <code>GenericRoi</code></p>"},{"location":"api/ngio/common/#ngio.common.Roi.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str | None\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Roi.z","title":"z  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>z: float | None = None\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Roi.t","title":"t  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>t: float | None = None\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Roi.x_length","title":"x_length  <code>instance-attribute</code>","text":"<pre><code>x_length: float\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Roi.y_length","title":"y_length  <code>instance-attribute</code>","text":"<pre><code>y_length: float\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Roi.z_length","title":"z_length  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>z_length: float | None = None\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Roi.t_length","title":"t_length  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>t_length: float | None = None\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Roi.label","title":"label  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>label: int | None = None\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Roi.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(extra='allow')\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Roi.x","title":"x  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>x: float = 0.0\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Roi.y","title":"y  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>y: float = 0.0\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Roi.unit","title":"unit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>unit: SpaceUnits | str | None = DefaultSpaceUnit\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Roi.intersection","title":"intersection","text":"<pre><code>intersection(other: GenericRoi) -&gt; GenericRoi | None\n</code></pre> <p>Calculate the intersection of this ROI with another ROI.</p> Source code in <code>ngio/common/_roi.py</code> <pre><code>def intersection(self, other: \"GenericRoi\") -&gt; \"GenericRoi | None\":\n    \"\"\"Calculate the intersection of this ROI with another ROI.\"\"\"\n    return roi_intersection(self, other)\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Roi.get_name","title":"get_name","text":"<pre><code>get_name() -&gt; str\n</code></pre> <p>Get the name of the ROI, or a default if not set.</p> Source code in <code>ngio/common/_roi.py</code> <pre><code>def get_name(self) -&gt; str:\n    \"\"\"Get the name of the ROI, or a default if not set.\"\"\"\n    if self.name is not None:\n        return self.name\n    return self._nice_str()\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Roi.to_roi_pixels","title":"to_roi_pixels","text":"<pre><code>to_roi_pixels(\n    pixel_size: PixelSize,\n    dimensions: Dimensions | None = None,\n) -&gt; RoiPixels\n</code></pre> <p>Convert to raster coordinates.</p> Source code in <code>ngio/common/_roi.py</code> <pre><code>def to_roi_pixels(\n    self, pixel_size: PixelSize, dimensions: Dimensions | None = None\n) -&gt; \"RoiPixels\":\n    \"\"\"Convert to raster coordinates.\"\"\"\n    if dimensions is None:\n        _dimensions = BaseDimensions()\n    else:\n        _dimensions = BaseDimensions(\n            dim_x=dimensions.get(\"x\"),\n            dim_y=dimensions.get(\"y\"),\n            dim_z=dimensions.get(\"z\"),\n            dim_t=dimensions.get(\"t\"),\n        )\n\n    x, x_length = _to_raster(self.x, self.x_length, pixel_size.x)\n    y, y_length = _to_raster(self.y, self.y_length, pixel_size.y)\n\n    if self.z is None:\n        z, z_length = None, None\n    else:\n        assert self.z_length is not None\n        z, z_length = _to_raster(self.z, self.z_length, pixel_size.z)\n\n    if self.t is None:\n        t, t_length = None, None\n    else:\n        assert self.t_length is not None\n        t, t_length = _to_raster(self.t, self.t_length, pixel_size.t)\n    extra_dict = self.model_extra if self.model_extra else {}\n\n    return RoiPixels(\n        name=self.name,\n        x=x,\n        y=y,\n        z=z,\n        t=t,\n        x_length=x_length,\n        y_length=y_length,\n        z_length=z_length,\n        t_length=t_length,\n        label=self.label,\n        unit=self.unit,\n        dimensions=_dimensions,\n        **extra_dict,\n    )\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Roi.to_pixel_roi","title":"to_pixel_roi","text":"<pre><code>to_pixel_roi(\n    pixel_size: PixelSize,\n    dimensions: Dimensions | None = None,\n) -&gt; RoiPixels\n</code></pre> <p>Convert to raster coordinates.</p> Source code in <code>ngio/common/_roi.py</code> <pre><code>def to_pixel_roi(\n    self, pixel_size: PixelSize, dimensions: Dimensions | None = None\n) -&gt; \"RoiPixels\":\n    \"\"\"Convert to raster coordinates.\"\"\"\n    warn(\n        \"to_pixel_roi is deprecated and will be removed in a future release. \"\n        \"Use to_roi_pixels instead.\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n\n    return self.to_roi_pixels(pixel_size=pixel_size, dimensions=dimensions)\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.Roi.zoom","title":"zoom","text":"<pre><code>zoom(zoom_factor: float = 1) -&gt; Roi\n</code></pre> <p>Zoom the ROI by a factor.</p> <p>Parameters:</p> <ul> <li> <code>zoom_factor</code>               (<code>float</code>, default:                   <code>1</code> )           \u2013            <p>The zoom factor. If the zoom factor is less than 1 the ROI will be zoomed in. If the zoom factor is greater than 1 the ROI will be zoomed out. If the zoom factor is 1 the ROI will not be changed.</p> </li> </ul> Source code in <code>ngio/common/_roi.py</code> <pre><code>def zoom(self, zoom_factor: float = 1) -&gt; \"Roi\":\n    \"\"\"Zoom the ROI by a factor.\n\n    Args:\n        zoom_factor: The zoom factor. If the zoom factor\n            is less than 1 the ROI will be zoomed in.\n            If the zoom factor is greater than 1 the ROI will be zoomed out.\n            If the zoom factor is 1 the ROI will not be changed.\n    \"\"\"\n    return zoom_roi(self, zoom_factor)\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.RoiPixels","title":"RoiPixels","text":"<p>               Bases: <code>GenericRoi</code></p> <p>Region of interest (ROI) in pixel coordinates.</p>"},{"location":"api/ngio/common/#ngio.common.RoiPixels.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str | None\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.RoiPixels.z","title":"z  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>z: float | None = None\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.RoiPixels.t","title":"t  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>t: float | None = None\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.RoiPixels.x_length","title":"x_length  <code>instance-attribute</code>","text":"<pre><code>x_length: float\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.RoiPixels.y_length","title":"y_length  <code>instance-attribute</code>","text":"<pre><code>y_length: float\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.RoiPixels.z_length","title":"z_length  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>z_length: float | None = None\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.RoiPixels.t_length","title":"t_length  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>t_length: float | None = None\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.RoiPixels.label","title":"label  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>label: int | None = None\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.RoiPixels.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(extra='allow')\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.RoiPixels.x","title":"x  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>x: float = 0\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.RoiPixels.y","title":"y  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>y: float = 0\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.RoiPixels.unit","title":"unit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>unit: SpaceUnits | str | None = None\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.RoiPixels.dimensions","title":"dimensions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dimensions: BaseDimensions = Field(\n    default_factory=BaseDimensions\n)\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.RoiPixels.intersection","title":"intersection","text":"<pre><code>intersection(other: GenericRoi) -&gt; GenericRoi | None\n</code></pre> <p>Calculate the intersection of this ROI with another ROI.</p> Source code in <code>ngio/common/_roi.py</code> <pre><code>def intersection(self, other: \"GenericRoi\") -&gt; \"GenericRoi | None\":\n    \"\"\"Calculate the intersection of this ROI with another ROI.\"\"\"\n    return roi_intersection(self, other)\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.RoiPixels.get_name","title":"get_name","text":"<pre><code>get_name() -&gt; str\n</code></pre> <p>Get the name of the ROI, or a default if not set.</p> Source code in <code>ngio/common/_roi.py</code> <pre><code>def get_name(self) -&gt; str:\n    \"\"\"Get the name of the ROI, or a default if not set.\"\"\"\n    if self.name is not None:\n        return self.name\n    return self._nice_str()\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.RoiPixels.to_roi","title":"to_roi","text":"<pre><code>to_roi(pixel_size: PixelSize) -&gt; Roi\n</code></pre> <p>Convert to raster coordinates.</p> Source code in <code>ngio/common/_roi.py</code> <pre><code>def to_roi(self, pixel_size: PixelSize) -&gt; \"Roi\":\n    \"\"\"Convert to raster coordinates.\"\"\"\n    x = _to_world(self.x, pixel_size.x)\n    x_length = _to_world(self.x_length, pixel_size.x)\n    y = _to_world(self.y, pixel_size.y)\n    y_length = _to_world(self.y_length, pixel_size.y)\n\n    if self.z is None:\n        z = None\n    else:\n        z = _to_world(self.z, pixel_size.z)\n\n    if self.z_length is None:\n        z_length = None\n    else:\n        z_length = _to_world(self.z_length, pixel_size.z)\n\n    if self.t is None:\n        t = None\n    else:\n        t = _to_world(self.t, pixel_size.t)\n\n    if self.t_length is None:\n        t_length = None\n    else:\n        t_length = _to_world(self.t_length, pixel_size.t)\n\n    extra_dict = self.model_extra if self.model_extra else {}\n    return Roi(\n        name=self.name,\n        x=x,\n        y=y,\n        z=z,\n        t=t,\n        x_length=x_length,\n        y_length=y_length,\n        z_length=z_length,\n        t_length=t_length,\n        label=self.label,\n        unit=self.unit,\n        **extra_dict,\n    )\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.RoiPixels.to_slicing_dict","title":"to_slicing_dict","text":"<pre><code>to_slicing_dict() -&gt; dict[str, slice]\n</code></pre> <p>Convert to a slicing dictionary.</p> Source code in <code>ngio/common/_roi.py</code> <pre><code>def to_slicing_dict(self) -&gt; dict[str, slice]:\n    \"\"\"Convert to a slicing dictionary.\"\"\"\n    x_slice = _to_slice(self.x, self.x_length)\n    y_slice = _to_slice(self.y, self.y_length)\n    z_slice = _to_slice(self.z, self.z_length)\n    t_slice = _to_slice(self.t, self.t_length)\n    return {\n        \"x\": x_slice,\n        \"y\": y_slice,\n        \"z\": z_slice,\n        \"t\": t_slice,\n    }\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.compute_masking_roi","title":"compute_masking_roi","text":"<pre><code>compute_masking_roi(\n    segmentation: ndarray | Array, pixel_size: PixelSize\n) -&gt; list[Roi]\n</code></pre> <p>Compute a ROIs for each label in a segmentation.</p> <p>This function expects a 2D or 3D segmentation array. And this function expects the axes order to be 'zyx' or 'yx'. Other axes orders are not supported.</p> Source code in <code>ngio/common/_masking_roi.py</code> <pre><code>def compute_masking_roi(\n    segmentation: np.ndarray | da.Array, pixel_size: PixelSize\n) -&gt; list[Roi]:\n    \"\"\"Compute a ROIs for each label in a segmentation.\n\n    This function expects a 2D or 3D segmentation array.\n    And this function expects the axes order to be 'zyx' or 'yx'.\n    Other axes orders are not supported.\n\n    \"\"\"\n    if segmentation.ndim not in [2, 3, 4]:\n        raise NgioValueError(\"Only 2D, 3D, and 4D segmentations are supported.\")\n\n    if isinstance(segmentation, da.Array):\n        slices = lazy_compute_slices(segmentation)\n    else:\n        slices = compute_slices(segmentation)\n\n    rois = []\n    for label, slice_ in slices.items():\n        if len(slice_) == 2:\n            min_t, max_t = None, None\n            min_z, max_z = None, None\n            min_y, min_x = slice_[0].start, slice_[1].start\n            max_y, max_x = slice_[0].stop, slice_[1].stop\n        elif len(slice_) == 3:\n            min_t, max_t = None, None\n            min_z, min_y, min_x = slice_[0].start, slice_[1].start, slice_[2].start\n            max_z, max_y, max_x = slice_[0].stop, slice_[1].stop, slice_[2].stop\n        elif len(slice_) == 4:\n            min_t, min_z, min_y, min_x = (\n                slice_[0].start,\n                slice_[1].start,\n                slice_[2].start,\n                slice_[3].start,\n            )\n            max_t, max_z, max_y, max_x = (\n                slice_[0].stop,\n                slice_[1].stop,\n                slice_[2].stop,\n                slice_[3].stop,\n            )\n        else:\n            raise ValueError(\"Invalid slice length.\")\n\n        if max_t is None:\n            t_length = None\n        else:\n            t_length = max_t - min_t\n\n        if max_z is None:\n            z_length = None\n        else:\n            z_length = max_z - min_z\n\n        roi = RoiPixels(\n            name=str(label),\n            x_length=max_x - min_x,\n            y_length=max_y - min_y,\n            z_length=z_length,\n            t_length=t_length,\n            x=min_x,\n            y=min_y,\n            z=min_z,\n            label=label,\n        )\n\n        roi = roi.to_roi(pixel_size)\n        rois.append(roi)\n    return rois\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.consolidate_pyramid","title":"consolidate_pyramid","text":"<pre><code>consolidate_pyramid(\n    source: Array,\n    targets: list[Array],\n    order: InterpolationOrder = \"linear\",\n    mode: Literal[\"dask\", \"numpy\", \"coarsen\"] = \"dask\",\n) -&gt; None\n</code></pre> <p>Consolidate the Zarr array.</p> Source code in <code>ngio/common/_pyramid.py</code> <pre><code>def consolidate_pyramid(\n    source: zarr.Array,\n    targets: list[zarr.Array],\n    order: InterpolationOrder = \"linear\",\n    mode: Literal[\"dask\", \"numpy\", \"coarsen\"] = \"dask\",\n) -&gt; None:\n    \"\"\"Consolidate the Zarr array.\"\"\"\n    processed = [source]\n    to_be_processed = targets\n\n    while to_be_processed:\n        source_id, target_id = _find_closest_arrays(processed, to_be_processed)\n\n        source_image = processed[source_id]\n        target_image = to_be_processed.pop(target_id)\n\n        on_disk_zoom(\n            source=source_image,\n            target=target_image,\n            mode=mode,\n            order=order,\n        )\n        processed.append(target_image)\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.init_empty_pyramid","title":"init_empty_pyramid","text":"<pre><code>init_empty_pyramid(\n    store: StoreOrGroup,\n    paths: list[str],\n    ref_shape: Sequence[int],\n    scaling_factors: Sequence[float],\n    chunks: Sequence[int] | None = None,\n    dtype: str = \"uint16\",\n    mode: AccessModeLiteral = \"a\",\n) -&gt; None\n</code></pre> Source code in <code>ngio/common/_pyramid.py</code> <pre><code>def init_empty_pyramid(\n    store: StoreOrGroup,\n    paths: list[str],\n    ref_shape: Sequence[int],\n    scaling_factors: Sequence[float],\n    chunks: Sequence[int] | None = None,\n    dtype: str = \"uint16\",\n    mode: AccessModeLiteral = \"a\",\n) -&gt; None:\n    # Return the an Image object\n    if chunks is not None and len(chunks) != len(ref_shape):\n        raise NgioValueError(\n            \"The shape and chunks must have the same number of dimensions.\"\n        )\n\n    if chunks is not None:\n        chunks = [min(c, s) for c, s in zip(chunks, ref_shape, strict=True)]\n\n    if len(ref_shape) != len(scaling_factors):\n        raise NgioValueError(\n            \"The shape and scaling factor must have the same number of dimensions.\"\n        )\n\n    # Ensure scaling factors are int if possible\n    # To reduce the risk of floating point issues\n    scaling_factors = [_maybe_int(s) for s in scaling_factors]\n\n    root_group = open_group_wrapper(store, mode=mode)\n\n    for path in paths:\n        if any(s &lt; 1 for s in ref_shape):\n            raise NgioValueError(\n                \"Level shape must be at least 1 on all dimensions. \"\n                f\"Calculated shape: {ref_shape} at level {path}.\"\n            )\n        new_arr = root_group.zeros(\n            name=path,\n            shape=ref_shape,\n            dtype=dtype,\n            chunks=chunks,\n            dimension_separator=\"/\",\n            overwrite=True,\n        )\n\n        _shape = [\n            math.floor(s / sc) for s, sc in zip(ref_shape, scaling_factors, strict=True)\n        ]\n        ref_shape = _shape\n\n        if chunks is None:\n            chunks = new_arr.chunks\n            assert chunks is not None\n        chunks = [min(c, s) for c, s in zip(chunks, ref_shape, strict=True)]\n    return None\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.on_disk_zoom","title":"on_disk_zoom","text":"<pre><code>on_disk_zoom(\n    source: Array,\n    target: Array,\n    order: InterpolationOrder = \"linear\",\n    mode: Literal[\"dask\", \"numpy\", \"coarsen\"] = \"dask\",\n) -&gt; None\n</code></pre> <p>Apply a zoom operation from a source zarr array to a target zarr array.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>Array</code>)           \u2013            <p>The source array to zoom.</p> </li> <li> <code>target</code>               (<code>Array</code>)           \u2013            <p>The target array to save the zoomed result to.</p> </li> <li> <code>order</code>               (<code>InterpolationOrder</code>, default:                   <code>'linear'</code> )           \u2013            <p>The order of interpolation. Defaults to \"linear\".</p> </li> <li> <code>mode</code>               (<code>Literal['dask', 'numpy', 'coarsen']</code>, default:                   <code>'dask'</code> )           \u2013            <p>The mode to use. Defaults to \"dask\".</p> </li> </ul> Source code in <code>ngio/common/_pyramid.py</code> <pre><code>def on_disk_zoom(\n    source: zarr.Array,\n    target: zarr.Array,\n    order: InterpolationOrder = \"linear\",\n    mode: Literal[\"dask\", \"numpy\", \"coarsen\"] = \"dask\",\n) -&gt; None:\n    \"\"\"Apply a zoom operation from a source zarr array to a target zarr array.\n\n    Args:\n        source (zarr.Array): The source array to zoom.\n        target (zarr.Array): The target array to save the zoomed result to.\n        order (InterpolationOrder): The order of interpolation. Defaults to \"linear\".\n        mode (Literal[\"dask\", \"numpy\", \"coarsen\"]): The mode to use. Defaults to \"dask\".\n    \"\"\"\n    if not isinstance(source, zarr.Array):\n        raise NgioValueError(\"source must be a zarr array\")\n\n    if not isinstance(target, zarr.Array):\n        raise NgioValueError(\"target must be a zarr array\")\n\n    if source.dtype != target.dtype:\n        raise NgioValueError(\"source and target must have the same dtype\")\n\n    match mode:\n        case \"numpy\":\n            return _on_disk_numpy_zoom(source, target, order)\n        case \"dask\":\n            return _on_disk_dask_zoom(source, target, order)\n        case \"coarsen\":\n            return _on_disk_coarsen(\n                source,\n                target,\n            )\n        case _:\n            raise NgioValueError(\"mode must be either 'dask', 'numpy' or 'coarsen'\")\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.dask_zoom","title":"dask_zoom","text":"<pre><code>dask_zoom(\n    source_array: Array,\n    scale: tuple[float | int, ...] | None = None,\n    target_shape: tuple[int, ...] | None = None,\n    order: InterpolationOrder = \"linear\",\n) -&gt; Array\n</code></pre> <p>Dask implementation of zooming an array.</p> <p>Only one of scale or target_shape must be provided.</p> <p>Parameters:</p> <ul> <li> <code>source_array</code>               (<code>Array</code>)           \u2013            <p>The source array to zoom.</p> </li> <li> <code>scale</code>               (<code>tuple[int, ...] | None</code>, default:                   <code>None</code> )           \u2013            <p>The scale factor to zoom by.</p> </li> <li> <code>target_shape</code>               (<code>(tuple[int, ...], None)</code>, default:                   <code>None</code> )           \u2013            <p>The target shape to zoom to.</p> </li> <li> <code>order</code>               (<code>Literal['nearest', 'linear', 'cubic']</code>, default:                   <code>'linear'</code> )           \u2013            <p>The order of interpolation. Defaults to \"linear\".</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array</code>           \u2013            <p>da.Array: The zoomed array.</p> </li> </ul> Source code in <code>ngio/common/_zoom.py</code> <pre><code>def dask_zoom(\n    source_array: da.Array,\n    scale: tuple[float | int, ...] | None = None,\n    target_shape: tuple[int, ...] | None = None,\n    order: InterpolationOrder = \"linear\",\n) -&gt; da.Array:\n    \"\"\"Dask implementation of zooming an array.\n\n    Only one of scale or target_shape must be provided.\n\n    Args:\n        source_array (da.Array): The source array to zoom.\n        scale (tuple[int, ...] | None): The scale factor to zoom by.\n        target_shape (tuple[int, ...], None): The target shape to zoom to.\n        order (Literal[\"nearest\", \"linear\", \"cubic\"]): The order of interpolation.\n            Defaults to \"linear\".\n\n    Returns:\n        da.Array: The zoomed array.\n    \"\"\"\n    # This function follow the implementation from:\n    # https://github.com/ome/ome-zarr-py/blob/master/ome_zarr/dask_utils.py\n    # The module was contributed by Andreas Eisenbarth @aeisenbarth\n    # See https://github.com/toloudis/ome-zarr-py/pull/\n    _scale, _target_shape = _zoom_inputs_check(\n        source_array=source_array, scale=scale, target_shape=target_shape\n    )\n\n    # Rechunk to better match the scaling operation\n    source_chunks = np.array(source_array.chunksize)  # type: ignore (da.Array.chunksize is a tuple of ints)\n    better_source_chunks = np.maximum(1, np.round(source_chunks * _scale) / _scale)\n    better_source_chunks = better_source_chunks.astype(int)\n    source_array = source_array.rechunk(better_source_chunks)  # type: ignore (better_source_chunks is a valid input for rechunk)\n\n    # Calculate the block output shape\n    block_output_shape = tuple(np.ceil(better_source_chunks * _scale).astype(int))\n\n    zoom_wrapper = partial(\n        fast_zoom,\n        zoom=_scale,\n        order=order_to_int(order),\n        mode=\"grid-constant\",\n        grid_mode=True,\n    )\n\n    out_array = da.map_blocks(\n        zoom_wrapper, source_array, chunks=block_output_shape, dtype=source_array.dtype\n    )\n\n    # Slice and rechunk to target\n    slices = tuple(slice(0, ts, 1) for ts in _target_shape)\n    out_array = out_array[slices]\n    return out_array\n</code></pre>"},{"location":"api/ngio/common/#ngio.common.numpy_zoom","title":"numpy_zoom","text":"<pre><code>numpy_zoom(\n    source_array: ndarray,\n    scale: tuple[int | float, ...] | None = None,\n    target_shape: tuple[int, ...] | None = None,\n    order: InterpolationOrder = \"linear\",\n) -&gt; ndarray\n</code></pre> <p>Numpy implementation of zooming an array.</p> <p>Only one of scale or target_shape must be provided.</p> <p>Parameters:</p> <ul> <li> <code>source_array</code>               (<code>ndarray</code>)           \u2013            <p>The source array to zoom.</p> </li> <li> <code>scale</code>               (<code>tuple[int, ...] | None</code>, default:                   <code>None</code> )           \u2013            <p>The scale factor to zoom by.</p> </li> <li> <code>target_shape</code>               (<code>(tuple[int, ...], None)</code>, default:                   <code>None</code> )           \u2013            <p>The target shape to zoom to.</p> </li> <li> <code>order</code>               (<code>Literal[0, 1, 2]</code>, default:                   <code>'linear'</code> )           \u2013            <p>The order of interpolation. Defaults to 1.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: The zoomed array</p> </li> </ul> Source code in <code>ngio/common/_zoom.py</code> <pre><code>def numpy_zoom(\n    source_array: np.ndarray,\n    scale: tuple[int | float, ...] | None = None,\n    target_shape: tuple[int, ...] | None = None,\n    order: InterpolationOrder = \"linear\",\n) -&gt; np.ndarray:\n    \"\"\"Numpy implementation of zooming an array.\n\n    Only one of scale or target_shape must be provided.\n\n    Args:\n        source_array (np.ndarray): The source array to zoom.\n        scale (tuple[int, ...] | None): The scale factor to zoom by.\n        target_shape (tuple[int, ...], None): The target shape to zoom to.\n        order (Literal[0, 1, 2]): The order of interpolation. Defaults to 1.\n\n    Returns:\n        np.ndarray: The zoomed array\n    \"\"\"\n    _scale, _ = _zoom_inputs_check(\n        source_array=source_array, scale=scale, target_shape=target_shape\n    )\n\n    out_array = fast_zoom(\n        source_array,\n        zoom=_scale,\n        order=order_to_int(order),\n        mode=\"grid-constant\",\n        grid_mode=True,\n    )\n    assert isinstance(out_array, np.ndarray)\n    return out_array\n</code></pre>"},{"location":"api/ngio/hcs/","title":"ngio.hcs API documentation","text":""},{"location":"api/ngio/hcs/#ngio.hcs","title":"ngio.hcs","text":"<p>OME-Zarr HCS objects models.</p>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate","title":"OmeZarrPlate","text":"<pre><code>OmeZarrPlate(\n    group_handler: ZarrGroupHandler,\n    table_container: TablesContainer | None = None,\n)\n</code></pre> <p>A class to handle the Plate Sequence in an OME-Zarr file.</p> <p>Initialize the LabelGroupHandler.</p> <p>Parameters:</p> <ul> <li> <code>group_handler</code>               (<code>ZarrGroupHandler</code>)           \u2013            <p>The Zarr group handler that contains the Plate.</p> </li> <li> <code>table_container</code>               (<code>TablesContainer | None</code>, default:                   <code>None</code> )           \u2013            <p>The tables container that contains plate level tables.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def __init__(\n    self,\n    group_handler: ZarrGroupHandler,\n    table_container: TablesContainer | None = None,\n) -&gt; None:\n    \"\"\"Initialize the LabelGroupHandler.\n\n    Args:\n        group_handler: The Zarr group handler that contains the Plate.\n        table_container: The tables container that contains plate level tables.\n    \"\"\"\n    self._group_handler = group_handler\n    self._meta_handler = find_plate_meta_handler(group_handler)\n    self._tables_container = table_container\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.meta_handler","title":"meta_handler  <code>property</code>","text":"<pre><code>meta_handler\n</code></pre> <p>Return the metadata handler.</p>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.meta","title":"meta  <code>property</code>","text":"<pre><code>meta\n</code></pre> <p>Return the metadata.</p>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.columns","title":"columns  <code>property</code>","text":"<pre><code>columns: list[str]\n</code></pre> <p>Return the number of columns in the plate.</p>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.rows","title":"rows  <code>property</code>","text":"<pre><code>rows: list[str]\n</code></pre> <p>Return the number of rows in the plate.</p>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.acquisitions_names","title":"acquisitions_names  <code>property</code>","text":"<pre><code>acquisitions_names: list[str | None]\n</code></pre> <p>Return the acquisitions in the plate.</p>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.acquisition_ids","title":"acquisition_ids  <code>property</code>","text":"<pre><code>acquisition_ids: list[int]\n</code></pre> <p>Return the acquisitions ids in the plate.</p>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.tables_container","title":"tables_container  <code>property</code>","text":"<pre><code>tables_container: TablesContainer\n</code></pre> <p>Return the tables container.</p>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.wells_paths","title":"wells_paths","text":"<pre><code>wells_paths() -&gt; list[str]\n</code></pre> <p>Return the wells paths in the plate.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def wells_paths(self) -&gt; list[str]:\n    \"\"\"Return the wells paths in the plate.\"\"\"\n    return self.meta.wells_paths\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.images_paths_async","title":"images_paths_async  <code>async</code>","text":"<pre><code>images_paths_async(\n    acquisition: int | None = None,\n) -&gt; list[str]\n</code></pre> <p>Return the images paths in the plate asynchronously.</p> <p>If acquisition is None, return all images paths in the plate. Else, return the images paths in the plate for the given acquisition.</p> <p>Parameters:</p> <ul> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>async def images_paths_async(self, acquisition: int | None = None) -&gt; list[str]:\n    \"\"\"Return the images paths in the plate asynchronously.\n\n    If acquisition is None, return all images paths in the plate.\n    Else, return the images paths in the plate for the given acquisition.\n\n    Args:\n        acquisition (int | None): The acquisition id to filter the images.\n    \"\"\"\n    wells = await self.get_wells_async()\n    paths = []\n    for well_path, well in wells.items():\n        for img_path in well.paths(acquisition):\n            paths.append(f\"{well_path}/{img_path}\")\n    return paths\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.images_paths","title":"images_paths","text":"<pre><code>images_paths(acquisition: int | None = None) -&gt; list[str]\n</code></pre> <p>Return the images paths in the plate.</p> <p>If acquisition is None, return all images paths in the plate. Else, return the images paths in the plate for the given acquisition.</p> <p>Parameters:</p> <ul> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def images_paths(self, acquisition: int | None = None) -&gt; list[str]:\n    \"\"\"Return the images paths in the plate.\n\n    If acquisition is None, return all images paths in the plate.\n    Else, return the images paths in the plate for the given acquisition.\n\n    Args:\n        acquisition (int | None): The acquisition id to filter the images.\n    \"\"\"\n    wells = self.get_wells()\n    images = []\n    for well_path, well in wells.items():\n        for img_path in well.paths(acquisition):\n            images.append(f\"{well_path}/{img_path}\")\n    return images\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.well_images_paths","title":"well_images_paths","text":"<pre><code>well_images_paths(\n    row: str,\n    column: int | str,\n    acquisition: int | None = None,\n) -&gt; list[str]\n</code></pre> <p>Return the images paths in a well.</p> <p>If acquisition is None, return all images paths in the well. Else, return the images paths in the well for the given acquisition.</p> <p>Parameters:</p> <ul> <li> <code>row</code>               (<code>str</code>)           \u2013            <p>The row of the well.</p> </li> <li> <code>column</code>               (<code>int | str</code>)           \u2013            <p>The column of the well.</p> </li> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def well_images_paths(\n    self, row: str, column: int | str, acquisition: int | None = None\n) -&gt; list[str]:\n    \"\"\"Return the images paths in a well.\n\n    If acquisition is None, return all images paths in the well.\n    Else, return the images paths in the well for the given acquisition.\n\n    Args:\n        row (str): The row of the well.\n        column (int | str): The column of the well.\n        acquisition (int | None): The acquisition id to filter the images.\n    \"\"\"\n    images = []\n    well = self.get_well(row=row, column=column)\n    for path in well.paths(acquisition):\n        images.append(self._image_path(row=row, column=column, path=path))\n    return images\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.get_image_acquisition_id","title":"get_image_acquisition_id","text":"<pre><code>get_image_acquisition_id(\n    row: str, column: int | str, image_path: str\n) -&gt; int | None\n</code></pre> <p>Get the acquisition id of an image in a well.</p> <p>Parameters:</p> <ul> <li> <code>row</code>               (<code>str</code>)           \u2013            <p>The row of the well.</p> </li> <li> <code>column</code>               (<code>int | str</code>)           \u2013            <p>The column of the well.</p> </li> <li> <code>image_path</code>               (<code>str</code>)           \u2013            <p>The path of the image.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int | None</code>           \u2013            <p>int | None: The acquisition id of the image.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_image_acquisition_id(\n    self, row: str, column: int | str, image_path: str\n) -&gt; int | None:\n    \"\"\"Get the acquisition id of an image in a well.\n\n    Args:\n        row (str): The row of the well.\n        column (int | str): The column of the well.\n        image_path (str): The path of the image.\n\n    Returns:\n        int | None: The acquisition id of the image.\n    \"\"\"\n    well = self.get_well(row=row, column=column)\n    return well.get_image_acquisition_id(image_path=image_path)\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.get_well","title":"get_well","text":"<pre><code>get_well(row: str, column: int | str) -&gt; OmeZarrWell\n</code></pre> <p>Get a well from the plate.</p> <p>Parameters:</p> <ul> <li> <code>row</code>               (<code>str</code>)           \u2013            <p>The row of the well.</p> </li> <li> <code>column</code>               (<code>int | str</code>)           \u2013            <p>The column of the well.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OmeZarrWell</code> (              <code>OmeZarrWell</code> )          \u2013            <p>The well.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_well(self, row: str, column: int | str) -&gt; OmeZarrWell:\n    \"\"\"Get a well from the plate.\n\n    Args:\n        row (str): The row of the well.\n        column (int | str): The column of the well.\n\n    Returns:\n        OmeZarrWell: The well.\n    \"\"\"\n    well_path = self._well_path(row=row, column=column)\n    group_handler = self._group_handler.derive_handler(well_path)\n    return OmeZarrWell(group_handler)\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.get_wells_async","title":"get_wells_async  <code>async</code>","text":"<pre><code>get_wells_async() -&gt; dict[str, OmeZarrWell]\n</code></pre> <p>Get all wells in the plate asynchronously.</p> <p>This method processes wells in parallel for improved performance when working with a large number of wells.</p> <p>Returns:</p> <ul> <li> <code>dict[str, OmeZarrWell]</code>           \u2013            <p>dict[str, OmeZarrWell]: A dictionary of wells, where the key is the well path and the value is the well object.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>async def get_wells_async(self) -&gt; dict[str, OmeZarrWell]:\n    \"\"\"Get all wells in the plate asynchronously.\n\n    This method processes wells in parallel for improved performance\n    when working with a large number of wells.\n\n    Returns:\n        dict[str, OmeZarrWell]: A dictionary of wells, where the key is the well\n            path and the value is the well object.\n    \"\"\"\n    wells = self._group_handler.get_from_cache(\"wells\")\n    if wells is not None:\n        assert isinstance(wells, dict)\n        return wells\n\n    def process_well(well_path):\n        group_handler = self._group_handler.derive_handler(well_path)\n        well = OmeZarrWell(group_handler)\n        return well_path, well\n\n    wells, tasks = {}, []\n    for well_path in self.wells_paths():\n        task = asyncio.to_thread(process_well, well_path)\n        tasks.append(task)\n\n    results = await asyncio.gather(*tasks)\n    for well_path, well in results:\n        wells[well_path] = well\n\n    self._group_handler.add_to_cache(\"wells\", wells)\n    return wells\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.get_wells","title":"get_wells","text":"<pre><code>get_wells() -&gt; dict[str, OmeZarrWell]\n</code></pre> <p>Get all wells in the plate.</p> <p>Returns:</p> <ul> <li> <code>dict[str, OmeZarrWell]</code>           \u2013            <p>dict[str, OmeZarrWell]: A dictionary of wells, where the key is the well path and the value is the well object.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_wells(self) -&gt; dict[str, OmeZarrWell]:\n    \"\"\"Get all wells in the plate.\n\n    Returns:\n        dict[str, OmeZarrWell]: A dictionary of wells, where the key is the well\n            path and the value is the well object.\n    \"\"\"\n    wells = self._group_handler.get_from_cache(\"wells\")\n    if wells is not None:\n        assert isinstance(wells, dict)\n        return wells\n\n    def process_well(well_path):\n        group_handler = self._group_handler.derive_handler(well_path)\n        well = OmeZarrWell(group_handler)\n        return well_path, well\n\n    wells = {}\n    for well_path in self.wells_paths():\n        _, well = process_well(well_path)\n        wells[well_path] = well\n\n    self._group_handler.add_to_cache(\"wells\", wells)\n    return wells\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.get_images_async","title":"get_images_async  <code>async</code>","text":"<pre><code>get_images_async(\n    acquisition: int | None = None,\n) -&gt; dict[str, OmeZarrContainer]\n</code></pre> <p>Get all images in the plate asynchronously.</p> <p>This method processes images in parallel for improved performance when working with a large number of images.</p> <p>Parameters:</p> <ul> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, OmeZarrContainer]</code>           \u2013            <p>dict[str, OmeZarrContainer]: A dictionary of images, where the key is the image path and the value is the image object.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>async def get_images_async(\n    self, acquisition: int | None = None\n) -&gt; dict[str, OmeZarrContainer]:\n    \"\"\"Get all images in the plate asynchronously.\n\n    This method processes images in parallel for improved performance\n    when working with a large number of images.\n\n    Args:\n        acquisition: The acquisition id to filter the images.\n\n    Returns:\n        dict[str, OmeZarrContainer]: A dictionary of images, where the key is the\n            image path and the value is the image object.\n    \"\"\"\n    images = self._group_handler.get_from_cache(\"images\")\n    if images is not None:\n        assert isinstance(images, dict)\n        return images\n\n    paths = await self.images_paths_async(acquisition=acquisition)\n\n    def process_image(image_path):\n        \"\"\"Process a single image and return the image path and image object.\"\"\"\n        img_group_handler = self._group_handler.derive_handler(image_path)\n        image = OmeZarrContainer(img_group_handler)\n        return image_path, image\n\n    images, tasks = {}, []\n    for image_path in paths:\n        task = asyncio.to_thread(process_image, image_path)\n        tasks.append(task)\n\n    results = await asyncio.gather(*tasks)\n\n    for image_path, image in results:\n        images[image_path] = image\n\n    self._group_handler.add_to_cache(\"images\", images)\n    return images\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.get_images","title":"get_images","text":"<pre><code>get_images(\n    acquisition: int | None = None,\n) -&gt; dict[str, OmeZarrContainer]\n</code></pre> <p>Get all images in the plate.</p> <p>Parameters:</p> <ul> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_images(self, acquisition: int | None = None) -&gt; dict[str, OmeZarrContainer]:\n    \"\"\"Get all images in the plate.\n\n    Args:\n        acquisition: The acquisition id to filter the images.\n    \"\"\"\n    images = self._group_handler.get_from_cache(\"images\")\n    if images is not None:\n        assert isinstance(images, dict)\n        return images\n    paths = self.images_paths(acquisition=acquisition)\n\n    def process_image(image_path):\n        \"\"\"Process a single image and return the image path and image object.\"\"\"\n        img_group_handler = self._group_handler.derive_handler(image_path)\n        image = OmeZarrContainer(img_group_handler)\n        return image_path, image\n\n    images = {}\n    for image_path in paths:\n        _, image = process_image(image_path)\n        images[image_path] = image\n\n    self._group_handler.add_to_cache(\"images\", images)\n    return images\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.get_image","title":"get_image","text":"<pre><code>get_image(\n    row: str, column: int | str, image_path: str\n) -&gt; OmeZarrContainer\n</code></pre> <p>Get an image from the plate.</p> <p>Parameters:</p> <ul> <li> <code>row</code>               (<code>str</code>)           \u2013            <p>The row of the well.</p> </li> <li> <code>column</code>               (<code>int | str</code>)           \u2013            <p>The column of the well.</p> </li> <li> <code>image_path</code>               (<code>str</code>)           \u2013            <p>The path of the image.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OmeZarrContainer</code> (              <code>OmeZarrContainer</code> )          \u2013            <p>The image.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_image(\n    self, row: str, column: int | str, image_path: str\n) -&gt; OmeZarrContainer:\n    \"\"\"Get an image from the plate.\n\n    Args:\n        row (str): The row of the well.\n        column (int | str): The column of the well.\n        image_path (str): The path of the image.\n\n    Returns:\n        OmeZarrContainer: The image.\n    \"\"\"\n    image_path = self._image_path(row=row, column=column, path=image_path)\n    group_handler = self._group_handler.derive_handler(image_path)\n    return OmeZarrContainer(group_handler)\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.get_image_store","title":"get_image_store","text":"<pre><code>get_image_store(\n    row: str, column: int | str, image_path: str\n) -&gt; StoreOrGroup\n</code></pre> <p>Get the image store from the plate.</p> <p>Parameters:</p> <ul> <li> <code>row</code>               (<code>str</code>)           \u2013            <p>The row of the well.</p> </li> <li> <code>column</code>               (<code>int | str</code>)           \u2013            <p>The column of the well.</p> </li> <li> <code>image_path</code>               (<code>str</code>)           \u2013            <p>The path of the image.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_image_store(\n    self, row: str, column: int | str, image_path: str\n) -&gt; StoreOrGroup:\n    \"\"\"Get the image store from the plate.\n\n    Args:\n        row (str): The row of the well.\n        column (int | str): The column of the well.\n        image_path (str): The path of the image.\n    \"\"\"\n    well = self.get_well(row=row, column=column)\n    return well.get_image_store(image_path=image_path)\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.get_well_images","title":"get_well_images","text":"<pre><code>get_well_images(\n    row: str,\n    column: str | int,\n    acquisition: int | None = None,\n) -&gt; dict[str, OmeZarrContainer]\n</code></pre> <p>Get all images in a well.</p> <p>Parameters:</p> <ul> <li> <code>row</code>               (<code>str</code>)           \u2013            <p>The row of the well.</p> </li> <li> <code>column</code>               (<code>str | int</code>)           \u2013            <p>The column of the well.</p> </li> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_well_images(\n    self, row: str, column: str | int, acquisition: int | None = None\n) -&gt; dict[str, OmeZarrContainer]:\n    \"\"\"Get all images in a well.\n\n    Args:\n        row: The row of the well.\n        column: The column of the well.\n        acquisition: The acquisition id to filter the images.\n    \"\"\"\n    images = {}\n    for image_paths in self.well_images_paths(\n        row=row, column=column, acquisition=acquisition\n    ):\n        group_handler = self._group_handler.derive_handler(image_paths)\n        images[image_paths] = OmeZarrContainer(group_handler)\n    return images\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.atomic_add_image","title":"atomic_add_image","text":"<pre><code>atomic_add_image(\n    row: str,\n    column: int | str,\n    image_path: str,\n    acquisition_id: int | None = None,\n    acquisition_name: str | None = None,\n) -&gt; str\n</code></pre> <p>Parallel safe version of add_image.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def atomic_add_image(\n    self,\n    row: str,\n    column: int | str,\n    image_path: str,\n    acquisition_id: int | None = None,\n    acquisition_name: str | None = None,\n) -&gt; str:\n    \"\"\"Parallel safe version of add_image.\"\"\"\n    if image_path is None:\n        raise ValueError(\n            \"Image path cannot be None for atomic add_image. \"\n            \"If your intent is to add a well, use add_well instead.\"\n        )\n    path = self._add_image(\n        row=row,\n        column=column,\n        image_path=image_path,\n        acquisition_id=acquisition_id,\n        acquisition_name=acquisition_name,\n        atomic=True,\n    )\n    return path\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.add_image","title":"add_image","text":"<pre><code>add_image(\n    row: str,\n    column: int | str,\n    image_path: str,\n    acquisition_id: int | None = None,\n    acquisition_name: str | None = None,\n) -&gt; str\n</code></pre> <p>Add an image to an ome-zarr plate.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def add_image(\n    self,\n    row: str,\n    column: int | str,\n    image_path: str,\n    acquisition_id: int | None = None,\n    acquisition_name: str | None = None,\n) -&gt; str:\n    \"\"\"Add an image to an ome-zarr plate.\"\"\"\n    if image_path is None:\n        raise ValueError(\n            \"Image path cannot be None for atomic add_image. \"\n            \"If your intent is to add a well, use add_well instead.\"\n        )\n    path = self._add_image(\n        row=row,\n        column=column,\n        image_path=image_path,\n        acquisition_id=acquisition_id,\n        acquisition_name=acquisition_name,\n        atomic=False,\n    )\n    return path\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.add_well","title":"add_well","text":"<pre><code>add_well(row: str, column: int | str) -&gt; OmeZarrWell\n</code></pre> <p>Add a well to an ome-zarr plate.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def add_well(\n    self,\n    row: str,\n    column: int | str,\n) -&gt; OmeZarrWell:\n    \"\"\"Add a well to an ome-zarr plate.\"\"\"\n    _ = self._add_image(\n        row=row,\n        column=column,\n        image_path=None,\n        acquisition_id=None,\n        acquisition_name=None,\n        atomic=False,\n    )\n    return self.get_well(row=row, column=column)\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.add_column","title":"add_column","text":"<pre><code>add_column(column: int | str) -&gt; OmeZarrPlate\n</code></pre> <p>Add a column to an ome-zarr plate.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def add_column(\n    self,\n    column: int | str,\n) -&gt; \"OmeZarrPlate\":\n    \"\"\"Add a column to an ome-zarr plate.\"\"\"\n    meta, _ = self.meta.add_column(column)\n    self.meta_handler.write_meta(meta)\n    self.meta_handler._group_handler.clean_cache()\n    return self\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.add_row","title":"add_row","text":"<pre><code>add_row(row: str) -&gt; OmeZarrPlate\n</code></pre> <p>Add a row to an ome-zarr plate.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def add_row(\n    self,\n    row: str,\n) -&gt; \"OmeZarrPlate\":\n    \"\"\"Add a row to an ome-zarr plate.\"\"\"\n    meta, _ = self.meta.add_row(row)\n    self.meta_handler.write_meta(meta)\n    self.meta_handler._group_handler.clean_cache()\n    return self\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.add_acquisition","title":"add_acquisition","text":"<pre><code>add_acquisition(\n    acquisition_id: int, acquisition_name: str\n) -&gt; OmeZarrPlate\n</code></pre> <p>Add an acquisition to an ome-zarr plate.</p> <p>Be aware that this is not a parallel safe operation.</p> <p>Parameters:</p> <ul> <li> <code>acquisition_id</code>               (<code>int</code>)           \u2013            <p>The acquisition id.</p> </li> <li> <code>acquisition_name</code>               (<code>str</code>)           \u2013            <p>The acquisition name.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def add_acquisition(\n    self,\n    acquisition_id: int,\n    acquisition_name: str,\n) -&gt; \"OmeZarrPlate\":\n    \"\"\"Add an acquisition to an ome-zarr plate.\n\n    Be aware that this is not a parallel safe operation.\n\n    Args:\n        acquisition_id (int): The acquisition id.\n        acquisition_name (str): The acquisition name.\n    \"\"\"\n    meta = self.meta.add_acquisition(\n        acquisition_id=acquisition_id, acquisition_name=acquisition_name\n    )\n    self.meta_handler.write_meta(meta)\n    self.meta_handler._group_handler.clean_cache()\n    return self\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.atomic_remove_image","title":"atomic_remove_image","text":"<pre><code>atomic_remove_image(\n    row: str, column: int | str, image_path: str\n)\n</code></pre> <p>Parallel safe version of remove_image.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def atomic_remove_image(\n    self,\n    row: str,\n    column: int | str,\n    image_path: str,\n):\n    \"\"\"Parallel safe version of remove_image.\"\"\"\n    return self._remove_image(\n        row=row,\n        column=column,\n        image_path=image_path,\n        atomic=True,\n    )\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.remove_image","title":"remove_image","text":"<pre><code>remove_image(row: str, column: int | str, image_path: str)\n</code></pre> <p>Remove an image from an ome-zarr plate.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def remove_image(\n    self,\n    row: str,\n    column: int | str,\n    image_path: str,\n):\n    \"\"\"Remove an image from an ome-zarr plate.\"\"\"\n    return self._remove_image(\n        row=row,\n        column=column,\n        image_path=image_path,\n        atomic=False,\n    )\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.derive_plate","title":"derive_plate","text":"<pre><code>derive_plate(\n    store: StoreOrGroup,\n    plate_name: str | None = None,\n    version: NgffVersions = \"0.4\",\n    keep_acquisitions: bool = False,\n    cache: bool = False,\n    overwrite: bool = False,\n    parallel_safe: bool = True,\n) -&gt; OmeZarrPlate\n</code></pre> <p>Derive a new OME-Zarr plate from an existing one.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group that stores the plate.</p> </li> <li> <code>plate_name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the new plate.</p> </li> <li> <code>version</code>               (<code>NgffVersion</code>, default:                   <code>'0.4'</code> )           \u2013            <p>The version of the new plate.</p> </li> <li> <code>keep_acquisitions</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to keep the acquisitions in the new plate.</p> </li> <li> <code>cache</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use a cache for the zarr group metadata.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to overwrite the existing plate.</p> </li> <li> <code>parallel_safe</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the group handler is parallel safe.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def derive_plate(\n    self,\n    store: StoreOrGroup,\n    plate_name: str | None = None,\n    version: NgffVersions = \"0.4\",\n    keep_acquisitions: bool = False,\n    cache: bool = False,\n    overwrite: bool = False,\n    parallel_safe: bool = True,\n) -&gt; \"OmeZarrPlate\":\n    \"\"\"Derive a new OME-Zarr plate from an existing one.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group that stores the plate.\n        plate_name (str | None): The name of the new plate.\n        version (NgffVersion): The version of the new plate.\n        keep_acquisitions (bool): Whether to keep the acquisitions in the new plate.\n        cache (bool): Whether to use a cache for the zarr group metadata.\n        overwrite (bool): Whether to overwrite the existing plate.\n        parallel_safe (bool): Whether the group handler is parallel safe.\n    \"\"\"\n    return derive_ome_zarr_plate(\n        ome_zarr_plate=self,\n        store=store,\n        plate_name=plate_name,\n        version=version,\n        keep_acquisitions=keep_acquisitions,\n        cache=cache,\n        overwrite=overwrite,\n        parallel_safe=parallel_safe,\n    )\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.list_tables","title":"list_tables","text":"<pre><code>list_tables(\n    filter_types: TypedTable | str | None = None,\n) -&gt; list[str]\n</code></pre> <p>List all tables in the image.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def list_tables(self, filter_types: TypedTable | str | None = None) -&gt; list[str]:\n    \"\"\"List all tables in the image.\"\"\"\n    return self.tables_container.list(filter_types=filter_types)\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.list_roi_tables","title":"list_roi_tables","text":"<pre><code>list_roi_tables() -&gt; list[str]\n</code></pre> <p>List all ROI tables in the image.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def list_roi_tables(self) -&gt; list[str]:\n    \"\"\"List all ROI tables in the image.\"\"\"\n    masking_roi = self.tables_container.list(\n        filter_types=\"masking_roi_table\",\n    )\n    roi = self.tables_container.list(\n        filter_types=\"roi_table\",\n    )\n    return masking_roi + roi\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.get_roi_table","title":"get_roi_table","text":"<pre><code>get_roi_table(name: str) -&gt; RoiTable\n</code></pre> <p>Get a ROI table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_roi_table(self, name: str) -&gt; RoiTable:\n    \"\"\"Get a ROI table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, RoiTable):\n        raise NgioValueError(f\"Table {name} is not a ROI table. Got {type(table)}\")\n    return table\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.get_masking_roi_table","title":"get_masking_roi_table","text":"<pre><code>get_masking_roi_table(name: str) -&gt; MaskingRoiTable\n</code></pre> <p>Get a masking ROI table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_masking_roi_table(self, name: str) -&gt; MaskingRoiTable:\n    \"\"\"Get a masking ROI table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, MaskingRoiTable):\n        raise NgioValueError(\n            f\"Table {name} is not a masking ROI table. Got {type(table)}\"\n        )\n    return table\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.get_feature_table","title":"get_feature_table","text":"<pre><code>get_feature_table(name: str) -&gt; FeatureTable\n</code></pre> <p>Get a feature table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_feature_table(self, name: str) -&gt; FeatureTable:\n    \"\"\"Get a feature table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, FeatureTable):\n        raise NgioValueError(\n            f\"Table {name} is not a feature table. Got {type(table)}\"\n        )\n    return table\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.get_generic_roi_table","title":"get_generic_roi_table","text":"<pre><code>get_generic_roi_table(name: str) -&gt; GenericRoiTable\n</code></pre> <p>Get a generic ROI table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_generic_roi_table(self, name: str) -&gt; GenericRoiTable:\n    \"\"\"Get a generic ROI table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, GenericRoiTable):\n        raise NgioValueError(\n            f\"Table {name} is not a generic ROI table. Got {type(table)}\"\n        )\n    return table\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.get_condition_table","title":"get_condition_table","text":"<pre><code>get_condition_table(name: str) -&gt; ConditionTable\n</code></pre> <p>Get a condition table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_condition_table(self, name: str) -&gt; ConditionTable:\n    \"\"\"Get a condition table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, ConditionTable):\n        raise NgioValueError(\n            f\"Table {name} is not a condition table. Got {type(table)}\"\n        )\n    return table\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.get_table","title":"get_table","text":"<pre><code>get_table(\n    name: str, check_type: TypedTable | None = None\n) -&gt; Table\n</code></pre> <p>Get a table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> <li> <code>check_type</code>               (<code>TypedTable | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Please use 'get_table_as' instead, or one of the type specific get_*table() methods.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_table(self, name: str, check_type: TypedTable | None = None) -&gt; Table:\n    \"\"\"Get a table from the image.\n\n    Args:\n        name (str): The name of the table.\n        check_type (TypedTable | None): Deprecated. Please use\n            'get_table_as' instead, or one of the type specific\n            get_*table() methods.\n\n    \"\"\"\n    if check_type is not None:\n        warnings.warn(\n            \"The 'check_type' argument is deprecated, and will be removed in \"\n            \"ngio=0.3. Use 'get_table_as' instead or one of the \"\n            \"type specific get_*table() methods.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n    return self.tables_container.get(name=name, strict=False)\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.get_table_as","title":"get_table_as","text":"<pre><code>get_table_as(\n    name: str,\n    table_cls: type[TableType],\n    backend: TableBackend | None = None,\n) -&gt; TableType\n</code></pre> <p>Get a table from the image as a specific type.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> <li> <code>table_cls</code>               (<code>type[TableType]</code>)           \u2013            <p>The type of the table.</p> </li> <li> <code>backend</code>               (<code>TableBackend | None</code>, default:                   <code>None</code> )           \u2013            <p>The backend to use. If None, the default backend is used.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_table_as(\n    self,\n    name: str,\n    table_cls: type[TableType],\n    backend: TableBackend | None = None,\n) -&gt; TableType:\n    \"\"\"Get a table from the image as a specific type.\n\n    Args:\n        name (str): The name of the table.\n        table_cls (type[TableType]): The type of the table.\n        backend (TableBackend | None): The backend to use. If None,\n            the default backend is used.\n    \"\"\"\n    return self.tables_container.get_as(\n        name=name,\n        table_cls=table_cls,\n        backend=backend,\n    )\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.add_table","title":"add_table","text":"<pre><code>add_table(\n    name: str,\n    table: Table,\n    backend: TableBackend = DefaultTableBackend,\n    overwrite: bool = False,\n) -&gt; None\n</code></pre> <p>Add a table to the image.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def add_table(\n    self,\n    name: str,\n    table: Table,\n    backend: TableBackend = DefaultTableBackend,\n    overwrite: bool = False,\n) -&gt; None:\n    \"\"\"Add a table to the image.\"\"\"\n    self.tables_container.add(\n        name=name, table=table, backend=backend, overwrite=overwrite\n    )\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.list_image_tables","title":"list_image_tables","text":"<pre><code>list_image_tables(\n    acquisition: int | None = None,\n    filter_types: str | None = None,\n    mode: Literal[\"common\", \"all\"] = \"common\",\n) -&gt; list[str]\n</code></pre> <p>List all image tables in the image.</p> <p>Parameters:</p> <ul> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> <li> <code>filter_types</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The type of tables to filter. If None, return all tables. Defaults to None.</p> </li> <li> <code>mode</code>               (<code>Literal['common', 'all']</code>, default:                   <code>'common'</code> )           \u2013            <p>The mode to use for listing the tables. If 'common', return only common tables between all images. If 'all', return all tables. Defaults to 'common'.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def list_image_tables(\n    self,\n    acquisition: int | None = None,\n    filter_types: str | None = None,\n    mode: Literal[\"common\", \"all\"] = \"common\",\n) -&gt; list[str]:\n    \"\"\"List all image tables in the image.\n\n    Args:\n        acquisition (int | None): The acquisition id to filter the images.\n        filter_types (str | None): The type of tables to filter. If None,\n            return all tables. Defaults to None.\n        mode (Literal[\"common\", \"all\"]): The mode to use for listing the tables.\n            If 'common', return only common tables between all images.\n            If 'all', return all tables. Defaults to 'common'.\n    \"\"\"\n    images = tuple(self.get_images(acquisition=acquisition).values())\n    return list_image_tables(\n        images=images,\n        filter_types=filter_types,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.list_image_tables_async","title":"list_image_tables_async  <code>async</code>","text":"<pre><code>list_image_tables_async(\n    acquisition: int | None = None,\n    filter_types: str | None = None,\n    mode: Literal[\"common\", \"all\"] = \"common\",\n) -&gt; list[str]\n</code></pre> <p>List all image tables in the image asynchronously.</p> <p>Parameters:</p> <ul> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> <li> <code>filter_types</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The type of tables to filter. If None, return all tables. Defaults to None.</p> </li> <li> <code>mode</code>               (<code>Literal['common', 'all']</code>, default:                   <code>'common'</code> )           \u2013            <p>The mode to use for listing the tables. If 'common', return only common tables between all images. If 'all', return all tables. Defaults to 'common'.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>async def list_image_tables_async(\n    self,\n    acquisition: int | None = None,\n    filter_types: str | None = None,\n    mode: Literal[\"common\", \"all\"] = \"common\",\n) -&gt; list[str]:\n    \"\"\"List all image tables in the image asynchronously.\n\n    Args:\n        acquisition (int | None): The acquisition id to filter the images.\n        filter_types (str | None): The type of tables to filter. If None,\n            return all tables. Defaults to None.\n        mode (Literal[\"common\", \"all\"]): The mode to use for listing the tables.\n            If 'common', return only common tables between all images.\n            If 'all', return all tables. Defaults to 'common'.\n    \"\"\"\n    images = await self.get_images_async(acquisition=acquisition)\n    images = tuple(images.values())\n    return await list_image_tables_async(\n        images=images,\n        filter_types=filter_types,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.concatenate_image_tables","title":"concatenate_image_tables","text":"<pre><code>concatenate_image_tables(\n    name: str,\n    acquisition: int | None = None,\n    strict: bool = True,\n    index_key: str | None = None,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; Table\n</code></pre> <p>Concatenate tables from all images in the plate.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table to concatenate.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The key to use for the index of the concatenated table.</p> </li> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, raise an error if the table is not found in the image.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>If a string is provided, a new index column will be created new_index_pattern = {row}{column}{path_in_well}_{label}</p> </li> <li> <code>mode</code>               (<code>Literal['eager', 'lazy']</code>, default:                   <code>'eager'</code> )           \u2013            <p>The mode to use for concatenation. Can be 'eager' or 'lazy'. if 'eager', the table will be loaded into memory. if 'lazy', the table will be loaded as a lazy frame.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def concatenate_image_tables(\n    self,\n    name: str,\n    acquisition: int | None = None,\n    strict: bool = True,\n    index_key: str | None = None,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; Table:\n    \"\"\"Concatenate tables from all images in the plate.\n\n    Args:\n        name: The name of the table to concatenate.\n        index_key: The key to use for the index of the concatenated table.\n        acquisition: The acquisition id to filter the images.\n        strict: If True, raise an error if the table is not found in the image.\n        index_key: If a string is provided, a new index column will be created\n            new_index_pattern = {row}_{column}_{path_in_well}_{label}\n        mode: The mode to use for concatenation. Can be 'eager' or 'lazy'.\n            if 'eager', the table will be loaded into memory.\n            if 'lazy', the table will be loaded as a lazy frame.\n    \"\"\"\n    images = self.get_images(acquisition=acquisition)\n    extras = _build_extras(tuple(images.keys()))\n    return concatenate_image_tables(\n        images=tuple(images.values()),\n        extras=extras,\n        name=name,\n        index_key=index_key,\n        strict=strict,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.concatenate_image_tables_as","title":"concatenate_image_tables_as","text":"<pre><code>concatenate_image_tables_as(\n    name: str,\n    table_cls: type[TableType],\n    acquisition: int | None = None,\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; TableType\n</code></pre> <p>Concatenate tables from all images in the plate as a specific type.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table to concatenate.</p> </li> <li> <code>table_cls</code>               (<code>type[TableType]</code>)           \u2013            <p>The type of the table to concatenate.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The key to use for the index of the concatenated table.</p> </li> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>If a string is provided, a new index column will be created new_index_pattern = {row}{column}{path_in_well}_{label}</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, raise an error if the table is not found in the image.</p> </li> <li> <code>mode</code>               (<code>Literal['eager', 'lazy']</code>, default:                   <code>'eager'</code> )           \u2013            <p>The mode to use for concatenation. Can be 'eager' or 'lazy'. if 'eager', the table will be loaded into memory. if 'lazy', the table will be loaded as a lazy frame.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def concatenate_image_tables_as(\n    self,\n    name: str,\n    table_cls: type[TableType],\n    acquisition: int | None = None,\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; TableType:\n    \"\"\"Concatenate tables from all images in the plate as a specific type.\n\n    Args:\n        name: The name of the table to concatenate.\n        table_cls: The type of the table to concatenate.\n        index_key: The key to use for the index of the concatenated table.\n        acquisition: The acquisition id to filter the images.\n        index_key: If a string is provided, a new index column will be created\n            new_index_pattern = {row}_{column}_{path_in_well}_{label}\n        strict: If True, raise an error if the table is not found in the image.\n        mode: The mode to use for concatenation. Can be 'eager' or 'lazy'.\n            if 'eager', the table will be loaded into memory.\n            if 'lazy', the table will be loaded as a lazy frame.\n    \"\"\"\n    images = self.get_images(acquisition=acquisition)\n    extras = _build_extras(tuple(images.keys()))\n    return concatenate_image_tables_as(\n        images=tuple(images.values()),\n        extras=extras,\n        name=name,\n        table_cls=table_cls,\n        index_key=index_key,\n        strict=strict,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.concatenate_image_tables_async","title":"concatenate_image_tables_async  <code>async</code>","text":"<pre><code>concatenate_image_tables_async(\n    name: str,\n    acquisition: int | None = None,\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; Table\n</code></pre> <p>Concatenate tables from all images in the plate asynchronously.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table to concatenate.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The key to use for the index of the concatenated table.</p> </li> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>If a string is provided, a new index column will be created new_index_pattern = {row}{column}{path_in_well}_{label}</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, raise an error if the table is not found in the image.</p> </li> <li> <code>mode</code>               (<code>Literal['eager', 'lazy']</code>, default:                   <code>'eager'</code> )           \u2013            <p>The mode to use for concatenation. Can be 'eager' or 'lazy'. if 'eager', the table will be loaded into memory. if 'lazy', the table will be loaded as a lazy frame.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>async def concatenate_image_tables_async(\n    self,\n    name: str,\n    acquisition: int | None = None,\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; Table:\n    \"\"\"Concatenate tables from all images in the plate asynchronously.\n\n    Args:\n        name: The name of the table to concatenate.\n        index_key: The key to use for the index of the concatenated table.\n        acquisition: The acquisition id to filter the images.\n        index_key: If a string is provided, a new index column will be created\n            new_index_pattern = {row}_{column}_{path_in_well}_{label}\n        strict: If True, raise an error if the table is not found in the image.\n        mode: The mode to use for concatenation. Can be 'eager' or 'lazy'.\n            if 'eager', the table will be loaded into memory.\n            if 'lazy', the table will be loaded as a lazy frame.\n    \"\"\"\n    images = await self.get_images_async(acquisition=acquisition)\n    extras = _build_extras(tuple(images.keys()))\n    return await concatenate_image_tables_async(\n        images=tuple(images.values()),\n        extras=extras,\n        name=name,\n        index_key=index_key,\n        strict=strict,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrPlate.concatenate_image_tables_as_async","title":"concatenate_image_tables_as_async  <code>async</code>","text":"<pre><code>concatenate_image_tables_as_async(\n    name: str,\n    table_cls: type[TableType],\n    acquisition: int | None = None,\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; TableType\n</code></pre> <p>Concatenate tables from all images in the plate as a specific type.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table to concatenate.</p> </li> <li> <code>table_cls</code>               (<code>type[TableType]</code>)           \u2013            <p>The type of the table to concatenate.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The key to use for the index of the concatenated table.</p> </li> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>If a string is provided, a new index column will be created new_index_pattern = {row}{column}{path_in_well}_{label}</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, raise an error if the table is not found in the image.</p> </li> <li> <code>mode</code>               (<code>Literal['eager', 'lazy']</code>, default:                   <code>'eager'</code> )           \u2013            <p>The mode to use for concatenation. Can be 'eager' or 'lazy'. if 'eager', the table will be loaded into memory. if 'lazy', the table will be loaded as a lazy frame.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>async def concatenate_image_tables_as_async(\n    self,\n    name: str,\n    table_cls: type[TableType],\n    acquisition: int | None = None,\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; TableType:\n    \"\"\"Concatenate tables from all images in the plate as a specific type.\n\n    Args:\n        name: The name of the table to concatenate.\n        table_cls: The type of the table to concatenate.\n        index_key: The key to use for the index of the concatenated table.\n        acquisition: The acquisition id to filter the images.\n        index_key: If a string is provided, a new index column will be created\n            new_index_pattern = {row}_{column}_{path_in_well}_{label}\n        strict: If True, raise an error if the table is not found in the image.\n        mode: The mode to use for concatenation. Can be 'eager' or 'lazy'.\n            if 'eager', the table will be loaded into memory.\n            if 'lazy', the table will be loaded as a lazy frame.\n    \"\"\"\n    images = await self.get_images_async(acquisition=acquisition)\n    extras = _build_extras(tuple(images.keys()))\n    return await concatenate_image_tables_as_async(\n        images=tuple(images.values()),\n        extras=extras,\n        name=name,\n        table_cls=table_cls,\n        index_key=index_key,\n        strict=strict,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrWell","title":"OmeZarrWell","text":"<pre><code>OmeZarrWell(group_handler: ZarrGroupHandler)\n</code></pre> <p>A class to handle the Well Sequence in an OME-Zarr file.</p> <p>Initialize the LabelGroupHandler.</p> <p>Parameters:</p> <ul> <li> <code>group_handler</code>               (<code>ZarrGroupHandler</code>)           \u2013            <p>The Zarr group handler that contains the Well.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def __init__(self, group_handler: ZarrGroupHandler) -&gt; None:\n    \"\"\"Initialize the LabelGroupHandler.\n\n    Args:\n        group_handler: The Zarr group handler that contains the Well.\n    \"\"\"\n    self._group_handler = group_handler\n    self._meta_handler = find_well_meta_handler(group_handler)\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrWell.meta_handler","title":"meta_handler  <code>property</code>","text":"<pre><code>meta_handler\n</code></pre> <p>Return the metadata handler.</p>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrWell.meta","title":"meta  <code>property</code>","text":"<pre><code>meta\n</code></pre> <p>Return the metadata.</p>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrWell.acquisition_ids","title":"acquisition_ids  <code>property</code>","text":"<pre><code>acquisition_ids: list[int]\n</code></pre> <p>Return the acquisitions ids in the well.</p>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrWell.paths","title":"paths","text":"<pre><code>paths(acquisition: int | None = None) -&gt; list[str]\n</code></pre> <p>Return the images paths in the well.</p> <p>If acquisition is None, return all images paths in the well. Else, return the images paths in the well for the given acquisition.</p> <p>Parameters:</p> <ul> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def paths(self, acquisition: int | None = None) -&gt; list[str]:\n    \"\"\"Return the images paths in the well.\n\n    If acquisition is None, return all images paths in the well.\n    Else, return the images paths in the well for the given acquisition.\n\n    Args:\n        acquisition (int | None): The acquisition id to filter the images.\n    \"\"\"\n    return self.meta.paths(acquisition)\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrWell.get_image_store","title":"get_image_store","text":"<pre><code>get_image_store(image_path: str) -&gt; StoreOrGroup\n</code></pre> <p>Get the image store from the well.</p> <p>Parameters:</p> <ul> <li> <code>image_path</code>               (<code>str</code>)           \u2013            <p>The path of the image.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_image_store(self, image_path: str) -&gt; StoreOrGroup:\n    \"\"\"Get the image store from the well.\n\n    Args:\n        image_path (str): The path of the image.\n    \"\"\"\n    return self._group_handler.get_group(image_path, create_mode=True)\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrWell.get_image_acquisition_id","title":"get_image_acquisition_id","text":"<pre><code>get_image_acquisition_id(image_path: str) -&gt; int | None\n</code></pre> <p>Get the acquisition id of an image in the well.</p> <p>Parameters:</p> <ul> <li> <code>image_path</code>               (<code>str</code>)           \u2013            <p>The path of the image.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int | None</code>           \u2013            <p>int | None: The acquisition id of the image.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_image_acquisition_id(self, image_path: str) -&gt; int | None:\n    \"\"\"Get the acquisition id of an image in the well.\n\n    Args:\n        image_path (str): The path of the image.\n\n    Returns:\n        int | None: The acquisition id of the image.\n    \"\"\"\n    return self.meta.get_image_acquisition_id(image_path=image_path)\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrWell.get_image","title":"get_image","text":"<pre><code>get_image(image_path: str) -&gt; OmeZarrContainer\n</code></pre> <p>Get an image from the well.</p> <p>Parameters:</p> <ul> <li> <code>image_path</code>               (<code>str</code>)           \u2013            <p>The path of the image.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OmeZarrContainer</code> (              <code>OmeZarrContainer</code> )          \u2013            <p>The image.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_image(self, image_path: str) -&gt; OmeZarrContainer:\n    \"\"\"Get an image from the well.\n\n    Args:\n        image_path (str): The path of the image.\n\n    Returns:\n        OmeZarrContainer: The image.\n    \"\"\"\n    handler = self._group_handler.derive_handler(image_path)\n    return OmeZarrContainer(handler)\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrWell.atomic_add_image","title":"atomic_add_image","text":"<pre><code>atomic_add_image(\n    image_path: str,\n    acquisition_id: int | None = None,\n    strict: bool = True,\n) -&gt; StoreOrGroup\n</code></pre> <p>Parallel safe version of add_image.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def atomic_add_image(\n    self,\n    image_path: str,\n    acquisition_id: int | None = None,\n    strict: bool = True,\n) -&gt; StoreOrGroup:\n    \"\"\"Parallel safe version of add_image.\"\"\"\n    return self._add_image(\n        image_path=image_path,\n        acquisition_id=acquisition_id,\n        atomic=True,\n        strict=strict,\n    )\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.OmeZarrWell.add_image","title":"add_image","text":"<pre><code>add_image(\n    image_path: str,\n    acquisition_id: int | None = None,\n    strict: bool = True,\n) -&gt; StoreOrGroup\n</code></pre> <p>Add an image to an ome-zarr well.</p> <p>Parameters:</p> <ul> <li> <code>image_path</code>               (<code>str</code>)           \u2013            <p>The path of the image.</p> </li> <li> <code>acquisition_id</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to check if the acquisition id is already exists in the well. Defaults to True. If False this might lead to acquisition in a well that does not exist at the plate level.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def add_image(\n    self,\n    image_path: str,\n    acquisition_id: int | None = None,\n    strict: bool = True,\n) -&gt; StoreOrGroup:\n    \"\"\"Add an image to an ome-zarr well.\n\n    Args:\n        image_path (str): The path of the image.\n        acquisition_id (int | None): The acquisition id to filter the images.\n        strict (bool): Whether to check if the acquisition id is already exists\n            in the well. Defaults to True. If False this might lead to\n            acquisition in a well that does not exist at the plate level.\n    \"\"\"\n    return self._add_image(\n        image_path=image_path,\n        acquisition_id=acquisition_id,\n        atomic=False,\n        strict=strict,\n    )\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.create_empty_plate","title":"create_empty_plate","text":"<pre><code>create_empty_plate(\n    store: StoreOrGroup,\n    name: str,\n    images: list[ImageInWellPath] | None = None,\n    version: NgffVersions = \"0.4\",\n    cache: bool = False,\n    overwrite: bool = False,\n    parallel_safe: bool = True,\n) -&gt; OmeZarrPlate\n</code></pre> <p>Initialize and create an empty OME-Zarr plate.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def create_empty_plate(\n    store: StoreOrGroup,\n    name: str,\n    images: list[ImageInWellPath] | None = None,\n    version: NgffVersions = \"0.4\",\n    cache: bool = False,\n    overwrite: bool = False,\n    parallel_safe: bool = True,\n) -&gt; OmeZarrPlate:\n    \"\"\"Initialize and create an empty OME-Zarr plate.\"\"\"\n    plate_meta = NgioPlateMeta.default_init(\n        name=name,\n        version=version,\n    )\n    group_handler = _create_empty_plate_from_meta(\n        store=store,\n        meta=plate_meta,\n        version=version,\n        overwrite=overwrite,\n    )\n\n    if images is not None:\n        plate = OmeZarrPlate(group_handler)\n        for image in images:\n            plate.add_image(\n                row=image.row,\n                column=image.column,\n                image_path=image.path,\n                acquisition_id=image.acquisition_id,\n                acquisition_name=image.acquisition_name,\n            )\n    return open_ome_zarr_plate(\n        store=store,\n        cache=cache,\n        mode=\"r+\",\n        parallel_safe=parallel_safe,\n    )\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.create_empty_well","title":"create_empty_well","text":"<pre><code>create_empty_well(\n    store: StoreOrGroup,\n    version: NgffVersions = \"0.4\",\n    cache: bool = False,\n    overwrite: bool = False,\n    parallel_safe: bool = True,\n) -&gt; OmeZarrWell\n</code></pre> <p>Create an empty OME-Zarr well.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group that stores the well.</p> </li> <li> <code>version</code>               (<code>NgffVersion</code>, default:                   <code>'0.4'</code> )           \u2013            <p>The version of the new well.</p> </li> <li> <code>cache</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use a cache for the zarr group metadata.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to overwrite the existing well.</p> </li> <li> <code>parallel_safe</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the group handler is parallel safe.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def create_empty_well(\n    store: StoreOrGroup,\n    version: NgffVersions = \"0.4\",\n    cache: bool = False,\n    overwrite: bool = False,\n    parallel_safe: bool = True,\n) -&gt; OmeZarrWell:\n    \"\"\"Create an empty OME-Zarr well.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group that stores the well.\n        version (NgffVersion): The version of the new well.\n        cache (bool): Whether to use a cache for the zarr group metadata.\n        overwrite (bool): Whether to overwrite the existing well.\n        parallel_safe (bool): Whether the group handler is parallel safe.\n    \"\"\"\n    group_handler = ZarrGroupHandler(\n        store=store, cache=True, mode=\"w\" if overwrite else \"w-\", parallel_safe=False\n    )\n    meta_handler = get_well_meta_handler(group_handler, version=version)\n    meta = NgioWellMeta.default_init()\n    meta_handler.write_meta(meta)\n\n    return open_ome_zarr_well(\n        store=store,\n        cache=cache,\n        mode=\"r+\",\n        parallel_safe=parallel_safe,\n    )\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.open_ome_zarr_plate","title":"open_ome_zarr_plate","text":"<pre><code>open_ome_zarr_plate(\n    store: StoreOrGroup,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n    parallel_safe: bool = True,\n) -&gt; OmeZarrPlate\n</code></pre> <p>Open an OME-Zarr plate.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group that stores the plate.</p> </li> <li> <code>cache</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use a cache for the zarr group metadata.</p> </li> <li> <code>mode</code>               (<code>AccessModeLiteral</code>, default:                   <code>'r+'</code> )           \u2013            <p>The access mode for the image. Defaults to \"r+\".</p> </li> <li> <code>parallel_safe</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the group handler is parallel safe.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def open_ome_zarr_plate(\n    store: StoreOrGroup,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n    parallel_safe: bool = True,\n) -&gt; OmeZarrPlate:\n    \"\"\"Open an OME-Zarr plate.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group that stores the plate.\n        cache (bool): Whether to use a cache for the zarr group metadata.\n        mode (AccessModeLiteral): The\n            access mode for the image. Defaults to \"r+\".\n        parallel_safe (bool): Whether the group handler is parallel safe.\n    \"\"\"\n    group_handler = ZarrGroupHandler(\n        store=store, cache=cache, mode=mode, parallel_safe=parallel_safe\n    )\n    return OmeZarrPlate(group_handler)\n</code></pre>"},{"location":"api/ngio/hcs/#ngio.hcs.open_ome_zarr_well","title":"open_ome_zarr_well","text":"<pre><code>open_ome_zarr_well(\n    store: StoreOrGroup,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n    parallel_safe: bool = True,\n) -&gt; OmeZarrWell\n</code></pre> <p>Open an OME-Zarr well.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group that stores the plate.</p> </li> <li> <code>cache</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use a cache for the zarr group metadata.</p> </li> <li> <code>mode</code>               (<code>AccessModeLiteral</code>, default:                   <code>'r+'</code> )           \u2013            <p>The access mode for the image. Defaults to \"r+\".</p> </li> <li> <code>parallel_safe</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the group handler is parallel safe.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def open_ome_zarr_well(\n    store: StoreOrGroup,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n    parallel_safe: bool = True,\n) -&gt; OmeZarrWell:\n    \"\"\"Open an OME-Zarr well.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group that stores the plate.\n        cache (bool): Whether to use a cache for the zarr group metadata.\n        mode (AccessModeLiteral): The access mode for the image. Defaults to \"r+\".\n        parallel_safe (bool): Whether the group handler is parallel safe.\n    \"\"\"\n    group_handler = ZarrGroupHandler(\n        store=store, cache=cache, mode=mode, parallel_safe=parallel_safe\n    )\n    return OmeZarrWell(group_handler)\n</code></pre>"},{"location":"api/ngio/images/","title":"ngio.images API documentation","text":""},{"location":"api/ngio/images/#ngio.images","title":"ngio.images","text":"<p>OME-Zarr object models.</p>"},{"location":"api/ngio/images/#ngio.images.ChannelSelectionModel","title":"ChannelSelectionModel","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for channel selection.</p> <p>This model is used to select a channel by label, wavelength ID, or index.</p> <p>Parameters:</p> <ul> <li> <code>identifier</code>               (<code>str</code>)           \u2013            <p>Unique identifier for the channel. This can be a channel label, wavelength ID, or index.</p> </li> <li> <code>mode</code>               (<code>Literal['label', 'wavelength_id', 'index']</code>)           \u2013            <p>Specifies how to interpret the identifier. Can be \"label\", \"wavelength_id\", or \"index\" (must be an integer).</p> </li> </ul>"},{"location":"api/ngio/images/#ngio.images.ChannelSelectionModel.mode","title":"mode  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mode: Literal['label', 'wavelength_id', 'index'] = 'label'\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.ChannelSelectionModel.identifier","title":"identifier  <code>instance-attribute</code>","text":"<pre><code>identifier: str\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.ChannelSelectionModel.check_channel_selection","title":"check_channel_selection","text":"<pre><code>check_channel_selection()\n</code></pre> Source code in <code>ngio/images/_image.py</code> <pre><code>@model_validator(mode=\"after\")\ndef check_channel_selection(self):\n    if self.mode == \"index\":\n        try:\n            int(self.identifier)\n        except ValueError as e:\n            raise ValueError(\n                \"Identifier must be an integer when mode is 'index'\"\n            ) from e\n    return self\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Image","title":"Image","text":"<pre><code>Image(\n    group_handler: ZarrGroupHandler,\n    path: str,\n    meta_handler: ImageMetaHandler | None,\n)\n</code></pre> <p>               Bases: <code>AbstractImage[ImageMetaHandler]</code></p> <p>A class to handle a single image (or level) in an OME-Zarr image.</p> <p>This class is meant to be subclassed by specific image types.</p> <p>Initialize the Image at a single level.</p> <p>Parameters:</p> <ul> <li> <code>group_handler</code>               (<code>ZarrGroupHandler</code>)           \u2013            <p>The Zarr group handler.</p> </li> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path to the image in the ome_zarr file.</p> </li> <li> <code>meta_handler</code>               (<code>ImageMetaHandler | None</code>)           \u2013            <p>The image metadata handler.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def __init__(\n    self,\n    group_handler: ZarrGroupHandler,\n    path: str,\n    meta_handler: ImageMetaHandler | None,\n) -&gt; None:\n    \"\"\"Initialize the Image at a single level.\n\n    Args:\n        group_handler: The Zarr group handler.\n        path: The path to the image in the ome_zarr file.\n        meta_handler: The image metadata handler.\n\n    \"\"\"\n    if meta_handler is None:\n        meta_handler = find_image_meta_handler(group_handler)\n    super().__init__(\n        group_handler=group_handler, path=path, meta_handler=meta_handler\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Image.meta_handler","title":"meta_handler  <code>property</code>","text":"<pre><code>meta_handler: _image_handler\n</code></pre> <p>Return the metadata.</p>"},{"location":"api/ngio/images/#ngio.images.Image.zarr_array","title":"zarr_array  <code>property</code>","text":"<pre><code>zarr_array: Array\n</code></pre> <p>Return the Zarr array.</p>"},{"location":"api/ngio/images/#ngio.images.Image.shape","title":"shape  <code>property</code>","text":"<pre><code>shape: tuple[int, ...]\n</code></pre> <p>Return the shape of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Image.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype: str\n</code></pre> <p>Return the dtype of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Image.chunks","title":"chunks  <code>property</code>","text":"<pre><code>chunks: tuple[int, ...]\n</code></pre> <p>Return the chunks of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Image.dimensions","title":"dimensions  <code>property</code>","text":"<pre><code>dimensions: Dimensions\n</code></pre> <p>Return the dimensions of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Image.axes_mapper","title":"axes_mapper  <code>property</code>","text":"<pre><code>axes_mapper: AxesHandler\n</code></pre> <p>Return the axes mapper of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Image.is_3d","title":"is_3d  <code>property</code>","text":"<pre><code>is_3d: bool\n</code></pre> <p>Return True if the image is 3D.</p>"},{"location":"api/ngio/images/#ngio.images.Image.is_2d","title":"is_2d  <code>property</code>","text":"<pre><code>is_2d: bool\n</code></pre> <p>Return True if the image is 2D.</p>"},{"location":"api/ngio/images/#ngio.images.Image.is_time_series","title":"is_time_series  <code>property</code>","text":"<pre><code>is_time_series: bool\n</code></pre> <p>Return True if the image is a time series.</p>"},{"location":"api/ngio/images/#ngio.images.Image.is_2d_time_series","title":"is_2d_time_series  <code>property</code>","text":"<pre><code>is_2d_time_series: bool\n</code></pre> <p>Return True if the image is a 2D time series.</p>"},{"location":"api/ngio/images/#ngio.images.Image.is_3d_time_series","title":"is_3d_time_series  <code>property</code>","text":"<pre><code>is_3d_time_series: bool\n</code></pre> <p>Return True if the image is a 3D time series.</p>"},{"location":"api/ngio/images/#ngio.images.Image.is_multi_channels","title":"is_multi_channels  <code>property</code>","text":"<pre><code>is_multi_channels: bool\n</code></pre> <p>Return True if the image is multichannel.</p>"},{"location":"api/ngio/images/#ngio.images.Image.space_unit","title":"space_unit  <code>property</code>","text":"<pre><code>space_unit: str | None\n</code></pre> <p>Return the space unit of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Image.time_unit","title":"time_unit  <code>property</code>","text":"<pre><code>time_unit: str | None\n</code></pre> <p>Return the time unit of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Image.pixel_size","title":"pixel_size  <code>property</code>","text":"<pre><code>pixel_size: PixelSize\n</code></pre> <p>Return the pixel size of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Image.dataset","title":"dataset  <code>property</code>","text":"<pre><code>dataset: Dataset\n</code></pre> <p>Return the dataset of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Image.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Return the path of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Image.meta","title":"meta  <code>property</code>","text":"<pre><code>meta: NgioImageMeta\n</code></pre> <p>Return the metadata.</p>"},{"location":"api/ngio/images/#ngio.images.Image.channels_meta","title":"channels_meta  <code>property</code>","text":"<pre><code>channels_meta: ChannelsMeta\n</code></pre> <p>Return the channels metadata.</p>"},{"location":"api/ngio/images/#ngio.images.Image.channel_labels","title":"channel_labels  <code>property</code>","text":"<pre><code>channel_labels: list[str]\n</code></pre> <p>Return the channels of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Image.wavelength_ids","title":"wavelength_ids  <code>property</code>","text":"<pre><code>wavelength_ids: list[str | None]\n</code></pre> <p>Return the list of wavelength of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Image.num_channels","title":"num_channels  <code>property</code>","text":"<pre><code>num_channels: int\n</code></pre> <p>Return the number of channels.</p>"},{"location":"api/ngio/images/#ngio.images.Image.has_axis","title":"has_axis","text":"<pre><code>has_axis(axis: str) -&gt; bool\n</code></pre> <p>Return True if the image has the given axis.</p> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def has_axis(self, axis: str) -&gt; bool:\n    \"\"\"Return True if the image has the given axis.\"\"\"\n    self.axes_mapper.get_index(\"x\")\n    return self.dimensions.has_axis(axis)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Image.build_image_roi_table","title":"build_image_roi_table","text":"<pre><code>build_image_roi_table(\n    name: str | None = \"image\",\n) -&gt; RoiTable\n</code></pre> <p>Build the ROI table for an image.</p> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def build_image_roi_table(self, name: str | None = \"image\") -&gt; RoiTable:\n    \"\"\"Build the ROI table for an image.\"\"\"\n    return build_image_roi_table(image=self, name=name)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Image.assert_dimensions_match","title":"assert_dimensions_match","text":"<pre><code>assert_dimensions_match(\n    other: AbstractImage, allow_singleton: bool = False\n) -&gt; None\n</code></pre> <p>Assert that two images have matching spatial dimensions.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>AbstractImage</code>)           \u2013            <p>The other image to compare to.</p> </li> <li> <code>allow_singleton</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, allow singleton dimensions to be compatible with non-singleton dimensions.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NgioValueError</code>             \u2013            <p>If the images do not have compatible dimensions.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def assert_dimensions_match(\n    self,\n    other: \"AbstractImage\",\n    allow_singleton: bool = False,\n) -&gt; None:\n    \"\"\"Assert that two images have matching spatial dimensions.\n\n    Args:\n        other: The other image to compare to.\n        allow_singleton: If True, allow singleton dimensions to be\n            compatible with non-singleton dimensions.\n\n    Raises:\n        NgioValueError: If the images do not have compatible dimensions.\n    \"\"\"\n    assert_dimensions_match(\n        image1=self, image2=other, allow_singleton=allow_singleton\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Image.assert_axes_match","title":"assert_axes_match","text":"<pre><code>assert_axes_match(other: AbstractImage) -&gt; None\n</code></pre> <p>Assert that two images have compatible axes.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>AbstractImage</code>)           \u2013            <p>The other image to compare to.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NgioValueError</code>             \u2013            <p>If the images do not have compatible axes.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def assert_axes_match(\n    self,\n    other: \"AbstractImage\",\n) -&gt; None:\n    \"\"\"Assert that two images have compatible axes.\n\n    Args:\n        other: The other image to compare to.\n\n    Raises:\n        NgioValueError: If the images do not have compatible axes.\n    \"\"\"\n    assert_axes_match(image1=self, image2=other)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Image.assert_can_be_rescaled","title":"assert_can_be_rescaled","text":"<pre><code>assert_can_be_rescaled(other: AbstractImage) -&gt; None\n</code></pre> <p>Assert that two images can be rescaled to each other.</p> <p>For this to be true, the images must have the same axes, and the pixel sizes must be compatible (i.e. one can be scaled to the other).</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>AbstractImage</code>)           \u2013            <p>The other image to compare to.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NgioValueError</code>             \u2013            <p>If the images cannot be scaled to each other.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def assert_can_be_rescaled(\n    self,\n    other: \"AbstractImage\",\n) -&gt; None:\n    \"\"\"Assert that two images can be rescaled to each other.\n\n    For this to be true, the images must have the same axes, and\n    the pixel sizes must be compatible (i.e. one can be scaled to the other).\n\n    Args:\n        other: The other image to compare to.\n\n    Raises:\n        NgioValueError: If the images cannot be scaled to each other.\n    \"\"\"\n    assert_can_be_rescaled(image1=self, image2=other)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Image.get_channel_idx","title":"get_channel_idx","text":"<pre><code>get_channel_idx(\n    channel_label: str | None = None,\n    wavelength_id: str | None = None,\n) -&gt; int\n</code></pre> <p>Get the index of a channel by its label or wavelength ID.</p> Source code in <code>ngio/images/_image.py</code> <pre><code>def get_channel_idx(\n    self, channel_label: str | None = None, wavelength_id: str | None = None\n) -&gt; int:\n    \"\"\"Get the index of a channel by its label or wavelength ID.\"\"\"\n    return self.channels_meta.get_channel_idx(\n        channel_label=channel_label, wavelength_id=wavelength_id\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Image.get_as_numpy","title":"get_as_numpy","text":"<pre><code>get_as_numpy(\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: slice | int | Sequence[int] | None,\n) -&gt; ndarray\n</code></pre> <p>Get the image as a numpy array.</p> <p>Parameters:</p> <ul> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Select a specific channel by label. If None, all channels are returned. Alternatively, you can slice arbitrary channels using the slice_kwargs (c=[0, 2]).</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The order of the axes to return the array.</p> </li> <li> <code>transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>The transforms to apply to the array.</p> </li> <li> <code>**slicing_kwargs</code>               (<code>slice | int | Sequence[int] | None</code>, default:                   <code>{}</code> )           \u2013            <p>The slices to get the array.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The array of the region of interest.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def get_as_numpy(\n    self,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: slice | int | Sequence[int] | None,\n) -&gt; np.ndarray:\n    \"\"\"Get the image as a numpy array.\n\n    Args:\n        channel_selection: Select a specific channel by label.\n            If None, all channels are returned.\n            Alternatively, you can slice arbitrary channels\n            using the slice_kwargs (c=[0, 2]).\n        axes_order: The order of the axes to return the array.\n        transforms: The transforms to apply to the array.\n        **slicing_kwargs: The slices to get the array.\n\n    Returns:\n        The array of the region of interest.\n    \"\"\"\n    _slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self, channel_selection=channel_selection, slicing_dict=slicing_kwargs\n    )\n    return self._get_as_numpy(\n        axes_order=axes_order, transforms=transforms, **_slicing_kwargs\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Image.get_roi_as_numpy","title":"get_roi_as_numpy","text":"<pre><code>get_roi_as_numpy(\n    roi: Roi | RoiPixels,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; ndarray\n</code></pre> <p>Get the image as a numpy array for a region of interest.</p> <p>Parameters:</p> <ul> <li> <code>roi</code>               (<code>Roi | RoiPixels</code>)           \u2013            <p>The region of interest to get the array.</p> </li> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Select a what subset of channels to return. If None, all channels are returned.</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The order of the axes to return the array.</p> </li> <li> <code>transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>The transforms to apply to the array.</p> </li> <li> <code>**slicing_kwargs</code>               (<code>SlicingInputType</code>, default:                   <code>{}</code> )           \u2013            <p>The slices to get the array.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The array of the region of interest.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def get_roi_as_numpy(\n    self,\n    roi: Roi | RoiPixels,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; np.ndarray:\n    \"\"\"Get the image as a numpy array for a region of interest.\n\n    Args:\n        roi: The region of interest to get the array.\n        channel_selection: Select a what subset of channels to return.\n            If None, all channels are returned.\n        axes_order: The order of the axes to return the array.\n        transforms: The transforms to apply to the array.\n        **slicing_kwargs: The slices to get the array.\n\n    Returns:\n        The array of the region of interest.\n    \"\"\"\n    _slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self, channel_selection=channel_selection, slicing_dict=slicing_kwargs\n    )\n    return self._get_roi_as_numpy(\n        roi=roi, axes_order=axes_order, transforms=transforms, **_slicing_kwargs\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Image.get_as_dask","title":"get_as_dask","text":"<pre><code>get_as_dask(\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; Array\n</code></pre> <p>Get the image as a dask array.</p> <p>Parameters:</p> <ul> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Select a what subset of channels to return. If None, all channels are returned.</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The order of the axes to return the array.</p> </li> <li> <code>transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>The transforms to apply to the array.</p> </li> <li> <code>**slicing_kwargs</code>               (<code>SlicingInputType</code>, default:                   <code>{}</code> )           \u2013            <p>The slices to get the array.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array</code>           \u2013            <p>The dask array of the region of interest.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def get_as_dask(\n    self,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; da.Array:\n    \"\"\"Get the image as a dask array.\n\n    Args:\n        channel_selection: Select a what subset of channels to return.\n            If None, all channels are returned.\n        axes_order: The order of the axes to return the array.\n        transforms: The transforms to apply to the array.\n        **slicing_kwargs: The slices to get the array.\n\n    Returns:\n        The dask array of the region of interest.\n    \"\"\"\n    _slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self, channel_selection=channel_selection, slicing_dict=slicing_kwargs\n    )\n    return self._get_as_dask(\n        axes_order=axes_order, transforms=transforms, **_slicing_kwargs\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Image.get_roi_as_dask","title":"get_roi_as_dask","text":"<pre><code>get_roi_as_dask(\n    roi: Roi | RoiPixels,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; Array\n</code></pre> <p>Get the image as a dask array for a region of interest.</p> <p>Parameters:</p> <ul> <li> <code>roi</code>               (<code>Roi | RoiPixels</code>)           \u2013            <p>The region of interest to get the array.</p> </li> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Select a what subset of channels to return. If None, all channels are returned.</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The order of the axes to return the array.</p> </li> <li> <code>transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>The transforms to apply to the array.</p> </li> <li> <code>**slicing_kwargs</code>               (<code>SlicingInputType</code>, default:                   <code>{}</code> )           \u2013            <p>The slices to get the array.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array</code>           \u2013            <p>The dask array of the region of interest.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def get_roi_as_dask(\n    self,\n    roi: Roi | RoiPixels,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; da.Array:\n    \"\"\"Get the image as a dask array for a region of interest.\n\n    Args:\n        roi: The region of interest to get the array.\n        channel_selection: Select a what subset of channels to return.\n            If None, all channels are returned.\n        axes_order: The order of the axes to return the array.\n        transforms: The transforms to apply to the array.\n        **slicing_kwargs: The slices to get the array.\n\n    Returns:\n        The dask array of the region of interest.\n    \"\"\"\n    _slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self, channel_selection=channel_selection, slicing_dict=slicing_kwargs\n    )\n    return self._get_roi_as_dask(\n        roi=roi, axes_order=axes_order, transforms=transforms, **_slicing_kwargs\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Image.get_array","title":"get_array","text":"<pre><code>get_array(\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    mode: Literal[\"numpy\", \"dask\"] = \"numpy\",\n    **slicing_kwargs: SlicingInputType,\n) -&gt; ndarray | Array\n</code></pre> <p>Get the image as a zarr array.</p> <p>Parameters:</p> <ul> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Select a what subset of channels to return. If None, all channels are returned.</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The order of the axes to return the array.</p> </li> <li> <code>transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>The transforms to apply to the array.</p> </li> <li> <code>mode</code>               (<code>Literal['numpy', 'dask']</code>, default:                   <code>'numpy'</code> )           \u2013            <p>The object type to return. Can be \"dask\", \"numpy\".</p> </li> <li> <code>**slicing_kwargs</code>               (<code>SlicingInputType</code>, default:                   <code>{}</code> )           \u2013            <p>The slices to get the array.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray | Array</code>           \u2013            <p>The zarr array of the region of interest.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def get_array(\n    self,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    mode: Literal[\"numpy\", \"dask\"] = \"numpy\",\n    **slicing_kwargs: SlicingInputType,\n) -&gt; np.ndarray | da.Array:\n    \"\"\"Get the image as a zarr array.\n\n    Args:\n        channel_selection: Select a what subset of channels to return.\n            If None, all channels are returned.\n        axes_order: The order of the axes to return the array.\n        transforms: The transforms to apply to the array.\n        mode: The object type to return.\n            Can be \"dask\", \"numpy\".\n        **slicing_kwargs: The slices to get the array.\n\n    Returns:\n        The zarr array of the region of interest.\n    \"\"\"\n    _slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self, channel_selection=channel_selection, slicing_dict=slicing_kwargs\n    )\n    return self._get_array(\n        axes_order=axes_order, mode=mode, transforms=transforms, **_slicing_kwargs\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Image.get_roi","title":"get_roi","text":"<pre><code>get_roi(\n    roi: Roi | RoiPixels,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    mode: Literal[\"numpy\", \"dask\"] = \"numpy\",\n    **slicing_kwargs: SlicingInputType,\n) -&gt; ndarray | Array\n</code></pre> <p>Get the image as a zarr array for a region of interest.</p> <p>Parameters:</p> <ul> <li> <code>roi</code>               (<code>Roi | RoiPixels</code>)           \u2013            <p>The region of interest to get the array.</p> </li> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Select a what subset of channels to return. If None, all channels are returned.</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The order of the axes to return the array.</p> </li> <li> <code>transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>The transforms to apply to the array.</p> </li> <li> <code>mode</code>               (<code>Literal['numpy', 'dask']</code>, default:                   <code>'numpy'</code> )           \u2013            <p>The object type to return. Can be \"dask\", \"numpy\".</p> </li> <li> <code>**slicing_kwargs</code>               (<code>SlicingInputType</code>, default:                   <code>{}</code> )           \u2013            <p>The slices to get the array.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray | Array</code>           \u2013            <p>The zarr array of the region of interest.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def get_roi(\n    self,\n    roi: Roi | RoiPixels,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    mode: Literal[\"numpy\", \"dask\"] = \"numpy\",\n    **slicing_kwargs: SlicingInputType,\n) -&gt; np.ndarray | da.Array:\n    \"\"\"Get the image as a zarr array for a region of interest.\n\n    Args:\n        roi: The region of interest to get the array.\n        channel_selection: Select a what subset of channels to return.\n            If None, all channels are returned.\n        axes_order: The order of the axes to return the array.\n        transforms: The transforms to apply to the array.\n        mode: The object type to return.\n            Can be \"dask\", \"numpy\".\n        **slicing_kwargs: The slices to get the array.\n\n    Returns:\n        The zarr array of the region of interest.\n    \"\"\"\n    _slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self, channel_selection=channel_selection, slicing_dict=slicing_kwargs\n    )\n    return self._get_roi(\n        roi=roi,\n        axes_order=axes_order,\n        mode=mode,\n        transforms=transforms,\n        **_slicing_kwargs,\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Image.set_array","title":"set_array","text":"<pre><code>set_array(\n    patch: ndarray | Array,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; None\n</code></pre> <p>Set the image array.</p> <p>Parameters:</p> <ul> <li> <code>patch</code>               (<code>ndarray | Array</code>)           \u2013            <p>The array to set.</p> </li> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Select a what subset of channels to return. If None, all channels are set.</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The order of the axes to set the array.</p> </li> <li> <code>transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>The transforms to apply to the array.</p> </li> <li> <code>**slicing_kwargs</code>               (<code>SlicingInputType</code>, default:                   <code>{}</code> )           \u2013            <p>The slices to set the array.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def set_array(\n    self,\n    patch: np.ndarray | da.Array,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; None:\n    \"\"\"Set the image array.\n\n    Args:\n        patch: The array to set.\n        channel_selection: Select a what subset of channels to return.\n            If None, all channels are set.\n        axes_order: The order of the axes to set the array.\n        transforms: The transforms to apply to the array.\n        **slicing_kwargs: The slices to set the array.\n    \"\"\"\n    _slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self, channel_selection=channel_selection, slicing_dict=slicing_kwargs\n    )\n    self._set_array(\n        patch=patch, axes_order=axes_order, transforms=transforms, **_slicing_kwargs\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Image.set_roi","title":"set_roi","text":"<pre><code>set_roi(\n    roi: Roi | RoiPixels,\n    patch: ndarray | Array,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; None\n</code></pre> <p>Set the image array for a region of interest.</p> <p>Parameters:</p> <ul> <li> <code>roi</code>               (<code>Roi | RoiPixels</code>)           \u2013            <p>The region of interest to set the array.</p> </li> <li> <code>patch</code>               (<code>ndarray | Array</code>)           \u2013            <p>The array to set.</p> </li> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Select a what subset of channels to return.</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The order of the axes to set the array.</p> </li> <li> <code>transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>The transforms to apply to the array.</p> </li> <li> <code>**slicing_kwargs</code>               (<code>SlicingInputType</code>, default:                   <code>{}</code> )           \u2013            <p>The slices to set the array.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def set_roi(\n    self,\n    roi: Roi | RoiPixels,\n    patch: np.ndarray | da.Array,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; None:\n    \"\"\"Set the image array for a region of interest.\n\n    Args:\n        roi: The region of interest to set the array.\n        patch: The array to set.\n        channel_selection: Select a what subset of channels to return.\n        axes_order: The order of the axes to set the array.\n        transforms: The transforms to apply to the array.\n        **slicing_kwargs: The slices to set the array.\n    \"\"\"\n    _slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self, channel_selection=channel_selection, slicing_dict=slicing_kwargs\n    )\n    self._set_roi(\n        roi=roi,\n        patch=patch,\n        axes_order=axes_order,\n        transforms=transforms,\n        **_slicing_kwargs,\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Image.consolidate","title":"consolidate","text":"<pre><code>consolidate(\n    order: InterpolationOrder = \"linear\",\n    mode: Literal[\"dask\", \"numpy\", \"coarsen\"] = \"dask\",\n) -&gt; None\n</code></pre> <p>Consolidate the label on disk.</p> Source code in <code>ngio/images/_image.py</code> <pre><code>def consolidate(\n    self,\n    order: InterpolationOrder = \"linear\",\n    mode: Literal[\"dask\", \"numpy\", \"coarsen\"] = \"dask\",\n) -&gt; None:\n    \"\"\"Consolidate the label on disk.\"\"\"\n    self._consolidate(order=order, mode=mode)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.ImagesContainer","title":"ImagesContainer","text":"<pre><code>ImagesContainer(group_handler: ZarrGroupHandler)\n</code></pre> <p>A class to handle the /labels group in an OME-NGFF file.</p> <p>Initialize the LabelGroupHandler.</p> Source code in <code>ngio/images/_image.py</code> <pre><code>def __init__(self, group_handler: ZarrGroupHandler) -&gt; None:\n    \"\"\"Initialize the LabelGroupHandler.\"\"\"\n    self._group_handler = group_handler\n    self._meta_handler = find_image_meta_handler(group_handler)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.ImagesContainer.meta","title":"meta  <code>property</code>","text":"<pre><code>meta: NgioImageMeta\n</code></pre> <p>Return the metadata.</p>"},{"location":"api/ngio/images/#ngio.images.ImagesContainer.levels","title":"levels  <code>property</code>","text":"<pre><code>levels: int\n</code></pre> <p>Return the number of levels in the image.</p>"},{"location":"api/ngio/images/#ngio.images.ImagesContainer.levels_paths","title":"levels_paths  <code>property</code>","text":"<pre><code>levels_paths: list[str]\n</code></pre> <p>Return the paths of the levels in the image.</p>"},{"location":"api/ngio/images/#ngio.images.ImagesContainer.num_channels","title":"num_channels  <code>property</code>","text":"<pre><code>num_channels: int\n</code></pre> <p>Return the number of channels.</p>"},{"location":"api/ngio/images/#ngio.images.ImagesContainer.channel_labels","title":"channel_labels  <code>property</code>","text":"<pre><code>channel_labels: list[str]\n</code></pre> <p>Return the channels of the image.</p>"},{"location":"api/ngio/images/#ngio.images.ImagesContainer.wavelength_ids","title":"wavelength_ids  <code>property</code>","text":"<pre><code>wavelength_ids: list[str | None]\n</code></pre> <p>Return the wavelength of the image.</p>"},{"location":"api/ngio/images/#ngio.images.ImagesContainer.get_channel_idx","title":"get_channel_idx","text":"<pre><code>get_channel_idx(\n    channel_label: str | None = None,\n    wavelength_id: str | None = None,\n) -&gt; int\n</code></pre> <p>Get the index of a channel by label or wavelength ID.</p> <p>Parameters:</p> <ul> <li> <code>channel_label</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The label of the channel. If None a wavelength ID must be provided.</p> </li> <li> <code>wavelength_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The wavelength ID of the channel. If None a channel label must be provided.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>The index of the channel.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def get_channel_idx(\n    self, channel_label: str | None = None, wavelength_id: str | None = None\n) -&gt; int:\n    \"\"\"Get the index of a channel by label or wavelength ID.\n\n    Args:\n        channel_label (str | None): The label of the channel.\n            If None a wavelength ID must be provided.\n        wavelength_id (str | None): The wavelength ID of the channel.\n            If None a channel label must be provided.\n\n    Returns:\n        int: The index of the channel.\n\n    \"\"\"\n    image = self.get()\n    return image.get_channel_idx(\n        channel_label=channel_label, wavelength_id=wavelength_id\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.ImagesContainer.set_channel_meta","title":"set_channel_meta","text":"<pre><code>set_channel_meta(\n    labels: Sequence[str | None] | int | None = None,\n    wavelength_id: Sequence[str | None] | None = None,\n    start: Sequence[float | None] | None = None,\n    end: Sequence[float | None] | None = None,\n    percentiles: tuple[float, float] | None = None,\n    colors: Sequence[str | None] | None = None,\n    active: Sequence[bool | None] | None = None,\n    **omero_kwargs: dict,\n) -&gt; None\n</code></pre> <p>Create a ChannelsMeta object with the default unit.</p> <p>Parameters:</p> <ul> <li> <code>labels</code>               (<code>Sequence[str | None] | int</code>, default:                   <code>None</code> )           \u2013            <p>The list of channels names in the image. If an integer is provided, the channels will be named \"channel_i\".</p> </li> <li> <code>wavelength_id</code>               (<code>Sequence[str | None]</code>, default:                   <code>None</code> )           \u2013            <p>The wavelength ID of the channel. If None, the wavelength ID will be the same as the channel name.</p> </li> <li> <code>start</code>               (<code>Sequence[float | None]</code>, default:                   <code>None</code> )           \u2013            <p>The start value for each channel. If None, the start value will be computed from the image.</p> </li> <li> <code>end</code>               (<code>Sequence[float | None]</code>, default:                   <code>None</code> )           \u2013            <p>The end value for each channel. If None, the end value will be computed from the image.</p> </li> <li> <code>percentiles</code>               (<code>tuple[float, float] | None</code>, default:                   <code>None</code> )           \u2013            <p>The start and end percentiles for each channel. If None, the percentiles will not be computed.</p> </li> <li> <code>colors</code>               (<code>Sequence[str | None]</code>, default:                   <code>None</code> )           \u2013            <p>The list of colors for the channels. If None, the colors will be random.</p> </li> <li> <code>active</code>               (<code>Sequence[bool | None]</code>, default:                   <code>None</code> )           \u2013            <p>Whether the channel should be shown by default.</p> </li> <li> <code>omero_kwargs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Extra fields to store in the omero attributes.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def set_channel_meta(\n    self,\n    labels: Sequence[str | None] | int | None = None,\n    wavelength_id: Sequence[str | None] | None = None,\n    start: Sequence[float | None] | None = None,\n    end: Sequence[float | None] | None = None,\n    percentiles: tuple[float, float] | None = None,\n    colors: Sequence[str | None] | None = None,\n    active: Sequence[bool | None] | None = None,\n    **omero_kwargs: dict,\n) -&gt; None:\n    \"\"\"Create a ChannelsMeta object with the default unit.\n\n    Args:\n        labels(Sequence[str | None] | int): The list of channels names\n            in the image. If an integer is provided, the channels will\n            be named \"channel_i\".\n        wavelength_id(Sequence[str | None]): The wavelength ID of the channel.\n            If None, the wavelength ID will be the same as the channel name.\n        start(Sequence[float | None]): The start value for each channel.\n            If None, the start value will be computed from the image.\n        end(Sequence[float | None]): The end value for each channel.\n            If None, the end value will be computed from the image.\n        percentiles(tuple[float, float] | None): The start and end\n            percentiles for each channel. If None, the percentiles will\n            not be computed.\n        colors(Sequence[str | None]): The list of colors for the\n            channels. If None, the colors will be random.\n        active (Sequence[bool | None]): Whether the channel should\n            be shown by default.\n        omero_kwargs(dict): Extra fields to store in the omero attributes.\n    \"\"\"\n    low_res_dataset = self.meta.get_lowest_resolution_dataset()\n    ref_image = self.get(path=low_res_dataset.path)\n\n    if start is not None and end is None:\n        raise NgioValidationError(\n            \"If start is provided, end must be provided as well.\"\n        )\n    if end is not None and start is None:\n        raise NgioValidationError(\n            \"If end is provided, start must be provided as well.\"\n        )\n\n    if start is not None and percentiles is not None:\n        raise NgioValidationError(\n            \"If start and end are provided, percentiles must be None.\"\n        )\n\n    if percentiles is not None:\n        start, end = compute_image_percentile(\n            ref_image,\n            start_percentile=percentiles[0],\n            end_percentile=percentiles[1],\n        )\n    elif start is not None and end is not None:\n        if len(start) != len(end):\n            raise NgioValidationError(\n                \"The start and end lists must have the same length.\"\n            )\n        if len(start) != self.num_channels:\n            raise NgioValidationError(\n                \"The start and end lists must have the same length as \"\n                \"the number of channels.\"\n            )\n\n        start = list(start)\n        end = list(end)\n\n    else:\n        start, end = None, None\n\n    if labels is None:\n        labels = ref_image.num_channels\n\n    channel_meta = ChannelsMeta.default_init(\n        labels=labels,\n        wavelength_id=wavelength_id,\n        colors=colors,\n        start=start,\n        end=end,\n        active=active,\n        data_type=ref_image.dtype,\n        **omero_kwargs,\n    )\n\n    meta = self.meta\n    meta.set_channels_meta(channel_meta)\n    self._meta_handler.write_meta(meta)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.ImagesContainer.set_channel_percentiles","title":"set_channel_percentiles","text":"<pre><code>set_channel_percentiles(\n    start_percentile: float = 0.1,\n    end_percentile: float = 99.9,\n) -&gt; None\n</code></pre> <p>Update the percentiles of the channels.</p> Source code in <code>ngio/images/_image.py</code> <pre><code>def set_channel_percentiles(\n    self,\n    start_percentile: float = 0.1,\n    end_percentile: float = 99.9,\n) -&gt; None:\n    \"\"\"Update the percentiles of the channels.\"\"\"\n    if self.meta._channels_meta is None:\n        raise NgioValidationError(\"The channels meta is not initialized.\")\n\n    low_res_dataset = self.meta.get_lowest_resolution_dataset()\n    ref_image = self.get(path=low_res_dataset.path)\n    starts, ends = compute_image_percentile(\n        ref_image, start_percentile=start_percentile, end_percentile=end_percentile\n    )\n\n    channels = []\n    for c, channel in enumerate(self.meta._channels_meta.channels):\n        new_v = ChannelVisualisation(\n            start=starts[c],\n            end=ends[c],\n            **channel.channel_visualisation.model_dump(exclude={\"start\", \"end\"}),\n        )\n        new_c = Channel(\n            channel_visualisation=new_v,\n            **channel.model_dump(exclude={\"channel_visualisation\"}),\n        )\n        channels.append(new_c)\n\n    new_meta = ChannelsMeta(channels=channels)\n\n    meta = self.meta\n    meta.set_channels_meta(new_meta)\n    self._meta_handler.write_meta(meta)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.ImagesContainer.set_axes_unit","title":"set_axes_unit","text":"<pre><code>set_axes_unit(\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n) -&gt; None\n</code></pre> <p>Set the axes unit of the image.</p> <p>Parameters:</p> <ul> <li> <code>space_unit</code>               (<code>SpaceUnits</code>, default:                   <code>DefaultSpaceUnit</code> )           \u2013            <p>The space unit of the image.</p> </li> <li> <code>time_unit</code>               (<code>TimeUnits</code>, default:                   <code>DefaultTimeUnit</code> )           \u2013            <p>The time unit of the image.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def set_axes_unit(\n    self,\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n) -&gt; None:\n    \"\"\"Set the axes unit of the image.\n\n    Args:\n        space_unit (SpaceUnits): The space unit of the image.\n        time_unit (TimeUnits): The time unit of the image.\n    \"\"\"\n    meta = self.meta\n    meta = meta.to_units(space_unit=space_unit, time_unit=time_unit)\n    self._meta_handler.write_meta(meta)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.ImagesContainer.derive","title":"derive","text":"<pre><code>derive(\n    store: StoreOrGroup,\n    ref_path: str | None = None,\n    shape: Sequence[int] | None = None,\n    labels: Sequence[str] | None = None,\n    pixel_size: PixelSize | None = None,\n    axes_names: Sequence[str] | None = None,\n    name: str | None = None,\n    chunks: Sequence[int] | None = None,\n    dtype: str | None = None,\n    overwrite: bool = False,\n) -&gt; ImagesContainer\n</code></pre> <p>Create an empty OME-Zarr image from an existing image.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group to create the image in.</p> </li> <li> <code>ref_path</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the reference image in the image container.</p> </li> <li> <code>shape</code>               (<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The shape of the new image.</p> </li> <li> <code>labels</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The labels of the new image.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the new image.</p> </li> <li> <code>axes_names</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The axes names of the new image.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the new image.</p> </li> <li> <code>chunks</code>               (<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The chunk shape of the new image.</p> </li> <li> <code>dtype</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The data type of the new image.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to overwrite an existing image.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ImagesContainer</code> (              <code>ImagesContainer</code> )          \u2013            <p>The new image</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def derive(\n    self,\n    store: StoreOrGroup,\n    ref_path: str | None = None,\n    shape: Sequence[int] | None = None,\n    labels: Sequence[str] | None = None,\n    pixel_size: PixelSize | None = None,\n    axes_names: Sequence[str] | None = None,\n    name: str | None = None,\n    chunks: Sequence[int] | None = None,\n    dtype: str | None = None,\n    overwrite: bool = False,\n) -&gt; \"ImagesContainer\":\n    \"\"\"Create an empty OME-Zarr image from an existing image.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group to create the image in.\n        ref_path (str | None): The path to the reference image in\n            the image container.\n        shape (Sequence[int] | None): The shape of the new image.\n        labels (Sequence[str] | None): The labels of the new image.\n        pixel_size (PixelSize | None): The pixel size of the new image.\n        axes_names (Sequence[str] | None): The axes names of the new image.\n        name (str | None): The name of the new image.\n        chunks (Sequence[int] | None): The chunk shape of the new image.\n        dtype (str | None): The data type of the new image.\n        overwrite (bool): Whether to overwrite an existing image.\n\n    Returns:\n        ImagesContainer: The new image\n    \"\"\"\n    return derive_image_container(\n        image_container=self,\n        store=store,\n        ref_path=ref_path,\n        shape=shape,\n        labels=labels,\n        pixel_size=pixel_size,\n        axes_names=axes_names,\n        name=name,\n        chunks=chunks,\n        dtype=dtype,\n        overwrite=overwrite,\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.ImagesContainer.get","title":"get","text":"<pre><code>get(\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; Image\n</code></pre> <p>Get an image at a specific level.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the image in the ome_zarr file.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the image.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Only used if the pixel size is provided. If True, the pixel size must match the image pixel size exactly. If False, the closest pixel size level will be returned.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def get(\n    self,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; Image:\n    \"\"\"Get an image at a specific level.\n\n    Args:\n        path (str | None): The path to the image in the ome_zarr file.\n        pixel_size (PixelSize | None): The pixel size of the image.\n        strict (bool): Only used if the pixel size is provided. If True, the\n            pixel size must match the image pixel size exactly. If False, the\n            closest pixel size level will be returned.\n\n    \"\"\"\n    dataset = self._meta_handler.meta.get_dataset(\n        path=path, pixel_size=pixel_size, strict=strict\n    )\n    return Image(\n        group_handler=self._group_handler,\n        path=dataset.path,\n        meta_handler=self._meta_handler,\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Label","title":"Label","text":"<pre><code>Label(\n    group_handler: ZarrGroupHandler,\n    path: str,\n    meta_handler: LabelMetaHandler | None,\n)\n</code></pre> <p>               Bases: <code>AbstractImage[LabelMetaHandler]</code></p> <p>Placeholder class for a label.</p> <p>Initialize the Image at a single level.</p> <p>Parameters:</p> <ul> <li> <code>group_handler</code>               (<code>ZarrGroupHandler</code>)           \u2013            <p>The Zarr group handler.</p> </li> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path to the image in the ome_zarr file.</p> </li> <li> <code>meta_handler</code>               (<code>LabelMetaHandler | None</code>)           \u2013            <p>The image metadata handler.</p> </li> </ul> Source code in <code>ngio/images/_label.py</code> <pre><code>def __init__(\n    self,\n    group_handler: ZarrGroupHandler,\n    path: str,\n    meta_handler: LabelMetaHandler | None,\n) -&gt; None:\n    \"\"\"Initialize the Image at a single level.\n\n    Args:\n        group_handler: The Zarr group handler.\n        path: The path to the image in the ome_zarr file.\n        meta_handler: The image metadata handler.\n\n    \"\"\"\n    if meta_handler is None:\n        meta_handler = find_label_meta_handler(group_handler)\n    super().__init__(\n        group_handler=group_handler, path=path, meta_handler=meta_handler\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Label.meta_handler","title":"meta_handler  <code>property</code>","text":"<pre><code>meta_handler: _image_handler\n</code></pre> <p>Return the metadata.</p>"},{"location":"api/ngio/images/#ngio.images.Label.zarr_array","title":"zarr_array  <code>property</code>","text":"<pre><code>zarr_array: Array\n</code></pre> <p>Return the Zarr array.</p>"},{"location":"api/ngio/images/#ngio.images.Label.shape","title":"shape  <code>property</code>","text":"<pre><code>shape: tuple[int, ...]\n</code></pre> <p>Return the shape of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Label.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype: str\n</code></pre> <p>Return the dtype of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Label.chunks","title":"chunks  <code>property</code>","text":"<pre><code>chunks: tuple[int, ...]\n</code></pre> <p>Return the chunks of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Label.dimensions","title":"dimensions  <code>property</code>","text":"<pre><code>dimensions: Dimensions\n</code></pre> <p>Return the dimensions of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Label.axes_mapper","title":"axes_mapper  <code>property</code>","text":"<pre><code>axes_mapper: AxesHandler\n</code></pre> <p>Return the axes mapper of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Label.is_3d","title":"is_3d  <code>property</code>","text":"<pre><code>is_3d: bool\n</code></pre> <p>Return True if the image is 3D.</p>"},{"location":"api/ngio/images/#ngio.images.Label.is_2d","title":"is_2d  <code>property</code>","text":"<pre><code>is_2d: bool\n</code></pre> <p>Return True if the image is 2D.</p>"},{"location":"api/ngio/images/#ngio.images.Label.is_time_series","title":"is_time_series  <code>property</code>","text":"<pre><code>is_time_series: bool\n</code></pre> <p>Return True if the image is a time series.</p>"},{"location":"api/ngio/images/#ngio.images.Label.is_2d_time_series","title":"is_2d_time_series  <code>property</code>","text":"<pre><code>is_2d_time_series: bool\n</code></pre> <p>Return True if the image is a 2D time series.</p>"},{"location":"api/ngio/images/#ngio.images.Label.is_3d_time_series","title":"is_3d_time_series  <code>property</code>","text":"<pre><code>is_3d_time_series: bool\n</code></pre> <p>Return True if the image is a 3D time series.</p>"},{"location":"api/ngio/images/#ngio.images.Label.is_multi_channels","title":"is_multi_channels  <code>property</code>","text":"<pre><code>is_multi_channels: bool\n</code></pre> <p>Return True if the image is multichannel.</p>"},{"location":"api/ngio/images/#ngio.images.Label.space_unit","title":"space_unit  <code>property</code>","text":"<pre><code>space_unit: str | None\n</code></pre> <p>Return the space unit of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Label.time_unit","title":"time_unit  <code>property</code>","text":"<pre><code>time_unit: str | None\n</code></pre> <p>Return the time unit of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Label.pixel_size","title":"pixel_size  <code>property</code>","text":"<pre><code>pixel_size: PixelSize\n</code></pre> <p>Return the pixel size of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Label.dataset","title":"dataset  <code>property</code>","text":"<pre><code>dataset: Dataset\n</code></pre> <p>Return the dataset of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Label.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Return the path of the image.</p>"},{"location":"api/ngio/images/#ngio.images.Label.get_as_numpy","title":"get_as_numpy  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_as_numpy = _get_as_numpy\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Label.get_as_dask","title":"get_as_dask  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_as_dask = _get_as_dask\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Label.get_array","title":"get_array  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_array = _get_array\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Label.get_roi_as_numpy","title":"get_roi_as_numpy  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_roi_as_numpy = _get_roi_as_numpy\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Label.get_roi_as_dask","title":"get_roi_as_dask  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_roi_as_dask = _get_roi_as_dask\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Label.get_roi","title":"get_roi  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_roi = _get_roi\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Label.set_array","title":"set_array  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>set_array = _set_array\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Label.set_roi","title":"set_roi  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>set_roi = _set_roi\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Label.meta","title":"meta  <code>property</code>","text":"<pre><code>meta: NgioLabelMeta\n</code></pre> <p>Return the metadata.</p>"},{"location":"api/ngio/images/#ngio.images.Label.has_axis","title":"has_axis","text":"<pre><code>has_axis(axis: str) -&gt; bool\n</code></pre> <p>Return True if the image has the given axis.</p> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def has_axis(self, axis: str) -&gt; bool:\n    \"\"\"Return True if the image has the given axis.\"\"\"\n    self.axes_mapper.get_index(\"x\")\n    return self.dimensions.has_axis(axis)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Label.build_image_roi_table","title":"build_image_roi_table","text":"<pre><code>build_image_roi_table(\n    name: str | None = \"image\",\n) -&gt; RoiTable\n</code></pre> <p>Build the ROI table for an image.</p> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def build_image_roi_table(self, name: str | None = \"image\") -&gt; RoiTable:\n    \"\"\"Build the ROI table for an image.\"\"\"\n    return build_image_roi_table(image=self, name=name)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Label.assert_dimensions_match","title":"assert_dimensions_match","text":"<pre><code>assert_dimensions_match(\n    other: AbstractImage, allow_singleton: bool = False\n) -&gt; None\n</code></pre> <p>Assert that two images have matching spatial dimensions.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>AbstractImage</code>)           \u2013            <p>The other image to compare to.</p> </li> <li> <code>allow_singleton</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, allow singleton dimensions to be compatible with non-singleton dimensions.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NgioValueError</code>             \u2013            <p>If the images do not have compatible dimensions.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def assert_dimensions_match(\n    self,\n    other: \"AbstractImage\",\n    allow_singleton: bool = False,\n) -&gt; None:\n    \"\"\"Assert that two images have matching spatial dimensions.\n\n    Args:\n        other: The other image to compare to.\n        allow_singleton: If True, allow singleton dimensions to be\n            compatible with non-singleton dimensions.\n\n    Raises:\n        NgioValueError: If the images do not have compatible dimensions.\n    \"\"\"\n    assert_dimensions_match(\n        image1=self, image2=other, allow_singleton=allow_singleton\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Label.assert_axes_match","title":"assert_axes_match","text":"<pre><code>assert_axes_match(other: AbstractImage) -&gt; None\n</code></pre> <p>Assert that two images have compatible axes.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>AbstractImage</code>)           \u2013            <p>The other image to compare to.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NgioValueError</code>             \u2013            <p>If the images do not have compatible axes.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def assert_axes_match(\n    self,\n    other: \"AbstractImage\",\n) -&gt; None:\n    \"\"\"Assert that two images have compatible axes.\n\n    Args:\n        other: The other image to compare to.\n\n    Raises:\n        NgioValueError: If the images do not have compatible axes.\n    \"\"\"\n    assert_axes_match(image1=self, image2=other)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Label.assert_can_be_rescaled","title":"assert_can_be_rescaled","text":"<pre><code>assert_can_be_rescaled(other: AbstractImage) -&gt; None\n</code></pre> <p>Assert that two images can be rescaled to each other.</p> <p>For this to be true, the images must have the same axes, and the pixel sizes must be compatible (i.e. one can be scaled to the other).</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>AbstractImage</code>)           \u2013            <p>The other image to compare to.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NgioValueError</code>             \u2013            <p>If the images cannot be scaled to each other.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def assert_can_be_rescaled(\n    self,\n    other: \"AbstractImage\",\n) -&gt; None:\n    \"\"\"Assert that two images can be rescaled to each other.\n\n    For this to be true, the images must have the same axes, and\n    the pixel sizes must be compatible (i.e. one can be scaled to the other).\n\n    Args:\n        other: The other image to compare to.\n\n    Raises:\n        NgioValueError: If the images cannot be scaled to each other.\n    \"\"\"\n    assert_can_be_rescaled(image1=self, image2=other)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Label.set_axes_unit","title":"set_axes_unit","text":"<pre><code>set_axes_unit(\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n) -&gt; None\n</code></pre> <p>Set the axes unit of the image.</p> <p>Parameters:</p> <ul> <li> <code>space_unit</code>               (<code>SpaceUnits</code>, default:                   <code>DefaultSpaceUnit</code> )           \u2013            <p>The space unit of the image.</p> </li> <li> <code>time_unit</code>               (<code>TimeUnits</code>, default:                   <code>DefaultTimeUnit</code> )           \u2013            <p>The time unit of the image.</p> </li> </ul> Source code in <code>ngio/images/_label.py</code> <pre><code>def set_axes_unit(\n    self,\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n) -&gt; None:\n    \"\"\"Set the axes unit of the image.\n\n    Args:\n        space_unit (SpaceUnits): The space unit of the image.\n        time_unit (TimeUnits): The time unit of the image.\n    \"\"\"\n    meta = self.meta\n    meta = meta.to_units(space_unit=space_unit, time_unit=time_unit)\n    self._meta_handler.write_meta(meta)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Label.build_masking_roi_table","title":"build_masking_roi_table","text":"<pre><code>build_masking_roi_table() -&gt; MaskingRoiTable\n</code></pre> <p>Compute the masking ROI table.</p> Source code in <code>ngio/images/_label.py</code> <pre><code>def build_masking_roi_table(self) -&gt; MaskingRoiTable:\n    \"\"\"Compute the masking ROI table.\"\"\"\n    return build_masking_roi_table(self)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.Label.consolidate","title":"consolidate","text":"<pre><code>consolidate(\n    mode: Literal[\"dask\", \"numpy\", \"coarsen\"] = \"dask\",\n) -&gt; None\n</code></pre> <p>Consolidate the label on disk.</p> Source code in <code>ngio/images/_label.py</code> <pre><code>def consolidate(\n    self,\n    mode: Literal[\"dask\", \"numpy\", \"coarsen\"] = \"dask\",\n) -&gt; None:\n    \"\"\"Consolidate the label on disk.\"\"\"\n    self._consolidate(\n        order=\"nearest\",\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.LabelsContainer","title":"LabelsContainer","text":"<pre><code>LabelsContainer(group_handler: ZarrGroupHandler)\n</code></pre> <p>A class to handle the /labels group in an OME-NGFF file.</p> <p>Initialize the LabelGroupHandler.</p> Source code in <code>ngio/images/_label.py</code> <pre><code>def __init__(self, group_handler: ZarrGroupHandler) -&gt; None:\n    \"\"\"Initialize the LabelGroupHandler.\"\"\"\n    self._group_handler = group_handler\n\n    # Validate the group\n    # Either contains a labels attribute or is empty\n    attrs = self._group_handler.load_attrs()\n    if len(attrs) == 0:\n        # It's an empty group\n        pass\n    elif \"labels\" in attrs and isinstance(attrs[\"labels\"], list):\n        # It's a valid group\n        pass\n    else:\n        raise NgioValidationError(\n            f\"Invalid /labels group. \"\n            f\"Expected a single labels attribute with a list of label names. \"\n            f\"Found: {attrs}\"\n        )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.LabelsContainer.list","title":"list","text":"<pre><code>list() -&gt; list[str]\n</code></pre> <p>Create the /labels group if it doesn't exist.</p> Source code in <code>ngio/images/_label.py</code> <pre><code>def list(self) -&gt; list[str]:\n    \"\"\"Create the /labels group if it doesn't exist.\"\"\"\n    attrs = self._group_handler.load_attrs()\n    return attrs.get(\"labels\", [])\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.LabelsContainer.get","title":"get","text":"<pre><code>get(\n    name: str,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; Label\n</code></pre> <p>Get a label from the group.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the label.</p> </li> <li> <code>path</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the image in the ome_zarr file.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the image.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Only used if the pixel size is provided. If True, the pixel size must match the image pixel size exactly. If False, the closest pixel size level will be returned.</p> </li> </ul> Source code in <code>ngio/images/_label.py</code> <pre><code>def get(\n    self,\n    name: str,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; Label:\n    \"\"\"Get a label from the group.\n\n    Args:\n        name (str): The name of the label.\n        path (str | None): The path to the image in the ome_zarr file.\n        pixel_size (PixelSize | None): The pixel size of the image.\n        strict (bool): Only used if the pixel size is provided. If True, the\n            pixel size must match the image pixel size exactly. If False, the\n            closest pixel size level will be returned.\n\n    \"\"\"\n    if name not in self.list():\n        raise NgioValueError(\n            f\"Label '{name}' not found in the Labels group. \"\n            f\"Available labels: {self.list()}\"\n        )\n\n    group_handler = self._group_handler.derive_handler(name)\n    label_meta_handler = find_label_meta_handler(group_handler)\n    path = label_meta_handler.meta.get_dataset(\n        path=path, pixel_size=pixel_size, strict=strict\n    ).path\n    return Label(group_handler, path, label_meta_handler)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.LabelsContainer.derive","title":"derive","text":"<pre><code>derive(\n    name: str,\n    ref_image: Image | Label,\n    shape: Sequence[int] | None = None,\n    pixel_size: PixelSize | None = None,\n    axes_names: Sequence[str] | None = None,\n    chunks: Sequence[int] | None = None,\n    dtype: str = \"uint32\",\n    overwrite: bool = False,\n) -&gt; Label\n</code></pre> <p>Create an empty OME-Zarr label from a reference image.</p> <p>And add the label to the /labels group.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group to create the image in.</p> </li> <li> <code>ref_image</code>               (<code>Image | Label</code>)           \u2013            <p>A reference image that will be used to create the new image.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the new image.</p> </li> <li> <code>shape</code>               (<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The shape of the new image.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the new image.</p> </li> <li> <code>axes_names</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The axes names of the new image. For labels, the channel axis is not allowed.</p> </li> <li> <code>chunks</code>               (<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The chunk shape of the new image.</p> </li> <li> <code>dtype</code>               (<code>str</code>, default:                   <code>'uint32'</code> )           \u2013            <p>The data type of the new label.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to overwrite an existing image.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Label</code> (              <code>Label</code> )          \u2013            <p>The new label.</p> </li> </ul> Source code in <code>ngio/images/_label.py</code> <pre><code>def derive(\n    self,\n    name: str,\n    ref_image: Image | Label,\n    shape: Sequence[int] | None = None,\n    pixel_size: PixelSize | None = None,\n    axes_names: Sequence[str] | None = None,\n    chunks: Sequence[int] | None = None,\n    dtype: str = \"uint32\",\n    overwrite: bool = False,\n) -&gt; \"Label\":\n    \"\"\"Create an empty OME-Zarr label from a reference image.\n\n    And add the label to the /labels group.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group to create the image in.\n        ref_image (Image | Label): A reference image that will be used to create\n            the new image.\n        name (str): The name of the new image.\n        shape (Sequence[int] | None): The shape of the new image.\n        pixel_size (PixelSize | None): The pixel size of the new image.\n        axes_names (Sequence[str] | None): The axes names of the new image.\n            For labels, the channel axis is not allowed.\n        chunks (Sequence[int] | None): The chunk shape of the new image.\n        dtype (str): The data type of the new label.\n        overwrite (bool): Whether to overwrite an existing image.\n\n    Returns:\n        Label: The new label.\n\n    \"\"\"\n    existing_labels = self.list()\n    if name in existing_labels and not overwrite:\n        raise NgioValueError(\n            f\"Label '{name}' already exists in the group. \"\n            \"Use overwrite=True to replace it.\"\n        )\n\n    label_group = self._group_handler.get_group(name, create_mode=True)\n\n    derive_label(\n        store=label_group,\n        ref_image=ref_image,\n        name=name,\n        shape=shape,\n        pixel_size=pixel_size,\n        axes_names=axes_names,\n        chunks=chunks,\n        dtype=dtype,\n        overwrite=overwrite,\n    )\n\n    if name not in existing_labels:\n        existing_labels.append(name)\n        self._group_handler.write_attrs({\"labels\": existing_labels})\n\n    return self.get(name)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer","title":"OmeZarrContainer","text":"<pre><code>OmeZarrContainer(\n    group_handler: ZarrGroupHandler,\n    table_container: TablesContainer | None = None,\n    label_container: LabelsContainer | None = None,\n    validate_paths: bool = False,\n)\n</code></pre> <p>This class is an object representation of an OME-Zarr image.</p> It provides methods to access <ul> <li>The multiscale image metadata</li> <li>To open images at different levels of resolution</li> <li>To access labels and tables associated with the image.</li> <li>To derive new images, labels, and add tables to the image.</li> <li>To modify the image metadata, such as axes units and channel metadata.</li> </ul> <p>Attributes:</p> <ul> <li> <code>images_container</code>               (<code>ImagesContainer</code>)           \u2013            <p>The container for the images.</p> </li> <li> <code>labels_container</code>               (<code>LabelsContainer</code>)           \u2013            <p>The container for the labels.</p> </li> <li> <code>tables_container</code>               (<code>TablesContainer</code>)           \u2013            <p>The container for the tables.</p> </li> </ul> <p>Initialize the OmeZarrContainer.</p> <p>Parameters:</p> <ul> <li> <code>group_handler</code>               (<code>ZarrGroupHandler</code>)           \u2013            <p>The Zarr group handler.</p> </li> <li> <code>table_container</code>               (<code>TablesContainer | None</code>, default:                   <code>None</code> )           \u2013            <p>The tables container.</p> </li> <li> <code>label_container</code>               (<code>LabelsContainer | None</code>, default:                   <code>None</code> )           \u2013            <p>The labels container.</p> </li> <li> <code>validate_paths</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to validate the paths of the image multiscale</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def __init__(\n    self,\n    group_handler: ZarrGroupHandler,\n    table_container: TablesContainer | None = None,\n    label_container: LabelsContainer | None = None,\n    validate_paths: bool = False,\n) -&gt; None:\n    \"\"\"Initialize the OmeZarrContainer.\n\n    Args:\n        group_handler (ZarrGroupHandler): The Zarr group handler.\n        table_container (TablesContainer | None): The tables container.\n        label_container (LabelsContainer | None): The labels container.\n        validate_paths (bool): Whether to validate the paths of the image multiscale\n    \"\"\"\n    self._group_handler = group_handler\n    self._images_container = ImagesContainer(self._group_handler)\n\n    self._labels_container = label_container\n    self._tables_container = table_container\n\n    if validate_paths:\n        for level_path in self._images_container.levels_paths:\n            self.get_image(path=level_path)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.images_container","title":"images_container  <code>property</code>","text":"<pre><code>images_container: ImagesContainer\n</code></pre> <p>Return the images container.</p> <p>Returns:</p> <ul> <li> <code>ImagesContainer</code> (              <code>ImagesContainer</code> )          \u2013            <p>The images container.</p> </li> </ul>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.labels_container","title":"labels_container  <code>property</code>","text":"<pre><code>labels_container: LabelsContainer\n</code></pre> <p>Return the labels container.</p>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.tables_container","title":"tables_container  <code>property</code>","text":"<pre><code>tables_container: TablesContainer\n</code></pre> <p>Return the tables container.</p>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.image_meta","title":"image_meta  <code>property</code>","text":"<pre><code>image_meta: NgioImageMeta\n</code></pre> <p>Return the image metadata.</p>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.levels","title":"levels  <code>property</code>","text":"<pre><code>levels: int\n</code></pre> <p>Return the number of levels in the image.</p>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.levels_paths","title":"levels_paths  <code>property</code>","text":"<pre><code>levels_paths: list[str]\n</code></pre> <p>Return the paths of the levels in the image.</p>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.is_3d","title":"is_3d  <code>property</code>","text":"<pre><code>is_3d: bool\n</code></pre> <p>Return True if the image is 3D.</p>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.is_2d","title":"is_2d  <code>property</code>","text":"<pre><code>is_2d: bool\n</code></pre> <p>Return True if the image is 2D.</p>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.is_time_series","title":"is_time_series  <code>property</code>","text":"<pre><code>is_time_series: bool\n</code></pre> <p>Return True if the image is a time series.</p>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.is_2d_time_series","title":"is_2d_time_series  <code>property</code>","text":"<pre><code>is_2d_time_series: bool\n</code></pre> <p>Return True if the image is a 2D time series.</p>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.is_3d_time_series","title":"is_3d_time_series  <code>property</code>","text":"<pre><code>is_3d_time_series: bool\n</code></pre> <p>Return True if the image is a 3D time series.</p>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.is_multi_channels","title":"is_multi_channels  <code>property</code>","text":"<pre><code>is_multi_channels: bool\n</code></pre> <p>Return True if the image is multichannel.</p>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.space_unit","title":"space_unit  <code>property</code>","text":"<pre><code>space_unit: str | None\n</code></pre> <p>Return the space unit of the image.</p>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.time_unit","title":"time_unit  <code>property</code>","text":"<pre><code>time_unit: str | None\n</code></pre> <p>Return the time unit of the image.</p>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.channel_labels","title":"channel_labels  <code>property</code>","text":"<pre><code>channel_labels: list[str]\n</code></pre> <p>Return the channels of the image.</p>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.wavelength_ids","title":"wavelength_ids  <code>property</code>","text":"<pre><code>wavelength_ids: list[str | None]\n</code></pre> <p>Return the list of wavelength of the image.</p>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.num_channels","title":"num_channels  <code>property</code>","text":"<pre><code>num_channels: int\n</code></pre> <p>Return the number of channels.</p>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.get_channel_idx","title":"get_channel_idx","text":"<pre><code>get_channel_idx(\n    channel_label: str | None = None,\n    wavelength_id: str | None = None,\n) -&gt; int\n</code></pre> <p>Get the index of a channel by its label or wavelength ID.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_channel_idx(\n    self, channel_label: str | None = None, wavelength_id: str | None = None\n) -&gt; int:\n    \"\"\"Get the index of a channel by its label or wavelength ID.\"\"\"\n    image = self.get_image()\n    return image.channels_meta.get_channel_idx(\n        channel_label=channel_label, wavelength_id=wavelength_id\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.set_channel_meta","title":"set_channel_meta","text":"<pre><code>set_channel_meta(\n    labels: Sequence[str] | int | None = None,\n    wavelength_id: Sequence[str] | None = None,\n    percentiles: tuple[float, float] | None = None,\n    colors: Sequence[str] | None = None,\n    active: Sequence[bool] | None = None,\n    **omero_kwargs: dict,\n) -&gt; None\n</code></pre> <p>Create a ChannelsMeta object with the default unit.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def set_channel_meta(\n    self,\n    labels: Sequence[str] | int | None = None,\n    wavelength_id: Sequence[str] | None = None,\n    percentiles: tuple[float, float] | None = None,\n    colors: Sequence[str] | None = None,\n    active: Sequence[bool] | None = None,\n    **omero_kwargs: dict,\n) -&gt; None:\n    \"\"\"Create a ChannelsMeta object with the default unit.\"\"\"\n    self._images_container.set_channel_meta(\n        labels=labels,\n        wavelength_id=wavelength_id,\n        start=None,\n        end=None,\n        percentiles=percentiles,\n        colors=colors,\n        active=active,\n        **omero_kwargs,\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.set_channel_percentiles","title":"set_channel_percentiles","text":"<pre><code>set_channel_percentiles(\n    start_percentile: float = 0.1,\n    end_percentile: float = 99.9,\n) -&gt; None\n</code></pre> <p>Update the percentiles of the image.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def set_channel_percentiles(\n    self,\n    start_percentile: float = 0.1,\n    end_percentile: float = 99.9,\n) -&gt; None:\n    \"\"\"Update the percentiles of the image.\"\"\"\n    self._images_container.set_channel_percentiles(\n        start_percentile=start_percentile, end_percentile=end_percentile\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.set_axes_units","title":"set_axes_units","text":"<pre><code>set_axes_units(\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n    set_labels: bool = True,\n) -&gt; None\n</code></pre> <p>Set the units of the image.</p> <p>Parameters:</p> <ul> <li> <code>space_unit</code>               (<code>SpaceUnits</code>, default:                   <code>DefaultSpaceUnit</code> )           \u2013            <p>The unit of space.</p> </li> <li> <code>time_unit</code>               (<code>TimeUnits</code>, default:                   <code>DefaultTimeUnit</code> )           \u2013            <p>The unit of time.</p> </li> <li> <code>set_labels</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to set the units for the labels as well.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def set_axes_units(\n    self,\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n    set_labels: bool = True,\n) -&gt; None:\n    \"\"\"Set the units of the image.\n\n    Args:\n        space_unit (SpaceUnits): The unit of space.\n        time_unit (TimeUnits): The unit of time.\n        set_labels (bool): Whether to set the units for the labels as well.\n    \"\"\"\n    self._images_container.set_axes_unit(space_unit=space_unit, time_unit=time_unit)\n    if not set_labels:\n        return\n    for label_name in self.list_labels():\n        label = self.get_label(label_name)\n        label.set_axes_unit(space_unit=space_unit, time_unit=time_unit)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.get_image","title":"get_image","text":"<pre><code>get_image(\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; Image\n</code></pre> <p>Get an image at a specific level.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the image in the ome_zarr file.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the image.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Only used if the pixel size is provided. If True, the pixel size must match the image pixel size exactly. If False, the closest pixel size level will be returned.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_image(\n    self,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; Image:\n    \"\"\"Get an image at a specific level.\n\n    Args:\n        path (str | None): The path to the image in the ome_zarr file.\n        pixel_size (PixelSize | None): The pixel size of the image.\n        strict (bool): Only used if the pixel size is provided. If True, the\n            pixel size must match the image pixel size exactly. If False, the\n            closest pixel size level will be returned.\n\n    \"\"\"\n    return self._images_container.get(\n        path=path, pixel_size=pixel_size, strict=strict\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.get_masked_image","title":"get_masked_image","text":"<pre><code>get_masked_image(\n    masking_label_name: str | None = None,\n    masking_table_name: str | None = None,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; MaskedImage\n</code></pre> <p>Get a masked image at a specific level.</p> <p>Parameters:</p> <ul> <li> <code>masking_label_name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the masking label to use. If None, the masking table must be provided.</p> </li> <li> <code>masking_table_name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the masking table to use. If None, the masking label must be provided.</p> </li> <li> <code>path</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the image in the ome_zarr file. If None, the first level will be used.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the image. This is only used if path is None.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Only used if the pixel size is provided. If True, the pixel size must match the image pixel size exactly. If False, the closest pixel size level will be returned.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_masked_image(\n    self,\n    masking_label_name: str | None = None,\n    masking_table_name: str | None = None,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; MaskedImage:\n    \"\"\"Get a masked image at a specific level.\n\n    Args:\n        masking_label_name (str | None): The name of the masking label to use.\n            If None, the masking table must be provided.\n        masking_table_name (str | None): The name of the masking table to use.\n            If None, the masking label must be provided.\n        path (str | None): The path to the image in the ome_zarr file.\n            If None, the first level will be used.\n        pixel_size (PixelSize | None): The pixel size of the image.\n            This is only used if path is None.\n        strict (bool): Only used if the pixel size is provided. If True, the\n            pixel size must match the image pixel size exactly. If False, the\n            closest pixel size level will be returned.\n    \"\"\"\n    image = self.get_image(path=path, pixel_size=pixel_size, strict=strict)\n    masking_label, masking_table = self._find_matching_masking_label(\n        masking_label_name=masking_label_name,\n        masking_table_name=masking_table_name,\n        pixel_size=pixel_size,\n    )\n    return MaskedImage(\n        group_handler=image._group_handler,\n        path=image.path,\n        meta_handler=image.meta_handler,\n        label=masking_label,\n        masking_roi_table=masking_table,\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.derive_image","title":"derive_image","text":"<pre><code>derive_image(\n    store: StoreOrGroup,\n    ref_path: str | None = None,\n    shape: Sequence[int] | None = None,\n    labels: Sequence[str] | None = None,\n    pixel_size: PixelSize | None = None,\n    axes_names: Sequence[str] | None = None,\n    name: str | None = None,\n    chunks: Sequence[int] | None = None,\n    dtype: str | None = None,\n    copy_labels: bool = False,\n    copy_tables: bool = False,\n    overwrite: bool = False,\n) -&gt; OmeZarrContainer\n</code></pre> <p>Create an empty OME-Zarr container from an existing image.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group to create the image in.</p> </li> <li> <code>ref_path</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the reference image in the image container.</p> </li> <li> <code>shape</code>               (<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The shape of the new image.</p> </li> <li> <code>labels</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The labels of the new image.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the new image.</p> </li> <li> <code>axes_names</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The axes names of the new image.</p> </li> <li> <code>chunks</code>               (<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The chunk shape of the new image.</p> </li> <li> <code>dtype</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The data type of the new image.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the new image.</p> </li> <li> <code>copy_labels</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to copy the labels from the reference image.</p> </li> <li> <code>copy_tables</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to copy the tables from the reference image.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to overwrite an existing image.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OmeZarrContainer</code> (              <code>OmeZarrContainer</code> )          \u2013            <p>The new image container.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def derive_image(\n    self,\n    store: StoreOrGroup,\n    ref_path: str | None = None,\n    shape: Sequence[int] | None = None,\n    labels: Sequence[str] | None = None,\n    pixel_size: PixelSize | None = None,\n    axes_names: Sequence[str] | None = None,\n    name: str | None = None,\n    chunks: Sequence[int] | None = None,\n    dtype: str | None = None,\n    copy_labels: bool = False,\n    copy_tables: bool = False,\n    overwrite: bool = False,\n) -&gt; \"OmeZarrContainer\":\n    \"\"\"Create an empty OME-Zarr container from an existing image.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group to create the image in.\n        ref_path (str | None): The path to the reference image in\n            the image container.\n        shape (Sequence[int] | None): The shape of the new image.\n        labels (Sequence[str] | None): The labels of the new image.\n        pixel_size (PixelSize | None): The pixel size of the new image.\n        axes_names (Sequence[str] | None): The axes names of the new image.\n        chunks (Sequence[int] | None): The chunk shape of the new image.\n        dtype (str | None): The data type of the new image.\n        name (str | None): The name of the new image.\n        copy_labels (bool): Whether to copy the labels from the reference image.\n        copy_tables (bool): Whether to copy the tables from the reference image.\n        overwrite (bool): Whether to overwrite an existing image.\n\n    Returns:\n        OmeZarrContainer: The new image container.\n\n    \"\"\"\n    _ = self._images_container.derive(\n        store=store,\n        ref_path=ref_path,\n        shape=shape,\n        labels=labels,\n        pixel_size=pixel_size,\n        axes_names=axes_names,\n        name=name,\n        chunks=chunks,\n        dtype=dtype,\n        overwrite=overwrite,\n    )\n\n    handler = ZarrGroupHandler(\n        store, cache=self._group_handler.use_cache, mode=self._group_handler.mode\n    )\n\n    new_ome_zarr = OmeZarrContainer(\n        group_handler=handler,\n        validate_paths=False,\n    )\n\n    if copy_labels:\n        self.labels_container._group_handler.copy_handler(\n            new_ome_zarr.labels_container._group_handler\n        )\n\n    if copy_tables:\n        self.tables_container._group_handler.copy_handler(\n            new_ome_zarr.tables_container._group_handler\n        )\n    return new_ome_zarr\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.list_tables","title":"list_tables","text":"<pre><code>list_tables(\n    filter_types: TypedTable | str | None = None,\n) -&gt; list[str]\n</code></pre> <p>List all tables in the image.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def list_tables(self, filter_types: TypedTable | str | None = None) -&gt; list[str]:\n    \"\"\"List all tables in the image.\"\"\"\n    table_container = self._get_tables_container()\n    if table_container is None:\n        return []\n\n    return table_container.list(\n        filter_types=filter_types,\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.list_roi_tables","title":"list_roi_tables","text":"<pre><code>list_roi_tables() -&gt; list[str]\n</code></pre> <p>List all ROI tables in the image.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def list_roi_tables(self) -&gt; list[str]:\n    \"\"\"List all ROI tables in the image.\"\"\"\n    masking_roi = self.tables_container.list(\n        filter_types=\"masking_roi_table\",\n    )\n    roi = self.tables_container.list(\n        filter_types=\"roi_table\",\n    )\n    return masking_roi + roi\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.get_roi_table","title":"get_roi_table","text":"<pre><code>get_roi_table(name: str) -&gt; RoiTable\n</code></pre> <p>Get a ROI table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_roi_table(self, name: str) -&gt; RoiTable:\n    \"\"\"Get a ROI table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, RoiTable):\n        raise NgioValueError(f\"Table {name} is not a ROI table. Got {type(table)}\")\n    return table\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.get_masking_roi_table","title":"get_masking_roi_table","text":"<pre><code>get_masking_roi_table(name: str) -&gt; MaskingRoiTable\n</code></pre> <p>Get a masking ROI table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_masking_roi_table(self, name: str) -&gt; MaskingRoiTable:\n    \"\"\"Get a masking ROI table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, MaskingRoiTable):\n        raise NgioValueError(\n            f\"Table {name} is not a masking ROI table. Got {type(table)}\"\n        )\n    return table\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.get_feature_table","title":"get_feature_table","text":"<pre><code>get_feature_table(name: str) -&gt; FeatureTable\n</code></pre> <p>Get a feature table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_feature_table(self, name: str) -&gt; FeatureTable:\n    \"\"\"Get a feature table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, FeatureTable):\n        raise NgioValueError(\n            f\"Table {name} is not a feature table. Got {type(table)}\"\n        )\n    return table\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.get_generic_roi_table","title":"get_generic_roi_table","text":"<pre><code>get_generic_roi_table(name: str) -&gt; GenericRoiTable\n</code></pre> <p>Get a generic ROI table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_generic_roi_table(self, name: str) -&gt; GenericRoiTable:\n    \"\"\"Get a generic ROI table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, GenericRoiTable):\n        raise NgioValueError(\n            f\"Table {name} is not a generic ROI table. Got {type(table)}\"\n        )\n    return table\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.get_condition_table","title":"get_condition_table","text":"<pre><code>get_condition_table(name: str) -&gt; ConditionTable\n</code></pre> <p>Get a condition table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_condition_table(self, name: str) -&gt; ConditionTable:\n    \"\"\"Get a condition table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, ConditionTable):\n        raise NgioValueError(\n            f\"Table {name} is not a condition table. Got {type(table)}\"\n        )\n    return table\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.get_table","title":"get_table","text":"<pre><code>get_table(\n    name: str, check_type: TypedTable | None = None\n) -&gt; Table\n</code></pre> <p>Get a table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> <li> <code>check_type</code>               (<code>TypedTable | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Please use 'get_table_as' instead, or one of the type specific get_*table() methods.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_table(self, name: str, check_type: TypedTable | None = None) -&gt; Table:\n    \"\"\"Get a table from the image.\n\n    Args:\n        name (str): The name of the table.\n        check_type (TypedTable | None): Deprecated. Please use\n            'get_table_as' instead, or one of the type specific\n            get_*table() methods.\n\n    \"\"\"\n    if check_type is not None:\n        warnings.warn(\n            \"The 'check_type' argument is deprecated, and will be removed in \"\n            \"ngio=0.3. Use 'get_table_as' instead or one of the \"\n            \"type specific get_*table() methods.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n    return self.tables_container.get(name=name, strict=False)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.get_table_as","title":"get_table_as","text":"<pre><code>get_table_as(\n    name: str,\n    table_cls: type[TableType],\n    backend: TableBackend | None = None,\n) -&gt; TableType\n</code></pre> <p>Get a table from the image as a specific type.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> <li> <code>table_cls</code>               (<code>type[TableType]</code>)           \u2013            <p>The type of the table.</p> </li> <li> <code>backend</code>               (<code>TableBackend | None</code>, default:                   <code>None</code> )           \u2013            <p>The backend to use. If None, the default backend is used.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_table_as(\n    self,\n    name: str,\n    table_cls: type[TableType],\n    backend: TableBackend | None = None,\n) -&gt; TableType:\n    \"\"\"Get a table from the image as a specific type.\n\n    Args:\n        name (str): The name of the table.\n        table_cls (type[TableType]): The type of the table.\n        backend (TableBackend | None): The backend to use. If None,\n            the default backend is used.\n    \"\"\"\n    return self.tables_container.get_as(\n        name=name,\n        table_cls=table_cls,\n        backend=backend,\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.build_image_roi_table","title":"build_image_roi_table","text":"<pre><code>build_image_roi_table(\n    name: str | None = \"image\",\n) -&gt; RoiTable\n</code></pre> <p>Compute the ROI table for an image.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def build_image_roi_table(self, name: str | None = \"image\") -&gt; RoiTable:\n    \"\"\"Compute the ROI table for an image.\"\"\"\n    return self.get_image().build_image_roi_table(name=name)\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.build_masking_roi_table","title":"build_masking_roi_table","text":"<pre><code>build_masking_roi_table(label: str) -&gt; MaskingRoiTable\n</code></pre> <p>Compute the masking ROI table for a label.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def build_masking_roi_table(self, label: str) -&gt; MaskingRoiTable:\n    \"\"\"Compute the masking ROI table for a label.\"\"\"\n    return self.get_label(label).build_masking_roi_table()\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.add_table","title":"add_table","text":"<pre><code>add_table(\n    name: str,\n    table: Table,\n    backend: TableBackend = DefaultTableBackend,\n    overwrite: bool = False,\n) -&gt; None\n</code></pre> <p>Add a table to the image.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def add_table(\n    self,\n    name: str,\n    table: Table,\n    backend: TableBackend = DefaultTableBackend,\n    overwrite: bool = False,\n) -&gt; None:\n    \"\"\"Add a table to the image.\"\"\"\n    self.tables_container.add(\n        name=name, table=table, backend=backend, overwrite=overwrite\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.list_labels","title":"list_labels","text":"<pre><code>list_labels() -&gt; list[str]\n</code></pre> <p>List all labels in the image.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def list_labels(self) -&gt; list[str]:\n    \"\"\"List all labels in the image.\"\"\"\n    label_container = self._get_labels_container()\n    if label_container is None:\n        return []\n    return label_container.list()\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.get_label","title":"get_label","text":"<pre><code>get_label(\n    name: str,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; Label\n</code></pre> <p>Get a label from the group.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the label.</p> </li> <li> <code>path</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the image in the ome_zarr file.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the image.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Only used if the pixel size is provided. If True, the pixel size must match the image pixel size exactly. If False, the closest pixel size level will be returned.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_label(\n    self,\n    name: str,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; Label:\n    \"\"\"Get a label from the group.\n\n    Args:\n        name (str): The name of the label.\n        path (str | None): The path to the image in the ome_zarr file.\n        pixel_size (PixelSize | None): The pixel size of the image.\n        strict (bool): Only used if the pixel size is provided. If True, the\n            pixel size must match the image pixel size exactly. If False, the\n            closest pixel size level will be returned.\n    \"\"\"\n    return self.labels_container.get(\n        name=name, path=path, pixel_size=pixel_size, strict=strict\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.get_masked_label","title":"get_masked_label","text":"<pre><code>get_masked_label(\n    label_name: str,\n    masking_label_name: str | None = None,\n    masking_table_name: str | None = None,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; MaskedLabel\n</code></pre> <p>Get a masked image at a specific level.</p> <p>Parameters:</p> <ul> <li> <code>label_name</code>               (<code>str</code>)           \u2013            <p>The name of the label.</p> </li> <li> <code>masking_label_name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the masking label.</p> </li> <li> <code>masking_table_name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the masking table.</p> </li> <li> <code>path</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the image in the ome_zarr file.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the image.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Only used if the pixel size is provided. If True, the pixel size must match the image pixel size exactly. If False, the closest pixel size level will be returned.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_masked_label(\n    self,\n    label_name: str,\n    masking_label_name: str | None = None,\n    masking_table_name: str | None = None,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; MaskedLabel:\n    \"\"\"Get a masked image at a specific level.\n\n    Args:\n        label_name (str): The name of the label.\n        masking_label_name (str | None): The name of the masking label.\n        masking_table_name (str | None): The name of the masking table.\n        path (str | None): The path to the image in the ome_zarr file.\n        pixel_size (PixelSize | None): The pixel size of the image.\n        strict (bool): Only used if the pixel size is provided. If True, the\n            pixel size must match the image pixel size exactly. If False, the\n            closest pixel size level will be returned.\n    \"\"\"\n    label = self.get_label(\n        name=label_name, path=path, pixel_size=pixel_size, strict=strict\n    )\n    masking_label, masking_table = self._find_matching_masking_label(\n        masking_label_name=masking_label_name,\n        masking_table_name=masking_table_name,\n        pixel_size=pixel_size,\n    )\n    return MaskedLabel(\n        group_handler=label._group_handler,\n        path=label.path,\n        meta_handler=label.meta_handler,\n        label=masking_label,\n        masking_roi_table=masking_table,\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.OmeZarrContainer.derive_label","title":"derive_label","text":"<pre><code>derive_label(\n    name: str,\n    ref_image: Image | Label | None = None,\n    shape: Sequence[int] | None = None,\n    pixel_size: PixelSize | None = None,\n    axes_names: Sequence[str] | None = None,\n    chunks: Sequence[int] | None = None,\n    dtype: str = \"uint32\",\n    overwrite: bool = False,\n) -&gt; Label\n</code></pre> <p>Create an empty OME-Zarr label from a reference image.</p> <p>And add the label to the /labels group.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the new image.</p> </li> <li> <code>ref_image</code>               (<code>Image | Label | None</code>, default:                   <code>None</code> )           \u2013            <p>A reference image that will be used to create the new image.</p> </li> <li> <code>shape</code>               (<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The shape of the new image.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the new image.</p> </li> <li> <code>axes_names</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The axes names of the new image. For labels, the channel axis is not allowed.</p> </li> <li> <code>chunks</code>               (<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The chunk shape of the new image.</p> </li> <li> <code>dtype</code>               (<code>str</code>, default:                   <code>'uint32'</code> )           \u2013            <p>The data type of the new label.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to overwrite an existing image.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Label</code> (              <code>Label</code> )          \u2013            <p>The new label.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def derive_label(\n    self,\n    name: str,\n    ref_image: Image | Label | None = None,\n    shape: Sequence[int] | None = None,\n    pixel_size: PixelSize | None = None,\n    axes_names: Sequence[str] | None = None,\n    chunks: Sequence[int] | None = None,\n    dtype: str = \"uint32\",\n    overwrite: bool = False,\n) -&gt; \"Label\":\n    \"\"\"Create an empty OME-Zarr label from a reference image.\n\n    And add the label to the /labels group.\n\n    Args:\n        name (str): The name of the new image.\n        ref_image (Image | Label | None): A reference image that will be used\n            to create the new image.\n        shape (Sequence[int] | None): The shape of the new image.\n        pixel_size (PixelSize | None): The pixel size of the new image.\n        axes_names (Sequence[str] | None): The axes names of the new image.\n            For labels, the channel axis is not allowed.\n        chunks (Sequence[int] | None): The chunk shape of the new image.\n        dtype (str): The data type of the new label.\n        overwrite (bool): Whether to overwrite an existing image.\n\n    Returns:\n        Label: The new label.\n\n    \"\"\"\n    if ref_image is None:\n        ref_image = self.get_image()\n    return self.labels_container.derive(\n        name=name,\n        ref_image=ref_image,\n        shape=shape,\n        pixel_size=pixel_size,\n        axes_names=axes_names,\n        chunks=chunks,\n        dtype=dtype,\n        overwrite=overwrite,\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.create_synthetic_ome_zarr","title":"create_synthetic_ome_zarr","text":"<pre><code>create_synthetic_ome_zarr(\n    store: StoreOrGroup,\n    shape: Sequence[int],\n    reference_sample: AVAILABLE_SAMPLES\n    | SampleInfo = \"Cardiomyocyte\",\n    levels: int | list[str] = 5,\n    xy_scaling_factor: float = 2,\n    z_scaling_factor: float = 1.0,\n    axes_names: Sequence[str] | None = None,\n    chunks: Sequence[int] | None = None,\n    channel_labels: list[str] | None = None,\n    channel_wavelengths: list[str] | None = None,\n    channel_colors: Sequence[str] | None = None,\n    channel_active: Sequence[bool] | None = None,\n    table_backend: TableBackend = DefaultTableBackend,\n    overwrite: bool = False,\n    version: NgffVersions = DefaultNgffVersion,\n) -&gt; OmeZarrContainer\n</code></pre> <p>Create an empty OME-Zarr image with the given shape and metadata.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group to create the image in.</p> </li> <li> <code>shape</code>               (<code>Sequence[int]</code>)           \u2013            <p>The shape of the image.</p> </li> <li> <code>reference_sample</code>               (<code>AVAILABLE_SAMPLES | SampleInfo</code>, default:                   <code>'Cardiomyocyte'</code> )           \u2013            <p>The reference sample to use.</p> </li> <li> <code>levels</code>               (<code>int | list[str]</code>, default:                   <code>5</code> )           \u2013            <p>The number of levels in the pyramid or a list of level names. Defaults to 5.</p> </li> <li> <code>xy_scaling_factor</code>               (<code>float</code>, default:                   <code>2</code> )           \u2013            <p>The down-scaling factor in x and y dimensions. Defaults to 2.0.</p> </li> <li> <code>z_scaling_factor</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The down-scaling factor in z dimension. Defaults to 1.0.</p> </li> <li> <code>axes_names</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The names of the axes. If None the canonical names are used. Defaults to None.</p> </li> <li> <code>chunks</code>               (<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The chunk shape. If None the shape is used. Defaults to None.</p> </li> <li> <code>channel_labels</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The labels of the channels. Defaults to None.</p> </li> <li> <code>channel_wavelengths</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The wavelengths of the channels. Defaults to None.</p> </li> <li> <code>channel_colors</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The colors of the channels. Defaults to None.</p> </li> <li> <code>channel_active</code>               (<code>Sequence[bool] | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether the channels are active. Defaults to None.</p> </li> <li> <code>table_backend</code>               (<code>TableBackend</code>, default:                   <code>DefaultTableBackend</code> )           \u2013            <p>Table backend to be used to store tables</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to overwrite an existing image. Defaults to True.</p> </li> <li> <code>version</code>               (<code>NgffVersion</code>, default:                   <code>DefaultNgffVersion</code> )           \u2013            <p>The version of the OME-Zarr specification. Defaults to DefaultNgffVersion.</p> </li> </ul> Source code in <code>ngio/images/_create_synt_container.py</code> <pre><code>def create_synthetic_ome_zarr(\n    store: StoreOrGroup,\n    shape: Sequence[int],\n    reference_sample: AVAILABLE_SAMPLES | SampleInfo = \"Cardiomyocyte\",\n    levels: int | list[str] = 5,\n    xy_scaling_factor: float = 2,\n    z_scaling_factor: float = 1.0,\n    axes_names: Sequence[str] | None = None,\n    chunks: Sequence[int] | None = None,\n    channel_labels: list[str] | None = None,\n    channel_wavelengths: list[str] | None = None,\n    channel_colors: Sequence[str] | None = None,\n    channel_active: Sequence[bool] | None = None,\n    table_backend: TableBackend = DefaultTableBackend,\n    overwrite: bool = False,\n    version: NgffVersions = DefaultNgffVersion,\n) -&gt; OmeZarrContainer:\n    \"\"\"Create an empty OME-Zarr image with the given shape and metadata.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group to create the image in.\n        shape (Sequence[int]): The shape of the image.\n        reference_sample (AVAILABLE_SAMPLES | SampleInfo): The reference sample to use.\n        levels (int | list[str], optional): The number of levels in the pyramid or a\n            list of level names. Defaults to 5.\n        xy_scaling_factor (float, optional): The down-scaling factor in x and y\n            dimensions. Defaults to 2.0.\n        z_scaling_factor (float, optional): The down-scaling factor in z dimension.\n            Defaults to 1.0.\n        axes_names (Sequence[str] | None, optional): The names of the axes.\n            If None the canonical names are used. Defaults to None.\n        chunks (Sequence[int] | None, optional): The chunk shape. If None the shape\n            is used. Defaults to None.\n        channel_labels (list[str] | None, optional): The labels of the channels.\n            Defaults to None.\n        channel_wavelengths (list[str] | None, optional): The wavelengths of the\n            channels. Defaults to None.\n        channel_colors (Sequence[str] | None, optional): The colors of the channels.\n            Defaults to None.\n        channel_active (Sequence[bool] | None, optional): Whether the channels are\n            active. Defaults to None.\n        table_backend (TableBackend): Table backend to be used to store tables\n        overwrite (bool, optional): Whether to overwrite an existing image.\n            Defaults to True.\n        version (NgffVersion, optional): The version of the OME-Zarr specification.\n            Defaults to DefaultNgffVersion.\n    \"\"\"\n    if isinstance(reference_sample, str):\n        sample_info = get_sample_info(reference_sample)\n    else:\n        sample_info = reference_sample\n\n    raw = np.asarray(PIL.Image.open(sample_info.img_path))\n    raw = fit_to_shape(arr=raw, out_shape=tuple(shape))\n    raw = raw / np.max(raw) * (2**16 - 1)\n    raw = raw.astype(np.uint16)\n    ome_zarr = create_ome_zarr_from_array(\n        store=store,\n        array=raw,\n        xy_pixelsize=sample_info.xy_pixelsize,\n        z_spacing=sample_info.z_spacing,\n        time_spacing=sample_info.time_spacing,\n        levels=levels,\n        xy_scaling_factor=xy_scaling_factor,\n        z_scaling_factor=z_scaling_factor,\n        space_unit=sample_info.space_unit,\n        time_unit=sample_info.time_unit,\n        axes_names=axes_names,\n        channel_labels=channel_labels,\n        channel_wavelengths=channel_wavelengths,\n        channel_colors=channel_colors,\n        channel_active=channel_active,\n        name=sample_info.name,\n        chunks=chunks,\n        overwrite=overwrite,\n        version=version,\n    )\n\n    image = ome_zarr.get_image()\n    well_table = image.build_image_roi_table()\n    ome_zarr.add_table(\"well_ROI_table\", table=well_table, backend=table_backend)\n\n    for label_info in sample_info.labels:\n        ome_zarr.derive_label(name=label_info.name)\n        label = ome_zarr.get_label(name=label_info.name)\n\n        ref_label = np.asarray(PIL.Image.open(label_info.label_path))\n        ref_label = ref_label.astype(label_info.dtype)\n\n        ref_label = fit_to_shape(\n            arr=ref_label,\n            out_shape=label.shape,\n            ensure_unique_info=label_info.ensure_unique_labels,\n        )\n        ref_label = ref_label.astype(np.uint32)\n        label.set_array(ref_label)\n        label.consolidate()\n\n        if label_info.create_masking_table:\n            masking_table = label.build_masking_roi_table()\n            ome_zarr.add_table(\n                name=f\"{label_info.name}_masking_table\",\n                table=masking_table,\n                backend=table_backend,\n            )\n\n    return ome_zarr\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.create_empty_ome_zarr","title":"create_empty_ome_zarr","text":"<pre><code>create_empty_ome_zarr(\n    store: StoreOrGroup,\n    shape: Sequence[int],\n    xy_pixelsize: float,\n    z_spacing: float = 1.0,\n    time_spacing: float = 1.0,\n    levels: int | list[str] = 5,\n    xy_scaling_factor: float = 2,\n    z_scaling_factor: float = 1.0,\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n    axes_names: Sequence[str] | None = None,\n    name: str | None = None,\n    chunks: Sequence[int] | None = None,\n    dtype: str = \"uint16\",\n    channel_labels: list[str] | None = None,\n    channel_wavelengths: list[str] | None = None,\n    channel_colors: Sequence[str] | None = None,\n    channel_active: Sequence[bool] | None = None,\n    overwrite: bool = False,\n    version: NgffVersions = DefaultNgffVersion,\n) -&gt; OmeZarrContainer\n</code></pre> <p>Create an empty OME-Zarr image with the given shape and metadata.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group to create the image in.</p> </li> <li> <code>shape</code>               (<code>Sequence[int]</code>)           \u2013            <p>The shape of the image.</p> </li> <li> <code>xy_pixelsize</code>               (<code>float</code>)           \u2013            <p>The pixel size in x and y dimensions.</p> </li> <li> <code>z_spacing</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The spacing between z slices. Defaults to 1.0.</p> </li> <li> <code>time_spacing</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The spacing between time points. Defaults to 1.0.</p> </li> <li> <code>levels</code>               (<code>int | list[str]</code>, default:                   <code>5</code> )           \u2013            <p>The number of levels in the pyramid or a list of level names. Defaults to 5.</p> </li> <li> <code>xy_scaling_factor</code>               (<code>float</code>, default:                   <code>2</code> )           \u2013            <p>The down-scaling factor in x and y dimensions. Defaults to 2.0.</p> </li> <li> <code>z_scaling_factor</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The down-scaling factor in z dimension. Defaults to 1.0.</p> </li> <li> <code>space_unit</code>               (<code>SpaceUnits</code>, default:                   <code>DefaultSpaceUnit</code> )           \u2013            <p>The unit of space. Defaults to DefaultSpaceUnit.</p> </li> <li> <code>time_unit</code>               (<code>TimeUnits</code>, default:                   <code>DefaultTimeUnit</code> )           \u2013            <p>The unit of time. Defaults to DefaultTimeUnit.</p> </li> <li> <code>axes_names</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The names of the axes. If None the canonical names are used. Defaults to None.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the image. Defaults to None.</p> </li> <li> <code>chunks</code>               (<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The chunk shape. If None the shape is used. Defaults to None.</p> </li> <li> <code>dtype</code>               (<code>str</code>, default:                   <code>'uint16'</code> )           \u2013            <p>The data type of the image. Defaults to \"uint16\".</p> </li> <li> <code>channel_labels</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The labels of the channels. Defaults to None.</p> </li> <li> <code>channel_wavelengths</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The wavelengths of the channels. Defaults to None.</p> </li> <li> <code>channel_colors</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The colors of the channels. Defaults to None.</p> </li> <li> <code>channel_active</code>               (<code>Sequence[bool] | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether the channels are active. Defaults to None.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to overwrite an existing image. Defaults to True.</p> </li> <li> <code>version</code>               (<code>NgffVersion</code>, default:                   <code>DefaultNgffVersion</code> )           \u2013            <p>The version of the OME-Zarr specification. Defaults to DefaultNgffVersion.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def create_empty_ome_zarr(\n    store: StoreOrGroup,\n    shape: Sequence[int],\n    xy_pixelsize: float,\n    z_spacing: float = 1.0,\n    time_spacing: float = 1.0,\n    levels: int | list[str] = 5,\n    xy_scaling_factor: float = 2,\n    z_scaling_factor: float = 1.0,\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n    axes_names: Sequence[str] | None = None,\n    name: str | None = None,\n    chunks: Sequence[int] | None = None,\n    dtype: str = \"uint16\",\n    channel_labels: list[str] | None = None,\n    channel_wavelengths: list[str] | None = None,\n    channel_colors: Sequence[str] | None = None,\n    channel_active: Sequence[bool] | None = None,\n    overwrite: bool = False,\n    version: NgffVersions = DefaultNgffVersion,\n) -&gt; OmeZarrContainer:\n    \"\"\"Create an empty OME-Zarr image with the given shape and metadata.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group to create the image in.\n        shape (Sequence[int]): The shape of the image.\n        xy_pixelsize (float): The pixel size in x and y dimensions.\n        z_spacing (float, optional): The spacing between z slices. Defaults to 1.0.\n        time_spacing (float, optional): The spacing between time points.\n            Defaults to 1.0.\n        levels (int | list[str], optional): The number of levels in the pyramid or a\n            list of level names. Defaults to 5.\n        xy_scaling_factor (float, optional): The down-scaling factor in x and y\n            dimensions. Defaults to 2.0.\n        z_scaling_factor (float, optional): The down-scaling factor in z dimension.\n            Defaults to 1.0.\n        space_unit (SpaceUnits, optional): The unit of space. Defaults to\n            DefaultSpaceUnit.\n        time_unit (TimeUnits, optional): The unit of time. Defaults to\n            DefaultTimeUnit.\n        axes_names (Sequence[str] | None, optional): The names of the axes.\n            If None the canonical names are used. Defaults to None.\n        name (str | None, optional): The name of the image. Defaults to None.\n        chunks (Sequence[int] | None, optional): The chunk shape. If None the shape\n            is used. Defaults to None.\n        dtype (str, optional): The data type of the image. Defaults to \"uint16\".\n        channel_labels (list[str] | None, optional): The labels of the channels.\n            Defaults to None.\n        channel_wavelengths (list[str] | None, optional): The wavelengths of the\n            channels. Defaults to None.\n        channel_colors (Sequence[str] | None, optional): The colors of the channels.\n            Defaults to None.\n        channel_active (Sequence[bool] | None, optional): Whether the channels are\n            active. Defaults to None.\n        overwrite (bool, optional): Whether to overwrite an existing image.\n            Defaults to True.\n        version (NgffVersion, optional): The version of the OME-Zarr specification.\n            Defaults to DefaultNgffVersion.\n    \"\"\"\n    handler = create_empty_image_container(\n        store=store,\n        shape=shape,\n        pixelsize=xy_pixelsize,\n        z_spacing=z_spacing,\n        time_spacing=time_spacing,\n        levels=levels,\n        yx_scaling_factor=xy_scaling_factor,\n        z_scaling_factor=z_scaling_factor,\n        space_unit=space_unit,\n        time_unit=time_unit,\n        axes_names=axes_names,\n        name=name,\n        chunks=chunks,\n        dtype=dtype,\n        overwrite=overwrite,\n        version=version,\n    )\n\n    ome_zarr = OmeZarrContainer(group_handler=handler)\n    ome_zarr.set_channel_meta(\n        labels=channel_labels,\n        wavelength_id=channel_wavelengths,\n        percentiles=None,\n        colors=channel_colors,\n        active=channel_active,\n    )\n    return ome_zarr\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.create_ome_zarr_from_array","title":"create_ome_zarr_from_array","text":"<pre><code>create_ome_zarr_from_array(\n    store: StoreOrGroup,\n    array: ndarray,\n    xy_pixelsize: float,\n    z_spacing: float = 1.0,\n    time_spacing: float = 1.0,\n    levels: int | list[str] = 5,\n    xy_scaling_factor: float = 2.0,\n    z_scaling_factor: float = 1.0,\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n    axes_names: Sequence[str] | None = None,\n    channel_labels: list[str] | None = None,\n    channel_wavelengths: list[str] | None = None,\n    percentiles: tuple[float, float] | None = (0.1, 99.9),\n    channel_colors: Sequence[str] | None = None,\n    channel_active: Sequence[bool] | None = None,\n    name: str | None = None,\n    chunks: Sequence[int] | None = None,\n    overwrite: bool = False,\n    version: NgffVersions = DefaultNgffVersion,\n) -&gt; OmeZarrContainer\n</code></pre> <p>Create an OME-Zarr image from a numpy array.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group to create the image in.</p> </li> <li> <code>array</code>               (<code>ndarray</code>)           \u2013            <p>The image data.</p> </li> <li> <code>xy_pixelsize</code>               (<code>float</code>)           \u2013            <p>The pixel size in x and y dimensions.</p> </li> <li> <code>z_spacing</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The spacing between z slices. Defaults to 1.0.</p> </li> <li> <code>time_spacing</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The spacing between time points. Defaults to 1.0.</p> </li> <li> <code>levels</code>               (<code>int | list[str]</code>, default:                   <code>5</code> )           \u2013            <p>The number of levels in the pyramid or a list of level names. Defaults to 5.</p> </li> <li> <code>xy_scaling_factor</code>               (<code>float</code>, default:                   <code>2.0</code> )           \u2013            <p>The down-scaling factor in x and y dimensions. Defaults to 2.0.</p> </li> <li> <code>z_scaling_factor</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The down-scaling factor in z dimension. Defaults to 1.0.</p> </li> <li> <code>space_unit</code>               (<code>SpaceUnits</code>, default:                   <code>DefaultSpaceUnit</code> )           \u2013            <p>The unit of space. Defaults to DefaultSpaceUnit.</p> </li> <li> <code>time_unit</code>               (<code>TimeUnits</code>, default:                   <code>DefaultTimeUnit</code> )           \u2013            <p>The unit of time. Defaults to DefaultTimeUnit.</p> </li> <li> <code>axes_names</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The names of the axes. If None the canonical names are used. Defaults to None.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the image. Defaults to None.</p> </li> <li> <code>chunks</code>               (<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The chunk shape. If None the shape is used. Defaults to None.</p> </li> <li> <code>channel_labels</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The labels of the channels. Defaults to None.</p> </li> <li> <code>channel_wavelengths</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The wavelengths of the channels. Defaults to None.</p> </li> <li> <code>percentiles</code>               (<code>tuple[float, float] | None</code>, default:                   <code>(0.1, 99.9)</code> )           \u2013            <p>The percentiles of the channels. Defaults to None.</p> </li> <li> <code>channel_colors</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The colors of the channels. Defaults to None.</p> </li> <li> <code>channel_active</code>               (<code>Sequence[bool] | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether the channels are active. Defaults to None.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to overwrite an existing image. Defaults to True.</p> </li> <li> <code>version</code>               (<code>str</code>, default:                   <code>DefaultNgffVersion</code> )           \u2013            <p>The version of the OME-Zarr specification. Defaults to DefaultNgffVersion.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def create_ome_zarr_from_array(\n    store: StoreOrGroup,\n    array: np.ndarray,\n    xy_pixelsize: float,\n    z_spacing: float = 1.0,\n    time_spacing: float = 1.0,\n    levels: int | list[str] = 5,\n    xy_scaling_factor: float = 2.0,\n    z_scaling_factor: float = 1.0,\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n    axes_names: Sequence[str] | None = None,\n    channel_labels: list[str] | None = None,\n    channel_wavelengths: list[str] | None = None,\n    percentiles: tuple[float, float] | None = (0.1, 99.9),\n    channel_colors: Sequence[str] | None = None,\n    channel_active: Sequence[bool] | None = None,\n    name: str | None = None,\n    chunks: Sequence[int] | None = None,\n    overwrite: bool = False,\n    version: NgffVersions = DefaultNgffVersion,\n) -&gt; OmeZarrContainer:\n    \"\"\"Create an OME-Zarr image from a numpy array.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group to create the image in.\n        array (np.ndarray): The image data.\n        xy_pixelsize (float): The pixel size in x and y dimensions.\n        z_spacing (float, optional): The spacing between z slices. Defaults to 1.0.\n        time_spacing (float, optional): The spacing between time points.\n            Defaults to 1.0.\n        levels (int | list[str], optional): The number of levels in the pyramid or a\n            list of level names. Defaults to 5.\n        xy_scaling_factor (float, optional): The down-scaling factor in x and y\n            dimensions. Defaults to 2.0.\n        z_scaling_factor (float, optional): The down-scaling factor in z dimension.\n            Defaults to 1.0.\n        space_unit (SpaceUnits, optional): The unit of space. Defaults to\n            DefaultSpaceUnit.\n        time_unit (TimeUnits, optional): The unit of time. Defaults to\n            DefaultTimeUnit.\n        axes_names (Sequence[str] | None, optional): The names of the axes.\n            If None the canonical names are used. Defaults to None.\n        name (str | None, optional): The name of the image. Defaults to None.\n        chunks (Sequence[int] | None, optional): The chunk shape. If None the shape\n            is used. Defaults to None.\n        channel_labels (list[str] | None, optional): The labels of the channels.\n            Defaults to None.\n        channel_wavelengths (list[str] | None, optional): The wavelengths of the\n            channels. Defaults to None.\n        percentiles (tuple[float, float] | None, optional): The percentiles of the\n            channels. Defaults to None.\n        channel_colors (Sequence[str] | None, optional): The colors of the channels.\n            Defaults to None.\n        channel_active (Sequence[bool] | None, optional): Whether the channels are\n            active. Defaults to None.\n        overwrite (bool, optional): Whether to overwrite an existing image.\n            Defaults to True.\n        version (str, optional): The version of the OME-Zarr specification.\n            Defaults to DefaultNgffVersion.\n    \"\"\"\n    handler = create_empty_image_container(\n        store=store,\n        shape=array.shape,\n        pixelsize=xy_pixelsize,\n        z_spacing=z_spacing,\n        time_spacing=time_spacing,\n        levels=levels,\n        yx_scaling_factor=xy_scaling_factor,\n        z_scaling_factor=z_scaling_factor,\n        space_unit=space_unit,\n        time_unit=time_unit,\n        axes_names=axes_names,\n        name=name,\n        chunks=chunks,\n        dtype=str(array.dtype),\n        overwrite=overwrite,\n        version=version,\n    )\n\n    ome_zarr = OmeZarrContainer(group_handler=handler)\n    image = ome_zarr.get_image()\n    image.set_array(array)\n    image.consolidate()\n    ome_zarr.set_channel_meta(\n        labels=channel_labels,\n        wavelength_id=channel_wavelengths,\n        percentiles=percentiles,\n        colors=channel_colors,\n        active=channel_active,\n    )\n    return ome_zarr\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.open_image","title":"open_image","text":"<pre><code>open_image(\n    store: StoreOrGroup,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = True,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n) -&gt; Image\n</code></pre> <p>Open a single level image from an OME-Zarr image.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group to create the image in.</p> </li> <li> <code>path</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the image in the ome_zarr file.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the image.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Only used if the pixel size is provided. If True, the     pixel size must match the image pixel size exactly. If False, the     closest pixel size level will be returned.</p> </li> <li> <code>cache</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use a cache for the zarr group metadata.</p> </li> <li> <code>mode</code>               (<code>AccessModeLiteral</code>, default:                   <code>'r+'</code> )           \u2013            <p>The access mode for the image. Defaults to \"r+\".</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def open_image(\n    store: StoreOrGroup,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = True,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n) -&gt; Image:\n    \"\"\"Open a single level image from an OME-Zarr image.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group to create the image in.\n        path (str | None): The path to the image in the ome_zarr file.\n        pixel_size (PixelSize | None): The pixel size of the image.\n        strict (bool): Only used if the pixel size is provided. If True, the\n                pixel size must match the image pixel size exactly. If False, the\n                closest pixel size level will be returned.\n        cache (bool): Whether to use a cache for the zarr group metadata.\n        mode (AccessModeLiteral): The\n            access mode for the image. Defaults to \"r+\".\n    \"\"\"\n    group_handler = ZarrGroupHandler(store, cache, mode)\n    images_container = ImagesContainer(group_handler)\n    return images_container.get(\n        path=path,\n        pixel_size=pixel_size,\n        strict=strict,\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.open_label","title":"open_label","text":"<pre><code>open_label(\n    store: StoreOrGroup,\n    name: str | None = None,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = True,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n) -&gt; Label\n</code></pre> <p>Open a single level label from an OME-Zarr Label group.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group to create the image in.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the label. If None, we will try to open the store as a multiscale label.</p> </li> <li> <code>path</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the image in the ome_zarr file.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the image.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Only used if the pixel size is provided. If True, the pixel size must match the image pixel size exactly. If False, the closest pixel size level will be returned.</p> </li> <li> <code>cache</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use a cache for the zarr group metadata.</p> </li> <li> <code>mode</code>               (<code>AccessModeLiteral</code>, default:                   <code>'r+'</code> )           \u2013            <p>The access mode for the image. Defaults to \"r+\".</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def open_label(\n    store: StoreOrGroup,\n    name: str | None = None,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = True,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n) -&gt; Label:\n    \"\"\"Open a single level label from an OME-Zarr Label group.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group to create the image in.\n        name (str | None): The name of the label. If None,\n            we will try to open the store as a multiscale label.\n        path (str | None): The path to the image in the ome_zarr file.\n        pixel_size (PixelSize | None): The pixel size of the image.\n        strict (bool): Only used if the pixel size is provided. If True, the\n            pixel size must match the image pixel size exactly. If False, the\n            closest pixel size level will be returned.\n        cache (bool): Whether to use a cache for the zarr group metadata.\n        mode (AccessModeLiteral): The access mode for the image. Defaults to \"r+\".\n\n    \"\"\"\n    group_handler = ZarrGroupHandler(store, cache, mode)\n    if name is None:\n        label_meta_handler = find_label_meta_handler(group_handler)\n        path = label_meta_handler.meta.get_dataset(\n            path=path, pixel_size=pixel_size, strict=strict\n        ).path\n        return Label(group_handler, path, label_meta_handler)\n\n    labels_container = LabelsContainer(group_handler)\n    return labels_container.get(\n        name=name,\n        path=path,\n        pixel_size=pixel_size,\n        strict=strict,\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.open_ome_zarr_container","title":"open_ome_zarr_container","text":"<pre><code>open_ome_zarr_container(\n    store: StoreOrGroup,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n    validate_arrays: bool = True,\n) -&gt; OmeZarrContainer\n</code></pre> <p>Open an OME-Zarr image.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def open_ome_zarr_container(\n    store: StoreOrGroup,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n    validate_arrays: bool = True,\n) -&gt; OmeZarrContainer:\n    \"\"\"Open an OME-Zarr image.\"\"\"\n    handler = ZarrGroupHandler(store=store, cache=cache, mode=mode)\n    return OmeZarrContainer(\n        group_handler=handler,\n        validate_paths=validate_arrays,\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.concatenate_image_tables","title":"concatenate_image_tables","text":"<pre><code>concatenate_image_tables(\n    images: Sequence[OmeZarrContainer],\n    extras: Sequence[dict[str, str]],\n    name: str,\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; Table\n</code></pre> <p>Concatenate tables from different images into a single table.</p> <p>Parameters:</p> <ul> <li> <code>images</code>               (<code>Sequence[OmeZarrContainer]</code>)           \u2013            <p>A collection of images.</p> </li> <li> <code>extras</code>               (<code>Sequence[dict[str, str]]</code>)           \u2013            <p>A collection of extras dictionaries for each image. this will be added as columns to the table, and will be concatenated with the table index to create a new index.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table to concatenate.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The key to use for the index of the concatenated table.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, raise an error if the table is not found in the image.</p> </li> <li> <code>mode</code>               (<code>Literal['eager', 'lazy']</code>, default:                   <code>'eager'</code> )           \u2013            <p>The mode to use for concatenation. Can be 'eager' or 'lazy'. if 'eager', the table will be loaded into memory. if 'lazy', the table will be loaded as a lazy frame.</p> </li> </ul> Source code in <code>ngio/images/_table_ops.py</code> <pre><code>def concatenate_image_tables(\n    images: Sequence[OmeZarrContainer],\n    extras: Sequence[dict[str, str]],\n    name: str,\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; Table:\n    \"\"\"Concatenate tables from different images into a single table.\n\n    Args:\n        images: A collection of images.\n        extras: A collection of extras dictionaries for each image.\n            this will be added as columns to the table, and will be\n            concatenated with the table index to create a new index.\n        name: The name of the table to concatenate.\n        index_key: The key to use for the index of the concatenated table.\n        strict: If True, raise an error if the table is not found in the image.\n        mode: The mode to use for concatenation. Can be 'eager' or 'lazy'.\n            if 'eager', the table will be loaded into memory.\n            if 'lazy', the table will be loaded as a lazy frame.\n    \"\"\"\n    return _concatenate_image_tables(\n        images=images,\n        extras=extras,\n        name=name,\n        table_cls=None,\n        index_key=index_key,\n        strict=strict,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.concatenate_image_tables_as","title":"concatenate_image_tables_as","text":"<pre><code>concatenate_image_tables_as(\n    images: Sequence[OmeZarrContainer],\n    extras: Sequence[dict[str, str]],\n    name: str,\n    table_cls: type[TableType],\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; TableType\n</code></pre> <p>Concatenate tables from different images into a single table.</p> <p>Parameters:</p> <ul> <li> <code>images</code>               (<code>Sequence[OmeZarrContainer]</code>)           \u2013            <p>A collection of images.</p> </li> <li> <code>extras</code>               (<code>Sequence[dict[str, str]]</code>)           \u2013            <p>A collection of extras dictionaries for each image. this will be added as columns to the table, and will be concatenated with the table index to create a new index.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table to concatenate.</p> </li> <li> <code>table_cls</code>               (<code>type[TableType]</code>)           \u2013            <p>The output will be casted to this class, if the new table_cls is compatible with the table_cls of the input tables.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The key to use for the index of the concatenated table.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, raise an error if the table is not found in the image.</p> </li> <li> <code>mode</code>               (<code>Literal['eager', 'lazy']</code>, default:                   <code>'eager'</code> )           \u2013            <p>The mode to use for concatenation. Can be 'eager' or 'lazy'. if 'eager', the table will be loaded into memory. if 'lazy', the table will be loaded as a lazy frame.</p> </li> </ul> Source code in <code>ngio/images/_table_ops.py</code> <pre><code>def concatenate_image_tables_as(\n    images: Sequence[OmeZarrContainer],\n    extras: Sequence[dict[str, str]],\n    name: str,\n    table_cls: type[TableType],\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; TableType:\n    \"\"\"Concatenate tables from different images into a single table.\n\n    Args:\n        images: A collection of images.\n        extras: A collection of extras dictionaries for each image.\n            this will be added as columns to the table, and will be\n            concatenated with the table index to create a new index.\n        name: The name of the table to concatenate.\n        table_cls: The output will be casted to this class, if the new table_cls is\n            compatible with the table_cls of the input tables.\n        index_key: The key to use for the index of the concatenated table.\n        strict: If True, raise an error if the table is not found in the image.\n        mode: The mode to use for concatenation. Can be 'eager' or 'lazy'.\n            if 'eager', the table will be loaded into memory.\n            if 'lazy', the table will be loaded as a lazy frame.\n    \"\"\"\n    table = _concatenate_image_tables(\n        images=images,\n        extras=extras,\n        name=name,\n        table_cls=table_cls,\n        index_key=index_key,\n        strict=strict,\n        mode=mode,\n    )\n    if not isinstance(table, table_cls):\n        raise ValueError(f\"Table is not of type {table_cls}. Got {type(table)}\")\n    return table\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.concatenate_image_tables_as_async","title":"concatenate_image_tables_as_async  <code>async</code>","text":"<pre><code>concatenate_image_tables_as_async(\n    images: Sequence[OmeZarrContainer],\n    extras: Sequence[dict[str, str]],\n    name: str,\n    table_cls: type[TableType],\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; TableType\n</code></pre> <p>Concatenate tables from different images into a single table.</p> <p>Parameters:</p> <ul> <li> <code>images</code>               (<code>Sequence[OmeZarrContainer]</code>)           \u2013            <p>A collection of images.</p> </li> <li> <code>extras</code>               (<code>Sequence[dict[str, str]]</code>)           \u2013            <p>A collection of extras dictionaries for each image. this will be added as columns to the table, and will be concatenated with the table index to create a new index.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table to concatenate.</p> </li> <li> <code>table_cls</code>               (<code>type[TableType]</code>)           \u2013            <p>The output will be casted to this class, if the new table_cls is compatible with the table_cls of the input tables.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The key to use for the index of the concatenated table.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, raise an error if the table is not found in the image.</p> </li> <li> <code>mode</code>               (<code>Literal['eager', 'lazy']</code>, default:                   <code>'eager'</code> )           \u2013            <p>The mode to use for concatenation. Can be 'eager' or 'lazy'. if 'eager', the table will be loaded into memory. if 'lazy', the table will be loaded as a lazy frame.</p> </li> </ul> Source code in <code>ngio/images/_table_ops.py</code> <pre><code>async def concatenate_image_tables_as_async(\n    images: Sequence[OmeZarrContainer],\n    extras: Sequence[dict[str, str]],\n    name: str,\n    table_cls: type[TableType],\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; TableType:\n    \"\"\"Concatenate tables from different images into a single table.\n\n    Args:\n        images: A collection of images.\n        extras: A collection of extras dictionaries for each image.\n            this will be added as columns to the table, and will be\n            concatenated with the table index to create a new index.\n        name: The name of the table to concatenate.\n        table_cls: The output will be casted to this class, if the new table_cls is\n            compatible with the table_cls of the input tables.\n        index_key: The key to use for the index of the concatenated table.\n        strict: If True, raise an error if the table is not found in the image.\n        mode: The mode to use for concatenation. Can be 'eager' or 'lazy'.\n            if 'eager', the table will be loaded into memory.\n            if 'lazy', the table will be loaded as a lazy frame.\n    \"\"\"\n    table = await _concatenate_image_tables_async(\n        images=images,\n        extras=extras,\n        name=name,\n        table_cls=table_cls,\n        index_key=index_key,\n        strict=strict,\n        mode=mode,\n    )\n    if not isinstance(table, table_cls):\n        raise ValueError(f\"Table is not of type {table_cls}. Got {type(table)}\")\n    return table\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.concatenate_image_tables_async","title":"concatenate_image_tables_async  <code>async</code>","text":"<pre><code>concatenate_image_tables_async(\n    images: Sequence[OmeZarrContainer],\n    extras: Sequence[dict[str, str]],\n    name: str,\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; Table\n</code></pre> <p>Concatenate tables from different images into a single table.</p> <p>Parameters:</p> <ul> <li> <code>images</code>               (<code>Sequence[OmeZarrContainer]</code>)           \u2013            <p>A collection of images.</p> </li> <li> <code>extras</code>               (<code>Sequence[dict[str, str]]</code>)           \u2013            <p>A collection of extras dictionaries for each image. this will be added as columns to the table, and will be concatenated with the table index to create a new index.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table to concatenate.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The key to use for the index of the concatenated table.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, raise an error if the table is not found in the image.</p> </li> <li> <code>mode</code>               (<code>Literal['eager', 'lazy']</code>, default:                   <code>'eager'</code> )           \u2013            <p>The mode to use for concatenation. Can be 'eager' or 'lazy'. if 'eager', the table will be loaded into memory. if 'lazy', the table will be loaded as a lazy frame.</p> </li> </ul> Source code in <code>ngio/images/_table_ops.py</code> <pre><code>async def concatenate_image_tables_async(\n    images: Sequence[OmeZarrContainer],\n    extras: Sequence[dict[str, str]],\n    name: str,\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; Table:\n    \"\"\"Concatenate tables from different images into a single table.\n\n    Args:\n        images: A collection of images.\n        extras: A collection of extras dictionaries for each image.\n            this will be added as columns to the table, and will be\n            concatenated with the table index to create a new index.\n        name: The name of the table to concatenate.\n        index_key: The key to use for the index of the concatenated table.\n        strict: If True, raise an error if the table is not found in the image.\n        mode: The mode to use for concatenation. Can be 'eager' or 'lazy'.\n            if 'eager', the table will be loaded into memory.\n            if 'lazy', the table will be loaded as a lazy frame.\n    \"\"\"\n    return await _concatenate_image_tables_async(\n        images=images,\n        extras=extras,\n        name=name,\n        table_cls=None,\n        index_key=index_key,\n        strict=strict,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.conctatenate_tables","title":"conctatenate_tables","text":"<pre><code>conctatenate_tables(\n    tables: Sequence[TableWithExtras],\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n    index_key: str | None = None,\n    table_cls: type[TableType] | None = None,\n) -&gt; Table\n</code></pre> <p>Concatenate tables from different plates into a single table.</p> Source code in <code>ngio/images/_table_ops.py</code> <pre><code>def conctatenate_tables(\n    tables: Sequence[TableWithExtras],\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n    index_key: str | None = None,\n    table_cls: type[TableType] | None = None,\n) -&gt; Table:\n    \"\"\"Concatenate tables from different plates into a single table.\"\"\"\n    if len(tables) == 0:\n        raise ValueError(\"No tables to concatenate.\")\n\n    table0 = next(iter(tables)).table\n\n    if mode == \"lazy\":\n        concatenated_table = _pl_concat(tables=tables, index_key=index_key)\n    elif mode == \"eager\":\n        concatenated_table = _pd_concat(tables=tables, index_key=index_key)\n    else:\n        raise ValueError(f\"Unknown mode: {mode}. Use 'eager' or 'lazy'.\")\n\n    meta = table0.meta\n    meta.index_key = index_key\n    meta.index_type = \"str\"\n\n    if table_cls is not None:\n        return table_cls.from_table_data(\n            table_data=concatenated_table,\n            meta=meta,\n        )\n    return table0.from_table_data(\n        table_data=concatenated_table,\n        meta=meta,\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.list_image_tables","title":"list_image_tables","text":"<pre><code>list_image_tables(\n    images: Sequence[OmeZarrContainer],\n    filter_types: str | None = None,\n    mode: Literal[\"common\", \"all\"] = \"common\",\n) -&gt; list[str]\n</code></pre> <p>List all table names in the images.</p> <p>Parameters:</p> <ul> <li> <code>images</code>               (<code>Sequence[OmeZarrContainer]</code>)           \u2013            <p>A collection of images.</p> </li> <li> <code>filter_types</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The type of tables to filter. If None, return all tables. Defaults to None.</p> </li> <li> <code>mode</code>               (<code>Literal['common', 'all']</code>, default:                   <code>'common'</code> )           \u2013            <p>Whether to return only common tables between all images or all tables. Defaults to \"common\".</p> </li> </ul> Source code in <code>ngio/images/_table_ops.py</code> <pre><code>def list_image_tables(\n    images: Sequence[OmeZarrContainer],\n    filter_types: str | None = None,\n    mode: Literal[\"common\", \"all\"] = \"common\",\n) -&gt; list[str]:\n    \"\"\"List all table names in the images.\n\n    Args:\n        images: A collection of images.\n        filter_types (str | None): The type of tables to filter. If None,\n            return all tables. Defaults to None.\n        mode (Literal[\"common\", \"all\"]): Whether to return only common tables\n            between all images or all tables. Defaults to \"common\".\n    \"\"\"\n    tables_names = []\n    for image in images:\n        tables = image.list_tables(filter_types=filter_types)\n        tables_names.append(tables)\n\n    return _tables_names_coalesce(\n        tables_names=tables_names,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/ngio/images/#ngio.images.list_image_tables_async","title":"list_image_tables_async  <code>async</code>","text":"<pre><code>list_image_tables_async(\n    images: Sequence[OmeZarrContainer],\n    filter_types: str | None = None,\n    mode: Literal[\"common\", \"all\"] = \"common\",\n) -&gt; list[str]\n</code></pre> <p>List all image tables in the image asynchronously.</p> <p>Parameters:</p> <ul> <li> <code>images</code>               (<code>Sequence[OmeZarrContainer]</code>)           \u2013            <p>A collection of images.</p> </li> <li> <code>filter_types</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The type of tables to filter. If None, return all tables. Defaults to None.</p> </li> <li> <code>mode</code>               (<code>Literal['common', 'all']</code>, default:                   <code>'common'</code> )           \u2013            <p>Whether to return only common tables between all images or all tables. Defaults to \"common\".</p> </li> </ul> Source code in <code>ngio/images/_table_ops.py</code> <pre><code>async def list_image_tables_async(\n    images: Sequence[OmeZarrContainer],\n    filter_types: str | None = None,\n    mode: Literal[\"common\", \"all\"] = \"common\",\n) -&gt; list[str]:\n    \"\"\"List all image tables in the image asynchronously.\n\n    Args:\n        images: A collection of images.\n        filter_types (str | None): The type of tables to filter. If None,\n            return all tables. Defaults to None.\n        mode (Literal[\"common\", \"all\"]): Whether to return only common tables\n            between all images or all tables. Defaults to \"common\".\n    \"\"\"\n    images_ids = []\n\n    # key table name, value list of paths\n    def process_image(\n        image: OmeZarrContainer, filter_types: str | None = None\n    ) -&gt; list[str]:\n        tables = image.list_tables(filter_types=filter_types)\n        return tables\n\n    tasks = []\n    for i, image in enumerate(images):\n        images_ids.append(i)\n        task = asyncio.to_thread(process_image, image, filter_types=filter_types)\n        tasks.append(task)\n\n    tables_names = await asyncio.gather(*tasks)\n    return _tables_names_coalesce(\n        tables_names=tables_names,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/ngio/ngio/","title":"ngio API documentation","text":""},{"location":"api/ngio/ngio/#ngio","title":"ngio","text":"<p>Next Generation file format IO.</p>"},{"location":"api/ngio/ngio/#ngio.DefaultNgffVersion","title":"DefaultNgffVersion  <code>module-attribute</code>","text":"<pre><code>DefaultNgffVersion: Literal['0.4'] = '0.4'\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.NgffVersions","title":"NgffVersions  <code>module-attribute</code>","text":"<pre><code>NgffVersions = Literal['0.4']\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Dimensions","title":"Dimensions","text":"<pre><code>Dimensions(\n    shape: tuple[int, ...], axes_handler: AxesHandler\n)\n</code></pre> <p>Dimension metadata Handling Class.</p> <p>This class is used to handle and manipulate dimension metadata. It provides methods to access and validate dimension information, such as shape, axes, and properties like is_2d, is_3d, is_time_series, etc.</p> <p>Create a Dimension object from a Zarr array.</p> <p>Parameters:</p> <ul> <li> <code>shape</code>               (<code>tuple[int, ...]</code>)           \u2013            <p>The shape of the Zarr array.</p> </li> <li> <code>axes_handler</code>               (<code>AxesHandler</code>)           \u2013            <p>The axes handler object.</p> </li> </ul> Source code in <code>ngio/common/_dimensions.py</code> <pre><code>def __init__(\n    self,\n    shape: tuple[int, ...],\n    axes_handler: AxesHandler,\n) -&gt; None:\n    \"\"\"Create a Dimension object from a Zarr array.\n\n    Args:\n        shape: The shape of the Zarr array.\n        axes_handler: The axes handler object.\n    \"\"\"\n    self._shape = shape\n    self._axes_handler = axes_handler\n\n    if len(self._shape) != len(self._axes_handler.axes):\n        raise NgioValueError(\n            \"The number of dimensions must match the number of axes. \"\n            f\"Expected Axis {self._axes_handler.axes_names} but got shape \"\n            f\"{self._shape}.\"\n        )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Dimensions.axes_handler","title":"axes_handler  <code>property</code>","text":"<pre><code>axes_handler: AxesHandler\n</code></pre> <p>Return the axes handler object.</p>"},{"location":"api/ngio/ngio/#ngio.Dimensions.shape","title":"shape  <code>property</code>","text":"<pre><code>shape: tuple[int, ...]\n</code></pre> <p>Return the shape as a tuple.</p>"},{"location":"api/ngio/ngio/#ngio.Dimensions.axes","title":"axes  <code>property</code>","text":"<pre><code>axes: tuple[str, ...]\n</code></pre> <p>Return the axes as a tuple of strings.</p>"},{"location":"api/ngio/ngio/#ngio.Dimensions.is_time_series","title":"is_time_series  <code>property</code>","text":"<pre><code>is_time_series: bool\n</code></pre> <p>Return whether the data is a time series.</p>"},{"location":"api/ngio/ngio/#ngio.Dimensions.is_2d","title":"is_2d  <code>property</code>","text":"<pre><code>is_2d: bool\n</code></pre> <p>Return whether the data is 2D.</p>"},{"location":"api/ngio/ngio/#ngio.Dimensions.is_2d_time_series","title":"is_2d_time_series  <code>property</code>","text":"<pre><code>is_2d_time_series: bool\n</code></pre> <p>Return whether the data is a 2D time series.</p>"},{"location":"api/ngio/ngio/#ngio.Dimensions.is_3d","title":"is_3d  <code>property</code>","text":"<pre><code>is_3d: bool\n</code></pre> <p>Return whether the data is 3D.</p>"},{"location":"api/ngio/ngio/#ngio.Dimensions.is_3d_time_series","title":"is_3d_time_series  <code>property</code>","text":"<pre><code>is_3d_time_series: bool\n</code></pre> <p>Return whether the data is a 3D time series.</p>"},{"location":"api/ngio/ngio/#ngio.Dimensions.is_multi_channels","title":"is_multi_channels  <code>property</code>","text":"<pre><code>is_multi_channels: bool\n</code></pre> <p>Return whether the data has multiple channels.</p>"},{"location":"api/ngio/ngio/#ngio.Dimensions.default_init","title":"default_init  <code>classmethod</code>","text":"<pre><code>default_init(\n    shape: tuple[int, ...],\n    axes_names: Sequence[str],\n    space_units: SpaceUnits | str | None = DefaultSpaceUnit,\n    time_units: TimeUnits | str | None = DefaultTimeUnit,\n    axes_setup: AxesSetup | None = None,\n    allow_non_canonical_axes: bool = False,\n    strict_canonical_order: bool = False,\n) -&gt; Dimensions\n</code></pre> <p>Create a Dimension object from a shape and axes names.</p> Source code in <code>ngio/common/_dimensions.py</code> <pre><code>@classmethod\ndef default_init(\n    cls,\n    shape: tuple[int, ...],\n    axes_names: Sequence[str],\n    space_units: SpaceUnits | str | None = DefaultSpaceUnit,\n    time_units: TimeUnits | str | None = DefaultTimeUnit,\n    # user defined args\n    axes_setup: AxesSetup | None = None,\n    allow_non_canonical_axes: bool = False,\n    strict_canonical_order: bool = False,\n) -&gt; \"Dimensions\":\n    \"\"\"Create a Dimension object from a shape and axes names.\"\"\"\n    axes_handler = build_canonical_axes_handler(\n        axes_names=axes_names,\n        space_units=space_units,\n        time_units=time_units,\n        axes_setup=axes_setup,\n        allow_non_canonical_axes=allow_non_canonical_axes,\n        strict_canonical_order=strict_canonical_order,\n    )\n    return cls(shape=shape, axes_handler=axes_handler)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Dimensions.get","title":"get","text":"<pre><code>get(axis_name: str, default: None = None) -&gt; int | None\n</code></pre><pre><code>get(axis_name: str, default: int) -&gt; int\n</code></pre> <pre><code>get(\n    axis_name: str, default: int | None = None\n) -&gt; int | None\n</code></pre> <p>Return the dimension of the given axis name.</p> <p>Parameters:</p> <ul> <li> <code>axis_name</code>               (<code>str</code>)           \u2013            <p>The name of the axis (either canonical or non-canonical).</p> </li> <li> <code>default</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The default value to return if the axis does not exist.</p> </li> </ul> Source code in <code>ngio/common/_dimensions.py</code> <pre><code>def get(self, axis_name: str, default: int | None = None) -&gt; int | None:\n    \"\"\"Return the dimension of the given axis name.\n\n    Args:\n        axis_name: The name of the axis (either canonical or non-canonical).\n        default: The default value to return if the axis does not exist.\n    \"\"\"\n    index = self.axes_handler.get_index(axis_name)\n    if index is None:\n        return default\n    return self._shape[index]\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Dimensions.get_index","title":"get_index","text":"<pre><code>get_index(axis_name: str) -&gt; int | None\n</code></pre> <p>Return the index of the given axis name.</p> <p>Parameters:</p> <ul> <li> <code>axis_name</code>               (<code>str</code>)           \u2013            <p>The name of the axis (either canonical or non-canonical).</p> </li> </ul> Source code in <code>ngio/common/_dimensions.py</code> <pre><code>def get_index(self, axis_name: str) -&gt; int | None:\n    \"\"\"Return the index of the given axis name.\n\n    Args:\n        axis_name: The name of the axis (either canonical or non-canonical).\n    \"\"\"\n    return self.axes_handler.get_index(axis_name)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Dimensions.get_pixel_size","title":"get_pixel_size","text":"<pre><code>get_pixel_size(axis_name: str) -&gt; float | None\n</code></pre> <p>Return the pixel size of the given axis name.</p> <p>Parameters:</p> <ul> <li> <code>axis_name</code>               (<code>str</code>)           \u2013            <p>The name of the axis (either canonical or non-canonical).</p> </li> </ul> Source code in <code>ngio/common/_dimensions.py</code> <pre><code>def get_pixel_size(self, axis_name: str) -&gt; float | None:\n    \"\"\"Return the pixel size of the given axis name.\n\n    Args:\n        axis_name: The name of the axis (either canonical or non-canonical).\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Dimensions.has_axis","title":"has_axis","text":"<pre><code>has_axis(axis_name: str) -&gt; bool\n</code></pre> <p>Return whether the axis exists.</p> Source code in <code>ngio/common/_dimensions.py</code> <pre><code>def has_axis(self, axis_name: str) -&gt; bool:\n    \"\"\"Return whether the axis exists.\"\"\"\n    index = self.axes_handler.get_index(axis_name)\n    if index is None:\n        return False\n    return True\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Dimensions.assert_axes_match","title":"assert_axes_match","text":"<pre><code>assert_axes_match(other: Dimensions) -&gt; None\n</code></pre> <p>Check if two Dimensions objects have the same axes.</p> <p>Besides the channel axis (which is a special case), all axes must be present in both Dimensions objects.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>Dimensions</code>)           \u2013            <p>The other dimensions object to compare against.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NgioValueError</code>             \u2013            <p>If the axes do not match.</p> </li> </ul> Source code in <code>ngio/common/_dimensions.py</code> <pre><code>def assert_axes_match(self, other: \"Dimensions\") -&gt; None:\n    \"\"\"Check if two Dimensions objects have the same axes.\n\n    Besides the channel axis (which is a special case), all axes must be\n    present in both Dimensions objects.\n\n    Args:\n        other (Dimensions): The other dimensions object to compare against.\n\n    Raises:\n        NgioValueError: If the axes do not match.\n    \"\"\"\n    for s_axis in self.axes_handler.axes:\n        if s_axis.axis_type == \"channel\":\n            continue\n        o_axis = other.axes_handler.get_axis(s_axis.name)\n        if o_axis is None:\n            raise NgioValueError(\n                f\"Axes do not match. The axis {s_axis.name} \"\n                f\"is not present in either dimensions.\"\n            )\n    # Check for axes present in the other dimensions but not in this one\n    for o_axis in other.axes_handler.axes:\n        if o_axis.axis_type == \"channel\":\n            continue\n        s_axis = self.axes_handler.get_axis(o_axis.name)\n        if s_axis is None:\n            raise NgioValueError(\n                f\"Axes do not match. The axis {o_axis.name} \"\n                f\"is not present in either dimensions.\"\n            )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Dimensions.assert_dimensions_match","title":"assert_dimensions_match","text":"<pre><code>assert_dimensions_match(\n    other: Dimensions, allow_singleton: bool = False\n) -&gt; None\n</code></pre> <p>Check if two Dimensions objects have the same axes and dimensions.</p> <p>Besides the channel axis, all axes must have the same dimension in both images.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>Dimensions</code>)           \u2013            <p>The other dimensions object to compare against.</p> </li> <li> <code>allow_singleton</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to allow singleton dimensions to be different. For example, if the input image has shape (5, 100, 100) and the label has shape (1, 100, 100).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NgioValueError</code>             \u2013            <p>If the dimensions do not match.</p> </li> </ul> Source code in <code>ngio/common/_dimensions.py</code> <pre><code>def assert_dimensions_match(\n    self, other: \"Dimensions\", allow_singleton: bool = False\n) -&gt; None:\n    \"\"\"Check if two Dimensions objects have the same axes and dimensions.\n\n    Besides the channel axis, all axes must have the same dimension in\n    both images.\n\n    Args:\n        other (Dimensions): The other dimensions object to compare against.\n        allow_singleton (bool): Whether to allow singleton dimensions to be\n            different. For example, if the input image has shape\n            (5, 100, 100) and the label has shape (1, 100, 100).\n\n    Raises:\n        NgioValueError: If the dimensions do not match.\n    \"\"\"\n    self.assert_axes_match(other)\n    for s_axis in self.axes_handler.axes:\n        if s_axis.axis_type == \"channel\":\n            continue\n        o_axis = other.axes_handler.get_axis(s_axis.name)\n        assert o_axis is not None  # already checked in assert_axes_match\n\n        i_dim = self.get(s_axis.name, default=1)\n        o_dim = other.get(o_axis.name, default=1)\n\n        if i_dim != o_dim:\n            if allow_singleton and (i_dim == 1 or o_dim == 1):\n                continue\n            raise NgioValueError(\n                f\"Dimensions do not match for axis \"\n                f\"{s_axis.name}. Got {i_dim} and {o_dim}.\"\n            )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Roi","title":"Roi","text":"<p>               Bases: <code>GenericRoi</code></p>"},{"location":"api/ngio/ngio/#ngio.Roi.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str | None\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Roi.z","title":"z  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>z: float | None = None\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Roi.t","title":"t  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>t: float | None = None\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Roi.x_length","title":"x_length  <code>instance-attribute</code>","text":"<pre><code>x_length: float\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Roi.y_length","title":"y_length  <code>instance-attribute</code>","text":"<pre><code>y_length: float\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Roi.z_length","title":"z_length  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>z_length: float | None = None\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Roi.t_length","title":"t_length  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>t_length: float | None = None\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Roi.label","title":"label  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>label: int | None = None\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Roi.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(extra='allow')\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Roi.x","title":"x  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>x: float = 0.0\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Roi.y","title":"y  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>y: float = 0.0\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Roi.unit","title":"unit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>unit: SpaceUnits | str | None = DefaultSpaceUnit\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Roi.intersection","title":"intersection","text":"<pre><code>intersection(other: GenericRoi) -&gt; GenericRoi | None\n</code></pre> <p>Calculate the intersection of this ROI with another ROI.</p> Source code in <code>ngio/common/_roi.py</code> <pre><code>def intersection(self, other: \"GenericRoi\") -&gt; \"GenericRoi | None\":\n    \"\"\"Calculate the intersection of this ROI with another ROI.\"\"\"\n    return roi_intersection(self, other)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Roi.get_name","title":"get_name","text":"<pre><code>get_name() -&gt; str\n</code></pre> <p>Get the name of the ROI, or a default if not set.</p> Source code in <code>ngio/common/_roi.py</code> <pre><code>def get_name(self) -&gt; str:\n    \"\"\"Get the name of the ROI, or a default if not set.\"\"\"\n    if self.name is not None:\n        return self.name\n    return self._nice_str()\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Roi.to_roi_pixels","title":"to_roi_pixels","text":"<pre><code>to_roi_pixels(\n    pixel_size: PixelSize,\n    dimensions: Dimensions | None = None,\n) -&gt; RoiPixels\n</code></pre> <p>Convert to raster coordinates.</p> Source code in <code>ngio/common/_roi.py</code> <pre><code>def to_roi_pixels(\n    self, pixel_size: PixelSize, dimensions: Dimensions | None = None\n) -&gt; \"RoiPixels\":\n    \"\"\"Convert to raster coordinates.\"\"\"\n    if dimensions is None:\n        _dimensions = BaseDimensions()\n    else:\n        _dimensions = BaseDimensions(\n            dim_x=dimensions.get(\"x\"),\n            dim_y=dimensions.get(\"y\"),\n            dim_z=dimensions.get(\"z\"),\n            dim_t=dimensions.get(\"t\"),\n        )\n\n    x, x_length = _to_raster(self.x, self.x_length, pixel_size.x)\n    y, y_length = _to_raster(self.y, self.y_length, pixel_size.y)\n\n    if self.z is None:\n        z, z_length = None, None\n    else:\n        assert self.z_length is not None\n        z, z_length = _to_raster(self.z, self.z_length, pixel_size.z)\n\n    if self.t is None:\n        t, t_length = None, None\n    else:\n        assert self.t_length is not None\n        t, t_length = _to_raster(self.t, self.t_length, pixel_size.t)\n    extra_dict = self.model_extra if self.model_extra else {}\n\n    return RoiPixels(\n        name=self.name,\n        x=x,\n        y=y,\n        z=z,\n        t=t,\n        x_length=x_length,\n        y_length=y_length,\n        z_length=z_length,\n        t_length=t_length,\n        label=self.label,\n        unit=self.unit,\n        dimensions=_dimensions,\n        **extra_dict,\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Roi.to_pixel_roi","title":"to_pixel_roi","text":"<pre><code>to_pixel_roi(\n    pixel_size: PixelSize,\n    dimensions: Dimensions | None = None,\n) -&gt; RoiPixels\n</code></pre> <p>Convert to raster coordinates.</p> Source code in <code>ngio/common/_roi.py</code> <pre><code>def to_pixel_roi(\n    self, pixel_size: PixelSize, dimensions: Dimensions | None = None\n) -&gt; \"RoiPixels\":\n    \"\"\"Convert to raster coordinates.\"\"\"\n    warn(\n        \"to_pixel_roi is deprecated and will be removed in a future release. \"\n        \"Use to_roi_pixels instead.\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n\n    return self.to_roi_pixels(pixel_size=pixel_size, dimensions=dimensions)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Roi.zoom","title":"zoom","text":"<pre><code>zoom(zoom_factor: float = 1) -&gt; Roi\n</code></pre> <p>Zoom the ROI by a factor.</p> <p>Parameters:</p> <ul> <li> <code>zoom_factor</code>               (<code>float</code>, default:                   <code>1</code> )           \u2013            <p>The zoom factor. If the zoom factor is less than 1 the ROI will be zoomed in. If the zoom factor is greater than 1 the ROI will be zoomed out. If the zoom factor is 1 the ROI will not be changed.</p> </li> </ul> Source code in <code>ngio/common/_roi.py</code> <pre><code>def zoom(self, zoom_factor: float = 1) -&gt; \"Roi\":\n    \"\"\"Zoom the ROI by a factor.\n\n    Args:\n        zoom_factor: The zoom factor. If the zoom factor\n            is less than 1 the ROI will be zoomed in.\n            If the zoom factor is greater than 1 the ROI will be zoomed out.\n            If the zoom factor is 1 the ROI will not be changed.\n    \"\"\"\n    return zoom_roi(self, zoom_factor)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.RoiPixels","title":"RoiPixels","text":"<p>               Bases: <code>GenericRoi</code></p> <p>Region of interest (ROI) in pixel coordinates.</p>"},{"location":"api/ngio/ngio/#ngio.RoiPixels.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str | None\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.RoiPixels.z","title":"z  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>z: float | None = None\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.RoiPixels.t","title":"t  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>t: float | None = None\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.RoiPixels.x_length","title":"x_length  <code>instance-attribute</code>","text":"<pre><code>x_length: float\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.RoiPixels.y_length","title":"y_length  <code>instance-attribute</code>","text":"<pre><code>y_length: float\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.RoiPixels.z_length","title":"z_length  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>z_length: float | None = None\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.RoiPixels.t_length","title":"t_length  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>t_length: float | None = None\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.RoiPixels.label","title":"label  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>label: int | None = None\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.RoiPixels.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(extra='allow')\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.RoiPixels.x","title":"x  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>x: float = 0\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.RoiPixels.y","title":"y  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>y: float = 0\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.RoiPixels.unit","title":"unit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>unit: SpaceUnits | str | None = None\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.RoiPixels.dimensions","title":"dimensions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dimensions: BaseDimensions = Field(\n    default_factory=BaseDimensions\n)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.RoiPixels.intersection","title":"intersection","text":"<pre><code>intersection(other: GenericRoi) -&gt; GenericRoi | None\n</code></pre> <p>Calculate the intersection of this ROI with another ROI.</p> Source code in <code>ngio/common/_roi.py</code> <pre><code>def intersection(self, other: \"GenericRoi\") -&gt; \"GenericRoi | None\":\n    \"\"\"Calculate the intersection of this ROI with another ROI.\"\"\"\n    return roi_intersection(self, other)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.RoiPixels.get_name","title":"get_name","text":"<pre><code>get_name() -&gt; str\n</code></pre> <p>Get the name of the ROI, or a default if not set.</p> Source code in <code>ngio/common/_roi.py</code> <pre><code>def get_name(self) -&gt; str:\n    \"\"\"Get the name of the ROI, or a default if not set.\"\"\"\n    if self.name is not None:\n        return self.name\n    return self._nice_str()\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.RoiPixels.to_roi","title":"to_roi","text":"<pre><code>to_roi(pixel_size: PixelSize) -&gt; Roi\n</code></pre> <p>Convert to raster coordinates.</p> Source code in <code>ngio/common/_roi.py</code> <pre><code>def to_roi(self, pixel_size: PixelSize) -&gt; \"Roi\":\n    \"\"\"Convert to raster coordinates.\"\"\"\n    x = _to_world(self.x, pixel_size.x)\n    x_length = _to_world(self.x_length, pixel_size.x)\n    y = _to_world(self.y, pixel_size.y)\n    y_length = _to_world(self.y_length, pixel_size.y)\n\n    if self.z is None:\n        z = None\n    else:\n        z = _to_world(self.z, pixel_size.z)\n\n    if self.z_length is None:\n        z_length = None\n    else:\n        z_length = _to_world(self.z_length, pixel_size.z)\n\n    if self.t is None:\n        t = None\n    else:\n        t = _to_world(self.t, pixel_size.t)\n\n    if self.t_length is None:\n        t_length = None\n    else:\n        t_length = _to_world(self.t_length, pixel_size.t)\n\n    extra_dict = self.model_extra if self.model_extra else {}\n    return Roi(\n        name=self.name,\n        x=x,\n        y=y,\n        z=z,\n        t=t,\n        x_length=x_length,\n        y_length=y_length,\n        z_length=z_length,\n        t_length=t_length,\n        label=self.label,\n        unit=self.unit,\n        **extra_dict,\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.RoiPixels.to_slicing_dict","title":"to_slicing_dict","text":"<pre><code>to_slicing_dict() -&gt; dict[str, slice]\n</code></pre> <p>Convert to a slicing dictionary.</p> Source code in <code>ngio/common/_roi.py</code> <pre><code>def to_slicing_dict(self) -&gt; dict[str, slice]:\n    \"\"\"Convert to a slicing dictionary.\"\"\"\n    x_slice = _to_slice(self.x, self.x_length)\n    y_slice = _to_slice(self.y, self.y_length)\n    z_slice = _to_slice(self.z, self.z_length)\n    t_slice = _to_slice(self.t, self.t_length)\n    return {\n        \"x\": x_slice,\n        \"y\": y_slice,\n        \"z\": z_slice,\n        \"t\": t_slice,\n    }\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate","title":"OmeZarrPlate","text":"<pre><code>OmeZarrPlate(\n    group_handler: ZarrGroupHandler,\n    table_container: TablesContainer | None = None,\n)\n</code></pre> <p>A class to handle the Plate Sequence in an OME-Zarr file.</p> <p>Initialize the LabelGroupHandler.</p> <p>Parameters:</p> <ul> <li> <code>group_handler</code>               (<code>ZarrGroupHandler</code>)           \u2013            <p>The Zarr group handler that contains the Plate.</p> </li> <li> <code>table_container</code>               (<code>TablesContainer | None</code>, default:                   <code>None</code> )           \u2013            <p>The tables container that contains plate level tables.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def __init__(\n    self,\n    group_handler: ZarrGroupHandler,\n    table_container: TablesContainer | None = None,\n) -&gt; None:\n    \"\"\"Initialize the LabelGroupHandler.\n\n    Args:\n        group_handler: The Zarr group handler that contains the Plate.\n        table_container: The tables container that contains plate level tables.\n    \"\"\"\n    self._group_handler = group_handler\n    self._meta_handler = find_plate_meta_handler(group_handler)\n    self._tables_container = table_container\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.meta_handler","title":"meta_handler  <code>property</code>","text":"<pre><code>meta_handler\n</code></pre> <p>Return the metadata handler.</p>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.meta","title":"meta  <code>property</code>","text":"<pre><code>meta\n</code></pre> <p>Return the metadata.</p>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.columns","title":"columns  <code>property</code>","text":"<pre><code>columns: list[str]\n</code></pre> <p>Return the number of columns in the plate.</p>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.rows","title":"rows  <code>property</code>","text":"<pre><code>rows: list[str]\n</code></pre> <p>Return the number of rows in the plate.</p>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.acquisitions_names","title":"acquisitions_names  <code>property</code>","text":"<pre><code>acquisitions_names: list[str | None]\n</code></pre> <p>Return the acquisitions in the plate.</p>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.acquisition_ids","title":"acquisition_ids  <code>property</code>","text":"<pre><code>acquisition_ids: list[int]\n</code></pre> <p>Return the acquisitions ids in the plate.</p>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.tables_container","title":"tables_container  <code>property</code>","text":"<pre><code>tables_container: TablesContainer\n</code></pre> <p>Return the tables container.</p>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.wells_paths","title":"wells_paths","text":"<pre><code>wells_paths() -&gt; list[str]\n</code></pre> <p>Return the wells paths in the plate.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def wells_paths(self) -&gt; list[str]:\n    \"\"\"Return the wells paths in the plate.\"\"\"\n    return self.meta.wells_paths\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.images_paths_async","title":"images_paths_async  <code>async</code>","text":"<pre><code>images_paths_async(\n    acquisition: int | None = None,\n) -&gt; list[str]\n</code></pre> <p>Return the images paths in the plate asynchronously.</p> <p>If acquisition is None, return all images paths in the plate. Else, return the images paths in the plate for the given acquisition.</p> <p>Parameters:</p> <ul> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>async def images_paths_async(self, acquisition: int | None = None) -&gt; list[str]:\n    \"\"\"Return the images paths in the plate asynchronously.\n\n    If acquisition is None, return all images paths in the plate.\n    Else, return the images paths in the plate for the given acquisition.\n\n    Args:\n        acquisition (int | None): The acquisition id to filter the images.\n    \"\"\"\n    wells = await self.get_wells_async()\n    paths = []\n    for well_path, well in wells.items():\n        for img_path in well.paths(acquisition):\n            paths.append(f\"{well_path}/{img_path}\")\n    return paths\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.images_paths","title":"images_paths","text":"<pre><code>images_paths(acquisition: int | None = None) -&gt; list[str]\n</code></pre> <p>Return the images paths in the plate.</p> <p>If acquisition is None, return all images paths in the plate. Else, return the images paths in the plate for the given acquisition.</p> <p>Parameters:</p> <ul> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def images_paths(self, acquisition: int | None = None) -&gt; list[str]:\n    \"\"\"Return the images paths in the plate.\n\n    If acquisition is None, return all images paths in the plate.\n    Else, return the images paths in the plate for the given acquisition.\n\n    Args:\n        acquisition (int | None): The acquisition id to filter the images.\n    \"\"\"\n    wells = self.get_wells()\n    images = []\n    for well_path, well in wells.items():\n        for img_path in well.paths(acquisition):\n            images.append(f\"{well_path}/{img_path}\")\n    return images\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.well_images_paths","title":"well_images_paths","text":"<pre><code>well_images_paths(\n    row: str,\n    column: int | str,\n    acquisition: int | None = None,\n) -&gt; list[str]\n</code></pre> <p>Return the images paths in a well.</p> <p>If acquisition is None, return all images paths in the well. Else, return the images paths in the well for the given acquisition.</p> <p>Parameters:</p> <ul> <li> <code>row</code>               (<code>str</code>)           \u2013            <p>The row of the well.</p> </li> <li> <code>column</code>               (<code>int | str</code>)           \u2013            <p>The column of the well.</p> </li> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def well_images_paths(\n    self, row: str, column: int | str, acquisition: int | None = None\n) -&gt; list[str]:\n    \"\"\"Return the images paths in a well.\n\n    If acquisition is None, return all images paths in the well.\n    Else, return the images paths in the well for the given acquisition.\n\n    Args:\n        row (str): The row of the well.\n        column (int | str): The column of the well.\n        acquisition (int | None): The acquisition id to filter the images.\n    \"\"\"\n    images = []\n    well = self.get_well(row=row, column=column)\n    for path in well.paths(acquisition):\n        images.append(self._image_path(row=row, column=column, path=path))\n    return images\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.get_image_acquisition_id","title":"get_image_acquisition_id","text":"<pre><code>get_image_acquisition_id(\n    row: str, column: int | str, image_path: str\n) -&gt; int | None\n</code></pre> <p>Get the acquisition id of an image in a well.</p> <p>Parameters:</p> <ul> <li> <code>row</code>               (<code>str</code>)           \u2013            <p>The row of the well.</p> </li> <li> <code>column</code>               (<code>int | str</code>)           \u2013            <p>The column of the well.</p> </li> <li> <code>image_path</code>               (<code>str</code>)           \u2013            <p>The path of the image.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int | None</code>           \u2013            <p>int | None: The acquisition id of the image.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_image_acquisition_id(\n    self, row: str, column: int | str, image_path: str\n) -&gt; int | None:\n    \"\"\"Get the acquisition id of an image in a well.\n\n    Args:\n        row (str): The row of the well.\n        column (int | str): The column of the well.\n        image_path (str): The path of the image.\n\n    Returns:\n        int | None: The acquisition id of the image.\n    \"\"\"\n    well = self.get_well(row=row, column=column)\n    return well.get_image_acquisition_id(image_path=image_path)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.get_well","title":"get_well","text":"<pre><code>get_well(row: str, column: int | str) -&gt; OmeZarrWell\n</code></pre> <p>Get a well from the plate.</p> <p>Parameters:</p> <ul> <li> <code>row</code>               (<code>str</code>)           \u2013            <p>The row of the well.</p> </li> <li> <code>column</code>               (<code>int | str</code>)           \u2013            <p>The column of the well.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OmeZarrWell</code> (              <code>OmeZarrWell</code> )          \u2013            <p>The well.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_well(self, row: str, column: int | str) -&gt; OmeZarrWell:\n    \"\"\"Get a well from the plate.\n\n    Args:\n        row (str): The row of the well.\n        column (int | str): The column of the well.\n\n    Returns:\n        OmeZarrWell: The well.\n    \"\"\"\n    well_path = self._well_path(row=row, column=column)\n    group_handler = self._group_handler.derive_handler(well_path)\n    return OmeZarrWell(group_handler)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.get_wells_async","title":"get_wells_async  <code>async</code>","text":"<pre><code>get_wells_async() -&gt; dict[str, OmeZarrWell]\n</code></pre> <p>Get all wells in the plate asynchronously.</p> <p>This method processes wells in parallel for improved performance when working with a large number of wells.</p> <p>Returns:</p> <ul> <li> <code>dict[str, OmeZarrWell]</code>           \u2013            <p>dict[str, OmeZarrWell]: A dictionary of wells, where the key is the well path and the value is the well object.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>async def get_wells_async(self) -&gt; dict[str, OmeZarrWell]:\n    \"\"\"Get all wells in the plate asynchronously.\n\n    This method processes wells in parallel for improved performance\n    when working with a large number of wells.\n\n    Returns:\n        dict[str, OmeZarrWell]: A dictionary of wells, where the key is the well\n            path and the value is the well object.\n    \"\"\"\n    wells = self._group_handler.get_from_cache(\"wells\")\n    if wells is not None:\n        assert isinstance(wells, dict)\n        return wells\n\n    def process_well(well_path):\n        group_handler = self._group_handler.derive_handler(well_path)\n        well = OmeZarrWell(group_handler)\n        return well_path, well\n\n    wells, tasks = {}, []\n    for well_path in self.wells_paths():\n        task = asyncio.to_thread(process_well, well_path)\n        tasks.append(task)\n\n    results = await asyncio.gather(*tasks)\n    for well_path, well in results:\n        wells[well_path] = well\n\n    self._group_handler.add_to_cache(\"wells\", wells)\n    return wells\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.get_wells","title":"get_wells","text":"<pre><code>get_wells() -&gt; dict[str, OmeZarrWell]\n</code></pre> <p>Get all wells in the plate.</p> <p>Returns:</p> <ul> <li> <code>dict[str, OmeZarrWell]</code>           \u2013            <p>dict[str, OmeZarrWell]: A dictionary of wells, where the key is the well path and the value is the well object.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_wells(self) -&gt; dict[str, OmeZarrWell]:\n    \"\"\"Get all wells in the plate.\n\n    Returns:\n        dict[str, OmeZarrWell]: A dictionary of wells, where the key is the well\n            path and the value is the well object.\n    \"\"\"\n    wells = self._group_handler.get_from_cache(\"wells\")\n    if wells is not None:\n        assert isinstance(wells, dict)\n        return wells\n\n    def process_well(well_path):\n        group_handler = self._group_handler.derive_handler(well_path)\n        well = OmeZarrWell(group_handler)\n        return well_path, well\n\n    wells = {}\n    for well_path in self.wells_paths():\n        _, well = process_well(well_path)\n        wells[well_path] = well\n\n    self._group_handler.add_to_cache(\"wells\", wells)\n    return wells\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.get_images_async","title":"get_images_async  <code>async</code>","text":"<pre><code>get_images_async(\n    acquisition: int | None = None,\n) -&gt; dict[str, OmeZarrContainer]\n</code></pre> <p>Get all images in the plate asynchronously.</p> <p>This method processes images in parallel for improved performance when working with a large number of images.</p> <p>Parameters:</p> <ul> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, OmeZarrContainer]</code>           \u2013            <p>dict[str, OmeZarrContainer]: A dictionary of images, where the key is the image path and the value is the image object.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>async def get_images_async(\n    self, acquisition: int | None = None\n) -&gt; dict[str, OmeZarrContainer]:\n    \"\"\"Get all images in the plate asynchronously.\n\n    This method processes images in parallel for improved performance\n    when working with a large number of images.\n\n    Args:\n        acquisition: The acquisition id to filter the images.\n\n    Returns:\n        dict[str, OmeZarrContainer]: A dictionary of images, where the key is the\n            image path and the value is the image object.\n    \"\"\"\n    images = self._group_handler.get_from_cache(\"images\")\n    if images is not None:\n        assert isinstance(images, dict)\n        return images\n\n    paths = await self.images_paths_async(acquisition=acquisition)\n\n    def process_image(image_path):\n        \"\"\"Process a single image and return the image path and image object.\"\"\"\n        img_group_handler = self._group_handler.derive_handler(image_path)\n        image = OmeZarrContainer(img_group_handler)\n        return image_path, image\n\n    images, tasks = {}, []\n    for image_path in paths:\n        task = asyncio.to_thread(process_image, image_path)\n        tasks.append(task)\n\n    results = await asyncio.gather(*tasks)\n\n    for image_path, image in results:\n        images[image_path] = image\n\n    self._group_handler.add_to_cache(\"images\", images)\n    return images\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.get_images","title":"get_images","text":"<pre><code>get_images(\n    acquisition: int | None = None,\n) -&gt; dict[str, OmeZarrContainer]\n</code></pre> <p>Get all images in the plate.</p> <p>Parameters:</p> <ul> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_images(self, acquisition: int | None = None) -&gt; dict[str, OmeZarrContainer]:\n    \"\"\"Get all images in the plate.\n\n    Args:\n        acquisition: The acquisition id to filter the images.\n    \"\"\"\n    images = self._group_handler.get_from_cache(\"images\")\n    if images is not None:\n        assert isinstance(images, dict)\n        return images\n    paths = self.images_paths(acquisition=acquisition)\n\n    def process_image(image_path):\n        \"\"\"Process a single image and return the image path and image object.\"\"\"\n        img_group_handler = self._group_handler.derive_handler(image_path)\n        image = OmeZarrContainer(img_group_handler)\n        return image_path, image\n\n    images = {}\n    for image_path in paths:\n        _, image = process_image(image_path)\n        images[image_path] = image\n\n    self._group_handler.add_to_cache(\"images\", images)\n    return images\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.get_image","title":"get_image","text":"<pre><code>get_image(\n    row: str, column: int | str, image_path: str\n) -&gt; OmeZarrContainer\n</code></pre> <p>Get an image from the plate.</p> <p>Parameters:</p> <ul> <li> <code>row</code>               (<code>str</code>)           \u2013            <p>The row of the well.</p> </li> <li> <code>column</code>               (<code>int | str</code>)           \u2013            <p>The column of the well.</p> </li> <li> <code>image_path</code>               (<code>str</code>)           \u2013            <p>The path of the image.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OmeZarrContainer</code> (              <code>OmeZarrContainer</code> )          \u2013            <p>The image.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_image(\n    self, row: str, column: int | str, image_path: str\n) -&gt; OmeZarrContainer:\n    \"\"\"Get an image from the plate.\n\n    Args:\n        row (str): The row of the well.\n        column (int | str): The column of the well.\n        image_path (str): The path of the image.\n\n    Returns:\n        OmeZarrContainer: The image.\n    \"\"\"\n    image_path = self._image_path(row=row, column=column, path=image_path)\n    group_handler = self._group_handler.derive_handler(image_path)\n    return OmeZarrContainer(group_handler)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.get_image_store","title":"get_image_store","text":"<pre><code>get_image_store(\n    row: str, column: int | str, image_path: str\n) -&gt; StoreOrGroup\n</code></pre> <p>Get the image store from the plate.</p> <p>Parameters:</p> <ul> <li> <code>row</code>               (<code>str</code>)           \u2013            <p>The row of the well.</p> </li> <li> <code>column</code>               (<code>int | str</code>)           \u2013            <p>The column of the well.</p> </li> <li> <code>image_path</code>               (<code>str</code>)           \u2013            <p>The path of the image.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_image_store(\n    self, row: str, column: int | str, image_path: str\n) -&gt; StoreOrGroup:\n    \"\"\"Get the image store from the plate.\n\n    Args:\n        row (str): The row of the well.\n        column (int | str): The column of the well.\n        image_path (str): The path of the image.\n    \"\"\"\n    well = self.get_well(row=row, column=column)\n    return well.get_image_store(image_path=image_path)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.get_well_images","title":"get_well_images","text":"<pre><code>get_well_images(\n    row: str,\n    column: str | int,\n    acquisition: int | None = None,\n) -&gt; dict[str, OmeZarrContainer]\n</code></pre> <p>Get all images in a well.</p> <p>Parameters:</p> <ul> <li> <code>row</code>               (<code>str</code>)           \u2013            <p>The row of the well.</p> </li> <li> <code>column</code>               (<code>str | int</code>)           \u2013            <p>The column of the well.</p> </li> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_well_images(\n    self, row: str, column: str | int, acquisition: int | None = None\n) -&gt; dict[str, OmeZarrContainer]:\n    \"\"\"Get all images in a well.\n\n    Args:\n        row: The row of the well.\n        column: The column of the well.\n        acquisition: The acquisition id to filter the images.\n    \"\"\"\n    images = {}\n    for image_paths in self.well_images_paths(\n        row=row, column=column, acquisition=acquisition\n    ):\n        group_handler = self._group_handler.derive_handler(image_paths)\n        images[image_paths] = OmeZarrContainer(group_handler)\n    return images\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.atomic_add_image","title":"atomic_add_image","text":"<pre><code>atomic_add_image(\n    row: str,\n    column: int | str,\n    image_path: str,\n    acquisition_id: int | None = None,\n    acquisition_name: str | None = None,\n) -&gt; str\n</code></pre> <p>Parallel safe version of add_image.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def atomic_add_image(\n    self,\n    row: str,\n    column: int | str,\n    image_path: str,\n    acquisition_id: int | None = None,\n    acquisition_name: str | None = None,\n) -&gt; str:\n    \"\"\"Parallel safe version of add_image.\"\"\"\n    if image_path is None:\n        raise ValueError(\n            \"Image path cannot be None for atomic add_image. \"\n            \"If your intent is to add a well, use add_well instead.\"\n        )\n    path = self._add_image(\n        row=row,\n        column=column,\n        image_path=image_path,\n        acquisition_id=acquisition_id,\n        acquisition_name=acquisition_name,\n        atomic=True,\n    )\n    return path\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.add_image","title":"add_image","text":"<pre><code>add_image(\n    row: str,\n    column: int | str,\n    image_path: str,\n    acquisition_id: int | None = None,\n    acquisition_name: str | None = None,\n) -&gt; str\n</code></pre> <p>Add an image to an ome-zarr plate.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def add_image(\n    self,\n    row: str,\n    column: int | str,\n    image_path: str,\n    acquisition_id: int | None = None,\n    acquisition_name: str | None = None,\n) -&gt; str:\n    \"\"\"Add an image to an ome-zarr plate.\"\"\"\n    if image_path is None:\n        raise ValueError(\n            \"Image path cannot be None for atomic add_image. \"\n            \"If your intent is to add a well, use add_well instead.\"\n        )\n    path = self._add_image(\n        row=row,\n        column=column,\n        image_path=image_path,\n        acquisition_id=acquisition_id,\n        acquisition_name=acquisition_name,\n        atomic=False,\n    )\n    return path\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.add_well","title":"add_well","text":"<pre><code>add_well(row: str, column: int | str) -&gt; OmeZarrWell\n</code></pre> <p>Add a well to an ome-zarr plate.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def add_well(\n    self,\n    row: str,\n    column: int | str,\n) -&gt; OmeZarrWell:\n    \"\"\"Add a well to an ome-zarr plate.\"\"\"\n    _ = self._add_image(\n        row=row,\n        column=column,\n        image_path=None,\n        acquisition_id=None,\n        acquisition_name=None,\n        atomic=False,\n    )\n    return self.get_well(row=row, column=column)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.add_column","title":"add_column","text":"<pre><code>add_column(column: int | str) -&gt; OmeZarrPlate\n</code></pre> <p>Add a column to an ome-zarr plate.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def add_column(\n    self,\n    column: int | str,\n) -&gt; \"OmeZarrPlate\":\n    \"\"\"Add a column to an ome-zarr plate.\"\"\"\n    meta, _ = self.meta.add_column(column)\n    self.meta_handler.write_meta(meta)\n    self.meta_handler._group_handler.clean_cache()\n    return self\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.add_row","title":"add_row","text":"<pre><code>add_row(row: str) -&gt; OmeZarrPlate\n</code></pre> <p>Add a row to an ome-zarr plate.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def add_row(\n    self,\n    row: str,\n) -&gt; \"OmeZarrPlate\":\n    \"\"\"Add a row to an ome-zarr plate.\"\"\"\n    meta, _ = self.meta.add_row(row)\n    self.meta_handler.write_meta(meta)\n    self.meta_handler._group_handler.clean_cache()\n    return self\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.add_acquisition","title":"add_acquisition","text":"<pre><code>add_acquisition(\n    acquisition_id: int, acquisition_name: str\n) -&gt; OmeZarrPlate\n</code></pre> <p>Add an acquisition to an ome-zarr plate.</p> <p>Be aware that this is not a parallel safe operation.</p> <p>Parameters:</p> <ul> <li> <code>acquisition_id</code>               (<code>int</code>)           \u2013            <p>The acquisition id.</p> </li> <li> <code>acquisition_name</code>               (<code>str</code>)           \u2013            <p>The acquisition name.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def add_acquisition(\n    self,\n    acquisition_id: int,\n    acquisition_name: str,\n) -&gt; \"OmeZarrPlate\":\n    \"\"\"Add an acquisition to an ome-zarr plate.\n\n    Be aware that this is not a parallel safe operation.\n\n    Args:\n        acquisition_id (int): The acquisition id.\n        acquisition_name (str): The acquisition name.\n    \"\"\"\n    meta = self.meta.add_acquisition(\n        acquisition_id=acquisition_id, acquisition_name=acquisition_name\n    )\n    self.meta_handler.write_meta(meta)\n    self.meta_handler._group_handler.clean_cache()\n    return self\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.atomic_remove_image","title":"atomic_remove_image","text":"<pre><code>atomic_remove_image(\n    row: str, column: int | str, image_path: str\n)\n</code></pre> <p>Parallel safe version of remove_image.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def atomic_remove_image(\n    self,\n    row: str,\n    column: int | str,\n    image_path: str,\n):\n    \"\"\"Parallel safe version of remove_image.\"\"\"\n    return self._remove_image(\n        row=row,\n        column=column,\n        image_path=image_path,\n        atomic=True,\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.remove_image","title":"remove_image","text":"<pre><code>remove_image(row: str, column: int | str, image_path: str)\n</code></pre> <p>Remove an image from an ome-zarr plate.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def remove_image(\n    self,\n    row: str,\n    column: int | str,\n    image_path: str,\n):\n    \"\"\"Remove an image from an ome-zarr plate.\"\"\"\n    return self._remove_image(\n        row=row,\n        column=column,\n        image_path=image_path,\n        atomic=False,\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.derive_plate","title":"derive_plate","text":"<pre><code>derive_plate(\n    store: StoreOrGroup,\n    plate_name: str | None = None,\n    version: NgffVersions = \"0.4\",\n    keep_acquisitions: bool = False,\n    cache: bool = False,\n    overwrite: bool = False,\n    parallel_safe: bool = True,\n) -&gt; OmeZarrPlate\n</code></pre> <p>Derive a new OME-Zarr plate from an existing one.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group that stores the plate.</p> </li> <li> <code>plate_name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the new plate.</p> </li> <li> <code>version</code>               (<code>NgffVersion</code>, default:                   <code>'0.4'</code> )           \u2013            <p>The version of the new plate.</p> </li> <li> <code>keep_acquisitions</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to keep the acquisitions in the new plate.</p> </li> <li> <code>cache</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use a cache for the zarr group metadata.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to overwrite the existing plate.</p> </li> <li> <code>parallel_safe</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the group handler is parallel safe.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def derive_plate(\n    self,\n    store: StoreOrGroup,\n    plate_name: str | None = None,\n    version: NgffVersions = \"0.4\",\n    keep_acquisitions: bool = False,\n    cache: bool = False,\n    overwrite: bool = False,\n    parallel_safe: bool = True,\n) -&gt; \"OmeZarrPlate\":\n    \"\"\"Derive a new OME-Zarr plate from an existing one.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group that stores the plate.\n        plate_name (str | None): The name of the new plate.\n        version (NgffVersion): The version of the new plate.\n        keep_acquisitions (bool): Whether to keep the acquisitions in the new plate.\n        cache (bool): Whether to use a cache for the zarr group metadata.\n        overwrite (bool): Whether to overwrite the existing plate.\n        parallel_safe (bool): Whether the group handler is parallel safe.\n    \"\"\"\n    return derive_ome_zarr_plate(\n        ome_zarr_plate=self,\n        store=store,\n        plate_name=plate_name,\n        version=version,\n        keep_acquisitions=keep_acquisitions,\n        cache=cache,\n        overwrite=overwrite,\n        parallel_safe=parallel_safe,\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.list_tables","title":"list_tables","text":"<pre><code>list_tables(\n    filter_types: TypedTable | str | None = None,\n) -&gt; list[str]\n</code></pre> <p>List all tables in the image.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def list_tables(self, filter_types: TypedTable | str | None = None) -&gt; list[str]:\n    \"\"\"List all tables in the image.\"\"\"\n    return self.tables_container.list(filter_types=filter_types)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.list_roi_tables","title":"list_roi_tables","text":"<pre><code>list_roi_tables() -&gt; list[str]\n</code></pre> <p>List all ROI tables in the image.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def list_roi_tables(self) -&gt; list[str]:\n    \"\"\"List all ROI tables in the image.\"\"\"\n    masking_roi = self.tables_container.list(\n        filter_types=\"masking_roi_table\",\n    )\n    roi = self.tables_container.list(\n        filter_types=\"roi_table\",\n    )\n    return masking_roi + roi\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.get_roi_table","title":"get_roi_table","text":"<pre><code>get_roi_table(name: str) -&gt; RoiTable\n</code></pre> <p>Get a ROI table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_roi_table(self, name: str) -&gt; RoiTable:\n    \"\"\"Get a ROI table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, RoiTable):\n        raise NgioValueError(f\"Table {name} is not a ROI table. Got {type(table)}\")\n    return table\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.get_masking_roi_table","title":"get_masking_roi_table","text":"<pre><code>get_masking_roi_table(name: str) -&gt; MaskingRoiTable\n</code></pre> <p>Get a masking ROI table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_masking_roi_table(self, name: str) -&gt; MaskingRoiTable:\n    \"\"\"Get a masking ROI table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, MaskingRoiTable):\n        raise NgioValueError(\n            f\"Table {name} is not a masking ROI table. Got {type(table)}\"\n        )\n    return table\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.get_feature_table","title":"get_feature_table","text":"<pre><code>get_feature_table(name: str) -&gt; FeatureTable\n</code></pre> <p>Get a feature table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_feature_table(self, name: str) -&gt; FeatureTable:\n    \"\"\"Get a feature table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, FeatureTable):\n        raise NgioValueError(\n            f\"Table {name} is not a feature table. Got {type(table)}\"\n        )\n    return table\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.get_generic_roi_table","title":"get_generic_roi_table","text":"<pre><code>get_generic_roi_table(name: str) -&gt; GenericRoiTable\n</code></pre> <p>Get a generic ROI table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_generic_roi_table(self, name: str) -&gt; GenericRoiTable:\n    \"\"\"Get a generic ROI table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, GenericRoiTable):\n        raise NgioValueError(\n            f\"Table {name} is not a generic ROI table. Got {type(table)}\"\n        )\n    return table\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.get_condition_table","title":"get_condition_table","text":"<pre><code>get_condition_table(name: str) -&gt; ConditionTable\n</code></pre> <p>Get a condition table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_condition_table(self, name: str) -&gt; ConditionTable:\n    \"\"\"Get a condition table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, ConditionTable):\n        raise NgioValueError(\n            f\"Table {name} is not a condition table. Got {type(table)}\"\n        )\n    return table\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.get_table","title":"get_table","text":"<pre><code>get_table(\n    name: str, check_type: TypedTable | None = None\n) -&gt; Table\n</code></pre> <p>Get a table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> <li> <code>check_type</code>               (<code>TypedTable | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Please use 'get_table_as' instead, or one of the type specific get_*table() methods.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_table(self, name: str, check_type: TypedTable | None = None) -&gt; Table:\n    \"\"\"Get a table from the image.\n\n    Args:\n        name (str): The name of the table.\n        check_type (TypedTable | None): Deprecated. Please use\n            'get_table_as' instead, or one of the type specific\n            get_*table() methods.\n\n    \"\"\"\n    if check_type is not None:\n        warnings.warn(\n            \"The 'check_type' argument is deprecated, and will be removed in \"\n            \"ngio=0.3. Use 'get_table_as' instead or one of the \"\n            \"type specific get_*table() methods.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n    return self.tables_container.get(name=name, strict=False)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.get_table_as","title":"get_table_as","text":"<pre><code>get_table_as(\n    name: str,\n    table_cls: type[TableType],\n    backend: TableBackend | None = None,\n) -&gt; TableType\n</code></pre> <p>Get a table from the image as a specific type.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> <li> <code>table_cls</code>               (<code>type[TableType]</code>)           \u2013            <p>The type of the table.</p> </li> <li> <code>backend</code>               (<code>TableBackend | None</code>, default:                   <code>None</code> )           \u2013            <p>The backend to use. If None, the default backend is used.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_table_as(\n    self,\n    name: str,\n    table_cls: type[TableType],\n    backend: TableBackend | None = None,\n) -&gt; TableType:\n    \"\"\"Get a table from the image as a specific type.\n\n    Args:\n        name (str): The name of the table.\n        table_cls (type[TableType]): The type of the table.\n        backend (TableBackend | None): The backend to use. If None,\n            the default backend is used.\n    \"\"\"\n    return self.tables_container.get_as(\n        name=name,\n        table_cls=table_cls,\n        backend=backend,\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.add_table","title":"add_table","text":"<pre><code>add_table(\n    name: str,\n    table: Table,\n    backend: TableBackend = DefaultTableBackend,\n    overwrite: bool = False,\n) -&gt; None\n</code></pre> <p>Add a table to the image.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def add_table(\n    self,\n    name: str,\n    table: Table,\n    backend: TableBackend = DefaultTableBackend,\n    overwrite: bool = False,\n) -&gt; None:\n    \"\"\"Add a table to the image.\"\"\"\n    self.tables_container.add(\n        name=name, table=table, backend=backend, overwrite=overwrite\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.list_image_tables","title":"list_image_tables","text":"<pre><code>list_image_tables(\n    acquisition: int | None = None,\n    filter_types: str | None = None,\n    mode: Literal[\"common\", \"all\"] = \"common\",\n) -&gt; list[str]\n</code></pre> <p>List all image tables in the image.</p> <p>Parameters:</p> <ul> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> <li> <code>filter_types</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The type of tables to filter. If None, return all tables. Defaults to None.</p> </li> <li> <code>mode</code>               (<code>Literal['common', 'all']</code>, default:                   <code>'common'</code> )           \u2013            <p>The mode to use for listing the tables. If 'common', return only common tables between all images. If 'all', return all tables. Defaults to 'common'.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def list_image_tables(\n    self,\n    acquisition: int | None = None,\n    filter_types: str | None = None,\n    mode: Literal[\"common\", \"all\"] = \"common\",\n) -&gt; list[str]:\n    \"\"\"List all image tables in the image.\n\n    Args:\n        acquisition (int | None): The acquisition id to filter the images.\n        filter_types (str | None): The type of tables to filter. If None,\n            return all tables. Defaults to None.\n        mode (Literal[\"common\", \"all\"]): The mode to use for listing the tables.\n            If 'common', return only common tables between all images.\n            If 'all', return all tables. Defaults to 'common'.\n    \"\"\"\n    images = tuple(self.get_images(acquisition=acquisition).values())\n    return list_image_tables(\n        images=images,\n        filter_types=filter_types,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.list_image_tables_async","title":"list_image_tables_async  <code>async</code>","text":"<pre><code>list_image_tables_async(\n    acquisition: int | None = None,\n    filter_types: str | None = None,\n    mode: Literal[\"common\", \"all\"] = \"common\",\n) -&gt; list[str]\n</code></pre> <p>List all image tables in the image asynchronously.</p> <p>Parameters:</p> <ul> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> <li> <code>filter_types</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The type of tables to filter. If None, return all tables. Defaults to None.</p> </li> <li> <code>mode</code>               (<code>Literal['common', 'all']</code>, default:                   <code>'common'</code> )           \u2013            <p>The mode to use for listing the tables. If 'common', return only common tables between all images. If 'all', return all tables. Defaults to 'common'.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>async def list_image_tables_async(\n    self,\n    acquisition: int | None = None,\n    filter_types: str | None = None,\n    mode: Literal[\"common\", \"all\"] = \"common\",\n) -&gt; list[str]:\n    \"\"\"List all image tables in the image asynchronously.\n\n    Args:\n        acquisition (int | None): The acquisition id to filter the images.\n        filter_types (str | None): The type of tables to filter. If None,\n            return all tables. Defaults to None.\n        mode (Literal[\"common\", \"all\"]): The mode to use for listing the tables.\n            If 'common', return only common tables between all images.\n            If 'all', return all tables. Defaults to 'common'.\n    \"\"\"\n    images = await self.get_images_async(acquisition=acquisition)\n    images = tuple(images.values())\n    return await list_image_tables_async(\n        images=images,\n        filter_types=filter_types,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.concatenate_image_tables","title":"concatenate_image_tables","text":"<pre><code>concatenate_image_tables(\n    name: str,\n    acquisition: int | None = None,\n    strict: bool = True,\n    index_key: str | None = None,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; Table\n</code></pre> <p>Concatenate tables from all images in the plate.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table to concatenate.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The key to use for the index of the concatenated table.</p> </li> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, raise an error if the table is not found in the image.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>If a string is provided, a new index column will be created new_index_pattern = {row}{column}{path_in_well}_{label}</p> </li> <li> <code>mode</code>               (<code>Literal['eager', 'lazy']</code>, default:                   <code>'eager'</code> )           \u2013            <p>The mode to use for concatenation. Can be 'eager' or 'lazy'. if 'eager', the table will be loaded into memory. if 'lazy', the table will be loaded as a lazy frame.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def concatenate_image_tables(\n    self,\n    name: str,\n    acquisition: int | None = None,\n    strict: bool = True,\n    index_key: str | None = None,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; Table:\n    \"\"\"Concatenate tables from all images in the plate.\n\n    Args:\n        name: The name of the table to concatenate.\n        index_key: The key to use for the index of the concatenated table.\n        acquisition: The acquisition id to filter the images.\n        strict: If True, raise an error if the table is not found in the image.\n        index_key: If a string is provided, a new index column will be created\n            new_index_pattern = {row}_{column}_{path_in_well}_{label}\n        mode: The mode to use for concatenation. Can be 'eager' or 'lazy'.\n            if 'eager', the table will be loaded into memory.\n            if 'lazy', the table will be loaded as a lazy frame.\n    \"\"\"\n    images = self.get_images(acquisition=acquisition)\n    extras = _build_extras(tuple(images.keys()))\n    return concatenate_image_tables(\n        images=tuple(images.values()),\n        extras=extras,\n        name=name,\n        index_key=index_key,\n        strict=strict,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.concatenate_image_tables_as","title":"concatenate_image_tables_as","text":"<pre><code>concatenate_image_tables_as(\n    name: str,\n    table_cls: type[TableType],\n    acquisition: int | None = None,\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; TableType\n</code></pre> <p>Concatenate tables from all images in the plate as a specific type.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table to concatenate.</p> </li> <li> <code>table_cls</code>               (<code>type[TableType]</code>)           \u2013            <p>The type of the table to concatenate.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The key to use for the index of the concatenated table.</p> </li> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>If a string is provided, a new index column will be created new_index_pattern = {row}{column}{path_in_well}_{label}</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, raise an error if the table is not found in the image.</p> </li> <li> <code>mode</code>               (<code>Literal['eager', 'lazy']</code>, default:                   <code>'eager'</code> )           \u2013            <p>The mode to use for concatenation. Can be 'eager' or 'lazy'. if 'eager', the table will be loaded into memory. if 'lazy', the table will be loaded as a lazy frame.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def concatenate_image_tables_as(\n    self,\n    name: str,\n    table_cls: type[TableType],\n    acquisition: int | None = None,\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; TableType:\n    \"\"\"Concatenate tables from all images in the plate as a specific type.\n\n    Args:\n        name: The name of the table to concatenate.\n        table_cls: The type of the table to concatenate.\n        index_key: The key to use for the index of the concatenated table.\n        acquisition: The acquisition id to filter the images.\n        index_key: If a string is provided, a new index column will be created\n            new_index_pattern = {row}_{column}_{path_in_well}_{label}\n        strict: If True, raise an error if the table is not found in the image.\n        mode: The mode to use for concatenation. Can be 'eager' or 'lazy'.\n            if 'eager', the table will be loaded into memory.\n            if 'lazy', the table will be loaded as a lazy frame.\n    \"\"\"\n    images = self.get_images(acquisition=acquisition)\n    extras = _build_extras(tuple(images.keys()))\n    return concatenate_image_tables_as(\n        images=tuple(images.values()),\n        extras=extras,\n        name=name,\n        table_cls=table_cls,\n        index_key=index_key,\n        strict=strict,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.concatenate_image_tables_async","title":"concatenate_image_tables_async  <code>async</code>","text":"<pre><code>concatenate_image_tables_async(\n    name: str,\n    acquisition: int | None = None,\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; Table\n</code></pre> <p>Concatenate tables from all images in the plate asynchronously.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table to concatenate.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The key to use for the index of the concatenated table.</p> </li> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>If a string is provided, a new index column will be created new_index_pattern = {row}{column}{path_in_well}_{label}</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, raise an error if the table is not found in the image.</p> </li> <li> <code>mode</code>               (<code>Literal['eager', 'lazy']</code>, default:                   <code>'eager'</code> )           \u2013            <p>The mode to use for concatenation. Can be 'eager' or 'lazy'. if 'eager', the table will be loaded into memory. if 'lazy', the table will be loaded as a lazy frame.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>async def concatenate_image_tables_async(\n    self,\n    name: str,\n    acquisition: int | None = None,\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; Table:\n    \"\"\"Concatenate tables from all images in the plate asynchronously.\n\n    Args:\n        name: The name of the table to concatenate.\n        index_key: The key to use for the index of the concatenated table.\n        acquisition: The acquisition id to filter the images.\n        index_key: If a string is provided, a new index column will be created\n            new_index_pattern = {row}_{column}_{path_in_well}_{label}\n        strict: If True, raise an error if the table is not found in the image.\n        mode: The mode to use for concatenation. Can be 'eager' or 'lazy'.\n            if 'eager', the table will be loaded into memory.\n            if 'lazy', the table will be loaded as a lazy frame.\n    \"\"\"\n    images = await self.get_images_async(acquisition=acquisition)\n    extras = _build_extras(tuple(images.keys()))\n    return await concatenate_image_tables_async(\n        images=tuple(images.values()),\n        extras=extras,\n        name=name,\n        index_key=index_key,\n        strict=strict,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrPlate.concatenate_image_tables_as_async","title":"concatenate_image_tables_as_async  <code>async</code>","text":"<pre><code>concatenate_image_tables_as_async(\n    name: str,\n    table_cls: type[TableType],\n    acquisition: int | None = None,\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; TableType\n</code></pre> <p>Concatenate tables from all images in the plate as a specific type.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table to concatenate.</p> </li> <li> <code>table_cls</code>               (<code>type[TableType]</code>)           \u2013            <p>The type of the table to concatenate.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The key to use for the index of the concatenated table.</p> </li> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> <li> <code>index_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>If a string is provided, a new index column will be created new_index_pattern = {row}{column}{path_in_well}_{label}</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, raise an error if the table is not found in the image.</p> </li> <li> <code>mode</code>               (<code>Literal['eager', 'lazy']</code>, default:                   <code>'eager'</code> )           \u2013            <p>The mode to use for concatenation. Can be 'eager' or 'lazy'. if 'eager', the table will be loaded into memory. if 'lazy', the table will be loaded as a lazy frame.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>async def concatenate_image_tables_as_async(\n    self,\n    name: str,\n    table_cls: type[TableType],\n    acquisition: int | None = None,\n    index_key: str | None = None,\n    strict: bool = True,\n    mode: Literal[\"eager\", \"lazy\"] = \"eager\",\n) -&gt; TableType:\n    \"\"\"Concatenate tables from all images in the plate as a specific type.\n\n    Args:\n        name: The name of the table to concatenate.\n        table_cls: The type of the table to concatenate.\n        index_key: The key to use for the index of the concatenated table.\n        acquisition: The acquisition id to filter the images.\n        index_key: If a string is provided, a new index column will be created\n            new_index_pattern = {row}_{column}_{path_in_well}_{label}\n        strict: If True, raise an error if the table is not found in the image.\n        mode: The mode to use for concatenation. Can be 'eager' or 'lazy'.\n            if 'eager', the table will be loaded into memory.\n            if 'lazy', the table will be loaded as a lazy frame.\n    \"\"\"\n    images = await self.get_images_async(acquisition=acquisition)\n    extras = _build_extras(tuple(images.keys()))\n    return await concatenate_image_tables_as_async(\n        images=tuple(images.values()),\n        extras=extras,\n        name=name,\n        table_cls=table_cls,\n        index_key=index_key,\n        strict=strict,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrWell","title":"OmeZarrWell","text":"<pre><code>OmeZarrWell(group_handler: ZarrGroupHandler)\n</code></pre> <p>A class to handle the Well Sequence in an OME-Zarr file.</p> <p>Initialize the LabelGroupHandler.</p> <p>Parameters:</p> <ul> <li> <code>group_handler</code>               (<code>ZarrGroupHandler</code>)           \u2013            <p>The Zarr group handler that contains the Well.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def __init__(self, group_handler: ZarrGroupHandler) -&gt; None:\n    \"\"\"Initialize the LabelGroupHandler.\n\n    Args:\n        group_handler: The Zarr group handler that contains the Well.\n    \"\"\"\n    self._group_handler = group_handler\n    self._meta_handler = find_well_meta_handler(group_handler)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrWell.meta_handler","title":"meta_handler  <code>property</code>","text":"<pre><code>meta_handler\n</code></pre> <p>Return the metadata handler.</p>"},{"location":"api/ngio/ngio/#ngio.OmeZarrWell.meta","title":"meta  <code>property</code>","text":"<pre><code>meta\n</code></pre> <p>Return the metadata.</p>"},{"location":"api/ngio/ngio/#ngio.OmeZarrWell.acquisition_ids","title":"acquisition_ids  <code>property</code>","text":"<pre><code>acquisition_ids: list[int]\n</code></pre> <p>Return the acquisitions ids in the well.</p>"},{"location":"api/ngio/ngio/#ngio.OmeZarrWell.paths","title":"paths","text":"<pre><code>paths(acquisition: int | None = None) -&gt; list[str]\n</code></pre> <p>Return the images paths in the well.</p> <p>If acquisition is None, return all images paths in the well. Else, return the images paths in the well for the given acquisition.</p> <p>Parameters:</p> <ul> <li> <code>acquisition</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def paths(self, acquisition: int | None = None) -&gt; list[str]:\n    \"\"\"Return the images paths in the well.\n\n    If acquisition is None, return all images paths in the well.\n    Else, return the images paths in the well for the given acquisition.\n\n    Args:\n        acquisition (int | None): The acquisition id to filter the images.\n    \"\"\"\n    return self.meta.paths(acquisition)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrWell.get_image_store","title":"get_image_store","text":"<pre><code>get_image_store(image_path: str) -&gt; StoreOrGroup\n</code></pre> <p>Get the image store from the well.</p> <p>Parameters:</p> <ul> <li> <code>image_path</code>               (<code>str</code>)           \u2013            <p>The path of the image.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_image_store(self, image_path: str) -&gt; StoreOrGroup:\n    \"\"\"Get the image store from the well.\n\n    Args:\n        image_path (str): The path of the image.\n    \"\"\"\n    return self._group_handler.get_group(image_path, create_mode=True)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrWell.get_image_acquisition_id","title":"get_image_acquisition_id","text":"<pre><code>get_image_acquisition_id(image_path: str) -&gt; int | None\n</code></pre> <p>Get the acquisition id of an image in the well.</p> <p>Parameters:</p> <ul> <li> <code>image_path</code>               (<code>str</code>)           \u2013            <p>The path of the image.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int | None</code>           \u2013            <p>int | None: The acquisition id of the image.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_image_acquisition_id(self, image_path: str) -&gt; int | None:\n    \"\"\"Get the acquisition id of an image in the well.\n\n    Args:\n        image_path (str): The path of the image.\n\n    Returns:\n        int | None: The acquisition id of the image.\n    \"\"\"\n    return self.meta.get_image_acquisition_id(image_path=image_path)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrWell.get_image","title":"get_image","text":"<pre><code>get_image(image_path: str) -&gt; OmeZarrContainer\n</code></pre> <p>Get an image from the well.</p> <p>Parameters:</p> <ul> <li> <code>image_path</code>               (<code>str</code>)           \u2013            <p>The path of the image.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OmeZarrContainer</code> (              <code>OmeZarrContainer</code> )          \u2013            <p>The image.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def get_image(self, image_path: str) -&gt; OmeZarrContainer:\n    \"\"\"Get an image from the well.\n\n    Args:\n        image_path (str): The path of the image.\n\n    Returns:\n        OmeZarrContainer: The image.\n    \"\"\"\n    handler = self._group_handler.derive_handler(image_path)\n    return OmeZarrContainer(handler)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrWell.atomic_add_image","title":"atomic_add_image","text":"<pre><code>atomic_add_image(\n    image_path: str,\n    acquisition_id: int | None = None,\n    strict: bool = True,\n) -&gt; StoreOrGroup\n</code></pre> <p>Parallel safe version of add_image.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def atomic_add_image(\n    self,\n    image_path: str,\n    acquisition_id: int | None = None,\n    strict: bool = True,\n) -&gt; StoreOrGroup:\n    \"\"\"Parallel safe version of add_image.\"\"\"\n    return self._add_image(\n        image_path=image_path,\n        acquisition_id=acquisition_id,\n        atomic=True,\n        strict=strict,\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrWell.add_image","title":"add_image","text":"<pre><code>add_image(\n    image_path: str,\n    acquisition_id: int | None = None,\n    strict: bool = True,\n) -&gt; StoreOrGroup\n</code></pre> <p>Add an image to an ome-zarr well.</p> <p>Parameters:</p> <ul> <li> <code>image_path</code>               (<code>str</code>)           \u2013            <p>The path of the image.</p> </li> <li> <code>acquisition_id</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The acquisition id to filter the images.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to check if the acquisition id is already exists in the well. Defaults to True. If False this might lead to acquisition in a well that does not exist at the plate level.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def add_image(\n    self,\n    image_path: str,\n    acquisition_id: int | None = None,\n    strict: bool = True,\n) -&gt; StoreOrGroup:\n    \"\"\"Add an image to an ome-zarr well.\n\n    Args:\n        image_path (str): The path of the image.\n        acquisition_id (int | None): The acquisition id to filter the images.\n        strict (bool): Whether to check if the acquisition id is already exists\n            in the well. Defaults to True. If False this might lead to\n            acquisition in a well that does not exist at the plate level.\n    \"\"\"\n    return self._add_image(\n        image_path=image_path,\n        acquisition_id=acquisition_id,\n        atomic=False,\n        strict=strict,\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.ChannelSelectionModel","title":"ChannelSelectionModel","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for channel selection.</p> <p>This model is used to select a channel by label, wavelength ID, or index.</p> <p>Parameters:</p> <ul> <li> <code>identifier</code>               (<code>str</code>)           \u2013            <p>Unique identifier for the channel. This can be a channel label, wavelength ID, or index.</p> </li> <li> <code>mode</code>               (<code>Literal['label', 'wavelength_id', 'index']</code>)           \u2013            <p>Specifies how to interpret the identifier. Can be \"label\", \"wavelength_id\", or \"index\" (must be an integer).</p> </li> </ul>"},{"location":"api/ngio/ngio/#ngio.ChannelSelectionModel.mode","title":"mode  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mode: Literal['label', 'wavelength_id', 'index'] = 'label'\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.ChannelSelectionModel.identifier","title":"identifier  <code>instance-attribute</code>","text":"<pre><code>identifier: str\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.ChannelSelectionModel.check_channel_selection","title":"check_channel_selection","text":"<pre><code>check_channel_selection()\n</code></pre> Source code in <code>ngio/images/_image.py</code> <pre><code>@model_validator(mode=\"after\")\ndef check_channel_selection(self):\n    if self.mode == \"index\":\n        try:\n            int(self.identifier)\n        except ValueError as e:\n            raise ValueError(\n                \"Identifier must be an integer when mode is 'index'\"\n            ) from e\n    return self\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Image","title":"Image","text":"<pre><code>Image(\n    group_handler: ZarrGroupHandler,\n    path: str,\n    meta_handler: ImageMetaHandler | None,\n)\n</code></pre> <p>               Bases: <code>AbstractImage[ImageMetaHandler]</code></p> <p>A class to handle a single image (or level) in an OME-Zarr image.</p> <p>This class is meant to be subclassed by specific image types.</p> <p>Initialize the Image at a single level.</p> <p>Parameters:</p> <ul> <li> <code>group_handler</code>               (<code>ZarrGroupHandler</code>)           \u2013            <p>The Zarr group handler.</p> </li> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path to the image in the ome_zarr file.</p> </li> <li> <code>meta_handler</code>               (<code>ImageMetaHandler | None</code>)           \u2013            <p>The image metadata handler.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def __init__(\n    self,\n    group_handler: ZarrGroupHandler,\n    path: str,\n    meta_handler: ImageMetaHandler | None,\n) -&gt; None:\n    \"\"\"Initialize the Image at a single level.\n\n    Args:\n        group_handler: The Zarr group handler.\n        path: The path to the image in the ome_zarr file.\n        meta_handler: The image metadata handler.\n\n    \"\"\"\n    if meta_handler is None:\n        meta_handler = find_image_meta_handler(group_handler)\n    super().__init__(\n        group_handler=group_handler, path=path, meta_handler=meta_handler\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Image.meta_handler","title":"meta_handler  <code>property</code>","text":"<pre><code>meta_handler: _image_handler\n</code></pre> <p>Return the metadata.</p>"},{"location":"api/ngio/ngio/#ngio.Image.zarr_array","title":"zarr_array  <code>property</code>","text":"<pre><code>zarr_array: Array\n</code></pre> <p>Return the Zarr array.</p>"},{"location":"api/ngio/ngio/#ngio.Image.shape","title":"shape  <code>property</code>","text":"<pre><code>shape: tuple[int, ...]\n</code></pre> <p>Return the shape of the image.</p>"},{"location":"api/ngio/ngio/#ngio.Image.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype: str\n</code></pre> <p>Return the dtype of the image.</p>"},{"location":"api/ngio/ngio/#ngio.Image.chunks","title":"chunks  <code>property</code>","text":"<pre><code>chunks: tuple[int, ...]\n</code></pre> <p>Return the chunks of the image.</p>"},{"location":"api/ngio/ngio/#ngio.Image.dimensions","title":"dimensions  <code>property</code>","text":"<pre><code>dimensions: Dimensions\n</code></pre> <p>Return the dimensions of the image.</p>"},{"location":"api/ngio/ngio/#ngio.Image.axes_mapper","title":"axes_mapper  <code>property</code>","text":"<pre><code>axes_mapper: AxesHandler\n</code></pre> <p>Return the axes mapper of the image.</p>"},{"location":"api/ngio/ngio/#ngio.Image.is_3d","title":"is_3d  <code>property</code>","text":"<pre><code>is_3d: bool\n</code></pre> <p>Return True if the image is 3D.</p>"},{"location":"api/ngio/ngio/#ngio.Image.is_2d","title":"is_2d  <code>property</code>","text":"<pre><code>is_2d: bool\n</code></pre> <p>Return True if the image is 2D.</p>"},{"location":"api/ngio/ngio/#ngio.Image.is_time_series","title":"is_time_series  <code>property</code>","text":"<pre><code>is_time_series: bool\n</code></pre> <p>Return True if the image is a time series.</p>"},{"location":"api/ngio/ngio/#ngio.Image.is_2d_time_series","title":"is_2d_time_series  <code>property</code>","text":"<pre><code>is_2d_time_series: bool\n</code></pre> <p>Return True if the image is a 2D time series.</p>"},{"location":"api/ngio/ngio/#ngio.Image.is_3d_time_series","title":"is_3d_time_series  <code>property</code>","text":"<pre><code>is_3d_time_series: bool\n</code></pre> <p>Return True if the image is a 3D time series.</p>"},{"location":"api/ngio/ngio/#ngio.Image.is_multi_channels","title":"is_multi_channels  <code>property</code>","text":"<pre><code>is_multi_channels: bool\n</code></pre> <p>Return True if the image is multichannel.</p>"},{"location":"api/ngio/ngio/#ngio.Image.space_unit","title":"space_unit  <code>property</code>","text":"<pre><code>space_unit: str | None\n</code></pre> <p>Return the space unit of the image.</p>"},{"location":"api/ngio/ngio/#ngio.Image.time_unit","title":"time_unit  <code>property</code>","text":"<pre><code>time_unit: str | None\n</code></pre> <p>Return the time unit of the image.</p>"},{"location":"api/ngio/ngio/#ngio.Image.pixel_size","title":"pixel_size  <code>property</code>","text":"<pre><code>pixel_size: PixelSize\n</code></pre> <p>Return the pixel size of the image.</p>"},{"location":"api/ngio/ngio/#ngio.Image.dataset","title":"dataset  <code>property</code>","text":"<pre><code>dataset: Dataset\n</code></pre> <p>Return the dataset of the image.</p>"},{"location":"api/ngio/ngio/#ngio.Image.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Return the path of the image.</p>"},{"location":"api/ngio/ngio/#ngio.Image.meta","title":"meta  <code>property</code>","text":"<pre><code>meta: NgioImageMeta\n</code></pre> <p>Return the metadata.</p>"},{"location":"api/ngio/ngio/#ngio.Image.channels_meta","title":"channels_meta  <code>property</code>","text":"<pre><code>channels_meta: ChannelsMeta\n</code></pre> <p>Return the channels metadata.</p>"},{"location":"api/ngio/ngio/#ngio.Image.channel_labels","title":"channel_labels  <code>property</code>","text":"<pre><code>channel_labels: list[str]\n</code></pre> <p>Return the channels of the image.</p>"},{"location":"api/ngio/ngio/#ngio.Image.wavelength_ids","title":"wavelength_ids  <code>property</code>","text":"<pre><code>wavelength_ids: list[str | None]\n</code></pre> <p>Return the list of wavelength of the image.</p>"},{"location":"api/ngio/ngio/#ngio.Image.num_channels","title":"num_channels  <code>property</code>","text":"<pre><code>num_channels: int\n</code></pre> <p>Return the number of channels.</p>"},{"location":"api/ngio/ngio/#ngio.Image.has_axis","title":"has_axis","text":"<pre><code>has_axis(axis: str) -&gt; bool\n</code></pre> <p>Return True if the image has the given axis.</p> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def has_axis(self, axis: str) -&gt; bool:\n    \"\"\"Return True if the image has the given axis.\"\"\"\n    self.axes_mapper.get_index(\"x\")\n    return self.dimensions.has_axis(axis)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Image.build_image_roi_table","title":"build_image_roi_table","text":"<pre><code>build_image_roi_table(\n    name: str | None = \"image\",\n) -&gt; RoiTable\n</code></pre> <p>Build the ROI table for an image.</p> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def build_image_roi_table(self, name: str | None = \"image\") -&gt; RoiTable:\n    \"\"\"Build the ROI table for an image.\"\"\"\n    return build_image_roi_table(image=self, name=name)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Image.assert_dimensions_match","title":"assert_dimensions_match","text":"<pre><code>assert_dimensions_match(\n    other: AbstractImage, allow_singleton: bool = False\n) -&gt; None\n</code></pre> <p>Assert that two images have matching spatial dimensions.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>AbstractImage</code>)           \u2013            <p>The other image to compare to.</p> </li> <li> <code>allow_singleton</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, allow singleton dimensions to be compatible with non-singleton dimensions.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NgioValueError</code>             \u2013            <p>If the images do not have compatible dimensions.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def assert_dimensions_match(\n    self,\n    other: \"AbstractImage\",\n    allow_singleton: bool = False,\n) -&gt; None:\n    \"\"\"Assert that two images have matching spatial dimensions.\n\n    Args:\n        other: The other image to compare to.\n        allow_singleton: If True, allow singleton dimensions to be\n            compatible with non-singleton dimensions.\n\n    Raises:\n        NgioValueError: If the images do not have compatible dimensions.\n    \"\"\"\n    assert_dimensions_match(\n        image1=self, image2=other, allow_singleton=allow_singleton\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Image.assert_axes_match","title":"assert_axes_match","text":"<pre><code>assert_axes_match(other: AbstractImage) -&gt; None\n</code></pre> <p>Assert that two images have compatible axes.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>AbstractImage</code>)           \u2013            <p>The other image to compare to.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NgioValueError</code>             \u2013            <p>If the images do not have compatible axes.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def assert_axes_match(\n    self,\n    other: \"AbstractImage\",\n) -&gt; None:\n    \"\"\"Assert that two images have compatible axes.\n\n    Args:\n        other: The other image to compare to.\n\n    Raises:\n        NgioValueError: If the images do not have compatible axes.\n    \"\"\"\n    assert_axes_match(image1=self, image2=other)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Image.assert_can_be_rescaled","title":"assert_can_be_rescaled","text":"<pre><code>assert_can_be_rescaled(other: AbstractImage) -&gt; None\n</code></pre> <p>Assert that two images can be rescaled to each other.</p> <p>For this to be true, the images must have the same axes, and the pixel sizes must be compatible (i.e. one can be scaled to the other).</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>AbstractImage</code>)           \u2013            <p>The other image to compare to.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NgioValueError</code>             \u2013            <p>If the images cannot be scaled to each other.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def assert_can_be_rescaled(\n    self,\n    other: \"AbstractImage\",\n) -&gt; None:\n    \"\"\"Assert that two images can be rescaled to each other.\n\n    For this to be true, the images must have the same axes, and\n    the pixel sizes must be compatible (i.e. one can be scaled to the other).\n\n    Args:\n        other: The other image to compare to.\n\n    Raises:\n        NgioValueError: If the images cannot be scaled to each other.\n    \"\"\"\n    assert_can_be_rescaled(image1=self, image2=other)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Image.get_channel_idx","title":"get_channel_idx","text":"<pre><code>get_channel_idx(\n    channel_label: str | None = None,\n    wavelength_id: str | None = None,\n) -&gt; int\n</code></pre> <p>Get the index of a channel by its label or wavelength ID.</p> Source code in <code>ngio/images/_image.py</code> <pre><code>def get_channel_idx(\n    self, channel_label: str | None = None, wavelength_id: str | None = None\n) -&gt; int:\n    \"\"\"Get the index of a channel by its label or wavelength ID.\"\"\"\n    return self.channels_meta.get_channel_idx(\n        channel_label=channel_label, wavelength_id=wavelength_id\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Image.get_as_numpy","title":"get_as_numpy","text":"<pre><code>get_as_numpy(\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: slice | int | Sequence[int] | None,\n) -&gt; ndarray\n</code></pre> <p>Get the image as a numpy array.</p> <p>Parameters:</p> <ul> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Select a specific channel by label. If None, all channels are returned. Alternatively, you can slice arbitrary channels using the slice_kwargs (c=[0, 2]).</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The order of the axes to return the array.</p> </li> <li> <code>transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>The transforms to apply to the array.</p> </li> <li> <code>**slicing_kwargs</code>               (<code>slice | int | Sequence[int] | None</code>, default:                   <code>{}</code> )           \u2013            <p>The slices to get the array.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The array of the region of interest.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def get_as_numpy(\n    self,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: slice | int | Sequence[int] | None,\n) -&gt; np.ndarray:\n    \"\"\"Get the image as a numpy array.\n\n    Args:\n        channel_selection: Select a specific channel by label.\n            If None, all channels are returned.\n            Alternatively, you can slice arbitrary channels\n            using the slice_kwargs (c=[0, 2]).\n        axes_order: The order of the axes to return the array.\n        transforms: The transforms to apply to the array.\n        **slicing_kwargs: The slices to get the array.\n\n    Returns:\n        The array of the region of interest.\n    \"\"\"\n    _slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self, channel_selection=channel_selection, slicing_dict=slicing_kwargs\n    )\n    return self._get_as_numpy(\n        axes_order=axes_order, transforms=transforms, **_slicing_kwargs\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Image.get_roi_as_numpy","title":"get_roi_as_numpy","text":"<pre><code>get_roi_as_numpy(\n    roi: Roi | RoiPixels,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; ndarray\n</code></pre> <p>Get the image as a numpy array for a region of interest.</p> <p>Parameters:</p> <ul> <li> <code>roi</code>               (<code>Roi | RoiPixels</code>)           \u2013            <p>The region of interest to get the array.</p> </li> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Select a what subset of channels to return. If None, all channels are returned.</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The order of the axes to return the array.</p> </li> <li> <code>transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>The transforms to apply to the array.</p> </li> <li> <code>**slicing_kwargs</code>               (<code>SlicingInputType</code>, default:                   <code>{}</code> )           \u2013            <p>The slices to get the array.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The array of the region of interest.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def get_roi_as_numpy(\n    self,\n    roi: Roi | RoiPixels,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; np.ndarray:\n    \"\"\"Get the image as a numpy array for a region of interest.\n\n    Args:\n        roi: The region of interest to get the array.\n        channel_selection: Select a what subset of channels to return.\n            If None, all channels are returned.\n        axes_order: The order of the axes to return the array.\n        transforms: The transforms to apply to the array.\n        **slicing_kwargs: The slices to get the array.\n\n    Returns:\n        The array of the region of interest.\n    \"\"\"\n    _slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self, channel_selection=channel_selection, slicing_dict=slicing_kwargs\n    )\n    return self._get_roi_as_numpy(\n        roi=roi, axes_order=axes_order, transforms=transforms, **_slicing_kwargs\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Image.get_as_dask","title":"get_as_dask","text":"<pre><code>get_as_dask(\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; Array\n</code></pre> <p>Get the image as a dask array.</p> <p>Parameters:</p> <ul> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Select a what subset of channels to return. If None, all channels are returned.</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The order of the axes to return the array.</p> </li> <li> <code>transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>The transforms to apply to the array.</p> </li> <li> <code>**slicing_kwargs</code>               (<code>SlicingInputType</code>, default:                   <code>{}</code> )           \u2013            <p>The slices to get the array.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array</code>           \u2013            <p>The dask array of the region of interest.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def get_as_dask(\n    self,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; da.Array:\n    \"\"\"Get the image as a dask array.\n\n    Args:\n        channel_selection: Select a what subset of channels to return.\n            If None, all channels are returned.\n        axes_order: The order of the axes to return the array.\n        transforms: The transforms to apply to the array.\n        **slicing_kwargs: The slices to get the array.\n\n    Returns:\n        The dask array of the region of interest.\n    \"\"\"\n    _slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self, channel_selection=channel_selection, slicing_dict=slicing_kwargs\n    )\n    return self._get_as_dask(\n        axes_order=axes_order, transforms=transforms, **_slicing_kwargs\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Image.get_roi_as_dask","title":"get_roi_as_dask","text":"<pre><code>get_roi_as_dask(\n    roi: Roi | RoiPixels,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; Array\n</code></pre> <p>Get the image as a dask array for a region of interest.</p> <p>Parameters:</p> <ul> <li> <code>roi</code>               (<code>Roi | RoiPixels</code>)           \u2013            <p>The region of interest to get the array.</p> </li> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Select a what subset of channels to return. If None, all channels are returned.</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The order of the axes to return the array.</p> </li> <li> <code>transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>The transforms to apply to the array.</p> </li> <li> <code>**slicing_kwargs</code>               (<code>SlicingInputType</code>, default:                   <code>{}</code> )           \u2013            <p>The slices to get the array.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array</code>           \u2013            <p>The dask array of the region of interest.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def get_roi_as_dask(\n    self,\n    roi: Roi | RoiPixels,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; da.Array:\n    \"\"\"Get the image as a dask array for a region of interest.\n\n    Args:\n        roi: The region of interest to get the array.\n        channel_selection: Select a what subset of channels to return.\n            If None, all channels are returned.\n        axes_order: The order of the axes to return the array.\n        transforms: The transforms to apply to the array.\n        **slicing_kwargs: The slices to get the array.\n\n    Returns:\n        The dask array of the region of interest.\n    \"\"\"\n    _slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self, channel_selection=channel_selection, slicing_dict=slicing_kwargs\n    )\n    return self._get_roi_as_dask(\n        roi=roi, axes_order=axes_order, transforms=transforms, **_slicing_kwargs\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Image.get_array","title":"get_array","text":"<pre><code>get_array(\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    mode: Literal[\"numpy\", \"dask\"] = \"numpy\",\n    **slicing_kwargs: SlicingInputType,\n) -&gt; ndarray | Array\n</code></pre> <p>Get the image as a zarr array.</p> <p>Parameters:</p> <ul> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Select a what subset of channels to return. If None, all channels are returned.</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The order of the axes to return the array.</p> </li> <li> <code>transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>The transforms to apply to the array.</p> </li> <li> <code>mode</code>               (<code>Literal['numpy', 'dask']</code>, default:                   <code>'numpy'</code> )           \u2013            <p>The object type to return. Can be \"dask\", \"numpy\".</p> </li> <li> <code>**slicing_kwargs</code>               (<code>SlicingInputType</code>, default:                   <code>{}</code> )           \u2013            <p>The slices to get the array.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray | Array</code>           \u2013            <p>The zarr array of the region of interest.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def get_array(\n    self,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    mode: Literal[\"numpy\", \"dask\"] = \"numpy\",\n    **slicing_kwargs: SlicingInputType,\n) -&gt; np.ndarray | da.Array:\n    \"\"\"Get the image as a zarr array.\n\n    Args:\n        channel_selection: Select a what subset of channels to return.\n            If None, all channels are returned.\n        axes_order: The order of the axes to return the array.\n        transforms: The transforms to apply to the array.\n        mode: The object type to return.\n            Can be \"dask\", \"numpy\".\n        **slicing_kwargs: The slices to get the array.\n\n    Returns:\n        The zarr array of the region of interest.\n    \"\"\"\n    _slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self, channel_selection=channel_selection, slicing_dict=slicing_kwargs\n    )\n    return self._get_array(\n        axes_order=axes_order, mode=mode, transforms=transforms, **_slicing_kwargs\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Image.get_roi","title":"get_roi","text":"<pre><code>get_roi(\n    roi: Roi | RoiPixels,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    mode: Literal[\"numpy\", \"dask\"] = \"numpy\",\n    **slicing_kwargs: SlicingInputType,\n) -&gt; ndarray | Array\n</code></pre> <p>Get the image as a zarr array for a region of interest.</p> <p>Parameters:</p> <ul> <li> <code>roi</code>               (<code>Roi | RoiPixels</code>)           \u2013            <p>The region of interest to get the array.</p> </li> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Select a what subset of channels to return. If None, all channels are returned.</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The order of the axes to return the array.</p> </li> <li> <code>transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>The transforms to apply to the array.</p> </li> <li> <code>mode</code>               (<code>Literal['numpy', 'dask']</code>, default:                   <code>'numpy'</code> )           \u2013            <p>The object type to return. Can be \"dask\", \"numpy\".</p> </li> <li> <code>**slicing_kwargs</code>               (<code>SlicingInputType</code>, default:                   <code>{}</code> )           \u2013            <p>The slices to get the array.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray | Array</code>           \u2013            <p>The zarr array of the region of interest.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def get_roi(\n    self,\n    roi: Roi | RoiPixels,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    mode: Literal[\"numpy\", \"dask\"] = \"numpy\",\n    **slicing_kwargs: SlicingInputType,\n) -&gt; np.ndarray | da.Array:\n    \"\"\"Get the image as a zarr array for a region of interest.\n\n    Args:\n        roi: The region of interest to get the array.\n        channel_selection: Select a what subset of channels to return.\n            If None, all channels are returned.\n        axes_order: The order of the axes to return the array.\n        transforms: The transforms to apply to the array.\n        mode: The object type to return.\n            Can be \"dask\", \"numpy\".\n        **slicing_kwargs: The slices to get the array.\n\n    Returns:\n        The zarr array of the region of interest.\n    \"\"\"\n    _slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self, channel_selection=channel_selection, slicing_dict=slicing_kwargs\n    )\n    return self._get_roi(\n        roi=roi,\n        axes_order=axes_order,\n        mode=mode,\n        transforms=transforms,\n        **_slicing_kwargs,\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Image.set_array","title":"set_array","text":"<pre><code>set_array(\n    patch: ndarray | Array,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; None\n</code></pre> <p>Set the image array.</p> <p>Parameters:</p> <ul> <li> <code>patch</code>               (<code>ndarray | Array</code>)           \u2013            <p>The array to set.</p> </li> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Select a what subset of channels to return. If None, all channels are set.</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The order of the axes to set the array.</p> </li> <li> <code>transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>The transforms to apply to the array.</p> </li> <li> <code>**slicing_kwargs</code>               (<code>SlicingInputType</code>, default:                   <code>{}</code> )           \u2013            <p>The slices to set the array.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def set_array(\n    self,\n    patch: np.ndarray | da.Array,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; None:\n    \"\"\"Set the image array.\n\n    Args:\n        patch: The array to set.\n        channel_selection: Select a what subset of channels to return.\n            If None, all channels are set.\n        axes_order: The order of the axes to set the array.\n        transforms: The transforms to apply to the array.\n        **slicing_kwargs: The slices to set the array.\n    \"\"\"\n    _slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self, channel_selection=channel_selection, slicing_dict=slicing_kwargs\n    )\n    self._set_array(\n        patch=patch, axes_order=axes_order, transforms=transforms, **_slicing_kwargs\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Image.set_roi","title":"set_roi","text":"<pre><code>set_roi(\n    roi: Roi | RoiPixels,\n    patch: ndarray | Array,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; None\n</code></pre> <p>Set the image array for a region of interest.</p> <p>Parameters:</p> <ul> <li> <code>roi</code>               (<code>Roi | RoiPixels</code>)           \u2013            <p>The region of interest to set the array.</p> </li> <li> <code>patch</code>               (<code>ndarray | Array</code>)           \u2013            <p>The array to set.</p> </li> <li> <code>channel_selection</code>               (<code>ChannelSlicingInputType</code>, default:                   <code>None</code> )           \u2013            <p>Select a what subset of channels to return.</p> </li> <li> <code>axes_order</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The order of the axes to set the array.</p> </li> <li> <code>transforms</code>               (<code>Sequence[TransformProtocol] | None</code>, default:                   <code>None</code> )           \u2013            <p>The transforms to apply to the array.</p> </li> <li> <code>**slicing_kwargs</code>               (<code>SlicingInputType</code>, default:                   <code>{}</code> )           \u2013            <p>The slices to set the array.</p> </li> </ul> Source code in <code>ngio/images/_image.py</code> <pre><code>def set_roi(\n    self,\n    roi: Roi | RoiPixels,\n    patch: np.ndarray | da.Array,\n    channel_selection: ChannelSlicingInputType = None,\n    axes_order: Sequence[str] | None = None,\n    transforms: Sequence[TransformProtocol] | None = None,\n    **slicing_kwargs: SlicingInputType,\n) -&gt; None:\n    \"\"\"Set the image array for a region of interest.\n\n    Args:\n        roi: The region of interest to set the array.\n        patch: The array to set.\n        channel_selection: Select a what subset of channels to return.\n        axes_order: The order of the axes to set the array.\n        transforms: The transforms to apply to the array.\n        **slicing_kwargs: The slices to set the array.\n    \"\"\"\n    _slicing_kwargs = add_channel_selection_to_slicing_dict(\n        image=self, channel_selection=channel_selection, slicing_dict=slicing_kwargs\n    )\n    self._set_roi(\n        roi=roi,\n        patch=patch,\n        axes_order=axes_order,\n        transforms=transforms,\n        **_slicing_kwargs,\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Image.consolidate","title":"consolidate","text":"<pre><code>consolidate(\n    order: InterpolationOrder = \"linear\",\n    mode: Literal[\"dask\", \"numpy\", \"coarsen\"] = \"dask\",\n) -&gt; None\n</code></pre> <p>Consolidate the label on disk.</p> Source code in <code>ngio/images/_image.py</code> <pre><code>def consolidate(\n    self,\n    order: InterpolationOrder = \"linear\",\n    mode: Literal[\"dask\", \"numpy\", \"coarsen\"] = \"dask\",\n) -&gt; None:\n    \"\"\"Consolidate the label on disk.\"\"\"\n    self._consolidate(order=order, mode=mode)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Label","title":"Label","text":"<pre><code>Label(\n    group_handler: ZarrGroupHandler,\n    path: str,\n    meta_handler: LabelMetaHandler | None,\n)\n</code></pre> <p>               Bases: <code>AbstractImage[LabelMetaHandler]</code></p> <p>Placeholder class for a label.</p> <p>Initialize the Image at a single level.</p> <p>Parameters:</p> <ul> <li> <code>group_handler</code>               (<code>ZarrGroupHandler</code>)           \u2013            <p>The Zarr group handler.</p> </li> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path to the image in the ome_zarr file.</p> </li> <li> <code>meta_handler</code>               (<code>LabelMetaHandler | None</code>)           \u2013            <p>The image metadata handler.</p> </li> </ul> Source code in <code>ngio/images/_label.py</code> <pre><code>def __init__(\n    self,\n    group_handler: ZarrGroupHandler,\n    path: str,\n    meta_handler: LabelMetaHandler | None,\n) -&gt; None:\n    \"\"\"Initialize the Image at a single level.\n\n    Args:\n        group_handler: The Zarr group handler.\n        path: The path to the image in the ome_zarr file.\n        meta_handler: The image metadata handler.\n\n    \"\"\"\n    if meta_handler is None:\n        meta_handler = find_label_meta_handler(group_handler)\n    super().__init__(\n        group_handler=group_handler, path=path, meta_handler=meta_handler\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Label.meta_handler","title":"meta_handler  <code>property</code>","text":"<pre><code>meta_handler: _image_handler\n</code></pre> <p>Return the metadata.</p>"},{"location":"api/ngio/ngio/#ngio.Label.zarr_array","title":"zarr_array  <code>property</code>","text":"<pre><code>zarr_array: Array\n</code></pre> <p>Return the Zarr array.</p>"},{"location":"api/ngio/ngio/#ngio.Label.shape","title":"shape  <code>property</code>","text":"<pre><code>shape: tuple[int, ...]\n</code></pre> <p>Return the shape of the image.</p>"},{"location":"api/ngio/ngio/#ngio.Label.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype: str\n</code></pre> <p>Return the dtype of the image.</p>"},{"location":"api/ngio/ngio/#ngio.Label.chunks","title":"chunks  <code>property</code>","text":"<pre><code>chunks: tuple[int, ...]\n</code></pre> <p>Return the chunks of the image.</p>"},{"location":"api/ngio/ngio/#ngio.Label.dimensions","title":"dimensions  <code>property</code>","text":"<pre><code>dimensions: Dimensions\n</code></pre> <p>Return the dimensions of the image.</p>"},{"location":"api/ngio/ngio/#ngio.Label.axes_mapper","title":"axes_mapper  <code>property</code>","text":"<pre><code>axes_mapper: AxesHandler\n</code></pre> <p>Return the axes mapper of the image.</p>"},{"location":"api/ngio/ngio/#ngio.Label.is_3d","title":"is_3d  <code>property</code>","text":"<pre><code>is_3d: bool\n</code></pre> <p>Return True if the image is 3D.</p>"},{"location":"api/ngio/ngio/#ngio.Label.is_2d","title":"is_2d  <code>property</code>","text":"<pre><code>is_2d: bool\n</code></pre> <p>Return True if the image is 2D.</p>"},{"location":"api/ngio/ngio/#ngio.Label.is_time_series","title":"is_time_series  <code>property</code>","text":"<pre><code>is_time_series: bool\n</code></pre> <p>Return True if the image is a time series.</p>"},{"location":"api/ngio/ngio/#ngio.Label.is_2d_time_series","title":"is_2d_time_series  <code>property</code>","text":"<pre><code>is_2d_time_series: bool\n</code></pre> <p>Return True if the image is a 2D time series.</p>"},{"location":"api/ngio/ngio/#ngio.Label.is_3d_time_series","title":"is_3d_time_series  <code>property</code>","text":"<pre><code>is_3d_time_series: bool\n</code></pre> <p>Return True if the image is a 3D time series.</p>"},{"location":"api/ngio/ngio/#ngio.Label.is_multi_channels","title":"is_multi_channels  <code>property</code>","text":"<pre><code>is_multi_channels: bool\n</code></pre> <p>Return True if the image is multichannel.</p>"},{"location":"api/ngio/ngio/#ngio.Label.space_unit","title":"space_unit  <code>property</code>","text":"<pre><code>space_unit: str | None\n</code></pre> <p>Return the space unit of the image.</p>"},{"location":"api/ngio/ngio/#ngio.Label.time_unit","title":"time_unit  <code>property</code>","text":"<pre><code>time_unit: str | None\n</code></pre> <p>Return the time unit of the image.</p>"},{"location":"api/ngio/ngio/#ngio.Label.pixel_size","title":"pixel_size  <code>property</code>","text":"<pre><code>pixel_size: PixelSize\n</code></pre> <p>Return the pixel size of the image.</p>"},{"location":"api/ngio/ngio/#ngio.Label.dataset","title":"dataset  <code>property</code>","text":"<pre><code>dataset: Dataset\n</code></pre> <p>Return the dataset of the image.</p>"},{"location":"api/ngio/ngio/#ngio.Label.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Return the path of the image.</p>"},{"location":"api/ngio/ngio/#ngio.Label.get_as_numpy","title":"get_as_numpy  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_as_numpy = _get_as_numpy\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Label.get_as_dask","title":"get_as_dask  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_as_dask = _get_as_dask\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Label.get_array","title":"get_array  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_array = _get_array\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Label.get_roi_as_numpy","title":"get_roi_as_numpy  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_roi_as_numpy = _get_roi_as_numpy\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Label.get_roi_as_dask","title":"get_roi_as_dask  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_roi_as_dask = _get_roi_as_dask\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Label.get_roi","title":"get_roi  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_roi = _get_roi\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Label.set_array","title":"set_array  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>set_array = _set_array\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Label.set_roi","title":"set_roi  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>set_roi = _set_roi\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Label.meta","title":"meta  <code>property</code>","text":"<pre><code>meta: NgioLabelMeta\n</code></pre> <p>Return the metadata.</p>"},{"location":"api/ngio/ngio/#ngio.Label.has_axis","title":"has_axis","text":"<pre><code>has_axis(axis: str) -&gt; bool\n</code></pre> <p>Return True if the image has the given axis.</p> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def has_axis(self, axis: str) -&gt; bool:\n    \"\"\"Return True if the image has the given axis.\"\"\"\n    self.axes_mapper.get_index(\"x\")\n    return self.dimensions.has_axis(axis)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Label.build_image_roi_table","title":"build_image_roi_table","text":"<pre><code>build_image_roi_table(\n    name: str | None = \"image\",\n) -&gt; RoiTable\n</code></pre> <p>Build the ROI table for an image.</p> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def build_image_roi_table(self, name: str | None = \"image\") -&gt; RoiTable:\n    \"\"\"Build the ROI table for an image.\"\"\"\n    return build_image_roi_table(image=self, name=name)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Label.assert_dimensions_match","title":"assert_dimensions_match","text":"<pre><code>assert_dimensions_match(\n    other: AbstractImage, allow_singleton: bool = False\n) -&gt; None\n</code></pre> <p>Assert that two images have matching spatial dimensions.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>AbstractImage</code>)           \u2013            <p>The other image to compare to.</p> </li> <li> <code>allow_singleton</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, allow singleton dimensions to be compatible with non-singleton dimensions.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NgioValueError</code>             \u2013            <p>If the images do not have compatible dimensions.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def assert_dimensions_match(\n    self,\n    other: \"AbstractImage\",\n    allow_singleton: bool = False,\n) -&gt; None:\n    \"\"\"Assert that two images have matching spatial dimensions.\n\n    Args:\n        other: The other image to compare to.\n        allow_singleton: If True, allow singleton dimensions to be\n            compatible with non-singleton dimensions.\n\n    Raises:\n        NgioValueError: If the images do not have compatible dimensions.\n    \"\"\"\n    assert_dimensions_match(\n        image1=self, image2=other, allow_singleton=allow_singleton\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Label.assert_axes_match","title":"assert_axes_match","text":"<pre><code>assert_axes_match(other: AbstractImage) -&gt; None\n</code></pre> <p>Assert that two images have compatible axes.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>AbstractImage</code>)           \u2013            <p>The other image to compare to.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NgioValueError</code>             \u2013            <p>If the images do not have compatible axes.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def assert_axes_match(\n    self,\n    other: \"AbstractImage\",\n) -&gt; None:\n    \"\"\"Assert that two images have compatible axes.\n\n    Args:\n        other: The other image to compare to.\n\n    Raises:\n        NgioValueError: If the images do not have compatible axes.\n    \"\"\"\n    assert_axes_match(image1=self, image2=other)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Label.assert_can_be_rescaled","title":"assert_can_be_rescaled","text":"<pre><code>assert_can_be_rescaled(other: AbstractImage) -&gt; None\n</code></pre> <p>Assert that two images can be rescaled to each other.</p> <p>For this to be true, the images must have the same axes, and the pixel sizes must be compatible (i.e. one can be scaled to the other).</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>AbstractImage</code>)           \u2013            <p>The other image to compare to.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NgioValueError</code>             \u2013            <p>If the images cannot be scaled to each other.</p> </li> </ul> Source code in <code>ngio/images/_abstract_image.py</code> <pre><code>def assert_can_be_rescaled(\n    self,\n    other: \"AbstractImage\",\n) -&gt; None:\n    \"\"\"Assert that two images can be rescaled to each other.\n\n    For this to be true, the images must have the same axes, and\n    the pixel sizes must be compatible (i.e. one can be scaled to the other).\n\n    Args:\n        other: The other image to compare to.\n\n    Raises:\n        NgioValueError: If the images cannot be scaled to each other.\n    \"\"\"\n    assert_can_be_rescaled(image1=self, image2=other)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Label.set_axes_unit","title":"set_axes_unit","text":"<pre><code>set_axes_unit(\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n) -&gt; None\n</code></pre> <p>Set the axes unit of the image.</p> <p>Parameters:</p> <ul> <li> <code>space_unit</code>               (<code>SpaceUnits</code>, default:                   <code>DefaultSpaceUnit</code> )           \u2013            <p>The space unit of the image.</p> </li> <li> <code>time_unit</code>               (<code>TimeUnits</code>, default:                   <code>DefaultTimeUnit</code> )           \u2013            <p>The time unit of the image.</p> </li> </ul> Source code in <code>ngio/images/_label.py</code> <pre><code>def set_axes_unit(\n    self,\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n) -&gt; None:\n    \"\"\"Set the axes unit of the image.\n\n    Args:\n        space_unit (SpaceUnits): The space unit of the image.\n        time_unit (TimeUnits): The time unit of the image.\n    \"\"\"\n    meta = self.meta\n    meta = meta.to_units(space_unit=space_unit, time_unit=time_unit)\n    self._meta_handler.write_meta(meta)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Label.build_masking_roi_table","title":"build_masking_roi_table","text":"<pre><code>build_masking_roi_table() -&gt; MaskingRoiTable\n</code></pre> <p>Compute the masking ROI table.</p> Source code in <code>ngio/images/_label.py</code> <pre><code>def build_masking_roi_table(self) -&gt; MaskingRoiTable:\n    \"\"\"Compute the masking ROI table.\"\"\"\n    return build_masking_roi_table(self)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.Label.consolidate","title":"consolidate","text":"<pre><code>consolidate(\n    mode: Literal[\"dask\", \"numpy\", \"coarsen\"] = \"dask\",\n) -&gt; None\n</code></pre> <p>Consolidate the label on disk.</p> Source code in <code>ngio/images/_label.py</code> <pre><code>def consolidate(\n    self,\n    mode: Literal[\"dask\", \"numpy\", \"coarsen\"] = \"dask\",\n) -&gt; None:\n    \"\"\"Consolidate the label on disk.\"\"\"\n    self._consolidate(\n        order=\"nearest\",\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrContainer","title":"OmeZarrContainer","text":"<pre><code>OmeZarrContainer(\n    group_handler: ZarrGroupHandler,\n    table_container: TablesContainer | None = None,\n    label_container: LabelsContainer | None = None,\n    validate_paths: bool = False,\n)\n</code></pre> <p>This class is an object representation of an OME-Zarr image.</p> It provides methods to access <ul> <li>The multiscale image metadata</li> <li>To open images at different levels of resolution</li> <li>To access labels and tables associated with the image.</li> <li>To derive new images, labels, and add tables to the image.</li> <li>To modify the image metadata, such as axes units and channel metadata.</li> </ul> <p>Attributes:</p> <ul> <li> <code>images_container</code>               (<code>ImagesContainer</code>)           \u2013            <p>The container for the images.</p> </li> <li> <code>labels_container</code>               (<code>LabelsContainer</code>)           \u2013            <p>The container for the labels.</p> </li> <li> <code>tables_container</code>               (<code>TablesContainer</code>)           \u2013            <p>The container for the tables.</p> </li> </ul> <p>Initialize the OmeZarrContainer.</p> <p>Parameters:</p> <ul> <li> <code>group_handler</code>               (<code>ZarrGroupHandler</code>)           \u2013            <p>The Zarr group handler.</p> </li> <li> <code>table_container</code>               (<code>TablesContainer | None</code>, default:                   <code>None</code> )           \u2013            <p>The tables container.</p> </li> <li> <code>label_container</code>               (<code>LabelsContainer | None</code>, default:                   <code>None</code> )           \u2013            <p>The labels container.</p> </li> <li> <code>validate_paths</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to validate the paths of the image multiscale</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def __init__(\n    self,\n    group_handler: ZarrGroupHandler,\n    table_container: TablesContainer | None = None,\n    label_container: LabelsContainer | None = None,\n    validate_paths: bool = False,\n) -&gt; None:\n    \"\"\"Initialize the OmeZarrContainer.\n\n    Args:\n        group_handler (ZarrGroupHandler): The Zarr group handler.\n        table_container (TablesContainer | None): The tables container.\n        label_container (LabelsContainer | None): The labels container.\n        validate_paths (bool): Whether to validate the paths of the image multiscale\n    \"\"\"\n    self._group_handler = group_handler\n    self._images_container = ImagesContainer(self._group_handler)\n\n    self._labels_container = label_container\n    self._tables_container = table_container\n\n    if validate_paths:\n        for level_path in self._images_container.levels_paths:\n            self.get_image(path=level_path)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrContainer.images_container","title":"images_container  <code>property</code>","text":"<pre><code>images_container: ImagesContainer\n</code></pre> <p>Return the images container.</p> <p>Returns:</p> <ul> <li> <code>ImagesContainer</code> (              <code>ImagesContainer</code> )          \u2013            <p>The images container.</p> </li> </ul>"},{"location":"api/ngio/ngio/#ngio.OmeZarrContainer.labels_container","title":"labels_container  <code>property</code>","text":"<pre><code>labels_container: LabelsContainer\n</code></pre> <p>Return the labels container.</p>"},{"location":"api/ngio/ngio/#ngio.OmeZarrContainer.tables_container","title":"tables_container  <code>property</code>","text":"<pre><code>tables_container: TablesContainer\n</code></pre> <p>Return the tables container.</p>"},{"location":"api/ngio/ngio/#ngio.OmeZarrContainer.image_meta","title":"image_meta  <code>property</code>","text":"<pre><code>image_meta: NgioImageMeta\n</code></pre> <p>Return the image metadata.</p>"},{"location":"api/ngio/ngio/#ngio.OmeZarrContainer.levels","title":"levels  <code>property</code>","text":"<pre><code>levels: int\n</code></pre> <p>Return the number of levels in the image.</p>"},{"location":"api/ngio/ngio/#ngio.OmeZarrContainer.levels_paths","title":"levels_paths  <code>property</code>","text":"<pre><code>levels_paths: list[str]\n</code></pre> <p>Return the paths of the levels in the image.</p>"},{"location":"api/ngio/ngio/#ngio.OmeZarrContainer.is_3d","title":"is_3d  <code>property</code>","text":"<pre><code>is_3d: bool\n</code></pre> <p>Return True if the image is 3D.</p>"},{"location":"api/ngio/ngio/#ngio.OmeZarrContainer.is_2d","title":"is_2d  <code>property</code>","text":"<pre><code>is_2d: bool\n</code></pre> <p>Return True if the image is 2D.</p>"},{"location":"api/ngio/ngio/#ngio.OmeZarrContainer.is_time_series","title":"is_time_series  <code>property</code>","text":"<pre><code>is_time_series: bool\n</code></pre> <p>Return True if the image is a time series.</p>"},{"location":"api/ngio/ngio/#ngio.OmeZarrContainer.is_2d_time_series","title":"is_2d_time_series  <code>property</code>","text":"<pre><code>is_2d_time_series: bool\n</code></pre> <p>Return True if the image is a 2D time series.</p>"},{"location":"api/ngio/ngio/#ngio.OmeZarrContainer.is_3d_time_series","title":"is_3d_time_series  <code>property</code>","text":"<pre><code>is_3d_time_series: bool\n</code></pre> <p>Return True if the image is a 3D time series.</p>"},{"location":"api/ngio/ngio/#ngio.OmeZarrContainer.is_multi_channels","title":"is_multi_channels  <code>property</code>","text":"<pre><code>is_multi_channels: bool\n</code></pre> <p>Return True if the image is multichannel.</p>"},{"location":"api/ngio/ngio/#ngio.OmeZarrContainer.space_unit","title":"space_unit  <code>property</code>","text":"<pre><code>space_unit: str | None\n</code></pre> <p>Return the space unit of the image.</p>"},{"location":"api/ngio/ngio/#ngio.OmeZarrContainer.time_unit","title":"time_unit  <code>property</code>","text":"<pre><code>time_unit: str | None\n</code></pre> <p>Return the time unit of the image.</p>"},{"location":"api/ngio/ngio/#ngio.OmeZarrContainer.channel_labels","title":"channel_labels  <code>property</code>","text":"<pre><code>channel_labels: list[str]\n</code></pre> <p>Return the channels of the image.</p>"},{"location":"api/ngio/ngio/#ngio.OmeZarrContainer.wavelength_ids","title":"wavelength_ids  <code>property</code>","text":"<pre><code>wavelength_ids: list[str | None]\n</code></pre> <p>Return the list of wavelength of the image.</p>"},{"location":"api/ngio/ngio/#ngio.OmeZarrContainer.num_channels","title":"num_channels  <code>property</code>","text":"<pre><code>num_channels: int\n</code></pre> <p>Return the number of channels.</p>"},{"location":"api/ngio/ngio/#ngio.OmeZarrContainer.get_channel_idx","title":"get_channel_idx","text":"<pre><code>get_channel_idx(\n    channel_label: str | None = None,\n    wavelength_id: str | None = None,\n) -&gt; int\n</code></pre> <p>Get the index of a channel by its label or wavelength ID.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_channel_idx(\n    self, channel_label: str | None = None, wavelength_id: str | None = None\n) -&gt; int:\n    \"\"\"Get the index of a channel by its label or wavelength ID.\"\"\"\n    image = self.get_image()\n    return image.channels_meta.get_channel_idx(\n        channel_label=channel_label, wavelength_id=wavelength_id\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrContainer.set_channel_meta","title":"set_channel_meta","text":"<pre><code>set_channel_meta(\n    labels: Sequence[str] | int | None = None,\n    wavelength_id: Sequence[str] | None = None,\n    percentiles: tuple[float, float] | None = None,\n    colors: Sequence[str] | None = None,\n    active: Sequence[bool] | None = None,\n    **omero_kwargs: dict,\n) -&gt; None\n</code></pre> <p>Create a ChannelsMeta object with the default unit.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def set_channel_meta(\n    self,\n    labels: Sequence[str] | int | None = None,\n    wavelength_id: Sequence[str] | None = None,\n    percentiles: tuple[float, float] | None = None,\n    colors: Sequence[str] | None = None,\n    active: Sequence[bool] | None = None,\n    **omero_kwargs: dict,\n) -&gt; None:\n    \"\"\"Create a ChannelsMeta object with the default unit.\"\"\"\n    self._images_container.set_channel_meta(\n        labels=labels,\n        wavelength_id=wavelength_id,\n        start=None,\n        end=None,\n        percentiles=percentiles,\n        colors=colors,\n        active=active,\n        **omero_kwargs,\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrContainer.set_channel_percentiles","title":"set_channel_percentiles","text":"<pre><code>set_channel_percentiles(\n    start_percentile: float = 0.1,\n    end_percentile: float = 99.9,\n) -&gt; None\n</code></pre> <p>Update the percentiles of the image.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def set_channel_percentiles(\n    self,\n    start_percentile: float = 0.1,\n    end_percentile: float = 99.9,\n) -&gt; None:\n    \"\"\"Update the percentiles of the image.\"\"\"\n    self._images_container.set_channel_percentiles(\n        start_percentile=start_percentile, end_percentile=end_percentile\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrContainer.set_axes_units","title":"set_axes_units","text":"<pre><code>set_axes_units(\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n    set_labels: bool = True,\n) -&gt; None\n</code></pre> <p>Set the units of the image.</p> <p>Parameters:</p> <ul> <li> <code>space_unit</code>               (<code>SpaceUnits</code>, default:                   <code>DefaultSpaceUnit</code> )           \u2013            <p>The unit of space.</p> </li> <li> <code>time_unit</code>               (<code>TimeUnits</code>, default:                   <code>DefaultTimeUnit</code> )           \u2013            <p>The unit of time.</p> </li> <li> <code>set_labels</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to set the units for the labels as well.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def set_axes_units(\n    self,\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n    set_labels: bool = True,\n) -&gt; None:\n    \"\"\"Set the units of the image.\n\n    Args:\n        space_unit (SpaceUnits): The unit of space.\n        time_unit (TimeUnits): The unit of time.\n        set_labels (bool): Whether to set the units for the labels as well.\n    \"\"\"\n    self._images_container.set_axes_unit(space_unit=space_unit, time_unit=time_unit)\n    if not set_labels:\n        return\n    for label_name in self.list_labels():\n        label = self.get_label(label_name)\n        label.set_axes_unit(space_unit=space_unit, time_unit=time_unit)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrContainer.get_image","title":"get_image","text":"<pre><code>get_image(\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; Image\n</code></pre> <p>Get an image at a specific level.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the image in the ome_zarr file.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the image.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Only used if the pixel size is provided. If True, the pixel size must match the image pixel size exactly. If False, the closest pixel size level will be returned.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_image(\n    self,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; Image:\n    \"\"\"Get an image at a specific level.\n\n    Args:\n        path (str | None): The path to the image in the ome_zarr file.\n        pixel_size (PixelSize | None): The pixel size of the image.\n        strict (bool): Only used if the pixel size is provided. If True, the\n            pixel size must match the image pixel size exactly. If False, the\n            closest pixel size level will be returned.\n\n    \"\"\"\n    return self._images_container.get(\n        path=path, pixel_size=pixel_size, strict=strict\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrContainer.get_masked_image","title":"get_masked_image","text":"<pre><code>get_masked_image(\n    masking_label_name: str | None = None,\n    masking_table_name: str | None = None,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; MaskedImage\n</code></pre> <p>Get a masked image at a specific level.</p> <p>Parameters:</p> <ul> <li> <code>masking_label_name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the masking label to use. If None, the masking table must be provided.</p> </li> <li> <code>masking_table_name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the masking table to use. If None, the masking label must be provided.</p> </li> <li> <code>path</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the image in the ome_zarr file. If None, the first level will be used.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the image. This is only used if path is None.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Only used if the pixel size is provided. If True, the pixel size must match the image pixel size exactly. If False, the closest pixel size level will be returned.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_masked_image(\n    self,\n    masking_label_name: str | None = None,\n    masking_table_name: str | None = None,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; MaskedImage:\n    \"\"\"Get a masked image at a specific level.\n\n    Args:\n        masking_label_name (str | None): The name of the masking label to use.\n            If None, the masking table must be provided.\n        masking_table_name (str | None): The name of the masking table to use.\n            If None, the masking label must be provided.\n        path (str | None): The path to the image in the ome_zarr file.\n            If None, the first level will be used.\n        pixel_size (PixelSize | None): The pixel size of the image.\n            This is only used if path is None.\n        strict (bool): Only used if the pixel size is provided. If True, the\n            pixel size must match the image pixel size exactly. If False, the\n            closest pixel size level will be returned.\n    \"\"\"\n    image = self.get_image(path=path, pixel_size=pixel_size, strict=strict)\n    masking_label, masking_table = self._find_matching_masking_label(\n        masking_label_name=masking_label_name,\n        masking_table_name=masking_table_name,\n        pixel_size=pixel_size,\n    )\n    return MaskedImage(\n        group_handler=image._group_handler,\n        path=image.path,\n        meta_handler=image.meta_handler,\n        label=masking_label,\n        masking_roi_table=masking_table,\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrContainer.derive_image","title":"derive_image","text":"<pre><code>derive_image(\n    store: StoreOrGroup,\n    ref_path: str | None = None,\n    shape: Sequence[int] | None = None,\n    labels: Sequence[str] | None = None,\n    pixel_size: PixelSize | None = None,\n    axes_names: Sequence[str] | None = None,\n    name: str | None = None,\n    chunks: Sequence[int] | None = None,\n    dtype: str | None = None,\n    copy_labels: bool = False,\n    copy_tables: bool = False,\n    overwrite: bool = False,\n) -&gt; OmeZarrContainer\n</code></pre> <p>Create an empty OME-Zarr container from an existing image.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group to create the image in.</p> </li> <li> <code>ref_path</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the reference image in the image container.</p> </li> <li> <code>shape</code>               (<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The shape of the new image.</p> </li> <li> <code>labels</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The labels of the new image.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the new image.</p> </li> <li> <code>axes_names</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The axes names of the new image.</p> </li> <li> <code>chunks</code>               (<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The chunk shape of the new image.</p> </li> <li> <code>dtype</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The data type of the new image.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the new image.</p> </li> <li> <code>copy_labels</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to copy the labels from the reference image.</p> </li> <li> <code>copy_tables</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to copy the tables from the reference image.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to overwrite an existing image.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OmeZarrContainer</code> (              <code>OmeZarrContainer</code> )          \u2013            <p>The new image container.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def derive_image(\n    self,\n    store: StoreOrGroup,\n    ref_path: str | None = None,\n    shape: Sequence[int] | None = None,\n    labels: Sequence[str] | None = None,\n    pixel_size: PixelSize | None = None,\n    axes_names: Sequence[str] | None = None,\n    name: str | None = None,\n    chunks: Sequence[int] | None = None,\n    dtype: str | None = None,\n    copy_labels: bool = False,\n    copy_tables: bool = False,\n    overwrite: bool = False,\n) -&gt; \"OmeZarrContainer\":\n    \"\"\"Create an empty OME-Zarr container from an existing image.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group to create the image in.\n        ref_path (str | None): The path to the reference image in\n            the image container.\n        shape (Sequence[int] | None): The shape of the new image.\n        labels (Sequence[str] | None): The labels of the new image.\n        pixel_size (PixelSize | None): The pixel size of the new image.\n        axes_names (Sequence[str] | None): The axes names of the new image.\n        chunks (Sequence[int] | None): The chunk shape of the new image.\n        dtype (str | None): The data type of the new image.\n        name (str | None): The name of the new image.\n        copy_labels (bool): Whether to copy the labels from the reference image.\n        copy_tables (bool): Whether to copy the tables from the reference image.\n        overwrite (bool): Whether to overwrite an existing image.\n\n    Returns:\n        OmeZarrContainer: The new image container.\n\n    \"\"\"\n    _ = self._images_container.derive(\n        store=store,\n        ref_path=ref_path,\n        shape=shape,\n        labels=labels,\n        pixel_size=pixel_size,\n        axes_names=axes_names,\n        name=name,\n        chunks=chunks,\n        dtype=dtype,\n        overwrite=overwrite,\n    )\n\n    handler = ZarrGroupHandler(\n        store, cache=self._group_handler.use_cache, mode=self._group_handler.mode\n    )\n\n    new_ome_zarr = OmeZarrContainer(\n        group_handler=handler,\n        validate_paths=False,\n    )\n\n    if copy_labels:\n        self.labels_container._group_handler.copy_handler(\n            new_ome_zarr.labels_container._group_handler\n        )\n\n    if copy_tables:\n        self.tables_container._group_handler.copy_handler(\n            new_ome_zarr.tables_container._group_handler\n        )\n    return new_ome_zarr\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrContainer.list_tables","title":"list_tables","text":"<pre><code>list_tables(\n    filter_types: TypedTable | str | None = None,\n) -&gt; list[str]\n</code></pre> <p>List all tables in the image.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def list_tables(self, filter_types: TypedTable | str | None = None) -&gt; list[str]:\n    \"\"\"List all tables in the image.\"\"\"\n    table_container = self._get_tables_container()\n    if table_container is None:\n        return []\n\n    return table_container.list(\n        filter_types=filter_types,\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrContainer.list_roi_tables","title":"list_roi_tables","text":"<pre><code>list_roi_tables() -&gt; list[str]\n</code></pre> <p>List all ROI tables in the image.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def list_roi_tables(self) -&gt; list[str]:\n    \"\"\"List all ROI tables in the image.\"\"\"\n    masking_roi = self.tables_container.list(\n        filter_types=\"masking_roi_table\",\n    )\n    roi = self.tables_container.list(\n        filter_types=\"roi_table\",\n    )\n    return masking_roi + roi\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrContainer.get_roi_table","title":"get_roi_table","text":"<pre><code>get_roi_table(name: str) -&gt; RoiTable\n</code></pre> <p>Get a ROI table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_roi_table(self, name: str) -&gt; RoiTable:\n    \"\"\"Get a ROI table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, RoiTable):\n        raise NgioValueError(f\"Table {name} is not a ROI table. Got {type(table)}\")\n    return table\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrContainer.get_masking_roi_table","title":"get_masking_roi_table","text":"<pre><code>get_masking_roi_table(name: str) -&gt; MaskingRoiTable\n</code></pre> <p>Get a masking ROI table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_masking_roi_table(self, name: str) -&gt; MaskingRoiTable:\n    \"\"\"Get a masking ROI table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, MaskingRoiTable):\n        raise NgioValueError(\n            f\"Table {name} is not a masking ROI table. Got {type(table)}\"\n        )\n    return table\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrContainer.get_feature_table","title":"get_feature_table","text":"<pre><code>get_feature_table(name: str) -&gt; FeatureTable\n</code></pre> <p>Get a feature table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_feature_table(self, name: str) -&gt; FeatureTable:\n    \"\"\"Get a feature table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, FeatureTable):\n        raise NgioValueError(\n            f\"Table {name} is not a feature table. Got {type(table)}\"\n        )\n    return table\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrContainer.get_generic_roi_table","title":"get_generic_roi_table","text":"<pre><code>get_generic_roi_table(name: str) -&gt; GenericRoiTable\n</code></pre> <p>Get a generic ROI table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_generic_roi_table(self, name: str) -&gt; GenericRoiTable:\n    \"\"\"Get a generic ROI table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, GenericRoiTable):\n        raise NgioValueError(\n            f\"Table {name} is not a generic ROI table. Got {type(table)}\"\n        )\n    return table\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrContainer.get_condition_table","title":"get_condition_table","text":"<pre><code>get_condition_table(name: str) -&gt; ConditionTable\n</code></pre> <p>Get a condition table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_condition_table(self, name: str) -&gt; ConditionTable:\n    \"\"\"Get a condition table from the image.\n\n    Args:\n        name (str): The name of the table.\n    \"\"\"\n    table = self.tables_container.get(name=name, strict=True)\n    if not isinstance(table, ConditionTable):\n        raise NgioValueError(\n            f\"Table {name} is not a condition table. Got {type(table)}\"\n        )\n    return table\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrContainer.get_table","title":"get_table","text":"<pre><code>get_table(\n    name: str, check_type: TypedTable | None = None\n) -&gt; Table\n</code></pre> <p>Get a table from the image.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> <li> <code>check_type</code>               (<code>TypedTable | None</code>, default:                   <code>None</code> )           \u2013            <p>Deprecated. Please use 'get_table_as' instead, or one of the type specific get_*table() methods.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_table(self, name: str, check_type: TypedTable | None = None) -&gt; Table:\n    \"\"\"Get a table from the image.\n\n    Args:\n        name (str): The name of the table.\n        check_type (TypedTable | None): Deprecated. Please use\n            'get_table_as' instead, or one of the type specific\n            get_*table() methods.\n\n    \"\"\"\n    if check_type is not None:\n        warnings.warn(\n            \"The 'check_type' argument is deprecated, and will be removed in \"\n            \"ngio=0.3. Use 'get_table_as' instead or one of the \"\n            \"type specific get_*table() methods.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n    return self.tables_container.get(name=name, strict=False)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrContainer.get_table_as","title":"get_table_as","text":"<pre><code>get_table_as(\n    name: str,\n    table_cls: type[TableType],\n    backend: TableBackend | None = None,\n) -&gt; TableType\n</code></pre> <p>Get a table from the image as a specific type.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> <li> <code>table_cls</code>               (<code>type[TableType]</code>)           \u2013            <p>The type of the table.</p> </li> <li> <code>backend</code>               (<code>TableBackend | None</code>, default:                   <code>None</code> )           \u2013            <p>The backend to use. If None, the default backend is used.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_table_as(\n    self,\n    name: str,\n    table_cls: type[TableType],\n    backend: TableBackend | None = None,\n) -&gt; TableType:\n    \"\"\"Get a table from the image as a specific type.\n\n    Args:\n        name (str): The name of the table.\n        table_cls (type[TableType]): The type of the table.\n        backend (TableBackend | None): The backend to use. If None,\n            the default backend is used.\n    \"\"\"\n    return self.tables_container.get_as(\n        name=name,\n        table_cls=table_cls,\n        backend=backend,\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrContainer.build_image_roi_table","title":"build_image_roi_table","text":"<pre><code>build_image_roi_table(\n    name: str | None = \"image\",\n) -&gt; RoiTable\n</code></pre> <p>Compute the ROI table for an image.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def build_image_roi_table(self, name: str | None = \"image\") -&gt; RoiTable:\n    \"\"\"Compute the ROI table for an image.\"\"\"\n    return self.get_image().build_image_roi_table(name=name)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrContainer.build_masking_roi_table","title":"build_masking_roi_table","text":"<pre><code>build_masking_roi_table(label: str) -&gt; MaskingRoiTable\n</code></pre> <p>Compute the masking ROI table for a label.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def build_masking_roi_table(self, label: str) -&gt; MaskingRoiTable:\n    \"\"\"Compute the masking ROI table for a label.\"\"\"\n    return self.get_label(label).build_masking_roi_table()\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrContainer.add_table","title":"add_table","text":"<pre><code>add_table(\n    name: str,\n    table: Table,\n    backend: TableBackend = DefaultTableBackend,\n    overwrite: bool = False,\n) -&gt; None\n</code></pre> <p>Add a table to the image.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def add_table(\n    self,\n    name: str,\n    table: Table,\n    backend: TableBackend = DefaultTableBackend,\n    overwrite: bool = False,\n) -&gt; None:\n    \"\"\"Add a table to the image.\"\"\"\n    self.tables_container.add(\n        name=name, table=table, backend=backend, overwrite=overwrite\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrContainer.list_labels","title":"list_labels","text":"<pre><code>list_labels() -&gt; list[str]\n</code></pre> <p>List all labels in the image.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def list_labels(self) -&gt; list[str]:\n    \"\"\"List all labels in the image.\"\"\"\n    label_container = self._get_labels_container()\n    if label_container is None:\n        return []\n    return label_container.list()\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrContainer.get_label","title":"get_label","text":"<pre><code>get_label(\n    name: str,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; Label\n</code></pre> <p>Get a label from the group.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the label.</p> </li> <li> <code>path</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the image in the ome_zarr file.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the image.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Only used if the pixel size is provided. If True, the pixel size must match the image pixel size exactly. If False, the closest pixel size level will be returned.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_label(\n    self,\n    name: str,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; Label:\n    \"\"\"Get a label from the group.\n\n    Args:\n        name (str): The name of the label.\n        path (str | None): The path to the image in the ome_zarr file.\n        pixel_size (PixelSize | None): The pixel size of the image.\n        strict (bool): Only used if the pixel size is provided. If True, the\n            pixel size must match the image pixel size exactly. If False, the\n            closest pixel size level will be returned.\n    \"\"\"\n    return self.labels_container.get(\n        name=name, path=path, pixel_size=pixel_size, strict=strict\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrContainer.get_masked_label","title":"get_masked_label","text":"<pre><code>get_masked_label(\n    label_name: str,\n    masking_label_name: str | None = None,\n    masking_table_name: str | None = None,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; MaskedLabel\n</code></pre> <p>Get a masked image at a specific level.</p> <p>Parameters:</p> <ul> <li> <code>label_name</code>               (<code>str</code>)           \u2013            <p>The name of the label.</p> </li> <li> <code>masking_label_name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the masking label.</p> </li> <li> <code>masking_table_name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the masking table.</p> </li> <li> <code>path</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the image in the ome_zarr file.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the image.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Only used if the pixel size is provided. If True, the pixel size must match the image pixel size exactly. If False, the closest pixel size level will be returned.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def get_masked_label(\n    self,\n    label_name: str,\n    masking_label_name: str | None = None,\n    masking_table_name: str | None = None,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = False,\n) -&gt; MaskedLabel:\n    \"\"\"Get a masked image at a specific level.\n\n    Args:\n        label_name (str): The name of the label.\n        masking_label_name (str | None): The name of the masking label.\n        masking_table_name (str | None): The name of the masking table.\n        path (str | None): The path to the image in the ome_zarr file.\n        pixel_size (PixelSize | None): The pixel size of the image.\n        strict (bool): Only used if the pixel size is provided. If True, the\n            pixel size must match the image pixel size exactly. If False, the\n            closest pixel size level will be returned.\n    \"\"\"\n    label = self.get_label(\n        name=label_name, path=path, pixel_size=pixel_size, strict=strict\n    )\n    masking_label, masking_table = self._find_matching_masking_label(\n        masking_label_name=masking_label_name,\n        masking_table_name=masking_table_name,\n        pixel_size=pixel_size,\n    )\n    return MaskedLabel(\n        group_handler=label._group_handler,\n        path=label.path,\n        meta_handler=label.meta_handler,\n        label=masking_label,\n        masking_roi_table=masking_table,\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.OmeZarrContainer.derive_label","title":"derive_label","text":"<pre><code>derive_label(\n    name: str,\n    ref_image: Image | Label | None = None,\n    shape: Sequence[int] | None = None,\n    pixel_size: PixelSize | None = None,\n    axes_names: Sequence[str] | None = None,\n    chunks: Sequence[int] | None = None,\n    dtype: str = \"uint32\",\n    overwrite: bool = False,\n) -&gt; Label\n</code></pre> <p>Create an empty OME-Zarr label from a reference image.</p> <p>And add the label to the /labels group.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the new image.</p> </li> <li> <code>ref_image</code>               (<code>Image | Label | None</code>, default:                   <code>None</code> )           \u2013            <p>A reference image that will be used to create the new image.</p> </li> <li> <code>shape</code>               (<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The shape of the new image.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the new image.</p> </li> <li> <code>axes_names</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The axes names of the new image. For labels, the channel axis is not allowed.</p> </li> <li> <code>chunks</code>               (<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The chunk shape of the new image.</p> </li> <li> <code>dtype</code>               (<code>str</code>, default:                   <code>'uint32'</code> )           \u2013            <p>The data type of the new label.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to overwrite an existing image.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Label</code> (              <code>Label</code> )          \u2013            <p>The new label.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def derive_label(\n    self,\n    name: str,\n    ref_image: Image | Label | None = None,\n    shape: Sequence[int] | None = None,\n    pixel_size: PixelSize | None = None,\n    axes_names: Sequence[str] | None = None,\n    chunks: Sequence[int] | None = None,\n    dtype: str = \"uint32\",\n    overwrite: bool = False,\n) -&gt; \"Label\":\n    \"\"\"Create an empty OME-Zarr label from a reference image.\n\n    And add the label to the /labels group.\n\n    Args:\n        name (str): The name of the new image.\n        ref_image (Image | Label | None): A reference image that will be used\n            to create the new image.\n        shape (Sequence[int] | None): The shape of the new image.\n        pixel_size (PixelSize | None): The pixel size of the new image.\n        axes_names (Sequence[str] | None): The axes names of the new image.\n            For labels, the channel axis is not allowed.\n        chunks (Sequence[int] | None): The chunk shape of the new image.\n        dtype (str): The data type of the new label.\n        overwrite (bool): Whether to overwrite an existing image.\n\n    Returns:\n        Label: The new label.\n\n    \"\"\"\n    if ref_image is None:\n        ref_image = self.get_image()\n    return self.labels_container.derive(\n        name=name,\n        ref_image=ref_image,\n        shape=shape,\n        pixel_size=pixel_size,\n        axes_names=axes_names,\n        chunks=chunks,\n        dtype=dtype,\n        overwrite=overwrite,\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.AxesSetup","title":"AxesSetup","text":"<p>               Bases: <code>BaseModel</code></p> <p>Axes setup model.</p> <p>This model is used to map the on disk axes to the canonical OME-Zarr axes.</p>"},{"location":"api/ngio/ngio/#ngio.AxesSetup.x","title":"x  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>x: str = 'x'\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.AxesSetup.y","title":"y  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>y: str = 'y'\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.AxesSetup.z","title":"z  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>z: str = 'z'\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.AxesSetup.c","title":"c  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>c: str = 'c'\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.AxesSetup.t","title":"t  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>t: str = 't'\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.AxesSetup.others","title":"others  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>others: list[str] = Field(default_factory=list)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.AxesSetup.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(extra='forbid', frozen=True)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.AxesSetup.canonical_map","title":"canonical_map","text":"<pre><code>canonical_map() -&gt; dict[str, str]\n</code></pre> <p>Get the canonical map of axes.</p> Source code in <code>ngio/ome_zarr_meta/ngio_specs/_axes.py</code> <pre><code>def canonical_map(self) -&gt; dict[str, str]:\n    \"\"\"Get the canonical map of axes.\"\"\"\n    return {\n        \"t\": self.t,\n        \"c\": self.c,\n        \"z\": self.z,\n        \"y\": self.y,\n        \"x\": self.x,\n    }\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.AxesSetup.get_on_disk_name","title":"get_on_disk_name","text":"<pre><code>get_on_disk_name(canonical_name: str) -&gt; str | None\n</code></pre> <p>Get the on disk name of the axis by its canonical name.</p> Source code in <code>ngio/ome_zarr_meta/ngio_specs/_axes.py</code> <pre><code>def get_on_disk_name(self, canonical_name: str) -&gt; str | None:\n    \"\"\"Get the on disk name of the axis by its canonical name.\"\"\"\n    canonical_map = self.canonical_map()\n    return canonical_map.get(canonical_name, None)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.AxesSetup.inverse_canonical_map","title":"inverse_canonical_map","text":"<pre><code>inverse_canonical_map() -&gt; dict[str, str]\n</code></pre> <p>Get the on disk map of axes.</p> Source code in <code>ngio/ome_zarr_meta/ngio_specs/_axes.py</code> <pre><code>def inverse_canonical_map(self) -&gt; dict[str, str]:\n    \"\"\"Get the on disk map of axes.\"\"\"\n    return {\n        self.t: \"t\",\n        self.c: \"c\",\n        self.z: \"z\",\n        self.y: \"y\",\n        self.x: \"x\",\n    }\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.AxesSetup.get_canonical_name","title":"get_canonical_name","text":"<pre><code>get_canonical_name(on_disk_name: str) -&gt; str | None\n</code></pre> <p>Get the canonical name of the axis by its on disk name.</p> Source code in <code>ngio/ome_zarr_meta/ngio_specs/_axes.py</code> <pre><code>def get_canonical_name(self, on_disk_name: str) -&gt; str | None:\n    \"\"\"Get the canonical name of the axis by its on disk name.\"\"\"\n    inv_map = self.inverse_canonical_map()\n    return inv_map.get(on_disk_name, None)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.ImageInWellPath","title":"ImageInWellPath","text":"<p>               Bases: <code>BaseModel</code></p> <p>Image in a well.</p>"},{"location":"api/ngio/ngio/#ngio.ImageInWellPath.row","title":"row  <code>instance-attribute</code>","text":"<pre><code>row: str\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.ImageInWellPath.column","title":"column  <code>instance-attribute</code>","text":"<pre><code>column: str | int\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.ImageInWellPath.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path: str\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.ImageInWellPath.acquisition_id","title":"acquisition_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>acquisition_id: int | None = None\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.ImageInWellPath.acquisition_name","title":"acquisition_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>acquisition_name: str | None = None\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.PixelSize","title":"PixelSize","text":"<pre><code>PixelSize(\n    x: float,\n    y: float,\n    z: float,\n    t: float = 1,\n    space_unit: SpaceUnits | str | None = DefaultSpaceUnit,\n    time_unit: TimeUnits | str | None = DefaultTimeUnit,\n)\n</code></pre> <p>PixelSize class to store the pixel size in 3D space.</p> <p>Initialize the pixel size.</p> Source code in <code>ngio/ome_zarr_meta/ngio_specs/_pixel_size.py</code> <pre><code>def __init__(\n    self,\n    x: float,\n    y: float,\n    z: float,\n    t: float = 1,\n    space_unit: SpaceUnits | str | None = DefaultSpaceUnit,\n    time_unit: TimeUnits | str | None = DefaultTimeUnit,\n):\n    \"\"\"Initialize the pixel size.\"\"\"\n    self.x = _validate_type(x, \"x\")\n    self.y = _validate_type(y, \"y\")\n    self.z = _validate_type(z, \"z\")\n    self.t = _validate_type(t, \"t\")\n\n    self._space_unit = space_unit\n    self._time_unit = time_unit\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.PixelSize.x","title":"x  <code>instance-attribute</code>","text":"<pre><code>x = _validate_type(x, 'x')\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.PixelSize.y","title":"y  <code>instance-attribute</code>","text":"<pre><code>y = _validate_type(y, 'y')\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.PixelSize.z","title":"z  <code>instance-attribute</code>","text":"<pre><code>z = _validate_type(z, 'z')\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.PixelSize.t","title":"t  <code>instance-attribute</code>","text":"<pre><code>t = _validate_type(t, 't')\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.PixelSize.space_unit","title":"space_unit  <code>property</code>","text":"<pre><code>space_unit: SpaceUnits | str | None\n</code></pre> <p>Return the space unit.</p>"},{"location":"api/ngio/ngio/#ngio.PixelSize.time_unit","title":"time_unit  <code>property</code>","text":"<pre><code>time_unit: TimeUnits | str | None\n</code></pre> <p>Return the time unit.</p>"},{"location":"api/ngio/ngio/#ngio.PixelSize.tzyx","title":"tzyx  <code>property</code>","text":"<pre><code>tzyx: tuple[float, float, float, float]\n</code></pre> <p>Return the voxel size in t, z, y, x order.</p>"},{"location":"api/ngio/ngio/#ngio.PixelSize.zyx","title":"zyx  <code>property</code>","text":"<pre><code>zyx: tuple[float, float, float]\n</code></pre> <p>Return the voxel size in z, y, x order.</p>"},{"location":"api/ngio/ngio/#ngio.PixelSize.yx","title":"yx  <code>property</code>","text":"<pre><code>yx: tuple[float, float]\n</code></pre> <p>Return the xy plane pixel size in y, x order.</p>"},{"location":"api/ngio/ngio/#ngio.PixelSize.voxel_volume","title":"voxel_volume  <code>property</code>","text":"<pre><code>voxel_volume: float\n</code></pre> <p>Return the volume of a voxel.</p>"},{"location":"api/ngio/ngio/#ngio.PixelSize.xy_plane_area","title":"xy_plane_area  <code>property</code>","text":"<pre><code>xy_plane_area: float\n</code></pre> <p>Return the area of the xy plane.</p>"},{"location":"api/ngio/ngio/#ngio.PixelSize.time_spacing","title":"time_spacing  <code>property</code>","text":"<pre><code>time_spacing: float | None\n</code></pre> <p>Return the time spacing.</p>"},{"location":"api/ngio/ngio/#ngio.PixelSize.as_dict","title":"as_dict","text":"<pre><code>as_dict() -&gt; dict[str, float]\n</code></pre> <p>Return the pixel size as a dictionary.</p> Source code in <code>ngio/ome_zarr_meta/ngio_specs/_pixel_size.py</code> <pre><code>def as_dict(self) -&gt; dict[str, float]:\n    \"\"\"Return the pixel size as a dictionary.\"\"\"\n    return {\"t\": self.t, \"z\": self.z, \"y\": self.y, \"x\": self.x}\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.PixelSize.get","title":"get","text":"<pre><code>get(axis: str, default: float) -&gt; float\n</code></pre><pre><code>get(axis: str, default: None = None) -&gt; float | None\n</code></pre> <pre><code>get(\n    axis: str, default: float | None = None\n) -&gt; float | None\n</code></pre> <p>Get the pixel size for a given axis (in canonical name).</p> Source code in <code>ngio/ome_zarr_meta/ngio_specs/_pixel_size.py</code> <pre><code>def get(self, axis: str, default: float | None = None) -&gt; float | None:\n    \"\"\"Get the pixel size for a given axis (in canonical name).\"\"\"\n    px_size = self.as_dict().get(axis, default)\n    if px_size is None:\n        raise ValueError(\n            f\"Invalid axis name: {axis}, must be one of 'x', 'y', 'z', 't'.\"\n        )\n    return px_size\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.PixelSize.distance","title":"distance","text":"<pre><code>distance(other: PixelSize) -&gt; float\n</code></pre> <p>Return the distance between two pixel sizes.</p> Source code in <code>ngio/ome_zarr_meta/ngio_specs/_pixel_size.py</code> <pre><code>def distance(self, other: \"PixelSize\") -&gt; float:\n    \"\"\"Return the distance between two pixel sizes.\"\"\"\n    return float(np.linalg.norm(np.array(self.tzyx) - np.array(other.tzyx)))\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.create_empty_plate","title":"create_empty_plate","text":"<pre><code>create_empty_plate(\n    store: StoreOrGroup,\n    name: str,\n    images: list[ImageInWellPath] | None = None,\n    version: NgffVersions = \"0.4\",\n    cache: bool = False,\n    overwrite: bool = False,\n    parallel_safe: bool = True,\n) -&gt; OmeZarrPlate\n</code></pre> <p>Initialize and create an empty OME-Zarr plate.</p> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def create_empty_plate(\n    store: StoreOrGroup,\n    name: str,\n    images: list[ImageInWellPath] | None = None,\n    version: NgffVersions = \"0.4\",\n    cache: bool = False,\n    overwrite: bool = False,\n    parallel_safe: bool = True,\n) -&gt; OmeZarrPlate:\n    \"\"\"Initialize and create an empty OME-Zarr plate.\"\"\"\n    plate_meta = NgioPlateMeta.default_init(\n        name=name,\n        version=version,\n    )\n    group_handler = _create_empty_plate_from_meta(\n        store=store,\n        meta=plate_meta,\n        version=version,\n        overwrite=overwrite,\n    )\n\n    if images is not None:\n        plate = OmeZarrPlate(group_handler)\n        for image in images:\n            plate.add_image(\n                row=image.row,\n                column=image.column,\n                image_path=image.path,\n                acquisition_id=image.acquisition_id,\n                acquisition_name=image.acquisition_name,\n            )\n    return open_ome_zarr_plate(\n        store=store,\n        cache=cache,\n        mode=\"r+\",\n        parallel_safe=parallel_safe,\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.create_empty_well","title":"create_empty_well","text":"<pre><code>create_empty_well(\n    store: StoreOrGroup,\n    version: NgffVersions = \"0.4\",\n    cache: bool = False,\n    overwrite: bool = False,\n    parallel_safe: bool = True,\n) -&gt; OmeZarrWell\n</code></pre> <p>Create an empty OME-Zarr well.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group that stores the well.</p> </li> <li> <code>version</code>               (<code>NgffVersion</code>, default:                   <code>'0.4'</code> )           \u2013            <p>The version of the new well.</p> </li> <li> <code>cache</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use a cache for the zarr group metadata.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to overwrite the existing well.</p> </li> <li> <code>parallel_safe</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the group handler is parallel safe.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def create_empty_well(\n    store: StoreOrGroup,\n    version: NgffVersions = \"0.4\",\n    cache: bool = False,\n    overwrite: bool = False,\n    parallel_safe: bool = True,\n) -&gt; OmeZarrWell:\n    \"\"\"Create an empty OME-Zarr well.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group that stores the well.\n        version (NgffVersion): The version of the new well.\n        cache (bool): Whether to use a cache for the zarr group metadata.\n        overwrite (bool): Whether to overwrite the existing well.\n        parallel_safe (bool): Whether the group handler is parallel safe.\n    \"\"\"\n    group_handler = ZarrGroupHandler(\n        store=store, cache=True, mode=\"w\" if overwrite else \"w-\", parallel_safe=False\n    )\n    meta_handler = get_well_meta_handler(group_handler, version=version)\n    meta = NgioWellMeta.default_init()\n    meta_handler.write_meta(meta)\n\n    return open_ome_zarr_well(\n        store=store,\n        cache=cache,\n        mode=\"r+\",\n        parallel_safe=parallel_safe,\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.open_ome_zarr_plate","title":"open_ome_zarr_plate","text":"<pre><code>open_ome_zarr_plate(\n    store: StoreOrGroup,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n    parallel_safe: bool = True,\n) -&gt; OmeZarrPlate\n</code></pre> <p>Open an OME-Zarr plate.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group that stores the plate.</p> </li> <li> <code>cache</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use a cache for the zarr group metadata.</p> </li> <li> <code>mode</code>               (<code>AccessModeLiteral</code>, default:                   <code>'r+'</code> )           \u2013            <p>The access mode for the image. Defaults to \"r+\".</p> </li> <li> <code>parallel_safe</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the group handler is parallel safe.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def open_ome_zarr_plate(\n    store: StoreOrGroup,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n    parallel_safe: bool = True,\n) -&gt; OmeZarrPlate:\n    \"\"\"Open an OME-Zarr plate.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group that stores the plate.\n        cache (bool): Whether to use a cache for the zarr group metadata.\n        mode (AccessModeLiteral): The\n            access mode for the image. Defaults to \"r+\".\n        parallel_safe (bool): Whether the group handler is parallel safe.\n    \"\"\"\n    group_handler = ZarrGroupHandler(\n        store=store, cache=cache, mode=mode, parallel_safe=parallel_safe\n    )\n    return OmeZarrPlate(group_handler)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.open_ome_zarr_well","title":"open_ome_zarr_well","text":"<pre><code>open_ome_zarr_well(\n    store: StoreOrGroup,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n    parallel_safe: bool = True,\n) -&gt; OmeZarrWell\n</code></pre> <p>Open an OME-Zarr well.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group that stores the plate.</p> </li> <li> <code>cache</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use a cache for the zarr group metadata.</p> </li> <li> <code>mode</code>               (<code>AccessModeLiteral</code>, default:                   <code>'r+'</code> )           \u2013            <p>The access mode for the image. Defaults to \"r+\".</p> </li> <li> <code>parallel_safe</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether the group handler is parallel safe.</p> </li> </ul> Source code in <code>ngio/hcs/_plate.py</code> <pre><code>def open_ome_zarr_well(\n    store: StoreOrGroup,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n    parallel_safe: bool = True,\n) -&gt; OmeZarrWell:\n    \"\"\"Open an OME-Zarr well.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group that stores the plate.\n        cache (bool): Whether to use a cache for the zarr group metadata.\n        mode (AccessModeLiteral): The access mode for the image. Defaults to \"r+\".\n        parallel_safe (bool): Whether the group handler is parallel safe.\n    \"\"\"\n    group_handler = ZarrGroupHandler(\n        store=store, cache=cache, mode=mode, parallel_safe=parallel_safe\n    )\n    return OmeZarrWell(group_handler)\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.create_empty_ome_zarr","title":"create_empty_ome_zarr","text":"<pre><code>create_empty_ome_zarr(\n    store: StoreOrGroup,\n    shape: Sequence[int],\n    xy_pixelsize: float,\n    z_spacing: float = 1.0,\n    time_spacing: float = 1.0,\n    levels: int | list[str] = 5,\n    xy_scaling_factor: float = 2,\n    z_scaling_factor: float = 1.0,\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n    axes_names: Sequence[str] | None = None,\n    name: str | None = None,\n    chunks: Sequence[int] | None = None,\n    dtype: str = \"uint16\",\n    channel_labels: list[str] | None = None,\n    channel_wavelengths: list[str] | None = None,\n    channel_colors: Sequence[str] | None = None,\n    channel_active: Sequence[bool] | None = None,\n    overwrite: bool = False,\n    version: NgffVersions = DefaultNgffVersion,\n) -&gt; OmeZarrContainer\n</code></pre> <p>Create an empty OME-Zarr image with the given shape and metadata.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group to create the image in.</p> </li> <li> <code>shape</code>               (<code>Sequence[int]</code>)           \u2013            <p>The shape of the image.</p> </li> <li> <code>xy_pixelsize</code>               (<code>float</code>)           \u2013            <p>The pixel size in x and y dimensions.</p> </li> <li> <code>z_spacing</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The spacing between z slices. Defaults to 1.0.</p> </li> <li> <code>time_spacing</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The spacing between time points. Defaults to 1.0.</p> </li> <li> <code>levels</code>               (<code>int | list[str]</code>, default:                   <code>5</code> )           \u2013            <p>The number of levels in the pyramid or a list of level names. Defaults to 5.</p> </li> <li> <code>xy_scaling_factor</code>               (<code>float</code>, default:                   <code>2</code> )           \u2013            <p>The down-scaling factor in x and y dimensions. Defaults to 2.0.</p> </li> <li> <code>z_scaling_factor</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The down-scaling factor in z dimension. Defaults to 1.0.</p> </li> <li> <code>space_unit</code>               (<code>SpaceUnits</code>, default:                   <code>DefaultSpaceUnit</code> )           \u2013            <p>The unit of space. Defaults to DefaultSpaceUnit.</p> </li> <li> <code>time_unit</code>               (<code>TimeUnits</code>, default:                   <code>DefaultTimeUnit</code> )           \u2013            <p>The unit of time. Defaults to DefaultTimeUnit.</p> </li> <li> <code>axes_names</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The names of the axes. If None the canonical names are used. Defaults to None.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the image. Defaults to None.</p> </li> <li> <code>chunks</code>               (<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The chunk shape. If None the shape is used. Defaults to None.</p> </li> <li> <code>dtype</code>               (<code>str</code>, default:                   <code>'uint16'</code> )           \u2013            <p>The data type of the image. Defaults to \"uint16\".</p> </li> <li> <code>channel_labels</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The labels of the channels. Defaults to None.</p> </li> <li> <code>channel_wavelengths</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The wavelengths of the channels. Defaults to None.</p> </li> <li> <code>channel_colors</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The colors of the channels. Defaults to None.</p> </li> <li> <code>channel_active</code>               (<code>Sequence[bool] | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether the channels are active. Defaults to None.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to overwrite an existing image. Defaults to True.</p> </li> <li> <code>version</code>               (<code>NgffVersion</code>, default:                   <code>DefaultNgffVersion</code> )           \u2013            <p>The version of the OME-Zarr specification. Defaults to DefaultNgffVersion.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def create_empty_ome_zarr(\n    store: StoreOrGroup,\n    shape: Sequence[int],\n    xy_pixelsize: float,\n    z_spacing: float = 1.0,\n    time_spacing: float = 1.0,\n    levels: int | list[str] = 5,\n    xy_scaling_factor: float = 2,\n    z_scaling_factor: float = 1.0,\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n    axes_names: Sequence[str] | None = None,\n    name: str | None = None,\n    chunks: Sequence[int] | None = None,\n    dtype: str = \"uint16\",\n    channel_labels: list[str] | None = None,\n    channel_wavelengths: list[str] | None = None,\n    channel_colors: Sequence[str] | None = None,\n    channel_active: Sequence[bool] | None = None,\n    overwrite: bool = False,\n    version: NgffVersions = DefaultNgffVersion,\n) -&gt; OmeZarrContainer:\n    \"\"\"Create an empty OME-Zarr image with the given shape and metadata.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group to create the image in.\n        shape (Sequence[int]): The shape of the image.\n        xy_pixelsize (float): The pixel size in x and y dimensions.\n        z_spacing (float, optional): The spacing between z slices. Defaults to 1.0.\n        time_spacing (float, optional): The spacing between time points.\n            Defaults to 1.0.\n        levels (int | list[str], optional): The number of levels in the pyramid or a\n            list of level names. Defaults to 5.\n        xy_scaling_factor (float, optional): The down-scaling factor in x and y\n            dimensions. Defaults to 2.0.\n        z_scaling_factor (float, optional): The down-scaling factor in z dimension.\n            Defaults to 1.0.\n        space_unit (SpaceUnits, optional): The unit of space. Defaults to\n            DefaultSpaceUnit.\n        time_unit (TimeUnits, optional): The unit of time. Defaults to\n            DefaultTimeUnit.\n        axes_names (Sequence[str] | None, optional): The names of the axes.\n            If None the canonical names are used. Defaults to None.\n        name (str | None, optional): The name of the image. Defaults to None.\n        chunks (Sequence[int] | None, optional): The chunk shape. If None the shape\n            is used. Defaults to None.\n        dtype (str, optional): The data type of the image. Defaults to \"uint16\".\n        channel_labels (list[str] | None, optional): The labels of the channels.\n            Defaults to None.\n        channel_wavelengths (list[str] | None, optional): The wavelengths of the\n            channels. Defaults to None.\n        channel_colors (Sequence[str] | None, optional): The colors of the channels.\n            Defaults to None.\n        channel_active (Sequence[bool] | None, optional): Whether the channels are\n            active. Defaults to None.\n        overwrite (bool, optional): Whether to overwrite an existing image.\n            Defaults to True.\n        version (NgffVersion, optional): The version of the OME-Zarr specification.\n            Defaults to DefaultNgffVersion.\n    \"\"\"\n    handler = create_empty_image_container(\n        store=store,\n        shape=shape,\n        pixelsize=xy_pixelsize,\n        z_spacing=z_spacing,\n        time_spacing=time_spacing,\n        levels=levels,\n        yx_scaling_factor=xy_scaling_factor,\n        z_scaling_factor=z_scaling_factor,\n        space_unit=space_unit,\n        time_unit=time_unit,\n        axes_names=axes_names,\n        name=name,\n        chunks=chunks,\n        dtype=dtype,\n        overwrite=overwrite,\n        version=version,\n    )\n\n    ome_zarr = OmeZarrContainer(group_handler=handler)\n    ome_zarr.set_channel_meta(\n        labels=channel_labels,\n        wavelength_id=channel_wavelengths,\n        percentiles=None,\n        colors=channel_colors,\n        active=channel_active,\n    )\n    return ome_zarr\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.create_ome_zarr_from_array","title":"create_ome_zarr_from_array","text":"<pre><code>create_ome_zarr_from_array(\n    store: StoreOrGroup,\n    array: ndarray,\n    xy_pixelsize: float,\n    z_spacing: float = 1.0,\n    time_spacing: float = 1.0,\n    levels: int | list[str] = 5,\n    xy_scaling_factor: float = 2.0,\n    z_scaling_factor: float = 1.0,\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n    axes_names: Sequence[str] | None = None,\n    channel_labels: list[str] | None = None,\n    channel_wavelengths: list[str] | None = None,\n    percentiles: tuple[float, float] | None = (0.1, 99.9),\n    channel_colors: Sequence[str] | None = None,\n    channel_active: Sequence[bool] | None = None,\n    name: str | None = None,\n    chunks: Sequence[int] | None = None,\n    overwrite: bool = False,\n    version: NgffVersions = DefaultNgffVersion,\n) -&gt; OmeZarrContainer\n</code></pre> <p>Create an OME-Zarr image from a numpy array.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group to create the image in.</p> </li> <li> <code>array</code>               (<code>ndarray</code>)           \u2013            <p>The image data.</p> </li> <li> <code>xy_pixelsize</code>               (<code>float</code>)           \u2013            <p>The pixel size in x and y dimensions.</p> </li> <li> <code>z_spacing</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The spacing between z slices. Defaults to 1.0.</p> </li> <li> <code>time_spacing</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The spacing between time points. Defaults to 1.0.</p> </li> <li> <code>levels</code>               (<code>int | list[str]</code>, default:                   <code>5</code> )           \u2013            <p>The number of levels in the pyramid or a list of level names. Defaults to 5.</p> </li> <li> <code>xy_scaling_factor</code>               (<code>float</code>, default:                   <code>2.0</code> )           \u2013            <p>The down-scaling factor in x and y dimensions. Defaults to 2.0.</p> </li> <li> <code>z_scaling_factor</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The down-scaling factor in z dimension. Defaults to 1.0.</p> </li> <li> <code>space_unit</code>               (<code>SpaceUnits</code>, default:                   <code>DefaultSpaceUnit</code> )           \u2013            <p>The unit of space. Defaults to DefaultSpaceUnit.</p> </li> <li> <code>time_unit</code>               (<code>TimeUnits</code>, default:                   <code>DefaultTimeUnit</code> )           \u2013            <p>The unit of time. Defaults to DefaultTimeUnit.</p> </li> <li> <code>axes_names</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The names of the axes. If None the canonical names are used. Defaults to None.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the image. Defaults to None.</p> </li> <li> <code>chunks</code>               (<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The chunk shape. If None the shape is used. Defaults to None.</p> </li> <li> <code>channel_labels</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The labels of the channels. Defaults to None.</p> </li> <li> <code>channel_wavelengths</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The wavelengths of the channels. Defaults to None.</p> </li> <li> <code>percentiles</code>               (<code>tuple[float, float] | None</code>, default:                   <code>(0.1, 99.9)</code> )           \u2013            <p>The percentiles of the channels. Defaults to None.</p> </li> <li> <code>channel_colors</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The colors of the channels. Defaults to None.</p> </li> <li> <code>channel_active</code>               (<code>Sequence[bool] | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether the channels are active. Defaults to None.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to overwrite an existing image. Defaults to True.</p> </li> <li> <code>version</code>               (<code>str</code>, default:                   <code>DefaultNgffVersion</code> )           \u2013            <p>The version of the OME-Zarr specification. Defaults to DefaultNgffVersion.</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def create_ome_zarr_from_array(\n    store: StoreOrGroup,\n    array: np.ndarray,\n    xy_pixelsize: float,\n    z_spacing: float = 1.0,\n    time_spacing: float = 1.0,\n    levels: int | list[str] = 5,\n    xy_scaling_factor: float = 2.0,\n    z_scaling_factor: float = 1.0,\n    space_unit: SpaceUnits = DefaultSpaceUnit,\n    time_unit: TimeUnits = DefaultTimeUnit,\n    axes_names: Sequence[str] | None = None,\n    channel_labels: list[str] | None = None,\n    channel_wavelengths: list[str] | None = None,\n    percentiles: tuple[float, float] | None = (0.1, 99.9),\n    channel_colors: Sequence[str] | None = None,\n    channel_active: Sequence[bool] | None = None,\n    name: str | None = None,\n    chunks: Sequence[int] | None = None,\n    overwrite: bool = False,\n    version: NgffVersions = DefaultNgffVersion,\n) -&gt; OmeZarrContainer:\n    \"\"\"Create an OME-Zarr image from a numpy array.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group to create the image in.\n        array (np.ndarray): The image data.\n        xy_pixelsize (float): The pixel size in x and y dimensions.\n        z_spacing (float, optional): The spacing between z slices. Defaults to 1.0.\n        time_spacing (float, optional): The spacing between time points.\n            Defaults to 1.0.\n        levels (int | list[str], optional): The number of levels in the pyramid or a\n            list of level names. Defaults to 5.\n        xy_scaling_factor (float, optional): The down-scaling factor in x and y\n            dimensions. Defaults to 2.0.\n        z_scaling_factor (float, optional): The down-scaling factor in z dimension.\n            Defaults to 1.0.\n        space_unit (SpaceUnits, optional): The unit of space. Defaults to\n            DefaultSpaceUnit.\n        time_unit (TimeUnits, optional): The unit of time. Defaults to\n            DefaultTimeUnit.\n        axes_names (Sequence[str] | None, optional): The names of the axes.\n            If None the canonical names are used. Defaults to None.\n        name (str | None, optional): The name of the image. Defaults to None.\n        chunks (Sequence[int] | None, optional): The chunk shape. If None the shape\n            is used. Defaults to None.\n        channel_labels (list[str] | None, optional): The labels of the channels.\n            Defaults to None.\n        channel_wavelengths (list[str] | None, optional): The wavelengths of the\n            channels. Defaults to None.\n        percentiles (tuple[float, float] | None, optional): The percentiles of the\n            channels. Defaults to None.\n        channel_colors (Sequence[str] | None, optional): The colors of the channels.\n            Defaults to None.\n        channel_active (Sequence[bool] | None, optional): Whether the channels are\n            active. Defaults to None.\n        overwrite (bool, optional): Whether to overwrite an existing image.\n            Defaults to True.\n        version (str, optional): The version of the OME-Zarr specification.\n            Defaults to DefaultNgffVersion.\n    \"\"\"\n    handler = create_empty_image_container(\n        store=store,\n        shape=array.shape,\n        pixelsize=xy_pixelsize,\n        z_spacing=z_spacing,\n        time_spacing=time_spacing,\n        levels=levels,\n        yx_scaling_factor=xy_scaling_factor,\n        z_scaling_factor=z_scaling_factor,\n        space_unit=space_unit,\n        time_unit=time_unit,\n        axes_names=axes_names,\n        name=name,\n        chunks=chunks,\n        dtype=str(array.dtype),\n        overwrite=overwrite,\n        version=version,\n    )\n\n    ome_zarr = OmeZarrContainer(group_handler=handler)\n    image = ome_zarr.get_image()\n    image.set_array(array)\n    image.consolidate()\n    ome_zarr.set_channel_meta(\n        labels=channel_labels,\n        wavelength_id=channel_wavelengths,\n        percentiles=percentiles,\n        colors=channel_colors,\n        active=channel_active,\n    )\n    return ome_zarr\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.create_synthetic_ome_zarr","title":"create_synthetic_ome_zarr","text":"<pre><code>create_synthetic_ome_zarr(\n    store: StoreOrGroup,\n    shape: Sequence[int],\n    reference_sample: AVAILABLE_SAMPLES\n    | SampleInfo = \"Cardiomyocyte\",\n    levels: int | list[str] = 5,\n    xy_scaling_factor: float = 2,\n    z_scaling_factor: float = 1.0,\n    axes_names: Sequence[str] | None = None,\n    chunks: Sequence[int] | None = None,\n    channel_labels: list[str] | None = None,\n    channel_wavelengths: list[str] | None = None,\n    channel_colors: Sequence[str] | None = None,\n    channel_active: Sequence[bool] | None = None,\n    table_backend: TableBackend = DefaultTableBackend,\n    overwrite: bool = False,\n    version: NgffVersions = DefaultNgffVersion,\n) -&gt; OmeZarrContainer\n</code></pre> <p>Create an empty OME-Zarr image with the given shape and metadata.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group to create the image in.</p> </li> <li> <code>shape</code>               (<code>Sequence[int]</code>)           \u2013            <p>The shape of the image.</p> </li> <li> <code>reference_sample</code>               (<code>AVAILABLE_SAMPLES | SampleInfo</code>, default:                   <code>'Cardiomyocyte'</code> )           \u2013            <p>The reference sample to use.</p> </li> <li> <code>levels</code>               (<code>int | list[str]</code>, default:                   <code>5</code> )           \u2013            <p>The number of levels in the pyramid or a list of level names. Defaults to 5.</p> </li> <li> <code>xy_scaling_factor</code>               (<code>float</code>, default:                   <code>2</code> )           \u2013            <p>The down-scaling factor in x and y dimensions. Defaults to 2.0.</p> </li> <li> <code>z_scaling_factor</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The down-scaling factor in z dimension. Defaults to 1.0.</p> </li> <li> <code>axes_names</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The names of the axes. If None the canonical names are used. Defaults to None.</p> </li> <li> <code>chunks</code>               (<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The chunk shape. If None the shape is used. Defaults to None.</p> </li> <li> <code>channel_labels</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The labels of the channels. Defaults to None.</p> </li> <li> <code>channel_wavelengths</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The wavelengths of the channels. Defaults to None.</p> </li> <li> <code>channel_colors</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The colors of the channels. Defaults to None.</p> </li> <li> <code>channel_active</code>               (<code>Sequence[bool] | None</code>, default:                   <code>None</code> )           \u2013            <p>Whether the channels are active. Defaults to None.</p> </li> <li> <code>table_backend</code>               (<code>TableBackend</code>, default:                   <code>DefaultTableBackend</code> )           \u2013            <p>Table backend to be used to store tables</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to overwrite an existing image. Defaults to True.</p> </li> <li> <code>version</code>               (<code>NgffVersion</code>, default:                   <code>DefaultNgffVersion</code> )           \u2013            <p>The version of the OME-Zarr specification. Defaults to DefaultNgffVersion.</p> </li> </ul> Source code in <code>ngio/images/_create_synt_container.py</code> <pre><code>def create_synthetic_ome_zarr(\n    store: StoreOrGroup,\n    shape: Sequence[int],\n    reference_sample: AVAILABLE_SAMPLES | SampleInfo = \"Cardiomyocyte\",\n    levels: int | list[str] = 5,\n    xy_scaling_factor: float = 2,\n    z_scaling_factor: float = 1.0,\n    axes_names: Sequence[str] | None = None,\n    chunks: Sequence[int] | None = None,\n    channel_labels: list[str] | None = None,\n    channel_wavelengths: list[str] | None = None,\n    channel_colors: Sequence[str] | None = None,\n    channel_active: Sequence[bool] | None = None,\n    table_backend: TableBackend = DefaultTableBackend,\n    overwrite: bool = False,\n    version: NgffVersions = DefaultNgffVersion,\n) -&gt; OmeZarrContainer:\n    \"\"\"Create an empty OME-Zarr image with the given shape and metadata.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group to create the image in.\n        shape (Sequence[int]): The shape of the image.\n        reference_sample (AVAILABLE_SAMPLES | SampleInfo): The reference sample to use.\n        levels (int | list[str], optional): The number of levels in the pyramid or a\n            list of level names. Defaults to 5.\n        xy_scaling_factor (float, optional): The down-scaling factor in x and y\n            dimensions. Defaults to 2.0.\n        z_scaling_factor (float, optional): The down-scaling factor in z dimension.\n            Defaults to 1.0.\n        axes_names (Sequence[str] | None, optional): The names of the axes.\n            If None the canonical names are used. Defaults to None.\n        chunks (Sequence[int] | None, optional): The chunk shape. If None the shape\n            is used. Defaults to None.\n        channel_labels (list[str] | None, optional): The labels of the channels.\n            Defaults to None.\n        channel_wavelengths (list[str] | None, optional): The wavelengths of the\n            channels. Defaults to None.\n        channel_colors (Sequence[str] | None, optional): The colors of the channels.\n            Defaults to None.\n        channel_active (Sequence[bool] | None, optional): Whether the channels are\n            active. Defaults to None.\n        table_backend (TableBackend): Table backend to be used to store tables\n        overwrite (bool, optional): Whether to overwrite an existing image.\n            Defaults to True.\n        version (NgffVersion, optional): The version of the OME-Zarr specification.\n            Defaults to DefaultNgffVersion.\n    \"\"\"\n    if isinstance(reference_sample, str):\n        sample_info = get_sample_info(reference_sample)\n    else:\n        sample_info = reference_sample\n\n    raw = np.asarray(PIL.Image.open(sample_info.img_path))\n    raw = fit_to_shape(arr=raw, out_shape=tuple(shape))\n    raw = raw / np.max(raw) * (2**16 - 1)\n    raw = raw.astype(np.uint16)\n    ome_zarr = create_ome_zarr_from_array(\n        store=store,\n        array=raw,\n        xy_pixelsize=sample_info.xy_pixelsize,\n        z_spacing=sample_info.z_spacing,\n        time_spacing=sample_info.time_spacing,\n        levels=levels,\n        xy_scaling_factor=xy_scaling_factor,\n        z_scaling_factor=z_scaling_factor,\n        space_unit=sample_info.space_unit,\n        time_unit=sample_info.time_unit,\n        axes_names=axes_names,\n        channel_labels=channel_labels,\n        channel_wavelengths=channel_wavelengths,\n        channel_colors=channel_colors,\n        channel_active=channel_active,\n        name=sample_info.name,\n        chunks=chunks,\n        overwrite=overwrite,\n        version=version,\n    )\n\n    image = ome_zarr.get_image()\n    well_table = image.build_image_roi_table()\n    ome_zarr.add_table(\"well_ROI_table\", table=well_table, backend=table_backend)\n\n    for label_info in sample_info.labels:\n        ome_zarr.derive_label(name=label_info.name)\n        label = ome_zarr.get_label(name=label_info.name)\n\n        ref_label = np.asarray(PIL.Image.open(label_info.label_path))\n        ref_label = ref_label.astype(label_info.dtype)\n\n        ref_label = fit_to_shape(\n            arr=ref_label,\n            out_shape=label.shape,\n            ensure_unique_info=label_info.ensure_unique_labels,\n        )\n        ref_label = ref_label.astype(np.uint32)\n        label.set_array(ref_label)\n        label.consolidate()\n\n        if label_info.create_masking_table:\n            masking_table = label.build_masking_roi_table()\n            ome_zarr.add_table(\n                name=f\"{label_info.name}_masking_table\",\n                table=masking_table,\n                backend=table_backend,\n            )\n\n    return ome_zarr\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.open_image","title":"open_image","text":"<pre><code>open_image(\n    store: StoreOrGroup,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = True,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n) -&gt; Image\n</code></pre> <p>Open a single level image from an OME-Zarr image.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group to create the image in.</p> </li> <li> <code>path</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the image in the ome_zarr file.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the image.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Only used if the pixel size is provided. If True, the     pixel size must match the image pixel size exactly. If False, the     closest pixel size level will be returned.</p> </li> <li> <code>cache</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use a cache for the zarr group metadata.</p> </li> <li> <code>mode</code>               (<code>AccessModeLiteral</code>, default:                   <code>'r+'</code> )           \u2013            <p>The access mode for the image. Defaults to \"r+\".</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def open_image(\n    store: StoreOrGroup,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = True,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n) -&gt; Image:\n    \"\"\"Open a single level image from an OME-Zarr image.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group to create the image in.\n        path (str | None): The path to the image in the ome_zarr file.\n        pixel_size (PixelSize | None): The pixel size of the image.\n        strict (bool): Only used if the pixel size is provided. If True, the\n                pixel size must match the image pixel size exactly. If False, the\n                closest pixel size level will be returned.\n        cache (bool): Whether to use a cache for the zarr group metadata.\n        mode (AccessModeLiteral): The\n            access mode for the image. Defaults to \"r+\".\n    \"\"\"\n    group_handler = ZarrGroupHandler(store, cache, mode)\n    images_container = ImagesContainer(group_handler)\n    return images_container.get(\n        path=path,\n        pixel_size=pixel_size,\n        strict=strict,\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.open_label","title":"open_label","text":"<pre><code>open_label(\n    store: StoreOrGroup,\n    name: str | None = None,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = True,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n) -&gt; Label\n</code></pre> <p>Open a single level label from an OME-Zarr Label group.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group to create the image in.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the label. If None, we will try to open the store as a multiscale label.</p> </li> <li> <code>path</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the image in the ome_zarr file.</p> </li> <li> <code>pixel_size</code>               (<code>PixelSize | None</code>, default:                   <code>None</code> )           \u2013            <p>The pixel size of the image.</p> </li> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Only used if the pixel size is provided. If True, the pixel size must match the image pixel size exactly. If False, the closest pixel size level will be returned.</p> </li> <li> <code>cache</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use a cache for the zarr group metadata.</p> </li> <li> <code>mode</code>               (<code>AccessModeLiteral</code>, default:                   <code>'r+'</code> )           \u2013            <p>The access mode for the image. Defaults to \"r+\".</p> </li> </ul> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def open_label(\n    store: StoreOrGroup,\n    name: str | None = None,\n    path: str | None = None,\n    pixel_size: PixelSize | None = None,\n    strict: bool = True,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n) -&gt; Label:\n    \"\"\"Open a single level label from an OME-Zarr Label group.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group to create the image in.\n        name (str | None): The name of the label. If None,\n            we will try to open the store as a multiscale label.\n        path (str | None): The path to the image in the ome_zarr file.\n        pixel_size (PixelSize | None): The pixel size of the image.\n        strict (bool): Only used if the pixel size is provided. If True, the\n            pixel size must match the image pixel size exactly. If False, the\n            closest pixel size level will be returned.\n        cache (bool): Whether to use a cache for the zarr group metadata.\n        mode (AccessModeLiteral): The access mode for the image. Defaults to \"r+\".\n\n    \"\"\"\n    group_handler = ZarrGroupHandler(store, cache, mode)\n    if name is None:\n        label_meta_handler = find_label_meta_handler(group_handler)\n        path = label_meta_handler.meta.get_dataset(\n            path=path, pixel_size=pixel_size, strict=strict\n        ).path\n        return Label(group_handler, path, label_meta_handler)\n\n    labels_container = LabelsContainer(group_handler)\n    return labels_container.get(\n        name=name,\n        path=path,\n        pixel_size=pixel_size,\n        strict=strict,\n    )\n</code></pre>"},{"location":"api/ngio/ngio/#ngio.open_ome_zarr_container","title":"open_ome_zarr_container","text":"<pre><code>open_ome_zarr_container(\n    store: StoreOrGroup,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n    validate_arrays: bool = True,\n) -&gt; OmeZarrContainer\n</code></pre> <p>Open an OME-Zarr image.</p> Source code in <code>ngio/images/_ome_zarr_container.py</code> <pre><code>def open_ome_zarr_container(\n    store: StoreOrGroup,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"r+\",\n    validate_arrays: bool = True,\n) -&gt; OmeZarrContainer:\n    \"\"\"Open an OME-Zarr image.\"\"\"\n    handler = ZarrGroupHandler(store=store, cache=cache, mode=mode)\n    return OmeZarrContainer(\n        group_handler=handler,\n        validate_paths=validate_arrays,\n    )\n</code></pre>"},{"location":"api/ngio/tables/","title":"ngio.tables API documentation","text":""},{"location":"api/ngio/tables/#ngio.tables","title":"ngio.tables","text":"<p>Ngio Tables implementations.</p>"},{"location":"api/ngio/tables/#ngio.tables.ConditionTable","title":"ConditionTable  <code>module-attribute</code>","text":"<pre><code>ConditionTable = ConditionTableV1\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.FeatureTable","title":"FeatureTable  <code>module-attribute</code>","text":"<pre><code>FeatureTable = FeatureTableV1\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.GenericRoiTable","title":"GenericRoiTable  <code>module-attribute</code>","text":"<pre><code>GenericRoiTable = GenericRoiTableV1\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.MaskingRoiTable","title":"MaskingRoiTable  <code>module-attribute</code>","text":"<pre><code>MaskingRoiTable = MaskingRoiTableV1\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.RoiTable","title":"RoiTable  <code>module-attribute</code>","text":"<pre><code>RoiTable = RoiTableV1\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.TableType","title":"TableType  <code>module-attribute</code>","text":"<pre><code>TableType = TypeVar('TableType', bound=Table)\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.TypedTable","title":"TypedTable  <code>module-attribute</code>","text":"<pre><code>TypedTable = Literal[\n    \"generic_table\",\n    \"roi_table\",\n    \"masking_roi_table\",\n    \"feature_table\",\n    \"condition_table\",\n]\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.DefaultTableBackend","title":"DefaultTableBackend  <code>module-attribute</code>","text":"<pre><code>DefaultTableBackend = 'anndata_v1'\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.TableBackend","title":"TableBackend  <code>module-attribute</code>","text":"<pre><code>TableBackend = (\n    Literal[\"anndata\", \"json\", \"csv\", \"parquet\"]\n    | str\n    | TableBackendProtocol\n)\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.Table","title":"Table","text":"<p>               Bases: <code>Protocol</code></p> <p>Placeholder class for a table.</p>"},{"location":"api/ngio/tables/#ngio.tables.Table.backend_name","title":"backend_name  <code>property</code>","text":"<pre><code>backend_name: str | None\n</code></pre> <p>The name of the backend.</p>"},{"location":"api/ngio/tables/#ngio.tables.Table.meta","title":"meta  <code>property</code>","text":"<pre><code>meta: BackendMeta\n</code></pre> <p>Return the metadata for the table.</p>"},{"location":"api/ngio/tables/#ngio.tables.Table.dataframe","title":"dataframe  <code>property</code>","text":"<pre><code>dataframe: DataFrame\n</code></pre> <p>Return the table as a DataFrame.</p>"},{"location":"api/ngio/tables/#ngio.tables.Table.lazy_frame","title":"lazy_frame  <code>property</code>","text":"<pre><code>lazy_frame: LazyFrame\n</code></pre> <p>Return the table as a LazyFrame.</p>"},{"location":"api/ngio/tables/#ngio.tables.Table.anndata","title":"anndata  <code>property</code>","text":"<pre><code>anndata: AnnData\n</code></pre> <p>Return the table as an AnnData object.</p>"},{"location":"api/ngio/tables/#ngio.tables.Table.table_data","title":"table_data  <code>property</code>","text":"<pre><code>table_data: TabularData\n</code></pre> <p>Return the table.</p>"},{"location":"api/ngio/tables/#ngio.tables.Table.table_type","title":"table_type  <code>staticmethod</code>","text":"<pre><code>table_type() -&gt; str\n</code></pre> <p>Return the type of the table.</p> Source code in <code>ngio/tables/_tables_container.py</code> <pre><code>@staticmethod\ndef table_type() -&gt; str:\n    \"\"\"Return the type of the table.\"\"\"\n    ...\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.Table.version","title":"version  <code>staticmethod</code>","text":"<pre><code>version() -&gt; str\n</code></pre> <p>Return the version of the table.</p> Source code in <code>ngio/tables/_tables_container.py</code> <pre><code>@staticmethod\ndef version() -&gt; str:\n    \"\"\"Return the version of the table.\"\"\"\n    ...\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.Table.set_table_data","title":"set_table_data","text":"<pre><code>set_table_data(\n    table_data: TabularData | None = None,\n    refresh: bool = False,\n) -&gt; None\n</code></pre> <p>Make sure that the table data is set (exist in memory).</p> <p>If an object is passed, it will be used as the table. If None is passed, the table will be loaded from the backend.</p> <p>If refresh is True, the table will be reloaded from the backend.     If table is not None, this will be ignored.</p> Source code in <code>ngio/tables/_tables_container.py</code> <pre><code>def set_table_data(\n    self,\n    table_data: TabularData | None = None,\n    refresh: bool = False,\n) -&gt; None:\n    \"\"\"Make sure that the table data is set (exist in memory).\n\n    If an object is passed, it will be used as the table.\n    If None is passed, the table will be loaded from the backend.\n\n    If refresh is True, the table will be reloaded from the backend.\n        If table is not None, this will be ignored.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.Table.set_backend","title":"set_backend","text":"<pre><code>set_backend(\n    handler: ZarrGroupHandler | None = None,\n    backend: TableBackend = DefaultTableBackend,\n) -&gt; None\n</code></pre> <p>Set the backend store and path for the table.</p> <p>Either a handler or a backend must be provided.</p> <p>If the handler in none it will be inferred from the backend. If the backend is none, it will be inferred from the group attrs</p> Source code in <code>ngio/tables/_tables_container.py</code> <pre><code>def set_backend(\n    self,\n    handler: ZarrGroupHandler | None = None,\n    backend: TableBackend = DefaultTableBackend,\n) -&gt; None:\n    \"\"\"Set the backend store and path for the table.\n\n    Either a handler or a backend must be provided.\n\n    If the handler in none it will be inferred from the backend.\n    If the backend is none, it will be inferred from the group attrs\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.Table.from_handler","title":"from_handler  <code>classmethod</code>","text":"<pre><code>from_handler(\n    handler: ZarrGroupHandler,\n    backend: TableBackend | None = None,\n) -&gt; Table\n</code></pre> <p>Create a new table from a Zarr group handler.</p> Source code in <code>ngio/tables/_tables_container.py</code> <pre><code>@classmethod\ndef from_handler(\n    cls,\n    handler: ZarrGroupHandler,\n    backend: TableBackend | None = None,\n) -&gt; \"Table\":\n    \"\"\"Create a new table from a Zarr group handler.\"\"\"\n    ...\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.Table.from_table_data","title":"from_table_data  <code>classmethod</code>","text":"<pre><code>from_table_data(\n    table_data: TabularData, meta: BackendMeta\n) -&gt; Table\n</code></pre> <p>Create a new table from a DataFrame.</p> Source code in <code>ngio/tables/_tables_container.py</code> <pre><code>@classmethod\ndef from_table_data(cls, table_data: TabularData, meta: BackendMeta) -&gt; \"Table\":\n    \"\"\"Create a new table from a DataFrame.\"\"\"\n    ...\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.Table.consolidate","title":"consolidate","text":"<pre><code>consolidate() -&gt; None\n</code></pre> <p>Consolidate the table on disk.</p> Source code in <code>ngio/tables/_tables_container.py</code> <pre><code>def consolidate(self) -&gt; None:\n    \"\"\"Consolidate the table on disk.\"\"\"\n    ...\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.TablesContainer","title":"TablesContainer","text":"<pre><code>TablesContainer(group_handler: ZarrGroupHandler)\n</code></pre> <p>A class to handle the /labels group in an OME-NGFF file.</p> <p>Initialize the LabelGroupHandler.</p> Source code in <code>ngio/tables/_tables_container.py</code> <pre><code>def __init__(self, group_handler: ZarrGroupHandler) -&gt; None:\n    \"\"\"Initialize the LabelGroupHandler.\"\"\"\n    self._group_handler = group_handler\n\n    # Validate the group\n    # Either contains a tables attribute or is empty\n    attrs = self._group_handler.load_attrs()\n    if len(attrs) == 0:\n        # It's an empty group\n        pass\n    elif \"tables\" in attrs and isinstance(attrs[\"tables\"], list):\n        # It's a valid group\n        pass\n    else:\n        raise NgioValidationError(\n            f\"Invalid /tables group. \"\n            f\"Expected a single tables attribute with a list of table names. \"\n            f\"Found: {attrs}\"\n        )\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.TablesContainer.list","title":"list","text":"<pre><code>list(\n    filter_types: TypedTable | str | None = None,\n) -&gt; list[str]\n</code></pre> <p>List all labels in the group.</p> Source code in <code>ngio/tables/_tables_container.py</code> <pre><code>def list(self, filter_types: TypedTable | str | None = None) -&gt; list[str]:\n    \"\"\"List all labels in the group.\"\"\"\n    tables = self._get_tables_list()\n    if filter_types is None:\n        return tables\n\n    filtered_tables = []\n    for table_name in tables:\n        tb_handler = self._get_table_group_handler(table_name)\n        table_type = _get_meta(tb_handler).type\n        if table_type == filter_types:\n            filtered_tables.append(table_name)\n    return filtered_tables\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.TablesContainer.get","title":"get","text":"<pre><code>get(\n    name: str,\n    backend: TableBackend | None = None,\n    strict: bool = True,\n) -&gt; Table\n</code></pre> <p>Get a label from the group.</p> Source code in <code>ngio/tables/_tables_container.py</code> <pre><code>def get(\n    self,\n    name: str,\n    backend: TableBackend | None = None,\n    strict: bool = True,\n) -&gt; Table:\n    \"\"\"Get a label from the group.\"\"\"\n    if name not in self.list():\n        raise NgioValueError(f\"Table '{name}' not found in the group.\")\n\n    table_handler = self._get_table_group_handler(name)\n\n    meta = _get_meta(table_handler)\n    return ImplementedTables().get_table(\n        meta=meta,\n        handler=table_handler,\n        backend=backend,\n        strict=strict,\n    )\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.TablesContainer.get_as","title":"get_as","text":"<pre><code>get_as(\n    name: str,\n    table_cls: type[TableType],\n    backend: TableBackend | None = None,\n) -&gt; TableType\n</code></pre> <p>Get a table from the group as a specific type.</p> Source code in <code>ngio/tables/_tables_container.py</code> <pre><code>def get_as(\n    self,\n    name: str,\n    table_cls: type[TableType],\n    backend: TableBackend | None = None,\n) -&gt; TableType:\n    \"\"\"Get a table from the group as a specific type.\"\"\"\n    if name not in self.list():\n        raise NgioValueError(f\"Table '{name}' not found in the group.\")\n\n    table_handler = self._get_table_group_handler(name)\n    return table_cls.from_handler(\n        handler=table_handler,\n        backend=backend,\n    )  # type: ignore[return-value]\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.TablesContainer.add","title":"add","text":"<pre><code>add(\n    name: str,\n    table: Table,\n    backend: TableBackend = DefaultTableBackend,\n    overwrite: bool = False,\n) -&gt; None\n</code></pre> <p>Add a table to the group.</p> Source code in <code>ngio/tables/_tables_container.py</code> <pre><code>def add(\n    self,\n    name: str,\n    table: Table,\n    backend: TableBackend = DefaultTableBackend,\n    overwrite: bool = False,\n) -&gt; None:\n    \"\"\"Add a table to the group.\"\"\"\n    existing_tables = self._get_tables_list()\n    if name in existing_tables and not overwrite:\n        raise NgioValueError(\n            f\"Table '{name}' already exists in the group. \"\n            \"Use overwrite=True to replace it.\"\n        )\n\n    table_handler = self._group_handler.derive_handler(\n        path=name, overwrite=overwrite\n    )\n\n    if backend is None:\n        backend = table.backend_name\n\n    table.set_table_data()\n    table.set_backend(\n        handler=table_handler,\n        backend=backend,\n    )\n    table.consolidate()\n    if name not in existing_tables:\n        existing_tables.append(name)\n        self._group_handler.write_attrs({\"tables\": existing_tables})\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.ImplementedTableBackends","title":"ImplementedTableBackends","text":"<p>A class to manage the available table backends.</p>"},{"location":"api/ngio/tables/#ngio.tables.ImplementedTableBackends.available_backends","title":"available_backends  <code>property</code>","text":"<pre><code>available_backends: list[str]\n</code></pre> <p>Return the available table backends.</p>"},{"location":"api/ngio/tables/#ngio.tables.ImplementedTableBackends.get_backend","title":"get_backend","text":"<pre><code>get_backend(\n    *,\n    group_handler: ZarrGroupHandler,\n    backend_name: str = \"anndata\",\n    index_key: str | None = None,\n    index_type: Literal[\"int\", \"str\"] | None = None,\n) -&gt; TableBackendProtocol\n</code></pre> <p>Try to get a handler for the given store based on the metadata version.</p> Source code in <code>ngio/tables/backends/_table_backends.py</code> <pre><code>def get_backend(\n    self,\n    *,\n    group_handler: ZarrGroupHandler,\n    backend_name: str = \"anndata\",\n    index_key: str | None = None,\n    index_type: Literal[\"int\", \"str\"] | None = None,\n) -&gt; TableBackendProtocol:\n    \"\"\"Try to get a handler for the given store based on the metadata version.\"\"\"\n    if backend_name not in self._implemented_backends:\n        raise NgioValueError(f\"Table backend {backend_name} not implemented.\")\n    backend = self._implemented_backends[backend_name]()\n    backend.set_group_handler(\n        group_handler=group_handler, index_key=index_key, index_type=index_type\n    )\n    return backend\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.ImplementedTableBackends.add_backend","title":"add_backend","text":"<pre><code>add_backend(\n    table_backend: type[TableBackendProtocol],\n    overwrite: bool = False,\n    aliases: list[str] | None = None,\n) -&gt; None\n</code></pre> <p>Register a new handler.</p> Source code in <code>ngio/tables/backends/_table_backends.py</code> <pre><code>def add_backend(\n    self,\n    table_backend: type[TableBackendProtocol],\n    overwrite: bool = False,\n    aliases: list[str] | None = None,\n) -&gt; None:\n    \"\"\"Register a new handler.\"\"\"\n    self._add_backend(\n        table_backend=table_backend,\n        name=table_backend.backend_name(),\n        overwrite=overwrite,\n    )\n    if aliases is not None:\n        for alias in aliases:\n            self._add_backend(\n                table_backend=table_backend, name=alias, overwrite=overwrite\n            )\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.TableBackendProtocol","title":"TableBackendProtocol","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/ngio/tables/#ngio.tables.TableBackendProtocol.group_handler","title":"group_handler  <code>property</code>","text":"<pre><code>group_handler: ZarrGroupHandler\n</code></pre> <p>Return the group handler.</p>"},{"location":"api/ngio/tables/#ngio.tables.TableBackendProtocol.set_group_handler","title":"set_group_handler","text":"<pre><code>set_group_handler(\n    group_handler: ZarrGroupHandler,\n    index_key: str | None = None,\n    index_type: Literal[\"int\", \"str\"] | None = None,\n) -&gt; None\n</code></pre> <p>Attach a group handler to the backend.</p> <p>Index keys and index types are used to ensure that the serialization and deserialization of the table is consistent across different backends.</p> <p>Making sure that this is consistent is a duty of the backend implementations.</p> Source code in <code>ngio/tables/backends/_table_backends.py</code> <pre><code>def set_group_handler(\n    self,\n    group_handler: ZarrGroupHandler,\n    index_key: str | None = None,\n    index_type: Literal[\"int\", \"str\"] | None = None,\n) -&gt; None:\n    \"\"\"Attach a group handler to the backend.\n\n    Index keys and index types are used to ensure that the\n    serialization and deserialization of the table\n    is consistent across different backends.\n\n    Making sure that this is consistent is\n    a duty of the backend implementations.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.TableBackendProtocol.backend_name","title":"backend_name  <code>staticmethod</code>","text":"<pre><code>backend_name() -&gt; str\n</code></pre> <p>Return the name of the backend.</p> As a convention we set name as <p>{backend_name}_v{version}</p> <p>Where the version is a integer.</p> Source code in <code>ngio/tables/backends/_table_backends.py</code> <pre><code>@staticmethod\ndef backend_name() -&gt; str:\n    \"\"\"Return the name of the backend.\n\n    As a convention we set name as:\n        {backend_name}_v{version}\n\n    Where the version is a integer.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.TableBackendProtocol.implements_anndata","title":"implements_anndata  <code>staticmethod</code>","text":"<pre><code>implements_anndata() -&gt; bool\n</code></pre> <p>Check if the backend implements the anndata protocol.</p> <p>If this is True, the backend should implement the <code>write_from_anndata</code> method.</p> <p>AnnData objects are more complex than DataFrames, so if this is true the backend should implement the full serialization of the AnnData object.</p> <p>If this is False, these methods should raise a <code>NotImplementedError</code>.</p> Source code in <code>ngio/tables/backends/_table_backends.py</code> <pre><code>@staticmethod\ndef implements_anndata() -&gt; bool:\n    \"\"\"Check if the backend implements the anndata protocol.\n\n    If this is True, the backend should implement the\n    `write_from_anndata` method.\n\n    AnnData objects are more complex than DataFrames,\n    so if this is true the backend should implement the\n    full serialization of the AnnData object.\n\n    If this is False, these methods should raise a\n    `NotImplementedError`.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.TableBackendProtocol.implements_pandas","title":"implements_pandas  <code>staticmethod</code>","text":"<pre><code>implements_pandas() -&gt; bool\n</code></pre> <p>Check if the backend implements the pandas protocol.</p> <p>If this is True, the backend should implement the <code>write_from_dataframe</code> methods.</p> <p>If this is False, these methods should raise a <code>NotImplementedError</code>.</p> Source code in <code>ngio/tables/backends/_table_backends.py</code> <pre><code>@staticmethod\ndef implements_pandas() -&gt; bool:\n    \"\"\"Check if the backend implements the pandas protocol.\n\n    If this is True, the backend should implement the\n    `write_from_dataframe` methods.\n\n    If this is False, these methods should raise a\n    `NotImplementedError`.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.TableBackendProtocol.implements_polars","title":"implements_polars  <code>staticmethod</code>","text":"<pre><code>implements_polars() -&gt; bool\n</code></pre> <p>Check if the backend implements the polars protocol.</p> <p>If this is True, the backend should implement the <code>write_from_polars</code> methods.</p> <p>If this is False, these methods should raise a <code>NotImplementedError</code>.</p> Source code in <code>ngio/tables/backends/_table_backends.py</code> <pre><code>@staticmethod\ndef implements_polars() -&gt; bool:\n    \"\"\"Check if the backend implements the polars protocol.\n\n    If this is True, the backend should implement the\n    `write_from_polars` methods.\n\n    If this is False, these methods should raise a\n    `NotImplementedError`.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.TableBackendProtocol.load_as_anndata","title":"load_as_anndata","text":"<pre><code>load_as_anndata() -&gt; AnnData\n</code></pre> <p>Load the table as an AnnData object.</p> Source code in <code>ngio/tables/backends/_table_backends.py</code> <pre><code>def load_as_anndata(self) -&gt; AnnData:\n    \"\"\"Load the table as an AnnData object.\"\"\"\n    ...\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.TableBackendProtocol.load_as_pandas_df","title":"load_as_pandas_df","text":"<pre><code>load_as_pandas_df() -&gt; DataFrame\n</code></pre> <p>Load the table as a pandas DataFrame.</p> Source code in <code>ngio/tables/backends/_table_backends.py</code> <pre><code>def load_as_pandas_df(self) -&gt; DataFrame:\n    \"\"\"Load the table as a pandas DataFrame.\"\"\"\n    ...\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.TableBackendProtocol.load_as_polars_lf","title":"load_as_polars_lf","text":"<pre><code>load_as_polars_lf() -&gt; LazyFrame\n</code></pre> <p>Load the table as a polars LazyFrame.</p> Source code in <code>ngio/tables/backends/_table_backends.py</code> <pre><code>def load_as_polars_lf(self) -&gt; LazyFrame:\n    \"\"\"Load the table as a polars LazyFrame.\"\"\"\n    ...\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.TableBackendProtocol.load","title":"load","text":"<pre><code>load() -&gt; TabularData\n</code></pre> <p>The default load method.</p> <p>This method will be default way to load the table from the backend. This method should wrap one of the <code>load_as_anndata</code>, <code>load_as_dataframe</code> or <code>load_as_polars</code> methods depending on the backend implementation.</p> Source code in <code>ngio/tables/backends/_table_backends.py</code> <pre><code>def load(self) -&gt; TabularData:\n    \"\"\"The default load method.\n\n    This method will be default way to load the table\n    from the backend. This method should wrap one of the\n    `load_as_anndata`, `load_as_dataframe` or `load_as_polars`\n    methods depending on the backend implementation.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.TableBackendProtocol.write_from_pandas","title":"write_from_pandas","text":"<pre><code>write_from_pandas(table: DataFrame) -&gt; None\n</code></pre> <p>Serialize the table from a pandas DataFrame.</p> Source code in <code>ngio/tables/backends/_table_backends.py</code> <pre><code>def write_from_pandas(self, table: DataFrame) -&gt; None:\n    \"\"\"Serialize the table from a pandas DataFrame.\"\"\"\n    ...\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.TableBackendProtocol.write_from_anndata","title":"write_from_anndata","text":"<pre><code>write_from_anndata(table: AnnData) -&gt; None\n</code></pre> <p>Serialize the table from an AnnData object.</p> Source code in <code>ngio/tables/backends/_table_backends.py</code> <pre><code>def write_from_anndata(self, table: AnnData) -&gt; None:\n    \"\"\"Serialize the table from an AnnData object.\"\"\"\n    ...\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.TableBackendProtocol.write_from_polars","title":"write_from_polars","text":"<pre><code>write_from_polars(table: LazyFrame | DataFrame) -&gt; None\n</code></pre> <p>Serialize the table from a polars DataFrame or LazyFrame.</p> Source code in <code>ngio/tables/backends/_table_backends.py</code> <pre><code>def write_from_polars(self, table: LazyFrame | PolarsDataFrame) -&gt; None:\n    \"\"\"Serialize the table from a polars DataFrame or LazyFrame.\"\"\"\n    ...\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.TableBackendProtocol.write","title":"write","text":"<pre><code>write(\n    table_data: DataFrame | AnnData | DataFrame | LazyFrame,\n    metadata: dict[str, str] | None = None,\n) -&gt; None\n</code></pre> <p>This is a generic write method.</p> <p>Will call the appropriate write method depending on the type of the table.</p> <p>Moreover it will also write the metadata if provided, and the backend methadata</p> <p>the backend should write in the zarr group attributes     - backend: the backend name (self.backend_name())     - index_key: the index key     - index_type: the index type</p> Source code in <code>ngio/tables/backends/_table_backends.py</code> <pre><code>def write(\n    self,\n    table_data: DataFrame | AnnData | PolarsDataFrame | LazyFrame,\n    metadata: dict[str, str] | None = None,\n) -&gt; None:\n    \"\"\"This is a generic write method.\n\n    Will call the appropriate write method\n    depending on the type of the table.\n\n    Moreover it will also write the metadata\n    if provided, and the backend methadata\n\n    the backend should write in the zarr group attributes\n        - backend: the backend name (self.backend_name())\n        - index_key: the index key\n        - index_type: the index type\n\n    \"\"\"\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.GenericTable","title":"GenericTable","text":"<pre><code>GenericTable(\n    table_data: TabularData | None = None,\n    *,\n    meta: BackendMeta | None = None,\n)\n</code></pre> <p>               Bases: <code>AbstractBaseTable</code></p> <p>Class to a non-specific table.</p> <p>This can be used to load any table that does not have a specific definition.</p> <p>Initialize the table.</p> Source code in <code>ngio/tables/_abstract_table.py</code> <pre><code>def __init__(\n    self,\n    table_data: TabularData | None = None,\n    *,\n    meta: BackendMeta | None = None,\n) -&gt; None:\n    \"\"\"Initialize the table.\"\"\"\n    if meta is None:\n        meta = BackendMeta()\n\n    self._meta = meta\n    if table_data is not None:\n        table_data = normalize_table(\n            table_data,\n            index_key=meta.index_key,\n            index_type=meta.index_type,\n        )\n    self._table_data = table_data\n    self._table_backend = None\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.GenericTable.backend_name","title":"backend_name  <code>property</code>","text":"<pre><code>backend_name: str | None\n</code></pre> <p>Return the name of the backend.</p>"},{"location":"api/ngio/tables/#ngio.tables.GenericTable.meta","title":"meta  <code>property</code>","text":"<pre><code>meta: BackendMeta\n</code></pre> <p>Return the metadata of the table.</p>"},{"location":"api/ngio/tables/#ngio.tables.GenericTable.index_key","title":"index_key  <code>property</code>","text":"<pre><code>index_key: str | None\n</code></pre> <p>Get the index key.</p>"},{"location":"api/ngio/tables/#ngio.tables.GenericTable.index_type","title":"index_type  <code>property</code>","text":"<pre><code>index_type: Literal['int', 'str'] | None\n</code></pre> <p>Get the index type.</p>"},{"location":"api/ngio/tables/#ngio.tables.GenericTable.table_data","title":"table_data  <code>property</code>","text":"<pre><code>table_data: TabularData\n</code></pre> <p>Return the table.</p>"},{"location":"api/ngio/tables/#ngio.tables.GenericTable.dataframe","title":"dataframe  <code>property</code>","text":"<pre><code>dataframe: DataFrame\n</code></pre> <p>Return the table as a DataFrame.</p>"},{"location":"api/ngio/tables/#ngio.tables.GenericTable.lazy_frame","title":"lazy_frame  <code>property</code>","text":"<pre><code>lazy_frame: LazyFrame\n</code></pre> <p>Return the table as a LazyFrame.</p>"},{"location":"api/ngio/tables/#ngio.tables.GenericTable.anndata","title":"anndata  <code>property</code>","text":"<pre><code>anndata: AnnData\n</code></pre> <p>Return the table as an AnnData object.</p>"},{"location":"api/ngio/tables/#ngio.tables.GenericTable.load_as_anndata","title":"load_as_anndata","text":"<pre><code>load_as_anndata() -&gt; AnnData\n</code></pre> <p>Load the table as an AnnData object.</p> Source code in <code>ngio/tables/_abstract_table.py</code> <pre><code>def load_as_anndata(self) -&gt; AnnData:\n    \"\"\"Load the table as an AnnData object.\"\"\"\n    if self._table_backend is None:\n        raise NgioValueError(\"No backend set for the table.\")\n    return self._table_backend.load_as_anndata()\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.GenericTable.load_as_pandas_df","title":"load_as_pandas_df","text":"<pre><code>load_as_pandas_df() -&gt; DataFrame\n</code></pre> <p>Load the table as a pandas DataFrame.</p> Source code in <code>ngio/tables/_abstract_table.py</code> <pre><code>def load_as_pandas_df(self) -&gt; pd.DataFrame:\n    \"\"\"Load the table as a pandas DataFrame.\"\"\"\n    if self._table_backend is None:\n        raise NgioValueError(\"No backend set for the table.\")\n    return self._table_backend.load_as_pandas_df()\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.GenericTable.load_as_polars_lf","title":"load_as_polars_lf","text":"<pre><code>load_as_polars_lf() -&gt; LazyFrame\n</code></pre> <p>Load the table as a polars LazyFrame.</p> Source code in <code>ngio/tables/_abstract_table.py</code> <pre><code>def load_as_polars_lf(self) -&gt; pl.LazyFrame:\n    \"\"\"Load the table as a polars LazyFrame.\"\"\"\n    if self._table_backend is None:\n        raise NgioValueError(\"No backend set for the table.\")\n    return self._table_backend.load_as_polars_lf()\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.GenericTable.set_table_data","title":"set_table_data","text":"<pre><code>set_table_data(\n    table_data: TabularData | None = None,\n    refresh: bool = False,\n) -&gt; None\n</code></pre> <p>Set the table.</p> <p>If an object is passed, it will be used as the table. If None is passed, the table will be loaded from the backend.</p> <p>If refresh is True, the table will be reloaded from the backend.     If table is not None, this will be ignored.</p> Source code in <code>ngio/tables/_abstract_table.py</code> <pre><code>def set_table_data(\n    self,\n    table_data: TabularData | None = None,\n    refresh: bool = False,\n) -&gt; None:\n    \"\"\"Set the table.\n\n    If an object is passed, it will be used as the table.\n    If None is passed, the table will be loaded from the backend.\n\n    If refresh is True, the table will be reloaded from the backend.\n        If table is not None, this will be ignored.\n    \"\"\"\n    if table_data is not None:\n        if not isinstance(table_data, TabularData):\n            raise NgioValueError(\n                \"The table must be a pandas DataFrame, polars LazyFrame, \"\n                \" or AnnData object.\"\n            )\n\n        self._table_data = normalize_table(\n            table_data,\n            index_key=self.index_key,\n            index_type=self.index_type,\n        )\n        return None\n\n    if self._table_data is not None and not refresh:\n        return None\n\n    if self._table_backend is None:\n        raise NgioValueError(\n            \"The table does not have a DataFrame in memory nor a backend.\"\n        )\n    self._table_data = self._table_backend.load()\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.GenericTable.set_backend","title":"set_backend","text":"<pre><code>set_backend(\n    handler: ZarrGroupHandler | None = None,\n    backend: TableBackend = DefaultTableBackend,\n) -&gt; None\n</code></pre> <p>Set the backend of the table.</p> Source code in <code>ngio/tables/_abstract_table.py</code> <pre><code>def set_backend(\n    self,\n    handler: ZarrGroupHandler | None = None,\n    backend: TableBackend = DefaultTableBackend,\n) -&gt; None:\n    \"\"\"Set the backend of the table.\"\"\"\n    if handler is None:\n        if self._table_backend is None:\n            raise NgioValueError(\n                \"No backend set for the table yet. \"\n                \"A ZarrGroupHandler must be provided.\"\n            )\n        handler = self._table_backend.group_handler\n\n    meta = self._meta\n    _backend = self._load_backend(\n        meta=meta,\n        handler=handler,\n        backend=backend,\n    )\n    self._table_backend = _backend\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.GenericTable.from_table_data","title":"from_table_data  <code>classmethod</code>","text":"<pre><code>from_table_data(\n    table_data: TabularData, meta: BackendMeta\n) -&gt; Self\n</code></pre> <p>Create a new ROI table from a Zarr group handler.</p> Source code in <code>ngio/tables/_abstract_table.py</code> <pre><code>@classmethod\ndef from_table_data(cls, table_data: TabularData, meta: BackendMeta) -&gt; Self:\n    \"\"\"Create a new ROI table from a Zarr group handler.\"\"\"\n    return cls(\n        table_data=table_data,\n        meta=meta,\n    )\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.GenericTable.consolidate","title":"consolidate","text":"<pre><code>consolidate() -&gt; None\n</code></pre> <p>Write the current state of the table to the Zarr file.</p> Source code in <code>ngio/tables/_abstract_table.py</code> <pre><code>def consolidate(self) -&gt; None:\n    \"\"\"Write the current state of the table to the Zarr file.\"\"\"\n    if self._table_backend is None:\n        raise NgioValueError(\n            \"No backend set for the table. \"\n            \"Please add the table to a OME-Zarr Image before calling consolidate.\"\n        )\n\n    self._table_backend.write(\n        self.table_data,\n        metadata=self._meta.model_dump(exclude_none=True),\n    )\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.GenericTable.table_type","title":"table_type  <code>staticmethod</code>","text":"<pre><code>table_type() -&gt; str\n</code></pre> <p>Return the type of the table.</p> Source code in <code>ngio/tables/v1/_generic_table.py</code> <pre><code>@staticmethod\ndef table_type() -&gt; str:\n    \"\"\"Return the type of the table.\"\"\"\n    return \"generic_table\"\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.GenericTable.version","title":"version  <code>staticmethod</code>","text":"<pre><code>version() -&gt; str\n</code></pre> <p>The generic table does not have a version.</p> <p>Since does not follow a specific schema.</p> Source code in <code>ngio/tables/v1/_generic_table.py</code> <pre><code>@staticmethod\ndef version() -&gt; str:\n    \"\"\"The generic table does not have a version.\n\n    Since does not follow a specific schema.\n    \"\"\"\n    return \"1\"\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.GenericTable.from_handler","title":"from_handler  <code>classmethod</code>","text":"<pre><code>from_handler(\n    handler: ZarrGroupHandler,\n    backend: TableBackend | None = None,\n) -&gt; GenericTable\n</code></pre> Source code in <code>ngio/tables/v1/_generic_table.py</code> <pre><code>@classmethod\ndef from_handler(\n    cls,\n    handler: ZarrGroupHandler,\n    backend: TableBackend | None = None,\n) -&gt; \"GenericTable\":\n    return cls._from_handler(\n        handler=handler,\n        backend=backend,\n        meta_model=BackendMeta,\n    )\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.open_table","title":"open_table","text":"<pre><code>open_table(\n    store: StoreOrGroup,\n    backend: TableBackend | None = None,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"a\",\n    parallel_safe: bool = False,\n) -&gt; Table\n</code></pre> <p>Open a table from a Zarr store.</p> Source code in <code>ngio/tables/_tables_container.py</code> <pre><code>def open_table(\n    store: StoreOrGroup,\n    backend: TableBackend | None = None,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"a\",\n    parallel_safe: bool = False,\n) -&gt; Table:\n    \"\"\"Open a table from a Zarr store.\"\"\"\n    handler = ZarrGroupHandler(\n        store=store, cache=cache, mode=mode, parallel_safe=parallel_safe\n    )\n    meta = _get_meta(handler)\n    return ImplementedTables().get_table(\n        meta=meta, handler=handler, backend=backend, strict=False\n    )\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.open_table_as","title":"open_table_as","text":"<pre><code>open_table_as(\n    store: StoreOrGroup,\n    table_cls: type[TableType],\n    backend: TableBackend | None = None,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"a\",\n    parallel_safe: bool = False,\n) -&gt; TableType\n</code></pre> <p>Open a table from a Zarr store as a specific type.</p> Source code in <code>ngio/tables/_tables_container.py</code> <pre><code>def open_table_as(\n    store: StoreOrGroup,\n    table_cls: type[TableType],\n    backend: TableBackend | None = None,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"a\",\n    parallel_safe: bool = False,\n) -&gt; TableType:\n    \"\"\"Open a table from a Zarr store as a specific type.\"\"\"\n    handler = ZarrGroupHandler(\n        store=store, cache=cache, mode=mode, parallel_safe=parallel_safe\n    )\n    return table_cls.from_handler(\n        handler=handler,\n        backend=backend,\n    )  # type: ignore[return-value]\n</code></pre>"},{"location":"api/ngio/tables/#ngio.tables.open_tables_container","title":"open_tables_container","text":"<pre><code>open_tables_container(\n    store: StoreOrGroup,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"a\",\n    parallel_safe: bool = False,\n) -&gt; TablesContainer\n</code></pre> <p>Open a table handler from a Zarr store.</p> Source code in <code>ngio/tables/_tables_container.py</code> <pre><code>def open_tables_container(\n    store: StoreOrGroup,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"a\",\n    parallel_safe: bool = False,\n) -&gt; TablesContainer:\n    \"\"\"Open a table handler from a Zarr store.\"\"\"\n    handler = ZarrGroupHandler(\n        store=store, cache=cache, mode=mode, parallel_safe=parallel_safe\n    )\n    return TablesContainer(handler)\n</code></pre>"},{"location":"api/ngio/utils/","title":"ngio.utils","text":""},{"location":"api/ngio/utils/#ngio.utils","title":"ngio.utils","text":"<p>Various utilities for the ngio package.</p>"},{"location":"api/ngio/utils/#ngio.utils.ngio_logger","title":"ngio_logger  <code>module-attribute</code>","text":"<pre><code>ngio_logger = getLogger('NgioLogger')\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.AccessModeLiteral","title":"AccessModeLiteral  <code>module-attribute</code>","text":"<pre><code>AccessModeLiteral = Literal['r', 'r+', 'w', 'w-', 'a']\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.StoreOrGroup","title":"StoreOrGroup  <code>module-attribute</code>","text":"<pre><code>StoreOrGroup = GenericStore | Group\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.NgioFileExistsError","title":"NgioFileExistsError","text":"<p>               Bases: <code>NgioError</code>, <code>FileExistsError</code></p> <p>Error raised when a file already exists.</p>"},{"location":"api/ngio/utils/#ngio.utils.NgioFileNotFoundError","title":"NgioFileNotFoundError","text":"<p>               Bases: <code>NgioError</code>, <code>FileNotFoundError</code></p> <p>Error raised when a file is not found.</p>"},{"location":"api/ngio/utils/#ngio.utils.NgioTableValidationError","title":"NgioTableValidationError","text":"<p>               Bases: <code>NgioError</code></p> <p>Error raised when a table does not pass validation.</p>"},{"location":"api/ngio/utils/#ngio.utils.NgioValidationError","title":"NgioValidationError","text":"<p>               Bases: <code>NgioError</code>, <code>ValueError</code></p> <p>Generic error raised when a file does not pass validation.</p>"},{"location":"api/ngio/utils/#ngio.utils.NgioValueError","title":"NgioValueError","text":"<p>               Bases: <code>NgioError</code>, <code>ValueError</code></p> <p>Error raised when a value does not pass a run time test.</p>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler","title":"ZarrGroupHandler","text":"<pre><code>ZarrGroupHandler(\n    store: StoreOrGroup,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"a\",\n    parallel_safe: bool = False,\n    parent: ZarrGroupHandler | None = None,\n)\n</code></pre> <p>A simple wrapper around a Zarr group to handle metadata.</p> <p>Initialize the handler.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The Zarr store or group containing the image data.</p> </li> <li> <code>meta_mode</code>               (<code>str</code>)           \u2013            <p>The mode of the metadata handler.</p> </li> <li> <code>cache</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to cache the metadata.</p> </li> <li> <code>mode</code>               (<code>str</code>, default:                   <code>'a'</code> )           \u2013            <p>The mode of the store.</p> </li> <li> <code>parallel_safe</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, the handler will create a lock file to make that can be used to make the handler parallel safe. Be aware that the lock needs to be used manually.</p> </li> <li> <code>parent</code>               (<code>ZarrGroupHandler | None</code>, default:                   <code>None</code> )           \u2013            <p>The parent handler.</p> </li> </ul> Source code in <code>ngio/utils/_zarr_utils.py</code> <pre><code>def __init__(\n    self,\n    store: StoreOrGroup,\n    cache: bool = False,\n    mode: AccessModeLiteral = \"a\",\n    parallel_safe: bool = False,\n    parent: \"ZarrGroupHandler | None\" = None,\n):\n    \"\"\"Initialize the handler.\n\n    Args:\n        store (StoreOrGroup): The Zarr store or group containing the image data.\n        meta_mode (str): The mode of the metadata handler.\n        cache (bool): Whether to cache the metadata.\n        mode (str): The mode of the store.\n        parallel_safe (bool): If True, the handler will create a lock file to make\n            that can be used to make the handler parallel safe.\n            Be aware that the lock needs to be used manually.\n        parent (ZarrGroupHandler | None): The parent handler.\n    \"\"\"\n    if mode not in [\"r\", \"r+\", \"w\", \"w-\", \"a\"]:\n        raise NgioValueError(f\"Mode {mode} is not supported.\")\n\n    if parallel_safe and cache:\n        raise NgioValueError(\n            \"The cache and parallel_safe options are mutually exclusive.\"\n            \"If you want to use the lock mechanism, you should not use the cache.\"\n        )\n\n    group = open_group_wrapper(store, mode)\n    _store = group.store\n\n    # Make sure the cache is set in the attrs\n    # in the same way as the cache in the handler\n    group.attrs.cache = cache\n\n    if parallel_safe:\n        if not isinstance(_store, DirectoryStore):\n            raise NgioValueError(\n                \"The store needs to be a DirectoryStore to use the lock mechanism. \"\n                f\"Instead, got {_store.__class__.__name__}.\"\n            )\n        store_path = Path(_store.path) / group.path\n        self._lock_path = store_path.with_suffix(\".lock\")\n        self._lock = FileLock(self._lock_path, timeout=10)\n\n    else:\n        self._lock_path = None\n        self._lock = None\n\n    self._group = group\n    self._mode = mode\n    self.use_cache = cache\n    self._parallel_safe = parallel_safe\n    self._cache = {}\n    self._parent = parent\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler.use_cache","title":"use_cache  <code>instance-attribute</code>","text":"<pre><code>use_cache = cache\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler.store","title":"store  <code>property</code>","text":"<pre><code>store: StoreLike\n</code></pre> <p>Return the store of the group.</p>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler.full_url","title":"full_url  <code>property</code>","text":"<pre><code>full_url: str | None\n</code></pre> <p>Return the store path.</p>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler.mode","title":"mode  <code>property</code>","text":"<pre><code>mode: AccessModeLiteral\n</code></pre> <p>Return the mode of the group.</p>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler.lock","title":"lock  <code>property</code>","text":"<pre><code>lock: BaseFileLock\n</code></pre> <p>Return the lock.</p>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler.parent","title":"parent  <code>property</code>","text":"<pre><code>parent: ZarrGroupHandler | None\n</code></pre> <p>Return the parent handler.</p>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler.group","title":"group  <code>property</code>","text":"<pre><code>group: Group\n</code></pre> <p>Return the group.</p>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler.remove_lock","title":"remove_lock","text":"<pre><code>remove_lock() -&gt; None\n</code></pre> <p>Return the lock.</p> Source code in <code>ngio/utils/_zarr_utils.py</code> <pre><code>def remove_lock(self) -&gt; None:\n    \"\"\"Return the lock.\"\"\"\n    if self._lock is None or self._lock_path is None:\n        return None\n\n    lock_path = Path(self._lock_path)\n    if lock_path.exists() and self._lock.lock_counter == 0:\n        lock_path.unlink()\n        self._lock = None\n        self._lock_path = None\n        return None\n\n    raise NgioValueError(\"The lock is still in use. Cannot remove it.\")\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler.add_to_cache","title":"add_to_cache","text":"<pre><code>add_to_cache(key: str, value: object) -&gt; None\n</code></pre> <p>Add an object to the cache.</p> Source code in <code>ngio/utils/_zarr_utils.py</code> <pre><code>def add_to_cache(self, key: str, value: object) -&gt; None:\n    \"\"\"Add an object to the cache.\"\"\"\n    if not self.use_cache:\n        return None\n    self._cache[key] = value\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler.get_from_cache","title":"get_from_cache","text":"<pre><code>get_from_cache(key: str) -&gt; object | None\n</code></pre> <p>Get an object from the cache.</p> Source code in <code>ngio/utils/_zarr_utils.py</code> <pre><code>def get_from_cache(self, key: str) -&gt; object | None:\n    \"\"\"Get an object from the cache.\"\"\"\n    if not self.use_cache:\n        return None\n    return self._cache.get(key, None)\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler.clean_cache","title":"clean_cache","text":"<pre><code>clean_cache() -&gt; None\n</code></pre> <p>Clear the cached metadata.</p> Source code in <code>ngio/utils/_zarr_utils.py</code> <pre><code>def clean_cache(self) -&gt; None:\n    \"\"\"Clear the cached metadata.\"\"\"\n    self._cache = {}\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler.load_attrs","title":"load_attrs","text":"<pre><code>load_attrs() -&gt; dict\n</code></pre> <p>Load the attributes of the group.</p> Source code in <code>ngio/utils/_zarr_utils.py</code> <pre><code>def load_attrs(self) -&gt; dict:\n    \"\"\"Load the attributes of the group.\"\"\"\n    attrs = self.get_from_cache(\"attrs\")\n    if attrs is not None and isinstance(attrs, dict):\n        return attrs\n\n    attrs = dict(self.group.attrs)\n\n    self.add_to_cache(\"attrs\", attrs)\n    return attrs\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler.write_attrs","title":"write_attrs","text":"<pre><code>write_attrs(attrs: dict, overwrite: bool = False) -&gt; None\n</code></pre> <p>Write the metadata to the store.</p> Source code in <code>ngio/utils/_zarr_utils.py</code> <pre><code>def write_attrs(self, attrs: dict, overwrite: bool = False) -&gt; None:\n    \"\"\"Write the metadata to the store.\"\"\"\n    # Maybe we should use the lock here\n    self._write_attrs(attrs, overwrite)\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler.create_group","title":"create_group","text":"<pre><code>create_group(path: str, overwrite: bool = False) -&gt; Group\n</code></pre> <p>Create a group in the group.</p> Source code in <code>ngio/utils/_zarr_utils.py</code> <pre><code>def create_group(self, path: str, overwrite: bool = False) -&gt; zarr.Group:\n    \"\"\"Create a group in the group.\"\"\"\n    if self.mode == \"r\":\n        raise NgioValueError(\"Cannot create a group in read only mode.\")\n\n    try:\n        group = self.group.create_group(path, overwrite=overwrite)\n    except ContainsGroupError as e:\n        raise NgioFileExistsError(\n            f\"A Zarr group already exists at {path}, \"\n            \"consider setting overwrite=True.\"\n        ) from e\n    self.add_to_cache(path, group)\n    return group\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler.get_group","title":"get_group","text":"<pre><code>get_group(\n    path: str,\n    create_mode: bool = False,\n    overwrite: bool = False,\n) -&gt; Group\n</code></pre> <p>Get a group from the group.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path to the group.</p> </li> <li> <code>create_mode</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, create the group if it does not exist.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, overwrite the group if it exists.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Group</code>           \u2013            <p>zarr.Group: The Zarr group.</p> </li> </ul> Source code in <code>ngio/utils/_zarr_utils.py</code> <pre><code>def get_group(\n    self,\n    path: str,\n    create_mode: bool = False,\n    overwrite: bool = False,\n) -&gt; zarr.Group:\n    \"\"\"Get a group from the group.\n\n    Args:\n        path (str): The path to the group.\n        create_mode (bool): If True, create the group if it does not exist.\n        overwrite (bool): If True, overwrite the group if it exists.\n\n    Returns:\n        zarr.Group: The Zarr group.\n\n    \"\"\"\n    if overwrite and not create_mode:\n        raise NgioValueError(\"Cannot overwrite a group without create_mode=True.\")\n\n    if overwrite:\n        return self.create_group(path, overwrite=overwrite)\n\n    group = self._obj_get(path)\n    if isinstance(group, zarr.Group):\n        return group\n\n    if group is not None:\n        raise NgioValueError(\n            f\"The object at {path} is not a group, but a {type(group)}\"\n        )\n\n    if not create_mode:\n        raise NgioFileNotFoundError(f\"No group found at {path}\")\n    group = self.create_group(path)\n    return group\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler.safe_get_group","title":"safe_get_group","text":"<pre><code>safe_get_group(\n    path: str, create_mode: bool = False\n) -&gt; tuple[bool, Group | NgioError]\n</code></pre> <p>Get a group from the group.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path to the group.</p> </li> <li> <code>create_mode</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, create the group if it does not exist.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[bool, Group | NgioError]</code>           \u2013            <p>zarr.Group | None: The Zarr group or None if it does not exist or an error occurs.</p> </li> </ul> Source code in <code>ngio/utils/_zarr_utils.py</code> <pre><code>def safe_get_group(\n    self, path: str, create_mode: bool = False\n) -&gt; tuple[bool, zarr.Group | NgioError]:\n    \"\"\"Get a group from the group.\n\n    Args:\n        path (str): The path to the group.\n        create_mode (bool): If True, create the group if it does not exist.\n\n    Returns:\n        zarr.Group | None: The Zarr group or None if it does not exist\n            or an error occurs.\n\n    \"\"\"\n    try:\n        return True, self.get_group(path, create_mode)\n    except NgioError as e:\n        return False, e\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler.get_array","title":"get_array","text":"<pre><code>get_array(path: str) -&gt; Array\n</code></pre> <p>Get an array from the group.</p> Source code in <code>ngio/utils/_zarr_utils.py</code> <pre><code>def get_array(self, path: str) -&gt; zarr.Array:\n    \"\"\"Get an array from the group.\"\"\"\n    array = self._obj_get(path)\n    if array is None:\n        raise NgioFileNotFoundError(f\"No array found at {path}\")\n    if not isinstance(array, zarr.Array):\n        raise NgioValueError(\n            f\"The object at {path} is not an array, but a {type(array)}\"\n        )\n    return array\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler.create_array","title":"create_array","text":"<pre><code>create_array(\n    path: str,\n    shape: tuple[int, ...],\n    dtype: str,\n    chunks: tuple[int, ...] | None = None,\n    overwrite: bool = False,\n) -&gt; Array\n</code></pre> Source code in <code>ngio/utils/_zarr_utils.py</code> <pre><code>def create_array(\n    self,\n    path: str,\n    shape: tuple[int, ...],\n    dtype: str,\n    chunks: tuple[int, ...] | None = None,\n    overwrite: bool = False,\n) -&gt; zarr.Array:\n    if self.mode == \"r\":\n        raise NgioValueError(\"Cannot create an array in read only mode.\")\n\n    try:\n        return self.group.zeros(\n            name=path,\n            shape=shape,\n            dtype=dtype,\n            chunks=chunks,\n            dimension_separator=\"/\",\n            overwrite=overwrite,\n        )\n    except ContainsGroupError as e:\n        raise NgioFileExistsError(\n            f\"A Zarr array already exists at {path}, \"\n            \"consider setting overwrite=True.\"\n        ) from e\n    except Exception as e:\n        raise NgioValueError(f\"Error creating array at {path}\") from e\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler.derive_handler","title":"derive_handler","text":"<pre><code>derive_handler(\n    path: str, overwrite: bool = False\n) -&gt; ZarrGroupHandler\n</code></pre> <p>Derive a new handler from the current handler.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path to the group.</p> </li> <li> <code>overwrite</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, overwrite the group if it exists.</p> </li> </ul> Source code in <code>ngio/utils/_zarr_utils.py</code> <pre><code>def derive_handler(\n    self,\n    path: str,\n    overwrite: bool = False,\n) -&gt; \"ZarrGroupHandler\":\n    \"\"\"Derive a new handler from the current handler.\n\n    Args:\n        path (str): The path to the group.\n        overwrite (bool): If True, overwrite the group if it exists.\n    \"\"\"\n    group = self.get_group(path, create_mode=True, overwrite=overwrite)\n    return ZarrGroupHandler(\n        store=group,\n        cache=self.use_cache,\n        mode=self.mode,\n        parallel_safe=self._parallel_safe,\n        parent=self,\n    )\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler.safe_derive_handler","title":"safe_derive_handler","text":"<pre><code>safe_derive_handler(\n    path: str, overwrite: bool = False\n) -&gt; tuple[bool, ZarrGroupHandler | NgioError]\n</code></pre> <p>Derive a new handler from the current handler.</p> Source code in <code>ngio/utils/_zarr_utils.py</code> <pre><code>def safe_derive_handler(\n    self,\n    path: str,\n    overwrite: bool = False,\n) -&gt; tuple[bool, \"ZarrGroupHandler | NgioError\"]:\n    \"\"\"Derive a new handler from the current handler.\"\"\"\n    try:\n        return True, self.derive_handler(path, overwrite=overwrite)\n    except NgioError as e:\n        return False, e\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.ZarrGroupHandler.copy_handler","title":"copy_handler","text":"<pre><code>copy_handler(handler: ZarrGroupHandler) -&gt; None\n</code></pre> <p>Copy the group to a new store.</p> Source code in <code>ngio/utils/_zarr_utils.py</code> <pre><code>def copy_handler(self, handler: \"ZarrGroupHandler\") -&gt; None:\n    \"\"\"Copy the group to a new store.\"\"\"\n    _, n_skipped, _ = zarr.copy_store(\n        source=self.group.store,\n        dest=handler.group.store,\n        source_path=self.group.path,\n        dest_path=handler.group.path,\n        if_exists=\"replace\",\n    )\n    if n_skipped &gt; 0:\n        raise NgioValueError(\n            f\"Error copying group to {handler.full_url}, \"\n            f\"#{n_skipped} files where skipped.\"\n        )\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.download_ome_zarr_dataset","title":"download_ome_zarr_dataset","text":"<pre><code>download_ome_zarr_dataset(\n    dataset_name: AVAILABLE_DATASETS | str,\n    download_dir: str | Path = \"data\",\n    re_unzip: bool = True,\n    progressbar: bool = False,\n) -&gt; Path\n</code></pre> <p>Download an OME-Zarr dataset.</p> <p>To list available datasets, use <code>list_ome_zarr_datasets</code>.</p> <p>Parameters:</p> <ul> <li> <code>dataset_name</code>               (<code>str</code>)           \u2013            <p>The dataset name.</p> </li> <li> <code>download_dir</code>               (<code>str</code>, default:                   <code>'data'</code> )           \u2013            <p>The download directory. Defaults to \"data\".</p> </li> <li> <code>re_unzip</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, it will unzip the dataset even if it already exists.</p> </li> <li> <code>progressbar</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, show a progress bar during download.</p> </li> </ul> Source code in <code>ngio/utils/_datasets.py</code> <pre><code>def download_ome_zarr_dataset(\n    dataset_name: AVAILABLE_DATASETS | str,\n    download_dir: str | Path = \"data\",\n    re_unzip: bool = True,\n    progressbar: bool = False,\n) -&gt; Path:\n    \"\"\"Download an OME-Zarr dataset.\n\n    To list available datasets, use `list_ome_zarr_datasets`.\n\n    Args:\n        dataset_name (str): The dataset name.\n        download_dir (str): The download directory. Defaults to \"data\".\n        re_unzip (bool): If True, it will unzip the dataset even if it already exists.\n        progressbar (bool): If True, show a progress bar during download.\n    \"\"\"\n    if dataset_name not in _ome_zarr_zoo:\n        raise NgioValueError(f\"Dataset {dataset_name} not found in the OME-Zarr zoo.\")\n    zenodo_infos = _ome_zarr_zoo[dataset_name]\n\n    fname = zenodo_infos[\"fname\"]\n    zarrname = fname.replace(\".zip\", \"\")\n\n    processor = UnzipAndRename(\n        extract_dir=\"\",\n        out_name=zarrname,\n        re_unzip=re_unzip,\n    )\n\n    pooch.retrieve(\n        url=zenodo_infos[\"url\"],\n        known_hash=zenodo_infos[\"known_hash\"],\n        fname=fname,\n        path=download_dir,\n        processor=processor,\n        progressbar=progressbar,\n    )\n    return processor.output_file()\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.list_ome_zarr_datasets","title":"list_ome_zarr_datasets","text":"<pre><code>list_ome_zarr_datasets() -&gt; list[str]\n</code></pre> <p>List available OME-Zarr datasets.</p> Source code in <code>ngio/utils/_datasets.py</code> <pre><code>def list_ome_zarr_datasets() -&gt; list[str]:\n    \"\"\"List available OME-Zarr datasets.\"\"\"\n    return list(_ome_zarr_zoo.keys())\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.print_datasets_infos","title":"print_datasets_infos","text":"<pre><code>print_datasets_infos() -&gt; None\n</code></pre> Source code in <code>ngio/utils/_datasets.py</code> <pre><code>def print_datasets_infos() -&gt; None:\n    for dataset_name, dataset_info in _ome_zarr_zoo.items():\n        print(f\"{dataset_name} - Description: {dataset_info['description']}\")\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.fractal_fsspec_store","title":"fractal_fsspec_store","text":"<pre><code>fractal_fsspec_store(\n    url: str,\n    fractal_token: str | None = None,\n    client_kwargs: dict | None = None,\n) -&gt; FSMap\n</code></pre> <p>Simple function to get an http fsspec store from a url.</p> Source code in <code>ngio/utils/_fractal_fsspec_store.py</code> <pre><code>def fractal_fsspec_store(\n    url: str, fractal_token: str | None = None, client_kwargs: dict | None = None\n) -&gt; fsspec.mapping.FSMap:\n    \"\"\"Simple function to get an http fsspec store from a url.\"\"\"\n    client_kwargs = {} if client_kwargs is None else client_kwargs\n    if fractal_token is not None:\n        client_kwargs[\"headers\"] = {\"Authorization\": f\"Bearer {fractal_token}\"}\n    fs = fsspec.implementations.http.HTTPFileSystem(client_kwargs=client_kwargs)\n\n    store = fs.get_mapper(url)\n\n    possible_keys = [\".zgroup\", \".zarray\"]\n    for key in possible_keys:\n        try:\n            value = store.get(key)\n            if value is not None:\n                break\n        except ClientResponseError as e:\n            if e.status == 401 and fractal_token is None:\n                raise NgioValueError(\n                    \"No auto token is provided. You need a valid \"\n                    f\"'fractal_token' to access: {url}.\"\n                ) from e\n            elif e.status == 401 and fractal_token is not None:\n                raise NgioValueError(\n                    f\"The 'fractal_token' provided is invalid for: {url}.\"\n                ) from e\n            else:\n                raise e\n    else:\n        raise NgioValueError(\n            f\"Store {url} can not be read. Possible problems are: \\n\"\n            \"- The url does not exist. \\n\"\n            \"- The url is not a valid .zarr. \\n\"\n        )\n    return store\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.ngio_warn","title":"ngio_warn","text":"<pre><code>ngio_warn(message: str, cooldown: int = 2) -&gt; None\n</code></pre> <p>Log a warning message.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>str</code>)           \u2013            <p>The warning message to log.</p> </li> <li> <code>cooldown</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <p>The cooldown period in seconds to avoid repeated logging.</p> </li> </ul> Source code in <code>ngio/utils/_logger.py</code> <pre><code>def ngio_warn(message: str, cooldown: int = 2) -&gt; None:\n    \"\"\"Log a warning message.\n\n    Args:\n        message: The warning message to log.\n        cooldown: The cooldown period in seconds to avoid repeated logging.\n    \"\"\"\n    ttl_hash = time.time() // cooldown\n    _warn(message, ttl_hash)\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.set_logger_level","title":"set_logger_level","text":"<pre><code>set_logger_level(level: str) -&gt; None\n</code></pre> <p>Set the logger level.</p> <p>Parameters:</p> <ul> <li> <code>level</code>               (<code>str</code>)           \u2013            <p>The level to set the logger to. Must be one of \"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\".</p> </li> </ul> Source code in <code>ngio/utils/_logger.py</code> <pre><code>def set_logger_level(level: str) -&gt; None:\n    \"\"\"Set the logger level.\n\n    Args:\n        level: The level to set the logger to.\n            Must be one of \"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\".\n    \"\"\"\n    if level not in [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]:\n        raise NgioValueError(f\"Invalid log level: {level}\")\n\n    ngio_logger.setLevel(level)\n</code></pre>"},{"location":"api/ngio/utils/#ngio.utils.open_group_wrapper","title":"open_group_wrapper","text":"<pre><code>open_group_wrapper(\n    store: StoreOrGroup, mode: AccessModeLiteral\n) -&gt; Group\n</code></pre> <p>Wrapper around zarr.open_group with some additional checks.</p> <p>Parameters:</p> <ul> <li> <code>store</code>               (<code>StoreOrGroup</code>)           \u2013            <p>The store or group to open.</p> </li> <li> <code>mode</code>               (<code>ReadOrEdirLiteral</code>)           \u2013            <p>The mode to open the group in.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Group</code>           \u2013            <p>zarr.Group: The opened Zarr group.</p> </li> </ul> Source code in <code>ngio/utils/_zarr_utils.py</code> <pre><code>def open_group_wrapper(store: StoreOrGroup, mode: AccessModeLiteral) -&gt; zarr.Group:\n    \"\"\"Wrapper around zarr.open_group with some additional checks.\n\n    Args:\n        store (StoreOrGroup): The store or group to open.\n        mode (ReadOrEdirLiteral): The mode to open the group in.\n\n    Returns:\n        zarr.Group: The opened Zarr group.\n    \"\"\"\n    if isinstance(store, zarr.Group):\n        group = _check_group(store, mode)\n        _check_store(group.store)\n        return group\n\n    try:\n        _check_store(store)\n        group = zarr.open_group(store=store, mode=mode)\n\n    except ContainsGroupError as e:\n        raise NgioFileExistsError(\n            f\"A Zarr group already exists at {store}, consider setting overwrite=True.\"\n        ) from e\n\n    except GroupNotFoundError as e:\n        raise NgioFileNotFoundError(f\"No Zarr group found at {store}\") from e\n\n    return group\n</code></pre>"},{"location":"getting_started/0_quickstart/","title":"Quickstart","text":"<p>Ngio is a Python package that provides a simple and intuitive API for reading and writing data to and from OME-Zarr. This guide will walk you through the basics of using <code>ngio</code> to read and write data.</p>"},{"location":"getting_started/0_quickstart/#installation","title":"Installation","text":"<p><code>ngio</code> can be installed from PyPI, conda-forge, or from source.</p> <ul> <li><code>ngio</code> requires Python <code>&gt;=3.11</code></li> </ul> pipmamba/condaSource <p>The recommended way to install <code>ngio</code> is from PyPI using pip:</p> <pre><code>pip install ngio\n</code></pre> <p>Alternatively, you can install <code>ngio</code> using mamba:</p> <pre><code>mamba install -c conda-forge ngio\n</code></pre> <p>or conda:</p> <pre><code>conda install -c conda-forge ngio\n</code></pre> <ol> <li> <p>Clone the repository: <pre><code>git clone https://github.com/fractal-analytics-platform/ngio.git\ncd ngio\n</code></pre></p> </li> <li> <p>Install the package: <pre><code>pip install .\n</code></pre></p> </li> </ol>"},{"location":"getting_started/0_quickstart/#troubleshooting","title":"Troubleshooting","text":"<p>Please report installation problems by opening an issue on our GitHub repository.</p>"},{"location":"getting_started/0_quickstart/#setup-some-test-data","title":"Setup some test data","text":"<p>Let's start by downloading a sample OME-Zarr dataset to work with.</p> <pre><code>from pathlib import Path\nfrom ngio.utils import download_ome_zarr_dataset\n\n# Download a sample dataset\ndownload_dir = Path(\"./data\")\nhcs_path = download_ome_zarr_dataset(\"CardiomyocyteSmallMip\", download_dir=download_dir)\nimage_path = hcs_path / \"B\" / \"03\" / \"0\"\n</code></pre>"},{"location":"getting_started/0_quickstart/#open-an-ome-zarr-image","title":"Open an OME-Zarr image","text":"<p>Let's start by opening an OME-Zarr file and inspecting its contents.</p> <pre><code>&gt;&gt;&gt; from ngio import open_ome_zarr_container\n&gt;&gt;&gt; ome_zarr_container = open_ome_zarr_container(image_path)\n&gt;&gt;&gt; ome_zarr_container\nOmeZarrContainer(levels=5, #labels=4, #tables=7)\n</code></pre>"},{"location":"getting_started/0_quickstart/#what-is-the-ome-zarr-container","title":"What is the OME-Zarr container?","text":"<p>The <code>OME-Zarr Container</code> is the core of ngio and the entry point to working with OME-Zarr images. It provides high-level access to the image metadata, images, labels, and tables.</p>"},{"location":"getting_started/0_quickstart/#what-is-the-ome-zarr-container-not","title":"What is the OME-Zarr container not?","text":"<p>The <code>OME-Zarr Container</code> object does not allow the user to interact with the image data directly. For that, we need to use the <code>Image</code>, <code>Label</code>, and <code>Table</code> objects.</p>"},{"location":"getting_started/0_quickstart/#next-steps","title":"Next steps","text":"<p>To learn how to work with the <code>OME-Zarr Container</code> object, but also with the image, label, and table data, check out the following guides:</p> <ul> <li>OME-Zarr Container: An overview on how to use the OME-Zarr Container object and how to create new images and labels.</li> <li>Images/Labels: To know more on how to work with image data.</li> <li>Tables: To know more on how to work with table data, and how you can combine tables with image data.</li> <li>Masked Images/Labels: To know more on how to work with masked image data.</li> <li>HCS Plates: To know more on how to work with HCS plate data.</li> </ul> <p>Also, checkout our jupyer notebook tutorials for more examples:</p> <ul> <li>Image Processing: Learn how to perform simple image processing operations.</li> <li>Image Segmentation: Learn how to create new labels from images.</li> <li>Feature Extraction: Learn how to extract features from images.</li> <li>HCS Processing: Learn how to process high-content screening data using ngio.</li> </ul>"},{"location":"getting_started/1_ome_zarr_containers/","title":"1. OME-Zarr Container","text":"<p>Let's see how to open and explore an OME-Zarr image using <code>ngio</code>:</p> <pre><code>from pathlib import Path\nfrom ngio import open_ome_zarr_container\nfrom ngio.utils import download_ome_zarr_dataset\n\n# Download a sample dataset\ndownload_dir = Path(\"./data\")\nhcs_path = download_ome_zarr_dataset(\"CardiomyocyteSmallMip\", download_dir=download_dir)\nimage_path = hcs_path / \"B\" / \"03\" / \"0\"\n\n# Open the OME-Zarr container\nome_zarr_container = open_ome_zarr_container(image_path)\n</code></pre> <p>The <code>OME-Zarr Container</code> in is your entry point to working with OME-Zarr images. It provides high-level access to the image metadata, images, labels, and tables.</p> <pre><code>&gt;&gt;&gt; ome_zarr_container\nOmeZarrContainer(levels=5, #labels=4, #tables=7)\n</code></pre> <p>The <code>OME-Zarr Container</code> will be the starting point for all your image processing tasks.</p>"},{"location":"getting_started/1_ome_zarr_containers/#main-concepts","title":"Main concepts","text":""},{"location":"getting_started/1_ome_zarr_containers/#what-is-the-ome-zarr-container","title":"What is the OME-Zarr container?","text":"<p>The <code>OME-Zarr Container</code> in ngio is your entry point to working with OME-Zarr images.</p> <p>It provides:</p> <ul> <li>OME-Zarr overview: get an overview of the OME-Zarr file, including the number of image levels, list of labels, and tables available.</li> <li>Image access: get access to the images at different resolution levels and pixel sizes.</li> <li>Label management: check which labels are available, access them, and create new labels.</li> <li>Table management: check which tables are available, access them, and create new tables.</li> <li>Derive new OME-Zarr images: create new images based on the original one, with the same or similar metadata.</li> </ul>"},{"location":"getting_started/1_ome_zarr_containers/#what-is-the-ome-zarr-container-not","title":"What is the OME-Zarr container not?","text":"<p>The <code>OME-Zarr Container</code> object does not allow the user to interact with the image data directly. For that, we need to use the <code>Image</code>, <code>Label</code>, and <code>Table</code> objects.</p>"},{"location":"getting_started/1_ome_zarr_containers/#ome-zarr-overview","title":"OME-Zarr overview","text":"<p>Examples of the OME-Zarr metadata access:</p> Number of Resolution LevelsAvailable PathsDimensionalityFull Metadata Object <p>Show the number of resolution levels: <pre><code>&gt;&gt;&gt; ome_zarr_container.levels # Show the number of resolution levels\n5\n</code></pre></p> <p>Show the paths to all available resolution levels: <pre><code>&gt;&gt;&gt; ome_zarr_container.levels_paths # Show the paths to all available images\n['0', '1', '2', '3', '4']\n</code></pre></p> <p>Show if the image is 2D or 3D: <pre><code>&gt;&gt;&gt; ome_zarr_container.is_3d # Get if the image is 3D\nFalse\n</code></pre> or if the image is a time series: <pre><code>&gt;&gt;&gt; ome_zarr_container.is_time_series # Get if the image is a time series\nFalse\n</code></pre></p> <p><pre><code>&gt;&gt;&gt; metadata = ome_zarr_container.image_meta\nNgioImageMeta(name=None, datasets=['0', '1', '2', '3', '4'], axes=('c', 'z', 'y', 'x'))\n</code></pre> The metadata object contains all the information about the image, for example, the channel labels: <pre><code>&gt;&gt;&gt; metadata.channels_meta.channel_labels\n['DAPI', 'nanog', 'Lamin B1']\n</code></pre></p>"},{"location":"getting_started/1_ome_zarr_containers/#accessing-images-labels-tables","title":"Accessing images / labels / tables","text":"<p>To access images, labels, and tables, you can use the <code>get_image</code>, <code>get_label</code>, and <code>get_table</code> methods of the <code>OME-Zarr Container</code> object.</p> <p>A variety of examples and additional information can be found in the Images and Labels, and Tables sections.</p>"},{"location":"getting_started/1_ome_zarr_containers/#creating-derived-images","title":"Creating derived images","text":"<p>When processing an image, you might want to create a new image with the same metadata:</p> <pre><code># Create a new image based on the original\nnew_image = ome_zarr_container.derive_image(\"data/new_ome.zarr\", overwrite=True)\n</code></pre> <p>This will create a new OME-Zarr image with the same metadata as the original image. But you can also create a new image with slightly different metadata, for example, with a different shape:</p> <pre><code># Create a new image with a different shape\nnew_image = ome_zarr_container.derive_image(\n    \"data/new_ome.zarr\", \n    overwrite=True, \n    shape=(16, 128, 128), \n    xy_pixelsize=0.65, \n    z_spacing=1.0\n)\n</code></pre>"},{"location":"getting_started/1_ome_zarr_containers/#creating-new-images","title":"Creating new images","text":"<p>You can create OME-Zarr images from an existing numpy array using the <code>create_ome_zarr_from_array</code> function.</p> <pre><code>import numpy as np\nfrom ngio import create_ome_zarr_from_array\n\n# Create a random 3D array\nx = np.random.randint(0, 255, (16, 128, 128), dtype=np.uint8)\n\n# Save as OME-Zarr\nnew_ome_zarr_image = create_ome_zarr_from_array(\n    store=\"random_ome.zarr\", \n    array=x, \n    xy_pixelsize=0.65, \n    z_spacing=1.0\n)\n</code></pre> <p>Alternatively, if you wanto to create an a empty OME-Zarr image, you can use the <code>create_empty_ome_zarr</code> function:</p> <pre><code>from ngio import create_empty_ome_zarr\n# Create an empty OME-Zarr image\nnew_ome_zarr_image = create_empty_ome_zarr(\n    store=\"empty_ome.zarr\", \n    shape=(16, 128, 128), \n    xy_pixelsize=0.65, \n    z_spacing=1.0\n)\n</code></pre> <p>This will create an empty OME-Zarr image with the specified shape and pixel sizes.</p>"},{"location":"getting_started/1_ome_zarr_containers/#opening-remote-ome-zarr-containers","title":"Opening remote OME-Zarr containers","text":"<p>You can use <code>ngio</code> to open remote OME-Zarr containers. For publicly available OME-Zarr containers, you can just use the <code>open_ome_zarr_container</code> function with a URL.</p> <p>For example, to open a remote OME-Zarr container hosted on a github repository:</p> <pre><code>from ngio.utils import fractal_fsspec_store\n\nurl = (\n    \"https://raw.githubusercontent.com/\"\n    \"fractal-analytics-platform/fractal-ome-zarr-examples/\"\n    \"refs/heads/main/v04/\"\n    \"20200812-CardiomyocyteDifferentiation14-Cycle1_B_03_mip.zarr/\"\n)\n\nstore = fractal_fsspec_store(url=url)\nome_zarr_container = open_ome_zarr_container(store)\n</code></pre> <p>For fractal users, the <code>fractal_fsspec_store</code> function can be used to open private OME-Zarr containers. In this case we need to provide a <code>fractal_token</code> to authenticate the user.</p> <pre><code>from ngio.utils import fractal_fsspec_store\n\nstore = fractal_fsspec_store(url=\"https://fractal_url...\", fractal_token=\"**your_secret_token**\")\nome_zarr_container = open_ome_zarr_container(store)\n</code></pre>"},{"location":"getting_started/2_images/","title":"2. Images and Labels","text":""},{"location":"getting_started/2_images/#images","title":"Images","text":"<p>In order to start working with the image data, we need to instantiate an <code>Image</code> object. ngio provides a high-level API to access the image data at different resolution levels and pixel sizes.</p>"},{"location":"getting_started/2_images/#getting-an-image","title":"Getting an image","text":"Highest Resolution ImageSpecific Pyramid LevelSpecific ResolutionNearest Resolution <p>By default, the <code>get_image</code> method returns the highest resolution image: <pre><code>&gt;&gt;&gt; ome_zarr_container.get_image() # Get the highest resolution image\nImage(path=0, Dimensions(c: 3, z: 1, y: 4320, x: 5120))\n</code></pre></p> <p>To get a specific pyramid level, you can use the <code>path</code> parameter: <pre><code>&gt;&gt;&gt; ome_zarr_container.get_image(path=\"1\") # Get a specific pyramid level\nImage(path=1, Dimensions(c: 3, z: 1, y: 2160, x: 2560))\n</code></pre> This will return the image at the specified pyramid level.</p> <p>If you want to get an image with a specific pixel size, you can use the <code>pixel_size</code> parameter: <pre><code>&gt;&gt;&gt; from ngio import PixelSize\n&gt;&gt;&gt; pixel_size = PixelSize(x=0.65, y=0.65, z=1.0)\n&gt;&gt;&gt; ome_zarr_container.get_image(pixel_size=pixel_size)\nImage(path=2, Dimensions(c: 3, z: 1, y: 1080, x: 1280))\n</code></pre></p> <p>By default the pixels must match exactly the requested pixel size. If you want to get the nearest resolution, you can use the <code>strict</code> parameter: <pre><code>&gt;&gt;&gt; from ngio import PixelSize\n&gt;&gt;&gt; pixel_size = PixelSize(x=0.60, y=0.60, z=1.0)\n&gt;&gt;&gt; ome_zarr_container.get_image(pixel_size=pixel_size, strict=False)\nImage(path=2, Dimensions(c: 3, z: 1, y: 1080, x: 1280))\n</code></pre> This will return the image with the nearest resolution to the requested pixel size.</p> <p>Similarly to the <code>OME-Zarr Container</code>, the <code>Image</code> object provides a high-level API to access the image metadata.</p> DimensionsPixel SizeOn disk array infos <p><pre><code>&gt;&gt;&gt; image.dimensions\nDimensions(c: 3, z: 1, y: 1080, x: 1280)\n</code></pre> The <code>dimensions</code> attribute returns a object with the image dimensions for each axis.</p> <p><pre><code>&gt;&gt;&gt; image.pixel_size\nPixelSize(x=0.65, y=0.65, z=1.0, t=1.0)\n</code></pre> The <code>pixel_size</code> attribute returns the pixel size for each axis.</p> <p><pre><code>&gt;&gt;&gt; image.shape, image.dtype, image.chunks\n(3, 1, 1080, 1280) uint16 (1, 1, 1080, 1280)\n</code></pre> The <code>axes</code> attribute returns the order of the axes in the image.</p>"},{"location":"getting_started/2_images/#working-with-image-data","title":"Working with image data","text":"<p>Once you have the <code>Image</code> object, you can access the image data as a:</p> Numpy ArrayDask ArrayLegacy <pre><code>&gt;&gt;&gt; data = image.get_as_numpy() # Get the image as a numpy array\n&gt;&gt;&gt; data.shape, data.dtype\n(3, 1, 1080, 1280) uint16\n</code></pre> <pre><code>&gt;&gt;&gt; dask_array = image.get_as_dask() # Get the image as a dask array\n&gt;&gt;&gt; dask_array\ndask.array&lt;from-zarr, shape=(3, 1, 1080, 1280), dtype=uint16, chunksize=(1, 1, 1080, 1280), chunktype=numpy.ndarray&gt;\n</code></pre> <p>A generic <code>get_array</code> method is still available for backwards compatibility.</p> <pre><code>&gt;&gt;&gt; data = image.get_array(mode=\"numpy\") # Get the image as a numpy or dask or delayed object\n&gt;&gt;&gt; data.shape, data.dtype\n(3, 1, 1080, 1280) uint16\n</code></pre> <p>The <code>get_as_*</code> can also be used to slice the image data, and query specific axes in specific orders:</p> <pre><code>&gt;&gt;&gt; image_slice = image.get_as_numpy(c=0, x=slice(0, 128), axes_order=[\"t\", \"z\", \"y\", \"x\", \"c\"]) # Get a specific channel and axes order\n&gt;&gt;&gt; image_slice.shape\n(1, 1, 1080, 128, 1)\n</code></pre> <p>If you want to edit the image data, you can use the <code>set_array</code> method:</p> <pre><code>&gt;&gt;&gt; image.set_array(data) # Set the image data\n</code></pre> <p>The <code>set_array</code> method can be used to set the image data from a numpy array, dask array, or dask delayed object.</p> <p>A minimal example of how to use the <code>get_array</code> and <code>set_array</code> methods:</p> <pre><code># Get the image data as a numpy array\ndata = image.get_as_numpy(c=0, x=slice(0, 128), y=slice(0, 128), axes_order=[\"z\", \"y\", \"x\", \"c\"])\n\n# Modify the image data\ndata = some_function(data)\n\n# Set the modified image data\nimage.set_array(data, c=0, x=slice(0, 128), y=slice(0, 128), axes_order=[\"z\", \"y\", \"x\", \"c\"])\nimage.consolidate() # Consolidate the changes to all resolution levels, see below for more details\n</code></pre> <p>Important</p> <p>The <code>set_array</code> method will overwrite the image data at single resolution level. After you have finished editing the image data, you need to <code>consolidate</code> the changes to the OME-Zarr file at all resolution levels: <pre><code>&gt;&gt;&gt; image.consolidate() # Consolidate the changes\n</code></pre> This will write the changes to the OME-Zarr file at all resolution levels.</p>"},{"location":"getting_started/2_images/#labels","title":"Labels","text":"<p><code>Labels</code> represent segmentation masks that identify objects in the image. In ngio <code>Labels</code> are similar to <code>Images</code> and can be accessed and manipulated in the same way.</p>"},{"location":"getting_started/2_images/#getting-a-label","title":"Getting a label","text":"<p>Now let's see what labels are available in our image:</p> <pre><code>&gt;&gt;&gt; ome_zarr_container.list_labels() # Available labels\n['nuclei', 'wf_2_labels', 'wf_3_labels', 'wf_4_labels']\n</code></pre> <p>We have <code>4</code> labels available in our image. Let's see how to access them:</p> Highest Resolution LabelSpecific Pyramid LevelSpecific ResolutionNearest Resolution <p>By default, the <code>get_label</code> method returns the highest resolution label: <pre><code>&gt;&gt;&gt; ome_zarr_container.get_label(\"nuclei\") # Get the highest resolution label\nLabel(path=0, Dimensions(z: 1, y: 4320, x: 5120))\n</code></pre></p> <p>To get a specific pyramid level, you can use the <code>path</code> parameter: <pre><code>&gt;&gt;&gt; ome_zarr_container.get_label(\"nuclei\", path=\"1\") # Get a specific pyramid level\nLabel(path=1, Dimensions(z: 1, y: 2160, x: 2560))\n</code></pre> This will return the label at the specified pyramid level.</p> <p>If you want to get a label with a specific pixel size, you can use the <code>pixel_size</code> parameter: <pre><code>&gt;&gt;&gt; from ngio import PixelSize\n&gt;&gt;&gt; pixel_size = PixelSize(x=0.65, y=0.65, z=1.0)\n&gt;&gt;&gt; ome_zarr_container.get_label(\"nuclei\", pixel_size=pixel_size)\nLabel(path=2, Dimensions(z: 1, y: 1080, x: 1280))\n</code></pre></p> <p>By default the pixels must match exactly the requested pixel size. If you want to get the nearest resolution, you can use the <code>strict</code> parameter: <pre><code>&gt;&gt;&gt; from ngio import PixelSize\n&gt;&gt;&gt; pixel_size = PixelSize(x=0.60, y=0.60, z=1.0)\n&gt;&gt;&gt; ome_zarr_container.get_label(\"nuclei\", pixel_size=pixel_size, strict=False)\nLabel(path=2, Dimensions(z: 1, y: 1080, x: 1280))\n</code></pre> This will return the label with the nearest resolution to the requested pixel size.</p>"},{"location":"getting_started/2_images/#working-with-label-data","title":"Working with label data","text":"<p>Data access and manipulation for <code>Labels</code> is similar to <code>Images</code>. You can use the <code>get_array</code> and <code>set_array</code> methods to access and modify the label data.</p>"},{"location":"getting_started/2_images/#deriving-a-label","title":"Deriving a label","text":"<p>Often, you might want to create a new label based on an existing image. You can do this using the <code>derive_label</code> method:</p> <pre><code>&gt;&gt;&gt; new_label = ome_zarr_container.derive_label(\"new_label\", overwrite=True) # Derive a new label\nLabel(path=0, Dimensions(z: 1, y: 4320, x: 5120))\n</code></pre> <p>This will create a new label with the same dimensions as the original image (without channels) and compatible metadata. If you want to create a new label with slightly different metadata see API Reference.</p>"},{"location":"getting_started/3_tables/","title":"3. Tables","text":"<p>Tables are not part of the core OME-Zarr specification but can be used in ngio to store measurements, features, regions of interest (ROIs), and other tabular data. Ngio follows the Fractal's Table Spec.</p>"},{"location":"getting_started/3_tables/#getting-a-table","title":"Getting a table","text":"<p>We can list all available tables and load a specific table:</p> <pre><code>&gt;&gt;&gt; ome_zarr_container.list_tables()\n['FOV_ROI_table', 'nuclei_ROI_table', 'well_ROI_table', 'regionprops_DAPI', 'nuclei_measurements_wf3', 'nuclei_measurements_wf4', 'nuclei_lamin_measurements_wf4']\n</code></pre> <p>Ngio supports three types of tables: <code>roi_table</code>, <code>feature_table</code>, and <code>masking_roi_table</code>, as well as untyped <code>generic_table</code>.</p> ROI TableMasking ROI TableFeatures Table <p>ROI tables can be used to store arbitrary regions of interest (ROIs) in the image. Here for example we will load the <code>FOV_ROI_table</code> that contains the microscope field of view (FOV) ROIs: <pre><code>&gt;&gt;&gt; roi_table = ome_zarr_container.get_table(\"FOV_ROI_table\") # Get a ROI table\n&gt;&gt;&gt; roi_table.get(\"FOV_1\")\nRoi(t=None, z=0.0-&gt;1.0, y=0.0-&gt;351.0, x=0.0-&gt;416.0)\n</code></pre> 2025-09-29T09:26:57.695157 image/svg+xml Matplotlib v3.10.6, https://matplotlib.org/    This will return all the ROIs in the table. ROIs can be used to slice the image data: <pre><code>&gt;&gt;&gt; roi = roi_table.get(\"FOV_1\")\n&gt;&gt;&gt; roi_data = image.get_roi(roi)\n&gt;&gt;&gt; roi_data.shape\n(3, 1, 540, 640)\n</code></pre> This will return the image data for the specified ROI.  2025-09-29T09:26:57.852930 image/svg+xml Matplotlib v3.10.6, https://matplotlib.org/ </p> <p>Masking ROIs are a special type of ROIs that can be used to store ROIs for masked objects in the image. The <code>nuclei_ROI_table</code> contains the masks for the <code>nuclei</code> label in the image, and is indexed by the label id. <pre><code>&gt;&gt;&gt; masking_table = ome_zarr_container.get_table(\"nuclei_ROI_table\") # Get a mask table\n&gt;&gt;&gt; masking_table.get_label(1)\nRoi(t=None, z=0.0-&gt;1.0, y=18.850000381469727-&gt;14.625, x=33.63750076293945-&gt;11.375, label=100)\n</code></pre> ROIs can be used to slice the image data: <pre><code>&gt;&gt;&gt; roi = masking_table.get_label(100)\n&gt;&gt;&gt; roi_data = image.get_roi(roi)\n&gt;&gt;&gt; roi_data.shape\n(3, 1, 23, 19)\n</code></pre> This will return the image data for the specified ROI.  2025-09-29T09:26:58.051904 image/svg+xml Matplotlib v3.10.6, https://matplotlib.org/    See 4. Masked Images and Labels for more details on how to use the masking ROIs to load masked data.</p> <p>Features tables are used to store measurements and are indexed by the label id <pre><code>&gt;&gt;&gt; feature_table = ome_zarr_container.get_table(\"regionprops_DAPI\") # Get a feature table\n&gt;&gt;&gt; feature_table.dataframe.head(5) # only show the first 5 rows\n</code></pre> label area bbox_area equivalent_diameter max_intensity mean_intensity min_intensity standard_deviation_intensity 1 2120 2655 15.9384 476 278.636 86 54.3438 2 327 456 8.54771 604 324.162 118 90.8471 3 1381 1749 13.8165 386 212.682 60 50.1696 4 2566 3588 16.9858 497 251.731 61 53.3072 5 4201 5472 20.0194 466 223.863 51 56.719 </p>"},{"location":"getting_started/3_tables/#creating-a-table","title":"Creating a table","text":"<p>Tables (differently from Images and Labels) can be purely in memory objects, and don't need to be saved on disk.</p> Creating a ROI TableCreating a Masking ROI TableCreating a Feature TableCreating a Generic Table <p><pre><code>&gt;&gt;&gt; from ngio.tables import RoiTable\n&gt;&gt;&gt; from ngio import Roi\n&gt;&gt;&gt; roi = Roi(x=0, y=0, x_length=128, y_length=128, name=\"FOV_1\")\n&gt;&gt;&gt; roi_table = RoiTable(rois=[roi])\nRoiTableV1(num_rois=1)\n</code></pre> If you would like to create on-the-fly a ROI table for the whole image: <pre><code>&gt;&gt;&gt; roi_table = ome_zarr_container.build_image_roi_table(\"whole_image\")\n&gt;&gt;&gt; roi_table\nRoiTableV1(num_rois=1)\n</code></pre> The <code>build_image_roi_table</code> method will create a ROI table with a single ROI that covers the whole image. This table is not associated with the image and is purely in memory. If we want to save it to disk, we can use the <code>add_table</code> method: <pre><code>&gt;&gt;&gt; ome_zarr_container.add_table(\"new_roi_table\", roi_table, overwrite=True)\n&gt;&gt;&gt; roi_table = ome_zarr_container.get_table(\"new_roi_table\")\nRoiTableV1(num_rois=1)\n</code></pre></p> <p>Similarly to the ROI table, we can create a masking ROI table on-the-fly: Let's for example create a masking ROI table for the <code>nuclei</code> label: <pre><code>&gt;&gt;&gt; masking_table = ome_zarr_container.build_masking_roi_table(\"nuclei\")\n&gt;&gt;&gt; masking_table\nMaskingRoiTableV1(num_rois=3006, reference_label=nuclei)\n</code></pre></p> <p>Feature tables can be created from a pandas <code>Dataframe</code>: <pre><code>&gt;&gt;&gt; from ngio.tables import FeatureTable\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; example_data = pd.DataFrame({\"label\": [1, 2, 3], \"area\": [100, 200, 300]})\n&gt;&gt;&gt; feature_table = FeatureTable(table_data=example_data)\n&gt;&gt;&gt; feature_table\nFeatureTableV1(num_rows=3, num_columns=1)\n</code></pre></p> <p>Sometimes you might want to create a table that doesn't fit into the <code>ROI</code>, <code>Masking ROI</code>, or <code>Feature</code> categories. In this case, you can use the <code>GenericTable</code> class, which allows you to store any tabular data. It can be created from a pandas <code>Dataframe</code>: <pre><code>&gt;&gt;&gt; from ngio.tables import GenericTable\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; example_data = pd.DataFrame({\"area\": [100, 200, 300], \"perimeter\": [50, 60, 70]})\n&gt;&gt;&gt; generic_table = GenericTable(table_data=example_data)\n&gt;&gt;&gt; generic_table\nGenericTable\n</code></pre> Or from an \"AnnData\" object: <pre><code>&gt;&gt;&gt; from ngio.tables import GenericTable\n&gt;&gt;&gt; import anndata as ad\n&gt;&gt;&gt; adata = ad.AnnData(X=np.random.rand(10, 5), obs=pd.DataFrame({\"cell_type\": [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\"]}))\n&gt;&gt;&gt; generic_table = GenericTable(table_data=adata)\n&gt;&gt;&gt; generic_table\nGenericTable\n</code></pre> The <code>GenericTable</code> class allows you to store any tabular data, and is a flexible way to work with tables in ngio.</p>"},{"location":"getting_started/4_masked_images/","title":"4. Masked Images and Labels","text":"<p>Masked images (or labels) are images that are masked by an instance segmentation mask.</p> <p>In this section we will show how to create a <code>MaskedImage</code> object and how to use it to get the data of the image.</p> <p></p> <p>Similar to the <code>Image</code> and <code>Label</code> objects, the <code>MaskedImage</code> can be initialized from an <code>OME-Zarr Container</code> object using the <code>get_masked_image</code> method.</p> <p>Let's create a masked image from the <code>nuclei</code> label:</p> <pre><code>&gt;&gt;&gt; masked_image = ome_zarr_container.get_masked_image(\"nuclei\")\n&gt;&gt;&gt; masked_image\nMaskedImage(path=0, Dimensions(c: 3, z: 1, y: 4320, x: 5120), nuclei)\n</code></pre> <p>Since the <code>MaskedImage</code> is a subclass of <code>Image</code>, we can use all the methods available for <code>Image</code> objects.</p> <p>The two most notable exceptions are the <code>get_roi</code> and <code>set_roi</code> which now instead of requiring a <code>roi</code> object, require an integer <code>label</code>.</p> <pre><code>&gt;&gt;&gt; roi_data = masked_image.get_roi(label=1009, c=0)\n&gt;&gt;&gt; roi_data.shape\n(1, 77, 84)\n</code></pre> 2025-09-29T09:26:59.555222 image/svg+xml Matplotlib v3.10.6, https://matplotlib.org/ <p>Additionally we can used the <code>zoom_factor</code> argument to get more context around the ROI. For example we can zoom out the ROI by a factor of <code>2</code>:</p> <pre><code>&gt;&gt;&gt; roi_data = masked_image.get_roi(label=1009, c=0, zoom_factor=2)\n&gt;&gt;&gt; roi_data.shape\n(1, 154, 167)\n</code></pre> 2025-09-29T09:26:59.620749 image/svg+xml Matplotlib v3.10.6, https://matplotlib.org/"},{"location":"getting_started/4_masked_images/#masked-operations","title":"Masked operations","text":"<p>In addition to the <code>get_roi</code> method, the <code>MaskedImage</code> class also provides a masked operation method that allows you to perform reading and writing only on the masked pixels.</p> <p>For these operations we can use the <code>get_roi_masked</code> and <code>set_roi_masked</code> methods. For example, we can use the <code>get_roi_masked</code> method to get the masked data for a specific label:</p> <pre><code>&gt;&gt;&gt; masked_roi_data = masked_image.get_roi_masked(label=1009, c=0, zoom_factor=2)\n&gt;&gt;&gt; masked_roi_data.shape\n(1, 154, 167)\n</code></pre> 2025-09-29T09:26:59.726726 image/svg+xml Matplotlib v3.10.6, https://matplotlib.org/ <p>We can also use the <code>set_roi_masked</code> method to set the masked data for a specific label:</p> <pre><code>&gt;&gt;&gt; masked_data = masked_image.get_roi_masked(label=1009, c=0)\n&gt;&gt;&gt; masked_data = np.random.randint(0, 255, masked_data.shape, dtype=np.uint8)\n&gt;&gt;&gt; masked_image.set_roi_masked(label=1009, c=0, patch=masked_data)\n</code></pre> 2025-09-29T09:26:59.826748 image/svg+xml Matplotlib v3.10.6, https://matplotlib.org/"},{"location":"getting_started/4_masked_images/#masked-labels","title":"Masked Labels","text":"<p>The <code>MaskedLabel</code> class is a subclass of <code>Label</code> and provides the same functionality as the <code>MaskedImage</code> class.</p> <p>The <code>MaskedLabel</code> class can be used to create a masked label from an <code>OME-Zarr Container</code> object using the <code>get_masked_label</code> method.</p> <pre><code>&gt;&gt;&gt; masked_label = ome_zarr_container.get_masked_label(label_name = \"wf_2_labels\", masking_label_name = \"nuclei\")\n&gt;&gt;&gt; masked_label\nMaskedLabel(path=0, Dimensions(z: 1, y: 4320, x: 5120), nuclei)\n</code></pre>"},{"location":"getting_started/5_hcs/","title":"5. HCS Plates","text":"<p>Ngio provides a simple interface for high-content screening (HCS) plates. An HCS plate is a collection of OME-Zarr images organized in a grid-like structure. Each plates contains columns and rows, and each well in the plate is identified by its row and column indices. Each well can contain multiple images, and each image can belong to a different acquisition.</p> <p>The HCS plate is represented by the <code>OmeZarrPlate</code> class.</p> <p>Let's open an <code>OmeZarrPlate</code> object.</p> <pre><code>&gt;&gt;&gt; from ngio.utils import download_ome_zarr_dataset\n&gt;&gt;&gt; from ngio import open_ome_zarr_plate\n&gt;&gt;&gt; hcs_path = download_ome_zarr_dataset(\"CardiomyocyteSmallMip\", download_dir=download_dir)\n&gt;&gt;&gt; ome_zarr_plate = open_ome_zarr_plate(hcs_path)\n&gt;&gt;&gt; ome_zarr_plate\nPlate([rows x columns] (1 x 1))\n</code></pre> <p>This example plate is very small and contains only a single well.</p>"},{"location":"getting_started/5_hcs/#plate-overview","title":"Plate overview","text":"<p>The <code>OmeZarrPlate</code> object provides a high-level overview of the plate, including rows, columns, and acquisitions. The following methods are available:</p> ColumnsRowsAcquisitions <p>Show the columns in the plate: <pre><code>&gt;&gt;&gt; ome_zarr_plate.columns\n['03']\n</code></pre></p> <p>Show the rows in the plate: <pre><code>&gt;&gt;&gt; ome_zarr_plate.rows\n['B']\n</code></pre></p> <p>Show the acquisitions ids: <pre><code>&gt;&gt;&gt; ome_zarr_plate.acquisition_ids\n[0]\n</code></pre></p>"},{"location":"getting_started/5_hcs/#retrieving-the-path-to-the-images","title":"Retrieving the path to the images","text":"<p>The <code>OmeZarrPlate</code> object provides multiple methods to retrieve the path to the images in the plate.</p> All Images PathsAll Wells PathsAll Images Paths in a Well <p>This will return the paths to all images in the plate: <pre><code>&gt;&gt;&gt; ome_zarr_plate.images_paths()\n['B/03/0']\n</code></pre></p> <p>This will return the paths to all wells in the plate: <pre><code>&gt;&gt;&gt; ome_zarr_plate.wells_paths()\n['B/03']\n</code></pre></p> <p>This will return the paths to all images in a well: <pre><code>&gt;&gt;&gt; ome_zarr_plate.well_images_paths(row=\"B\", column=3)\n['B/03/0']\n</code></pre></p>"},{"location":"getting_started/5_hcs/#getting-the-images","title":"Getting the images","text":"<p>The <code>OmeZarrPlate</code> object provides a method to get the image objects in a well. The method <code>get_well_images</code> takes the row and column indices of the well and returns a list of <code>OmeZarrContainer</code> objects.</p> All ImagesAll Images in a WellSpecific ImageFilter by Acquisition <p>Get all images in the plate: <pre><code>&gt;&gt;&gt; ome_zarr_plate.get_images()\n&gt;&gt;&gt; ome_zarr_plate\n{'B/03/0': OmeZarrContainer(levels=5, #labels=4, #tables=7)}\n</code></pre> This dictionary contains the path to the images and the corresponding <code>OmeZarrContainer</code> object.</p> <p>Get all images in a well: <pre><code>&gt;&gt;&gt; well_images = ome_zarr_plate.get_well_images(row=\"B\", column=3)\n&gt;&gt;&gt; well_images\n{'B/03/0': OmeZarrContainer(levels=5, #labels=4, #tables=7)}\n</code></pre> This dictionary contains the path to the images and the corresponding <code>OmeZarrContainer</code> object.</p> <p>Get a specific image in a well: <pre><code>&gt;&gt;&gt; ome_zarr_plate.get_image(row=\"B\", column=3, image_path=\"0\")\nOmeZarrContainer(levels=5, #labels=4, #tables=7)\n</code></pre> This will return the <code>OmeZarrContainer</code> object for the image in the well.</p> <p>In these methods, you can also filter the images by acquisition. When available, the <code>acquisition</code> parameter can be used to filter the images by acquisition id. <pre><code>&gt;&gt;&gt; well_images = ome_zarr_plate.get_well_images(row=\"B\", column=3, acquisition=0)\n&gt;&gt;&gt; well_images\n{}\n</code></pre> The <code>acquisition</code> is not required, and if not provided, an empty dictionary will be returned.</p>"},{"location":"getting_started/5_hcs/#creating-a-plate","title":"Creating a plate","text":"<p>Ngio provides a utility function to create a plate.</p> <p>The first step is to create a list of <code>ImageInWellPath</code> objects. Each <code>ImageInWellPath</code> object contains the path to the image and the corresponding well.</p> <pre><code>from ngio import ImageInWellPath\nlist_of_images = [ImageInWellPath(path=\"0\", row=\"A\", column=0),\n                    ImageInWellPath(path=\"0\", row=\"B\", column=1),\n                    ImageInWellPath(path=\"0\", row=\"C\", column=1),\n                    ImageInWellPath(path=\"1\", row=\"A\", column=0, acquisition_id=1, acquisition_name=\"acquisition_1\"),\n]\n</code></pre> <p>Note</p> <p>The order in which the images are added is not important. The <code>rows</code> and <code>columns</code> attributes of the plate will be sorted in alphabetical/numerical order.</p> <p>Then, you can create the plate using the <code>create_empty_plate</code> function.</p> <pre><code>&gt;&gt;&gt; from ngio import create_empty_plate\n&gt;&gt;&gt; plate = create_empty_plate(store=\"new_plate.zarr\", name=\"test_plate\", images=list_of_images, overwrite=True)\n&gt;&gt;&gt; plate\nPlate([rows x columns] (3 x 2))\n</code></pre> <p>This has created a new empty plate with the metadata correctly set. But no images have been added yet.</p>"},{"location":"getting_started/5_hcs/#modifying-the-plate","title":"Modifying the plate","text":"<p>You can add images or remove images</p> Add ImagesRemove Images <p>To add images to the plate, you can use the <code>add_image</code> method. This method takes the row and column indices of the well and the path to the image. <pre><code>&gt;&gt;&gt; print(f\"Before adding images: {plate.rows} rows, {plate.columns} columns\")\n&gt;&gt;&gt; plate.add_image(row=\"D\", column=0, image_path=\"0\")\n&gt;&gt;&gt; print(f\"After adding images: {plate.rows} rows, {plate.columns} columns\")\nBefore adding images: ['A', 'B', 'C'] rows, ['0', '1'] columns\nAfter adding images: ['A', 'B', 'C', 'D'] rows, ['0', '1'] columns\n</code></pre> This will add a new image to the plate and well metadata.</p> <p>Note</p> <p>The order in which the images are added is not important. The <code>rows</code> and <code>columns</code> attributes of the plate will be sorted in alphabetical/numerical order.</p> <p>Warning</p> <p>This function is not multiprocessing safe. If you are using multiprocessing, you should use the <code>atomic_add_image</code> method instead.</p> <p>To remove images from the plate, you can use the <code>remove_image</code> method. This method takes the row and column indices of the well and the path to the image. <pre><code>&gt;&gt;&gt; print(f\"Before removing images: {plate.wells_paths()} wells\")\n&gt;&gt;&gt; plate.remove_image(row=\"D\", column=0, image_path=\"0\")\n&gt;&gt;&gt; print(f\"After removing images: {plate.wells_paths()} wells\")\nBefore removing images: ['A/0', 'B/1', 'C/1', 'D/0'] wells\nAfter removing images: ['A/0', 'B/1', 'C/1'] wells\n</code></pre> This will remove the image metadata from the plate and well metadata.</p> <p>Warning</p> <p>No data will be removed from the store. If an image is saved in the store it will remain there. Also the metadata will only be removed from the plate.well metadata. The number of columns and rows will not be updated. This function is not multiprocessing safe. If you are using multiprocessing, you should use the <code>atomic_remove_image</code> method instead.</p>"},{"location":"table_specs/backend/","title":"Table Backends","text":"<p>In ngio we implemented four different table backends. Each table backend is a python class that can serialize tabular data into OME-Zarr containers.</p> <p>These backends are wrappers around existing tooling implemented in <code>anndata</code>, <code>pandas</code>, and <code>polars</code>. Currently, we provide a thin layer of metadata and table normalization to ensure that tables are serialized/deserialized in a consistent way across the different backends and across different table objects.</p> <p>In particular, we provide the metadata that describes the intended index key and type of the table for each backend.</p>"},{"location":"table_specs/backend/#anndata-backend","title":"AnnData Backend","text":"<p>AnnData is a widely used format in single-cell genomics, and can natively store complex tabular data in a Zarr group. The AnnData backend in ngio is a wrapper around the <code>anndata</code> library, which performs some table normalization for consistency and compatibility with the ngio table specifications.</p> <p>The following normalization steps are applied to each table before saving it to the AnnData backend:</p> <ul> <li>We separate the table in two parts: The floating point columns are casted to <code>float32</code> and stored as <code>X</code> in the AnnData object, while the categorical, boolean, and integer columns are stored as <code>obs</code>.</li> <li>The index column is cast to a string, and is stored in the <code>obs</code> index.</li> <li>The index column name must match the <code>index_key</code> specified in the metadata.</li> </ul> <p>AnnData backend metadata:</p> <pre><code>{\n    // Backend metadata\n    \"backend\": \"annadata\", // the backend used to store the table, e.g. \"annadata\", \"parquet\", etc..\n    \"index_key\": \"index\", // The default index key for the table, which is used to identify each row.\n    \"index_type\": \"str\", // Either \"int\" or \"str\"\n}\n</code></pre> <p>Additionally, the AnnData package will write some additional metadata to the group attributes</p> <pre><code>{\n    \"encoding-type\": \"anndata\",\n    \"encoding-version\": \"0.1.0\",\n}\n</code></pre>"},{"location":"table_specs/backend/#parquet-backend","title":"Parquet Backend","text":"<p>The Parquet backend is a high-performance columnar storage format that is widely used in big data processing. It is designed to efficiently store large datasets and can be used with various data processing frameworks. Another advantage of the Parquet backend is that it can be used lazily, meaning that the data is not loaded into memory until it is needed. This can be useful for working with large datasets that do not fit into memory.</p> <p>Parquet backend metadata:</p> <pre><code>{\n    // Backend metadata\n    \"backend\": \"parquet\", // the backend used to store the table, e.g. \"annadata\", \"parquet\", etc..\n    \"index_key\": \"index\", // The default index key for the table, which is used to identify each row.\n    \"index_type\": \"int\", // Either \"int\" or \"str\"\n}\n</code></pre> <p>The Zarr group directory will contain the Parquet file, and the metadata will be stored in the group attributes.</p> <pre><code>table.zarr          # Zarr group for the table\n\u251c\u2500\u2500 table.parquet   # Parquet file containing the table data\n\u251c\u2500\u2500 .zattrs         # Zarr group attributes containing the metadata\n\u2514\u2500\u2500 .zgroup         # Zarr group metadata\n</code></pre>"},{"location":"table_specs/backend/#csv-backend","title":"CSV Backend","text":"<p>The CSV backend is a plain text format that is widely used for tabular data. It is easy to read and write, and can be used across many different tools.</p> <p>The CSV backend in ngio follows closely the same specifications as the Parquet backend, with the following metadata:</p> <pre><code>{\n    // Backend metadata\n    \"backend\": \"csv\", // the backend used to store the table, e.g. \"annadata\", \"parquet\", etc..\n    \"index_key\": \"index\", // The default index key for the table, which is used to identify each row.\n    \"index_type\": \"int\", // Either \"int\" or \"str\"\n}\n</code></pre> <p>The Zarr group directory will contain the CSV file, and the metadata will be stored in the group attributes.</p> <pre><code>table.zarr         # Zarr group for the table\n\u251c\u2500\u2500 table.csv      # CSV file containing the table data\n\u251c\u2500\u2500 .zattrs        # Zarr group attributes containing the metadata\n\u2514\u2500\u2500 .zgroup        # Zarr group metadata\n</code></pre>"},{"location":"table_specs/backend/#json-backend","title":"JSON Backend","text":"<p>The JSON backend serializes the table data into the Zarr group attributes as a JSON object. This backend is useful for tiny tables.</p> <p>JSON backend metadata:</p> <pre><code>{\n    // Backend metadata\n    \"backend\": \"json\", // the backend used to store the table, e.g. \"annadata\", \"parquet\", etc..\n    \"index_key\": \"index\", // The default index key for the table, which is used to identify each row.\n    \"index_type\": \"int\" // Either \"int\" or \"str\"\n}\n</code></pre> <p>The table will be stored in a subgroup of the Zarr group, and the metadata will be stored in the group attributes. Storing the table in a subgroup instead of a standalone json file allows for easier access via the Zarr API.</p> <pre><code>table.zarr          # Zarr group for the table\n\u2514\u2500\u2500 table           # Zarr subgroup containing the table data\n    \u251c\u2500\u2500 .zattrs     # the json table data serialized as a JSON object\n    \u2514\u2500\u2500 .zgroup     # Zarr group metadata\n\u251c\u2500\u2500 .zattrs         # Zarr group attributes containing the metadata\n\u2514\u2500\u2500 .zgroup         # Zarr group metadata\n</code></pre>"},{"location":"table_specs/overview/","title":"Tables Overview","text":"<p>Ngio's architecture is designed to tightly integrate image and tabular data. For this purpose we developed custom specifications for serializing and deserializing tabular data into OME-Zarr containers, and semantically typed tables derived from the fractal table specification.</p>"},{"location":"table_specs/overview/#architecture","title":"Architecture","text":"<p>The ngio tables architectures is composed of three main components:</p>"},{"location":"table_specs/overview/#1-table-backends","title":"1. Table Backends","text":"<p>A backend module is a class that can serialize tabular data into OME-Zarr containers. We currently support four on-disk file formats:</p> <ul> <li>AnnData: Commonly used in single-cell genomics and was the standard table for the initial Fractal table spec.</li> <li>Parquet: A columnar storage file format optimized for large datasets.</li> <li>CSV: A simple text format for tabular data, easily human readable and writable.</li> <li>JSON: A lightweight data interchange format that both readable and efficient for small tables.</li> </ul> <p>A more detailed description of the backend module can be found in the Table Backends documentation.</p>"},{"location":"table_specs/overview/#2-in-memory-table-objects","title":"2. In-Memory Table Objects","text":"<p>These are Python objects that represent the tabular data in memory. They provide a convenient interface for manipulating and analyzing the data without needing to interact directly with the underlying file format. We support the following in-memory table objects:</p> <ul> <li>Pandas DataFrame: The most commonly used data structure for tabular data in Python.</li> <li>Polars LazyFrame: A fast DataFrame implementation that allows for lazy evaluation and efficient computation on large datasets.</li> <li>AnnData: A specialized data structure for single-cell genomics data, which goes beyond simple tabular data.</li> </ul> <p>We also provide utilities to convert between these in-memory representations in a standardized way based on the table type specifications/metadata.</p>"},{"location":"table_specs/overview/#3-table-type-specifications","title":"3. Table Type Specifications","text":"<p>These specifications define structured tables that standardize common table types used in image analysis. We have defined five table types so far:</p> <ul> <li>Generic Tables: A flexible table type that can represent any tabular data. See more in the Generic Tables documentation.</li> <li>ROI Tables: A table type specifically designed for representing Regions of Interest (ROIs) in images. See more in the ROI Tables documentation.</li> <li>Masking ROI Tables: A specialized table type for representing ROIs that are associated with specific labels in a OME-Zarr label image. See more in the Masking ROI Tables documentation.</li> <li>Feature Tables: A table type for representing features extracted from images. This table is also associated with a specific label image. See more in the Feature Tables documentation.</li> <li>Condition Tables: A table to represent experimental conditions or metadata associated with images or experiments. See more in the Condition Tables documentation.</li> </ul>"},{"location":"table_specs/overview/#tables-groups","title":"Tables Groups","text":"<p>Tables in OME-Zarr images are organized into groups of tables. Each group is saved in a Zarr group, and can be associated with a specific image or plate. The tables groups are:</p> <ul> <li>Image Tables: These tables are a sub group of the OME-Zarr image group and contain metadata or features related only to that specific image. The <code>.zarr</code> hierarchy is based on image specification in NGFF 0.4. The subgroup structure is based on the approach of the OME-Zarr <code>labels</code> group.</li> </ul> <pre><code>image.zarr        # Zarr group for a OME-Zarr image\n|\n\u251c\u2500\u2500 0             # Zarr array for multiscale level 0\n\u251c\u2500\u2500 ...\n\u251c\u2500\u2500 N             # Zarr array for multiscale level N\n|\n\u251c\u2500\u2500 labels        # Zarr subgroup with a list of labels associated to this image\n|   \u251c\u2500\u2500 label_A   # Zarr subgroup for a given label\n|   \u251c\u2500\u2500 label_B   # Zarr subgroup for a given label\n|   \u2514\u2500\u2500 ...\n|\n\u2514\u2500\u2500 tables        # Zarr subgroup with a list of tables associated to this image\n    \u251c\u2500\u2500 table_1   # Zarr subgroup for a given table\n    \u251c\u2500\u2500 table_2   # Zarr subgroup for a given table\n    \u2514\u2500\u2500 ...\n</code></pre> <ul> <li>Plate Tables: These tables are a sub group of the OME-Zarr plate group and contain metadata or features related only to that specific plate.</li> </ul> <pre><code>plate.zarr       # Zarr group for a OME-Zarr HCS plate\n|\n\u251c\u2500\u2500 A             # Row A of the plate\n|   \u251c\u2500\u2500 1         # Column 0 of row A\n|   |   \u251c\u2500\u2500 0     # Acquisition 0 of column A1\n|   |   \u251c\u2500\u2500 1     # Acquisition 1 of column A1\n|   |   \u2514\u2500\u2500 ...   # Other acquisitions of column A1\n...\n\u251c\u2500\u2500 tables        # Zarr subgroup with a list of tables associated to this plate\n|   \u251c\u2500\u2500 table_1   # Zarr subgroup for a given table\n|   \u251c\u2500\u2500 table_2   # Zarr subgroup for a given table\n|   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 ...\n</code></pre> <p>If a plate table contains per image information, the table should contain a <code>row</code>, <code>column</code>, and <code>path_in_well</code> columns.</p>"},{"location":"table_specs/overview/#tables-group-attributes","title":"Tables Group Attributes","text":"<p>The Zarr attributes of the tables group must include the key tables, pointing to the list of all tables (this simplifies discovery of tables associated to the current OME-Zarr image or plate), as in</p> <pre><code>{\n    \"tables\": [\"table_1\", \"table_2\"]\n}\n</code></pre>"},{"location":"table_specs/table_types/condition_table/","title":"Condition Table","text":"<p>A condition table is a simple table that can be used to represent experimental conditions or metadata associated with images or experiments. It is a flexible table type that can be used to store any kind of metadata related to the images or experiments.</p> <p>Example condition table:</p> Cell Type Drug Dose A Drug A 10 A Drug B 20"},{"location":"table_specs/table_types/condition_table/#specifications","title":"Specifications","text":""},{"location":"table_specs/table_types/condition_table/#v1","title":"V1","text":"<p>A condition table must include the following metadata fields in the group attributes:</p> <pre><code>{\n    // Condition table metadata\n    \"type\": \"condition_table\",\n    \"table_version\": \"1\",\n    // Backend metadata\n    \"backend\": \"csv\", // the backend used to store the table, e.g. \"annadata\", \"parquet\", etc..\n    \"index_key\": \"index\", // The default index key for the condition table, which is used to identify each row.\n    \"index_type\": \"int\" // Either \"int\" or \"str\"\n}\n</code></pre>"},{"location":"table_specs/table_types/custom_table/","title":"Add a Custom Table","text":"<p>Ngio allows users to define custom tables that can be used to store any kind of tabular data. Custom tables are flexible and can be used to represent any kind of data that does not fit into the predefined table types.</p> <p>Warning</p> <p>The library is still in the early stages and full documentation for custom tables is not yet available.</p>"},{"location":"table_specs/table_types/feature_table/","title":"Feature Tables","text":"<p>A feature table is a table type for representing per object features in an image. Each row in a feature table corresponds to a specific label in the label image.</p> <p>Feature tables can optionally include metadata to specify the type of features stored in each column:</p> <ul> <li><code>measurement</code>: A quantitative measurement of the object, such as area, perimeter, or intensity.</li> <li><code>categorical</code>: A categorical feature of the object, such as a classification label or a type.</li> <li><code>metadata</code>: Additional free-from columns that can be used to store any other information about the object, but that should not be used for analysis/classification purposes.</li> </ul> <p>These feature types inform casting of the values when serialising a table and can be used in downstream analysis to select specific subsets of features. The feature type can be explicitly specified in the feature table metadata. Alternatively, if a column is not specified, we apply the following casting rules:</p> <ul> <li>If the column contains only numeric values, it is considered a <code>measurement</code>.</li> <li>If the column contains string or boolean values, it is considered a <code>categorical</code>.</li> <li>The index column is considered a <code>categorical</code> feature.</li> </ul>"},{"location":"table_specs/table_types/feature_table/#specifications","title":"Specifications","text":""},{"location":"table_specs/table_types/feature_table/#v1","title":"V1","text":"<p>A feature table must include the following metadata fields in the group attributes:</p> <pre><code>{\n    // Feature table metadata\n    \"type\": \"feature_table\",\n    \"table_version\": \"1\",\n    \"region\": {\"path\": \"../labels/label_DAPI\"}, // Path to the label image associated with this feature table\n    // Backend metadata\n    \"backend\": \"annadata\", // the backend used to store the table, e.g. \"annadata\", \"parquet\", etc..\n    \"index_key\": \"label\", \n    \"index_type\": \"int\", // Either \"int\" or \"str\"\n}\n</code></pre> <p>Additionally, it can include feature type information such as:</p> <pre><code>{\n    \"categorical_columns\": [\n        \"label\",\n        \"cell_type\",\n    ],\n    \"measurement_columns\": [\n        \"area\",\n        \"perimeter\",\n        \"intensity_mean\",\n        \"intensity_std\"\n    ],\n    \"metadata_columns\": [\n        \"description\",\n    ],\n}\n</code></pre>"},{"location":"table_specs/table_types/generic_table/","title":"Generic Tables","text":"<p>A generic table is a flexible table type that can represent any tabular data. It is not tied to any specific domain or use case, making it suitable for a wide range of custom applications.</p> <p>Generic tables can used as a safe fallback when trying to read a table that does not match any other specific table type.</p>"},{"location":"table_specs/table_types/generic_table/#specifications","title":"Specifications","text":""},{"location":"table_specs/table_types/generic_table/#v1","title":"V1","text":"<p>A generic table should include the following metadata fields in the group attributes:</p> <pre><code>{\n    // Generic table metadata\n    \"type\": \"generic_table\",\n    \"table_version\": \"1\",\n    // Backend metadata\n    \"backend\": \"annadata\", // the backend used to store the table, e.g. \"annadata\", \"parquet\", etc..\n    \"index_key\": \"index\", // The default index key for the generic table, which is used to identify each row.\n    \"index_type\": \"int\" // Either \"int\" or \"str\"\n}\n</code></pre>"},{"location":"table_specs/table_types/masking_roi_table/","title":"Masking ROI Tables","text":"<p>A masking ROI table is a specialized table type for representing Regions of Interest (ROIs) that are associated with specific labels in a label image. Each row in a masking ROI table corresponds to a specific label in the label image.</p> <p>Masking ROI tables can be used for several purposes, such as:</p> <ul> <li>Feature extraction from specific regions in the image.</li> <li>Masking specific regions in the image for further processing. For example a masking ROI table could store the ROIs for specific tissues, and for each of these ROIs we would like to perform cell segmentation.</li> </ul>"},{"location":"table_specs/table_types/masking_roi_table/#specifications","title":"Specifications","text":""},{"location":"table_specs/table_types/masking_roi_table/#v1","title":"V1","text":"<p>A ROI table must include the following metadata fields in the group attributes:</p> <pre><code>{\n    // ROI table metadata\n    \"type\": \"masking_roi_table\",\n    \"table_version\": \"1\",\n    \"region\": {\"path\": \"../labels/label_DAPI\"}, // Path to the label image associated with this masking ROI table\n    // Backend metadata\n    \"backend\": \"annadata\", // the backend used to store the table, e.g. \"annadata\", \"parquet\", etc..\n    \"index_key\": \"label\", // The default index key for the ROI table, which is used to identify each ROI. \n    \"index_type\": \"int\", // Either \"int\" or \"str\"\n}\n</code></pre> <p>Moreover the ROI table must include the following columns:</p> <ul> <li><code>x_micrometer</code>, <code>y_micrometer</code>, <code>z_micrometer</code>: the top-left corner coordinates of the ROI in micrometers.</li> <li><code>len_x_micrometer</code>, <code>len_y_micrometer</code>, <code>len_z_micrometer</code>: the size of the ROI in micrometers along each axis.</li> <li><code>label</code>: An integer column label associated with the ROI, which corresponds to a specific label in the label image. This can also be the table index key.</li> <li>(Optional) <code>t_second</code> and <code>len_t_second</code>: the time coordinate of the ROI in seconds, and the length of the time coordinate in seconds. This is useful for multiplexing acquisitions.</li> </ul> <p>Additionally, each ROI can include the following optional columns: see ROI Table.</p>"},{"location":"table_specs/table_types/roi_table/","title":"ROI Table","text":"<p>A ROI table defines regions of space which are axes-aligned bounding boxes in the image space.</p> <p>ROI tables can be used for several purposes, such as:</p> <ul> <li>Storing information about the Microscope Field of View (FOV).</li> <li>Storing arbitrary regions of interest (ROIs).</li> <li>Use them as masks for other processes, such as segmentation or feature extraction.</li> </ul>"},{"location":"table_specs/table_types/roi_table/#specifications","title":"Specifications","text":""},{"location":"table_specs/table_types/roi_table/#v1","title":"V1","text":"<p>A ROI table must include the following metadata fields in the group attributes:</p> <pre><code>{\n    // ROI table metadata\n    \"type\": \"roi_table\",\n    \"table_version\": \"1\",\n    // Backend metadata\n    \"backend\": \"annadata\", // the backend used to store the table, e.g. \"annadata\", \"parquet\", etc..\n    \"index_key\": \"FieldIndex\", // The default index key for the ROI table, which is used to identify each ROI. \n    \"index_type\": \"str\", // Either \"int\" or \"str\"\n}\n</code></pre> <p>Moreover the ROI table must include the following columns:</p> <ul> <li><code>x_micrometer</code>, <code>y_micrometer</code>, <code>z_micrometer</code>: the top-left corner coordinates of the ROI in micrometers.</li> <li><code>len_x_micrometer</code>, <code>len_y_micrometer</code>, <code>len_z_micrometer</code>: the size of the ROI in micrometers along each axis.</li> </ul> <p>Additionally, each ROI can include the following optional columns:</p> <ul> <li><code>t_second</code> and <code>len_t_second</code>: the time coordinate of the ROI in seconds, and the length of the time coordinate in seconds. This is useful for multiplexing acquisitions.</li> <li><code>x_micrometer_original</code>, <code>y_micrometer_original</code> and <code>z_micrometer_original</code> which are the original coordinates of the ROI in micrometers. These are typically used when the data is saved in different coordinates during conversion, e.g. to avoid overwriting data from overlapping ROIs.</li> <li><code>translation_x</code>, <code>translation_y</code> and <code>translation_z</code>, which are used during registration of multiplexing acquisitions.</li> </ul> <p>The user can also add additional columns to the ROI table, but these columns will not be exposed in the ROI table API.</p>"},{"location":"tutorials/create_ome_zarr/","title":"OME-Zarr Creation","text":"In\u00a0[1]: Copied! <pre>import skimage\nfrom matplotlib import pyplot as plt\n\nplt.imshow(skimage.data.human_mitosis(), cmap=\"gray\")\nplt.axis(\"off\")\nplt.show()\n</pre> import skimage from matplotlib import pyplot as plt  plt.imshow(skimage.data.human_mitosis(), cmap=\"gray\") plt.axis(\"off\") plt.show() <pre>Downloading file 'data/mitosis.tif' from 'https://gitlab.com/scikit-image/data/-/raw/2cdc5ce89b334d28f06a58c9f0ca21aa6992a5ba/AS_09125_050116030001_D03f00d0.tif' to '/home/runner/.cache/scikit-image/0.25.2'.\n</pre> In\u00a0[2]: Copied! <pre>from ngio import create_ome_zarr_from_array\n\nome_zarr = create_ome_zarr_from_array(\n    store=\"./data/human_mitosis.zarr\",\n    array=skimage.data.human_mitosis(),\n    xy_pixelsize=0.1,  # Just a guess\n)\nome_zarr\n</pre> from ngio import create_ome_zarr_from_array  ome_zarr = create_ome_zarr_from_array(     store=\"./data/human_mitosis.zarr\",     array=skimage.data.human_mitosis(),     xy_pixelsize=0.1,  # Just a guess ) ome_zarr Out[2]: <pre>OmeZarrContainer(levels=5)</pre> In\u00a0[3]: Copied! <pre># create a roi for the whole image\nroi_table = ome_zarr.build_image_roi_table(name=\"image_roi\")\nome_zarr.add_table(\"image_roi_table\", roi_table)\n</pre> # create a roi for the whole image roi_table = ome_zarr.build_image_roi_table(name=\"image_roi\") ome_zarr.add_table(\"image_roi_table\", roi_table)"},{"location":"tutorials/create_ome_zarr/#ome-zarr-creation","title":"OME-Zarr Creation\u00b6","text":"<p>This is a minimal example of how to create an OME-Zarr image using <code>ngio</code>.</p> <p>This example is just a simple demonstration but for more complex conversion tasks please refer to the converter tooling library ome-zarr-converters-tools.</p> <p>Let's start by converting a sample image from <code>skimage</code> to OME-Zarr format.</p>"},{"location":"tutorials/create_ome_zarr/#adding-rois-to-ome-zarr","title":"Adding Rois to OME-Zarr\u00b6","text":"<p>Often, is useful to add ROIs to OME-Zarr images to be able to retrieve them later. This can be done using the <code>ngio</code> library as follows.</p>"},{"location":"tutorials/feature_extraction/","title":"Feature Extraction","text":"In\u00a0[1]: Copied! <pre>from pathlib import Path\n\nfrom ngio import open_ome_zarr_container\nfrom ngio.utils import download_ome_zarr_dataset\n\n# Download the dataset\ndownload_dir = Path(\".\").absolute().parent.parent / \"data\"\nhcs_path = download_ome_zarr_dataset(\"CardiomyocyteTinyMip\", download_dir=download_dir)\nimage_path = hcs_path / \"B\" / \"03\" / \"0\"\n\n# Open the ome-zarr container\nome_zarr = open_ome_zarr_container(image_path)\n</pre> from pathlib import Path  from ngio import open_ome_zarr_container from ngio.utils import download_ome_zarr_dataset  # Download the dataset download_dir = Path(\".\").absolute().parent.parent / \"data\" hcs_path = download_ome_zarr_dataset(\"CardiomyocyteTinyMip\", download_dir=download_dir) image_path = hcs_path / \"B\" / \"03\" / \"0\"  # Open the ome-zarr container ome_zarr = open_ome_zarr_container(image_path) <pre>Downloading data from 'https://zenodo.org/records/13305156/files/20200812-CardiomyocyteDifferentiation14-Cycle1_mip.zarr.zip' to file '/home/runner/work/ngio/ngio/data/20200812-CardiomyocyteDifferentiation14-Cycle1-tiny-mip.zarr.zip'.\n</pre> <pre>Unzipping contents of '/home/runner/work/ngio/ngio/data/20200812-CardiomyocyteDifferentiation14-Cycle1-tiny-mip.zarr.zip' to '/home/runner/work/ngio/ngio/data/tmp'\n</pre> In\u00a0[2]: Copied! <pre>import pandas as pd\nfrom skimage import measure\n\nfrom ngio.tables import FeatureTable\n\n# First we will need the image object and the FOVs table\nnuclei = ome_zarr.get_label(\"nuclei\")\nimage_data = ome_zarr.get_image(pixel_size=nuclei.pixel_size).get_as_numpy(\n    axes_order=[\"z\", \"y\", \"x\", \"c\"]\n)\nnuclei_data = nuclei.get_as_numpy(axes_order=[\"z\", \"y\", \"x\"])\n\nfeat_table = measure.regionprops_table(\n    label_image=nuclei_data,\n    intensity_image=image_data,\n    properties=[\"label\", \"area\", \"mean_intensity\", \"max_intensity\", \"min_intensity\"],\n)\n\nfeat_table = pd.DataFrame(feat_table)\nfeat_table = feat_table.set_index(\"label\")\n\n# Convert to a FeatureTable\nfeature_table = FeatureTable(table_data=feat_table, reference_label=\"nuclei\")\n\n# Save the Table in the ome-zarr container\nome_zarr.add_table(\"nuclei_regionprops\", feature_table)\n</pre> import pandas as pd from skimage import measure  from ngio.tables import FeatureTable  # First we will need the image object and the FOVs table nuclei = ome_zarr.get_label(\"nuclei\") image_data = ome_zarr.get_image(pixel_size=nuclei.pixel_size).get_as_numpy(     axes_order=[\"z\", \"y\", \"x\", \"c\"] ) nuclei_data = nuclei.get_as_numpy(axes_order=[\"z\", \"y\", \"x\"])  feat_table = measure.regionprops_table(     label_image=nuclei_data,     intensity_image=image_data,     properties=[\"label\", \"area\", \"mean_intensity\", \"max_intensity\", \"min_intensity\"], )  feat_table = pd.DataFrame(feat_table) feat_table = feat_table.set_index(\"label\")  # Convert to a FeatureTable feature_table = FeatureTable(table_data=feat_table, reference_label=\"nuclei\")  # Save the Table in the ome-zarr container ome_zarr.add_table(\"nuclei_regionprops\", feature_table) In\u00a0[3]: Copied! <pre>ome_zarr.get_table(\"nuclei_regionprops\").lazy_frame.collect()\n</pre> ome_zarr.get_table(\"nuclei_regionprops\").lazy_frame.collect() Out[3]: shape: (1_497, 5)labelareamean_intensity-0max_intensity-0min_intensity-0i64f64f64f64f64185.0183.8221.0151.02154.0272.493506392.0184.03123.0276.569106347.0189.04320.0278.271875370.0170.0518.0242.611111288.0193.0\u2026\u2026\u2026\u2026\u2026149378.0268.5338.0178.0149433.0315.030303407.0196.0149538.0280.842105327.0192.0149618.0260.222222304.0172.0149727.0335.333333390.0256.0"},{"location":"tutorials/feature_extraction/#feature-extraction","title":"Feature Extraction\u00b6","text":"<p>This sections will cover how to extract regionprops features from an image using <code>ngio</code>, <code>skimage</code>. Moreover we will also write the features to a table in the ome-zarr container.</p>"},{"location":"tutorials/feature_extraction/#step-1-open-the-ome-zarr-container","title":"Step 1: Open the OME-Zarr Container\u00b6","text":""},{"location":"tutorials/feature_extraction/#step-2-compute-the-regionprops-features","title":"Step 2: Compute the Regionprops Features\u00b6","text":""},{"location":"tutorials/feature_extraction/#sanity-check-read-the-table-back","title":"Sanity Check: Read the Table back\u00b6","text":""},{"location":"tutorials/hcs_exploration/","title":"HCS Plates","text":"In\u00a0[1]: Copied! <pre>from pathlib import Path\n\nfrom ngio import open_ome_zarr_plate\nfrom ngio.utils import download_ome_zarr_dataset\n\n# Download the dataset\ndownload_dir = Path(\".\").absolute().parent.parent / \"data\"\n\nhcs_path = download_ome_zarr_dataset(\"CardiomyocyteTinyMip\", download_dir=download_dir)\nhcs_zarr = open_ome_zarr_plate(hcs_path)\nprint(hcs_zarr)\nprint(f\"Rows: {hcs_zarr.rows}, Columns: {hcs_zarr.columns}\")\n\n# Get all the images in the plate\nhcs_zarr.get_images()\n</pre> from pathlib import Path  from ngio import open_ome_zarr_plate from ngio.utils import download_ome_zarr_dataset  # Download the dataset download_dir = Path(\".\").absolute().parent.parent / \"data\"  hcs_path = download_ome_zarr_dataset(\"CardiomyocyteTinyMip\", download_dir=download_dir) hcs_zarr = open_ome_zarr_plate(hcs_path) print(hcs_zarr) print(f\"Rows: {hcs_zarr.rows}, Columns: {hcs_zarr.columns}\")  # Get all the images in the plate hcs_zarr.get_images() <pre>Unzipping contents of '/home/runner/work/ngio/ngio/data/20200812-CardiomyocyteDifferentiation14-Cycle1-tiny-mip.zarr.zip' to '/home/runner/work/ngio/ngio/data/tmp'\n</pre> <pre>Plate([rows x columns] (1 x 1))\nRows: ['B'], Columns: ['03']\n</pre> Out[1]: <pre>{'B/03/0': OmeZarrContainer(levels=5, labels=['nuclei'], #tables=4)}</pre> In\u00a0[2]: Copied! <pre># Aggregate all table across all images\n\ntable = hcs_zarr.concatenate_image_tables(name=\"nuclei\")\ntable.dataframe\n</pre> # Aggregate all table across all images  table = hcs_zarr.concatenate_image_tables(name=\"nuclei\") table.dataframe <pre>/opt/hostedtoolcache/Python/3.13.7/x64/lib/python3.13/site-packages/anndata/_core/aligned_df.py:68: ImplicitModificationWarning: Transforming to str index.\n  warnings.warn(\"Transforming to str index.\", ImplicitModificationWarning)\n</pre> Out[2]: area bbox_area equivalent_diameter max_intensity mean_intensity min_intensity standard_deviation_intensity row column path_in_well label 1 1360.0 1664.0 13.746119 268.0 184.579407 125.0 24.502481 B 03 0 2 2464.0 2992.0 16.757685 461.0 273.246765 132.0 51.794971 B 03 0 3 1968.0 2688.0 15.548035 429.0 277.291656 143.0 41.822422 B 03 0 4 5120.0 6400.0 21.384073 413.0 279.035156 118.0 44.379074 B 03 0 5 288.0 352.0 8.193409 341.0 243.315979 147.0 41.861721 B 03 0 ... ... ... ... ... ... ... ... ... ... ... 1493 1248.0 1440.0 13.357914 385.0 269.291656 108.0 45.967396 B 03 0 1494 528.0 704.0 10.027941 475.0 315.710236 128.0 70.174896 B 03 0 1495 608.0 768.0 10.510781 377.0 281.544403 122.0 34.698723 B 03 0 1496 288.0 480.0 8.193409 356.0 261.003479 122.0 44.835232 B 03 0 1497 432.0 528.0 9.379111 454.0 336.101837 172.0 53.799728 B 03 0 <p>1497 rows \u00d7 10 columns</p> In\u00a0[3]: Copied! <pre># Save the tabvle in the HCS plate\nhcs_zarr.add_table(name=\"nuclei\", table=table)\n\n# Read the table back for sanity check\nhcs_zarr.get_table(\"nuclei\").dataframe\n</pre> # Save the tabvle in the HCS plate hcs_zarr.add_table(name=\"nuclei\", table=table)  # Read the table back for sanity check hcs_zarr.get_table(\"nuclei\").dataframe Out[3]: area bbox_area equivalent_diameter max_intensity mean_intensity min_intensity standard_deviation_intensity row column path_in_well label 1 1360.0 1664.0 13.746119 268.0 184.579407 125.0 24.502481 B 03 0 2 2464.0 2992.0 16.757685 461.0 273.246765 132.0 51.794971 B 03 0 3 1968.0 2688.0 15.548035 429.0 277.291656 143.0 41.822422 B 03 0 4 5120.0 6400.0 21.384073 413.0 279.035156 118.0 44.379074 B 03 0 5 288.0 352.0 8.193409 341.0 243.315979 147.0 41.861721 B 03 0 ... ... ... ... ... ... ... ... ... ... ... 1493 1248.0 1440.0 13.357914 385.0 269.291656 108.0 45.967396 B 03 0 1494 528.0 704.0 10.027941 475.0 315.710236 128.0 70.174896 B 03 0 1495 608.0 768.0 10.510781 377.0 281.544403 122.0 34.698723 B 03 0 1496 288.0 480.0 8.193409 356.0 261.003479 122.0 44.835232 B 03 0 1497 432.0 528.0 9.379111 454.0 336.101837 172.0 53.799728 B 03 0 <p>1497 rows \u00d7 10 columns</p> In\u00a0[4]: Copied! <pre>from ngio import ImageInWellPath, create_empty_plate\n\ntest_plate = create_empty_plate(\n    store=\"./data/empty_plate.zarr\",\n    name=\"Test Plate\",\n    images=[\n        ImageInWellPath(row=\"A\", column=\"01\", path=\"0\"),\n        ImageInWellPath(row=\"A\", column=\"02\", path=\"0\"),\n        ImageInWellPath(row=\"A\", column=\"02\", path=\"1\", acquisition_id=1),\n    ],\n    overwrite=True,\n)\n\nprint(test_plate)\nprint(f\"Rows: {test_plate.rows}, Columns: {test_plate.columns}\")\n</pre> from ngio import ImageInWellPath, create_empty_plate  test_plate = create_empty_plate(     store=\"./data/empty_plate.zarr\",     name=\"Test Plate\",     images=[         ImageInWellPath(row=\"A\", column=\"01\", path=\"0\"),         ImageInWellPath(row=\"A\", column=\"02\", path=\"0\"),         ImageInWellPath(row=\"A\", column=\"02\", path=\"1\", acquisition_id=1),     ],     overwrite=True, )  print(test_plate) print(f\"Rows: {test_plate.rows}, Columns: {test_plate.columns}\") <pre>Plate([rows x columns] (1 x 2))\nRows: ['A'], Columns: ['01', '02']\n</pre>"},{"location":"tutorials/hcs_exploration/#hcs-plates","title":"HCS Plates\u00b6","text":"<p>This is a minimal example of how to work with OME-Zarr Plates using <code>ngio</code>.</p>"},{"location":"tutorials/hcs_exploration/#show-whats-in-the-plate","title":"Show what's in the plate\u00b6","text":""},{"location":"tutorials/hcs_exploration/#aggregate-tables-across-all-images","title":"Aggregate tables across all images\u00b6","text":""},{"location":"tutorials/hcs_exploration/#save-the-table-in-the-hcs-plate","title":"Save the table in the HCS plate\u00b6","text":""},{"location":"tutorials/hcs_exploration/#create-a-new-empty-plate","title":"Create a new empty Plate\u00b6","text":""},{"location":"tutorials/image_processing/","title":"Image Processing","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport skimage\n\n\ndef gaussian_blur(image: np.ndarray, sigma: float) -&gt; np.ndarray:\n    \"\"\"Apply gaussian blur to an image.\"\"\"\n    original_type = image.dtype\n    image = skimage.filters.gaussian(\n        image, sigma=sigma, channel_axis=0, preserve_range=True\n    )\n    # Convert the image back to the original type\n    image = image.astype(original_type)\n    return image\n</pre> import numpy as np import skimage   def gaussian_blur(image: np.ndarray, sigma: float) -&gt; np.ndarray:     \"\"\"Apply gaussian blur to an image.\"\"\"     original_type = image.dtype     image = skimage.filters.gaussian(         image, sigma=sigma, channel_axis=0, preserve_range=True     )     # Convert the image back to the original type     image = image.astype(original_type)     return image In\u00a0[2]: Copied! <pre>from pathlib import Path\n\nfrom ngio import open_ome_zarr_container\nfrom ngio.utils import download_ome_zarr_dataset\n\n# Download the dataset\ndownload_dir = Path(\".\").absolute().parent.parent / \"data\"\n\nhcs_path = download_ome_zarr_dataset(\"CardiomyocyteTiny\", download_dir=download_dir)\nimage_path = hcs_path / \"B\" / \"03\" / \"0\"\n\n# Open the ome-zarr container\nome_zarr = open_ome_zarr_container(image_path)\n</pre> from pathlib import Path  from ngio import open_ome_zarr_container from ngio.utils import download_ome_zarr_dataset  # Download the dataset download_dir = Path(\".\").absolute().parent.parent / \"data\"  hcs_path = download_ome_zarr_dataset(\"CardiomyocyteTiny\", download_dir=download_dir) image_path = hcs_path / \"B\" / \"03\" / \"0\"  # Open the ome-zarr container ome_zarr = open_ome_zarr_container(image_path) <pre>Unzipping contents of '/home/runner/work/ngio/ngio/data/20200812-CardiomyocyteDifferentiation14-Cycle1-tiny.zarr.zip' to '/home/runner/work/ngio/ngio/data/tmp'\n</pre> In\u00a0[3]: Copied! <pre># First we will need the image object\nimage = ome_zarr.get_image()\n\n# Second we need to derive a new ome-zarr image where we will store\n# the processed image\n\nblurred_omezarr_path = image_path.parent / \"0_blurred\"\nblurred_omezarr = ome_zarr.derive_image(\n    store=blurred_omezarr_path, name=\"Blurred Image\", overwrite=True\n)\nblurred_image = blurred_omezarr.get_image()\n</pre> # First we will need the image object image = ome_zarr.get_image()  # Second we need to derive a new ome-zarr image where we will store # the processed image  blurred_omezarr_path = image_path.parent / \"0_blurred\" blurred_omezarr = ome_zarr.derive_image(     store=blurred_omezarr_path, name=\"Blurred Image\", overwrite=True ) blurred_image = blurred_omezarr.get_image() In\u00a0[4]: Copied! <pre># We can use the axes order to specify how we query the image data.\n# Here we will reorder the axes to be [\"c\", \"z\", \"y\", \"x\"].\n# So that it will be compatible with the gaussian blur function\n# which expects the channel axis to be the first one.\nimage_data = image.get_as_numpy(axes_order=[\"c\", \"z\", \"y\", \"x\"])\n# Apply gaussian blur to the image\nsigma = 5.0\nblurred_image_data = gaussian_blur(image_data, sigma=sigma)\n\n# Set the processed image data back to the ome-zarr image\nblurred_image.set_array(patch=blurred_image_data, axes_order=[\"c\", \"z\", \"y\", \"x\"])\n\n# The `set_array` method only saved the blurred image to the container at a specific\n# resolution level. So all other resolution levels are still empty.\n# To propagate the changes to all resolution levels,\n# we can use the `consolidate` method.\nblurred_image.consolidate()\n</pre> # We can use the axes order to specify how we query the image data. # Here we will reorder the axes to be [\"c\", \"z\", \"y\", \"x\"]. # So that it will be compatible with the gaussian blur function # which expects the channel axis to be the first one. image_data = image.get_as_numpy(axes_order=[\"c\", \"z\", \"y\", \"x\"]) # Apply gaussian blur to the image sigma = 5.0 blurred_image_data = gaussian_blur(image_data, sigma=sigma)  # Set the processed image data back to the ome-zarr image blurred_image.set_array(patch=blurred_image_data, axes_order=[\"c\", \"z\", \"y\", \"x\"])  # The `set_array` method only saved the blurred image to the container at a specific # resolution level. So all other resolution levels are still empty. # To propagate the changes to all resolution levels, # we can use the `consolidate` method. blurred_image.consolidate() In\u00a0[5]: Copied! <pre>import matplotlib.pyplot as plt\nimport numpy as np\nfrom matplotlib.colors import ListedColormap\n\nrand_cmap = np.random.rand(1000, 3)\nrand_cmap[0] = 0\nrand_cmap = ListedColormap(rand_cmap)\n\nfig, axs = plt.subplots(2, 1, figsize=(8, 4))\naxs[0].set_title(\"Original image\")\naxs[0].imshow(image.get_as_numpy(c=0, z=1, axes_order=[\"y\", \"x\"]), cmap=\"gray\")\naxs[1].set_title(\"Blurred image\")\naxs[1].imshow(blurred_image.get_as_numpy(c=0, z=1, axes_order=[\"y\", \"x\"]), cmap=\"gray\")\nfor ax in axs:\n    ax.axis(\"off\")\nplt.tight_layout()\nplt.show()\n</pre> import matplotlib.pyplot as plt import numpy as np from matplotlib.colors import ListedColormap  rand_cmap = np.random.rand(1000, 3) rand_cmap[0] = 0 rand_cmap = ListedColormap(rand_cmap)  fig, axs = plt.subplots(2, 1, figsize=(8, 4)) axs[0].set_title(\"Original image\") axs[0].imshow(image.get_as_numpy(c=0, z=1, axes_order=[\"y\", \"x\"]), cmap=\"gray\") axs[1].set_title(\"Blurred image\") axs[1].imshow(blurred_image.get_as_numpy(c=0, z=1, axes_order=[\"y\", \"x\"]), cmap=\"gray\") for ax in axs:     ax.axis(\"off\") plt.tight_layout() plt.show() In\u00a0[6]: Copied! <pre>from dask import array as da\n\n\ndef dask_gaussian_blur(image: da.Array, sigma: float) -&gt; da.Array:\n    \"\"\"Apply gaussian blur to a dask array.\"\"\"\n    return da.map_blocks(gaussian_blur, image, dtype=image.dtype, sigma=sigma)\n\n\nimage_dask = image.get_as_dask(axes_order=[\"c\", \"z\", \"y\", \"x\"])\nblurred_image_dask = dask_gaussian_blur(image_dask, sigma=sigma)\nblurred_image_dask\n</pre> from dask import array as da   def dask_gaussian_blur(image: da.Array, sigma: float) -&gt; da.Array:     \"\"\"Apply gaussian blur to a dask array.\"\"\"     return da.map_blocks(gaussian_blur, image, dtype=image.dtype, sigma=sigma)   image_dask = image.get_as_dask(axes_order=[\"c\", \"z\", \"y\", \"x\"]) blurred_image_dask = dask_gaussian_blur(image_dask, sigma=sigma) blurred_image_dask Out[6]:  Array   Chunk   Bytes   42.19 MiB   10.55 MiB   Shape   (1, 2, 2160, 5120)   (1, 1, 2160, 2560)   Dask graph   4 chunks in 3 graph layers   Data type   uint16 numpy.ndarray  1 1 5120 2160 2"},{"location":"tutorials/image_processing/#image-processing","title":"Image Processing\u00b6","text":"<p>This is a minimal example of how to use the <code>ngio</code> library for applying some basic image processing techniques.</p> <p>For this example we will apply gaussian blur to an image.</p>"},{"location":"tutorials/image_processing/#step-1-setup","title":"Step 1: Setup\u00b6","text":"<p>We will first create a simple function to apply gaussian blur to an image. This function will take an image and a sigma value as input and return the blurred image.</p>"},{"location":"tutorials/image_processing/#step-2-open-the-omezarr-container","title":"Step 2: Open the OmeZarr container\u00b6","text":""},{"location":"tutorials/image_processing/#step-3-create-a-new-empty-omezarr-container","title":"Step 3: Create a new empty omeZarr container\u00b6","text":"<p>ngio provide a simple way to \"derive\" a new container from an existing one. This is useful when you want to apply some processing to an image and save the results in a new container that preserves the original metadata and dimensions (unless explicitly changed when deriving).</p>"},{"location":"tutorials/image_processing/#step-4-apply-the-gaussian-blur-and-consolidate-the-processed-image","title":"Step 4: Apply the gaussian blur and consolidate the processed image\u00b6","text":""},{"location":"tutorials/image_processing/#plot-the-results","title":"Plot the results\u00b6","text":"<p>Finally, we can visualize the original and blurred images using <code>matplotlib</code>.</p>"},{"location":"tutorials/image_processing/#out-of-memory-processing","title":"Out of memory processing\u00b6","text":"<p>Sometimes we want to apply some simple processing to larger than memory images. In this case, we can use the <code>dask</code> library to process the image in chunks. In <code>ngio</code> we can simply query the data as a <code>dask</code> array and apply the desired processing function to it.</p>"},{"location":"tutorials/image_segmentation/","title":"Image Segmentation","text":"In\u00a0[1]: Copied! <pre># Setup a simple segmentation function\nimport numpy as np\nimport skimage\n\n\ndef otsu_threshold_segmentation(image: np.ndarray, max_label: int) -&gt; np.ndarray:\n    \"\"\"Simple segmentation using Otsu thresholding.\"\"\"\n    threshold = skimage.filters.threshold_otsu(image)\n    binary = image &gt; threshold\n    label_image = skimage.measure.label(binary)\n    label_image += max_label\n    label_image = np.where(binary, label_image, 0)\n    return label_image.astype(np.uint32)\n</pre> # Setup a simple segmentation function import numpy as np import skimage   def otsu_threshold_segmentation(image: np.ndarray, max_label: int) -&gt; np.ndarray:     \"\"\"Simple segmentation using Otsu thresholding.\"\"\"     threshold = skimage.filters.threshold_otsu(image)     binary = image &gt; threshold     label_image = skimage.measure.label(binary)     label_image += max_label     label_image = np.where(binary, label_image, 0)     return label_image.astype(np.uint32) In\u00a0[2]: Copied! <pre>from pathlib import Path\n\nfrom ngio import open_ome_zarr_container\nfrom ngio.utils import download_ome_zarr_dataset\n\n# Download the dataset\ndownload_dir = Path(\".\").absolute().parent.parent / \"data\"\nhcs_path = download_ome_zarr_dataset(\"CardiomyocyteTiny\", download_dir=download_dir)\nimage_path = hcs_path / \"B\" / \"03\" / \"0\"\n\n# Open the ome-zarr container\nome_zarr = open_ome_zarr_container(image_path)\n</pre> from pathlib import Path  from ngio import open_ome_zarr_container from ngio.utils import download_ome_zarr_dataset  # Download the dataset download_dir = Path(\".\").absolute().parent.parent / \"data\" hcs_path = download_ome_zarr_dataset(\"CardiomyocyteTiny\", download_dir=download_dir) image_path = hcs_path / \"B\" / \"03\" / \"0\"  # Open the ome-zarr container ome_zarr = open_ome_zarr_container(image_path) <pre>Unzipping contents of '/home/runner/work/ngio/ngio/data/20200812-CardiomyocyteDifferentiation14-Cycle1-tiny.zarr.zip' to '/home/runner/work/ngio/ngio/data/tmp'\n</pre> In\u00a0[3]: Copied! <pre># First we will need the image object and the FOVs table\nimage = ome_zarr.get_image()\nroi_table = ome_zarr.get_roi_table(\"FOV_ROI_table\")\n\n# Second we need to derive a new label image to use as target for the segmentation\n\nlabel = ome_zarr.derive_label(\"new_label\", overwrite=True)\n\nmax_label = 0  # We will use this to avoid label collisions\nfor roi in roi_table.rois():\n    # Get the image data for the ROI\n    image_data = image.get_roi_as_numpy(roi=roi, c=0, axes_order=[\"z\", \"y\", \"x\"])\n\n    roi_segmentation = otsu_threshold_segmentation(\n        image_data, max_label\n    )  # Segment the image\n\n    max_label = roi_segmentation.max()  # Get the max label for the next iteration\n\n    label.set_roi(\n        roi=roi, patch=roi_segmentation\n    )  # Write the segmentation to the label image\n</pre> # First we will need the image object and the FOVs table image = ome_zarr.get_image() roi_table = ome_zarr.get_roi_table(\"FOV_ROI_table\")  # Second we need to derive a new label image to use as target for the segmentation  label = ome_zarr.derive_label(\"new_label\", overwrite=True)  max_label = 0  # We will use this to avoid label collisions for roi in roi_table.rois():     # Get the image data for the ROI     image_data = image.get_roi_as_numpy(roi=roi, c=0, axes_order=[\"z\", \"y\", \"x\"])      roi_segmentation = otsu_threshold_segmentation(         image_data, max_label     )  # Segment the image      max_label = roi_segmentation.max()  # Get the max label for the next iteration      label.set_roi(         roi=roi, patch=roi_segmentation     )  # Write the segmentation to the label image In\u00a0[4]: Copied! <pre>label.consolidate()\n</pre> label.consolidate() In\u00a0[5]: Copied! <pre>import matplotlib.pyplot as plt\nimport numpy as np\nfrom matplotlib.colors import ListedColormap\n\nrand_cmap = np.random.rand(1000, 3)\nrand_cmap[0] = 0\nrand_cmap = ListedColormap(rand_cmap)\n\nfig, axs = plt.subplots(2, 1, figsize=(8, 4))\naxs[0].set_title(\"Original image\")\naxs[0].imshow(image.get_as_numpy(c=0, z=1, axes_order=[\"y\", \"x\"]), cmap=\"gray\")\naxs[1].set_title(\"Final segmentation\")\naxs[1].imshow(label.get_as_numpy(z=1, axes_order=[\"y\", \"x\"]), cmap=rand_cmap)\nfor ax in axs:\n    ax.axis(\"off\")\nplt.tight_layout()\nplt.show()\n</pre> import matplotlib.pyplot as plt import numpy as np from matplotlib.colors import ListedColormap  rand_cmap = np.random.rand(1000, 3) rand_cmap[0] = 0 rand_cmap = ListedColormap(rand_cmap)  fig, axs = plt.subplots(2, 1, figsize=(8, 4)) axs[0].set_title(\"Original image\") axs[0].imshow(image.get_as_numpy(c=0, z=1, axes_order=[\"y\", \"x\"]), cmap=\"gray\") axs[1].set_title(\"Final segmentation\") axs[1].imshow(label.get_as_numpy(z=1, axes_order=[\"y\", \"x\"]), cmap=rand_cmap) for ax in axs:     ax.axis(\"off\") plt.tight_layout() plt.show() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/image_segmentation/#image-segmentation","title":"Image Segmentation\u00b6","text":"<p>This is a minimal tutorial on how to use ngio for image segmentation.</p>"},{"location":"tutorials/image_segmentation/#step-1-setup","title":"Step 1: Setup\u00b6","text":"<p>We will first implement a very simple function to segment an image. We will use skimage to do this.</p>"},{"location":"tutorials/image_segmentation/#step-2-open-the-omezarr-container","title":"Step 2: Open the OmeZarr container\u00b6","text":""},{"location":"tutorials/image_segmentation/#step-3-segment-the-image","title":"Step 3: Segment the image\u00b6","text":"<p>For this example, we will not segment the image all at once. Instead we will iterate over the image FOVs and segment them one by one.</p>"},{"location":"tutorials/image_segmentation/#step-4-consolidate-the-segmentation","title":"Step 4: Consolidate the segmentation\u00b6","text":"<p>The <code>new_label</code> has data only at a single resolution lebel. To consolidate the segmentation to all other levels we will need to call the <code>consolidate</code> method.</p>"},{"location":"tutorials/image_segmentation/#plot-the-segmentation","title":"Plot the segmentation\u00b6","text":""}]}